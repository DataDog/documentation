---
title: プロファイルの検索
kind: ドキュメント
aliases:
  - /ja/tracing/profiling/search_profiles
further_reading:
  - link: tracing/profiler/enabling
    tag: Documentation
    text: アプリケーションの継続的なプロファイラー有効化
  - link: getting_started/profiler
    tag: Documentation
    text: プロファイラーの概要
  - link: https://www.datadoghq.com/blog/introducing-datadog-profiling/
    tags: ブログ
    text: Datadog に常時接続型の本番環境プロファイリングが登場
---
{{< img src="tracing/profiling/search_profiles.gif" alt="タグによるプロファイルの検索">}}

各行は、短時間のプロセスのプロファイルです。デフォルトでは、プロファイルは 1 分に 1 回アップロードされます。言語に応じて、これらのプロセスは 15 秒から 60 秒の間でプロファイルされます。

[環境トレース構成][1]から設定されたインフラストラクチャータグまたはアプリケーションタグに従ってフィルタリングできます。デフォルトでは、次のファセットを使用できます。

| ファセット    | 定義                                                                                             |
| -------- | ------------------------------------------------------------------------------------------------------ |
| Env      | アプリケーションが実行されている環境（`production`、`staging`）。                                    |
| サービス  | コードが実行している[サービス][2]の名前。                                                     |
| バージョン  | コードのバージョン。                                                                              |
| ホスト     | プロファイルされたプロセスが実行しているホスト名。 |
| ランタイム  | プロファイルされたプロセスが実行しているランタイムのタイプ（`JVM`、`CPython`）。                                |

次のメジャーを使用できます。

| メジャー           | 定義                                                                                                                                                                           |
| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| CPU              | CPU 使用量 (コア単位) |
| メモリ割り当て | プロファイル全体でのメモリ割り当て率。割り当てられたメモリはプロファイル中にガベージコレクションされる可能性があるため、この値はシステムのメモリ量を超える可能性があります。 |



## プロファイル

行をクリックして、特定のプロファイルを表示します。

{{< img src="tracing/profiling/profiling_flamegraph.gif" alt="特定のプロファイル">}}

ヘッダーには、プロファイルを生成したサービスや、それに関連付けられた環境とコードバージョンなど、プロファイルに関連付けられた情報が含まれています。

4 つのタブがプロファイルヘッダーの下にあります。

| タブ          | 定義                                                                                                                                  |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------- |
| プロファイル     | 現在見ているプロファイルのフレームグラフとサマリーテーブル。プロファイルタイプ（`CPU`、`Memory allocation`）を切り替えることができます |
| Analysis     | コードの潜在的な問題または改善の領域を示唆する一連のヒューリスティック。現在、Java でのみ利用できます。                   |
| メトリクス      | 同じサービスのすべてのプロファイルからのプロファイラーメトリクス                                                                              |
| ランタイム情報 | サポートされている言語のランタイムプロパティとプロファイルタグ。                                                                                                     |

**注**: 各プロファイルの右上隅には、次のオプションがあります。

- プロフィールをダウンロードする
- プロファイルをフルスクリーンに切り替える


### プロファイルタイプ

**Profiles** タブでは、特定の言語で使用できるすべてのプロファイルタイプを確認できます。言語によって、プロファイルについて収集される情報は異なります。

{{< programming-lang-wrapper langs="java,python,go,ruby" >}}
{{< programming-lang lang="java" >}}

{{< img src="tracing/profiling/profile.png" alt="特定のプロファイル">}}

有効にすると、次のプロファイルタイプが収集されます。


CPU in Java Code
: 各メソッドが CPU での実行に費やした時間を示します。これには JVM（Java、Kotlin など）で実行されるコードが含まれますが、JVM オペレーションや JVM 内から呼び出されるネイティブコードは含まれません。

Allocation
: 各メソッドによって割り当てられたヒープメモリの量を示します。これには、後で解放された割り当ても含まれます。

Wall Time in Native Code
: ネイティブコードで費やされた経過時間を示します。経過時間には、コードが CPU で実行されている時間、I/O を待機している時間、およびメソッドの実行中に発生するその他の時間が含まれます。このプロファイルには、通常ほとんどのアプリケーションコードである JVM バイトコードの実行に費やされた時間は含まれていません。

Class load
: 各メソッドによってロードされたクラスの数を示します。

Exception Profile
: 各メソッドによってスローされたエラーと例外の数を示します。

File I/O
: 各メソッドがファイルの読み取りと書き込みに費やした時間を示します。

Lock
: 各メソッドがロックの待機に費やした時間を示します。

Socket I/O
: 各メソッドがソケット I/O の読み取りと書き込みに費やした時間を示します。

{{< /programming-lang >}}
{{< programming-lang lang="python" >}}

有効にすると、次のプロファイルタイプが収集されます。


CPU
: Python やネイティブコードを含む、各関数が CPU での実行に費やした時間を示します。

Allocation
: 各関数によって割り当てられたヒープメモリの量を示します。これには、後で解放された割り当ても含まれます。Python 3 でのみサポートされます。

Allocation Count
: 各関数によるヒープ割り当ての数を示します。これには、後で解放された割り当ても含まれます。

Wall Time
: 各関数が使用した経過時間を表示します。経過時間には、コードが CPU で実行されている時間、I/O を待機している時間、および関数の実行中に発生するその他の時間が含まれます。

Exceptions
: 各関数によって発生したキャッチまたはキャッチされない例外の数を示します。

Lock
: 各関数がロック（ロックの待機または保持）に費やした時間、または関数がロックの施錠/解除を監視した回数を示します。

Uncaught Exceptions
: try/except ブロックでキャッチされなかった例外を示します。

Exceptions
: プログラムの実行中に発生した例外を示します。

{{< /programming-lang >}}
{{< programming-lang lang="go" >}}

有効にすると、次のプロファイルタイプが収集されます。


CPU Time
: 各関数が CPU での実行に費やした時間を示します。ネットワーキング、チャンネル、ミューテックス、スリープの待機のような Off-CPU の時間は、このプロファイルでキャプチャされません。ミューテックスおよびブロックのプロファイルをご確認ください。

Allocations
: アプリケーションの開始以降、各関数によってヒープメモリに割り当てられたオブジェクトの数を示します。これには、後で解放された割り当ても含まれます。これは、ガベージコレクションの負荷を調査する際に役立ちます。

Allocated Memory
: アプリケーションの開始以降、各関数によって割り当てられたヒープメモリの量を示します。これには、後で解放された割り当ても含まれます。 Go ではこれを `alloc_space` と呼びます。これは、ガベージコレクションの負荷を調査する際に役立ちます。

Heap Live Objects
: 各関数によってヒープメモリに割り当てられたオブジェクトの数と、アプリケーションの開始以降に割り当てられたまま残り、最後のガベージコレクション以降存在するオブジェクトの数を示します。これは、サービスの全体的なメモリ使用量を調査する際に役立ちます。

Heap Live Size
: 各関数によって割り当てられ、アプリケーションの開始以降に割り当てられたまま残り、最後のガベージコレクション以降存在するヒープメモリの量を示します。Go ではこれを `inuse_space` と呼びます。これは、サービスの全体的なメモリ使用量を調査する際に役立ちます。

Mutex
: アプリケーションの開始以降、関数がミューテックスを待機している時間を示します。このプロファイルのスタックトレースは、ミューテックスで続行をブロックされた別の goroutine を許可した `Unlock()` 演算子をポイントします。スピンロックを使用したショートミューテックスの競合はこのプロファイルでキャプチャされませんが、CPU プロファイルで確認できます。

Block
: アプリケーションの開始以降、関数がミューテックスおよびチャンネルオペレーションを待機している時間を示します。スリープ、GC、ネットワーク、Syscall オペレーションは、このプロファイルでキャプチャされません。ブロッキングオペレーションは、ブロックが解除されてからのみキャプチャされるため、スタックしていると思われるアプリケーションのデバッグにこのプロファイルを使用することはできません。ミューテックスの競合の場合、このプロファイルのスタックトレースはブロックされた `Lock()` 演算子をポイントします。これにより、ブロックされているプログラムがわかり、ミューテックスプロファイルにより、競合の原因となっているプログラムの部分がわかります。この点に関する詳しい情報は、[Go におけるプロファイリングのブロック][1]リサーチをご覧ください。

Goroutines
: 同じ関数（CPU 上および待機中の Off-CPU）で現在実行中の goroutines の数のスナップショットを示します。スナップショット間での goroutines の増加は、プログラムで goroutines がリークしていることを示しています。最も健康なアプリケーションでは、このプロファイルはワーカープールにより使用され、その goroutines 使用数が表示されます。遅延の影響を非常に受けやすく、大量の goroutines（10.000 以上）を使用するアプリケーションの場合、このプロファイルを有効にすると O(N) stop-the-world 型の一時停止が必要になることにご留意ください。一時停止はプロファイリング期間（デフォルトは 60 秒）ごとに発生し、通常 goroutine あたり `~1µsec` 継続します。`~100ms` の p99 レイテンシー SLO の典型的なアプリケーションでは、この警告を無視することが可能です。より詳しい情報については、[Go における Goroutine プロファイリング][2]リサーチをご覧ください。

[1]: https://github.com/DataDog/go-profiler-notes/blob/main/block.md
[2]: https://github.com/DataDog/go-profiler-notes/blob/main/goroutine.md
{{< /programming-lang >}}
{{< programming-lang lang="ruby" >}}

有効にすると、次のプロファイルタイプが収集されます。

CPU
: Ruby やネイティブコードを含む、各関数が CPU での実行に費やした時間を示します。

Wall Time
: 各関数が使用した経過時間を表示します。経過時間には、コードが CPU で実行されている時間、I/O を待機している時間、および関数の実行中に発生するその他の時間が含まれます。

{{< /programming-lang >}}
{{< /programming-lang-wrapper >}}


## その他の参考資料

{{< partial name="whats-next/whats-next.html" >}}


[1]: /ja/tracing/send_traces/#configure-your-environment
[2]: /ja/tracing/visualization/#services
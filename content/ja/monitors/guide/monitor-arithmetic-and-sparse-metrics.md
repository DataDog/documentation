---
title: 演算メトリクスと疎なメトリクスの監視
kind: ガイド
aliases:
  - /ja/monitors/guide/monitor-arithmetic-and-sparse-metrics
---
## 概要

演算を使用したクエリに基づくアラートの作成はよく行われます。このようなクエリを意図したとおりに評価できるよう、適切にモニターを設定するには、ツールと挙動についていくつか考慮する必要があります。

## 疎なメトリクス

疎なメトリクスや分子が **0** のメトリクスでは、一部の結果が拒否される可能性があります。

次のようなメトリクス値を考えます。

- `A = (10, 10, 10)`
- `B = (0, 1, -)`

計算式 `a/b` に対して、モニターは次のような評価を行います。

```
10/0 + 10/1 + 10/NaN = 10
```

評価ウィンドウに多数の「null」バケットが含まれている場合 (**10/NaN + 10/Nan + ... + 10/Nan**) は、評価が「スキップ」されるため、メトリクスを調整するか、以下のいずれかの回避策を使用する必要があります。

## 疎なメトリクスや不整列なメトリクスに対する回避策

### `.rollup()`

`.rollup()` 関数を適用すると、評価されているすべての時間バケットに有効な値を持たせることができます。この関数は、クエリに演算が含まれているかどうかに関係なく、ギャップを持つ任意のメトリクスに同様に役立ちます。

**オリジナル**: `sum:my_metric.is.sparse{*}`

```
| Timestamp             | Value    |
| :-------------------- | :------- |
| 2019-03-29 11:00:00   | 1        |
| 2019-03-29 11:00:30   |          |
| 2019-03-29 11:01:00   | 2        |
| 2019-03-29 11:01:30   | 1        |
| 2019-03-29 11:02:00   |          |
```

**変更後**: `sum:my_metric.is.sparse{*}.rollup(sum,60)`

```
| Timestamp             | Value    |
| :-------------------- | :------- |
| 2019-03-29 11:00:00   | 1        |
| 2019-03-29 11:01:00   | 3        |
| 2019-03-29 11:02:00   | 1*       |
```

`rollup()` 関数は、定義した時間間隔に基づいて時間バケットを作成します。メトリクス内のギャップの長さより大きいロールアップ間隔を設定すると、この関数でデータ内の「ギャップ」を無視できるので便利です。この例の場合、60 秒ウィンドウ内の値の合計が新しいバケットになります。

\*変更後のクエリの `2019-03-29 11:02:00` タイムスタンプの値が上の表内の値と整合していないことに注目してください。これは、`.rollup()` 関数が UNIX 時間を基準とするためです。この例の場合、`2019-03-29 11:02:30` に値 `1` があると見なすことができます。これはロールアップウィンドウ内にある時間ですが、モニターの評価ウィンドウ内にはありません。少量のデータサンプルしか入っていない不完全なロールアップ間隔に基づいてモニターがトリガーされないように、少なくともロールアップ間隔の長さの **Evaluation Delay** をモニターに加算してください。

### `.fill()`

`.fill()` 関数を適用すると、すべての時間バケットに有効な値を持たせることができます。**ゲージ**メトリクスタイプの場合、デフォルトの補間は 5 分間の `.fill(linear)` (線形) です。**カウント**および**レート**タイプのメトリクスの場合、デフォルトは `.fill(null)` (補間は無効) です。一般に、モニターでカウント/レートメトリクスに補間を使用することはお勧めしません。

**オリジナル**: `sum:my_metric.has_gaps.gauge{env:a} by {timer,env}`

```
| Timestamp             | timer:norm,env:a    | timer:offset,env:a  |
| :-------------------- | :------------------ | :------------------ |
| 2019-03-29 12:00:00   | 1                   |                     |
| 2019-03-29 12:05:00   |                     | 1                   |
| 2019-03-29 12:10:00   | 0                   |                     |
| 2019-03-29 12:15:00   |                     | 1                   |
| 2019-03-29 12:20:00   | 1                   |                     |
| 2019-03-29 12:25:00   |                     | 1                   |
| 2019-03-29 12:30:00   | 1                   |                     |
```

`my_metric.has_gaps.gauge` のメトリクスタイプが**ゲージ**だとすると、デフォルトで 5 分間の線形補間が使用されますが、このメトリクスは 10 分ごとに報告します。次のようなクエリを考えます。

```
sum(last_30m):sum:my_metric.has_gaps.gauge{timer:norm,env:a} / sum:my_metric.has_gaps.gauge{timer:offset,env:a}
```

大部分の評価は「スキップ」になります。

| パス                | 評価                               | 結果 |
| :------------------ | :--------------------------------------- | :----- |
| `classic_eval_path` | **1/Nan + Nan/1 + ... + 1/Nan + Nan/1**  |   N/A  |

補間を調整することで、すべての時間間隔でメトリクスを得ることができます。

**変更後**: `sum:my_metric.has_gaps.gauge{env:a} by {timer,env}.fill(last,900)`

```
| Timestamp             | timer:norm,env:a    | timer:offset,env:a  |
| :-------------------- | :------------------ | :------------------ |
| 2019-03-29 12:00:00   | 1                   | (1)                 |
| 2019-03-29 12:05:00   | 1                   | 1                   |
| 2019-03-29 12:10:00   | 0                   | 1                   |
| 2019-03-29 12:15:00   | 0                   | 1                   |
| 2019-03-29 12:20:00   | 1                   | 1                   |
| 2019-03-29 12:25:00   | 1                   | 1                   |
| 2019-03-29 12:30:00   | 1                   | 1                   |
```

変更後のクエリ

```
sum(last_30m):sum:my_metric.has_gaps.gauge{timer:norm,env:a}.fill(last,900) / sum:my_metric.has_gaps.gauge{timer:offset,env:a}.fill(last,900)
```

`.fill(last,900)` による新しい結果は次のとおりです。

| パス                | 評価                                    | 結果 |
| :------------------ | :-------------------------------------------- | :----- |
| `classic_eval_path` | **(1)/1 + 1/1 + 0/1 + 0/1 + 1/1 + 1/1 + 1/1** | 5      |

### 短い評価ウィンドウ

短い評価ウィンドウのモニターに除算が含まれると、タイミングの問題が発生する可能性があります。評価ウィンドウ 1 分のモニタークエリで除算を行う場合、その分子と分母は 2 ～ 3 秒のオーダーの時間バケットになります。クエリ時間に分子と分母のメトリクスのどちらかがない場合は、意味のない評価値を受け取る可能性があります。

```
| Timestamp             | sum:my_num{*}       | sum:my_denom{*}     |
| :-------------------- | :------------------ | :------------------ |
| ...                   | ...                 | ...                 |
| 2019-03-29 13:30:50   | 900                 | 1000                |
| 2019-03-29 13:30:52   | 900                 | 1000                |
| 2019-03-29 13:30:54   | 900                 | 1000                |
| 2019-03-29 13:30:56   | 120 (inc)           | 850 (inc)           |
```

`min(last_1m):sum:my_num{*}/sum:my_denom{*}` のようなクエリの場合は、最小値が歪められて、誤ったモニターがトリガーされる可能性があります。

したがって、短い評価ウィンドウのクエリに除算が含まれる場合は、タイミングの問題が発生しないように、30 ～ 60 秒の短い評価遅延を加算することを検討してください。または、評価ウィンドウを 5 分に変更する方法もあります。

このロジックに関するご質問は、[Datadog のサポートチームまでお問い合わせください][1]。

[1]: /ja/help
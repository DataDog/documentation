---
disable_toc: false
further_reading:
- link: logs/explorer/analytics
  tag: ドキュメント
  text: ログ分析の実行
- link: /logs/explorer/export
  tag: ドキュメント
  text: ログエクスプローラーからビューをエクスポートする
- link: /logs/explorer/saved_views/
  tag: ドキュメント
  text: 保存ビューについて
title: 高度な検索
---

## 概要

ログ検索の結果をさらに絞り込む必要がある場合は、[サブクエリ](#filter-logs-with-subqueries)を使って、セカンダリロググループと結果を比較したり、[リファレンステーブル](#filter-logs-based-on-reference-tables)のデータを使ってログをフィルタリングします。

## サブクエリによるログのフィルタリング

<div class="alert alert-warning">サブクエリによるログのフィルタリングはベータ版です。</div>

サブクエリは、セカンダリクエリの結果に基づいてクエリの結果をフィルタリングしたい場合に使用します。2 つの例については、[サブクエリの例](#subquery-examples)を参照してください。

サブクエリフィルターを追加するには

1. [ログエクスプローラー][1]に移動します。
1. 検索バーにクエリを入力して、ログをフィルタリングします。これがメインのクエリです。
1. **+ Add** をクリックします。
1. **Add Query Filter** セクションで、**Logs** を選択します。

これにより、クエリエディターに新しい要素がもたらされます。

{{< img src="logs/explorer/advanced_search/subquery.png" alt="メイン検索クエリの下のサブクエリエディター" style="width:95%;" >}}

1. **where** フィールドで、ドロップダウンメニューを使用して、相関させたい属性を選択します。利用可能な属性は、メインクエリで返されたログに基づいています。
1. **from** フィールドにサブクエリフィルターを定義します。
1. サブクエリフィルターの前にある **Select Column** ドロップダウンメニューで、サブクエリの結果をグループ化して並べ替えたい属性を選択します。 
1. **IN** または **NOT IN** のどちらの演算子を使用するかを選択します。
    - **IN** 演算子を用いた結果は、サブクエリの結果にも含まれる属性値を持つログのみを含みます。例えば、`service:a` によって生成されたログで、`service:b` のトップユーザーの一人であるユーザーに関連付けられているものだけを見たい場合です。 
    - **NOT IN** 演算子を用いた結果は、サブクエリの結果に含まれる属性値を持つログを除外します。例えば、`status:error` のログのみを表示したい場合、それに関連するユーザーが最終的に `status:success` のログを持つ `status:error` ログも除外したいとします。詳しい例については、[時代遅れまたは上書きされたログのフィルタリング](#filter-outdated-or-supersed-logs)を参照してください。
1. オプションで、照合するサブクエリの属性値の数を減らします。デフォルト値および最大値は `1000` です。**top** (最も頻度の高い値) または **bottom** (最も頻度の低い値) のどちらかを選択します。

### サブクエリの例

以下は、ログから必要な情報を取得するためにサブクエリを使用する必要があるシナリオです。

#### 時代遅れまたは上書きされたログのフィルタリング

E コマースプラットフォームを運営しているとします。顧客が注文しようとするたびにログが生成されます。Web サイトの継続的な問題によって失われた潜在的な購入の総額を理解するために、ログを分析したいとします。

しかし、注文が正常に完了するまでに何度も失敗する可能性があることに気づきます。つまり、その特定の注文 ID では、検索結果に `status:error` ログと `status:success` ログの両方のログエントリがあります。2 つのクエリから一意な注文 ID のリストを抽出した場合、この注文 ID は両方に表示されることになります。サブクエリを使用すると、相互に排他的なリストを取得できます。

この例では、あなたは最終的に成功しなかった注文のログにのみ関心があります。サブクエリ機能を使用して、最終的に成功した注文を除外するには

1. `status:success` ログ用のサブクエリを定義します。
1. サブクエリの結果セットから注文を除外するには、**NOT IN** 演算子を選択します。

{{< img src="logs/explorer/advanced_search/filter_outdated_example.png" alt="成功した注文を除外するためのセットアップを示すクエリエディター" style="width:100%;" >}}

#### 異なるログソース間の相関付け

`network_directory` という名前のサービスがあり、組織内のすべての内部ネットワークリソースと、それらのリソースへのアクセスを監視しているとします。このサービスによって生成されるログイベントには、標準的な属性 (`host`、`service`、`source` など) と、クライアントの IP アドレスのようなカスタム属性があります。

さらに、すべての内部アセット (インフラストラクチャー、従業員のデバイスなど) を追跡する別のサービス、`device-manager` もあります。

現在進行中の攻撃を調査中で、ほぼすべてのエンドポイントで API リクエストが大幅に増加していることに気付きました。まず、異常なリクエスト量に関連する IP アドレスを特定し、それらをファイアウォールレベルでブロックしたいと考えています。しかし、内部サービスはこれらエンドポイントの主要な利用者の一部であるため、誤ってブロックすることを避けるためにクエリ結果から除外する必要があります。

この例では、`service:network_directory` をメインのクエリとして使用し、次に `device-manager` サービス用のサブクエリフィルターを定義して、認識されたデバイスからの結果を除外します。

{{< img src="logs/explorer/advanced_search/narrow_dataset_example.png" alt="認識されたデバイスの結果を除外するためのセットアップを示すクエリエディター" style="width:100%;" >}}

## リファレンステーブルに基づくログのフィルター

<div class="alert alert-warning">リファレンステーブルはベータ版です。40,000 行を超えるリファレンステーブルは、ログのフィルタリングには使用できません。リファレンステーブルの作成および管理方法の詳細については、<a href="https://docs.datadoghq.com/integrations/guide/reference-tables/">リファレンステーブルによるカスタムメタデータの追加</a>を参照してください。</div>

リファレンステーブルを使用すると、メタデータとログを組み合わせて、アプリケーションの問題を解決するための詳細な情報を提供できます。リファレンステーブルに基づいてクエリフィルターを追加し、検索クエリを実行します。この機能の作成と管理の詳細については、[リファレンステーブル][2]ガイドを参照してください。

リファレンステーブルを使用してクエリフィルターを適用するには、クエリエディターの横にある `+ Add` ボタンをクリックし、**Reference Table** を選択します。次の例では、リファレンステーブルクエリフィルターを使用して、脅威インテリジェンスリファレンステーブルから悪意のある IP アドレスを含むすべての最近のログを検索します。

{{< img src="logs/explorer/advanced_search/reference_tables_logs.png" alt="リファレンステーブルの検索オプションがハイライトされた Datadog ログエクスプローラー" border="true" popup="true" style="width:100%;" >}}

## その他の参考資料

{{< partial name="whats-next/whats-next.html" >}}

[1]: https://app.datadoghq.com/logs
[2]: /ja/integrations/guide/reference-tables/?tab=manualupload
---
aliases:
- /ja/logs/search-syntax
- /ja/logs/search_syntax/
description: すべてのログを検索する
further_reading:
- link: /logs/explorer/#visualize
  tag: ドキュメント
  text: ログを視覚化する方法
- link: /logs/explorer/#patterns
  tag: ドキュメント
  text: ログ内のパターン検出
- link: /logs/log_configuration/processors
  tag: ドキュメント
  text: ログの処理方法
- link: /logs/explorer/saved_views/
  tag: ドキュメント
  text: 保存ビューについて
- link: /logs/explorer/calculated_fields/expression_language
  tag: ドキュメント
  text: Calculated Fields Expression Language について
title: ログ検索構文
---

## 概要

クエリフィルターは、用語と演算子で構成されます。

用語には 2 種類あります。

* **単一条件**は、1 つの単語です (`test`、`hello` など)。

* **シーケンス**は、二重引用符で囲まれた単語のグループです (`"hello dolly"` など)。

複合クエリで複数の条件を組み合わせるには、以下の大文字と小文字を区別するブール演算子を使用します。

|              |                                                                                                        |                              |
|--------------|--------------------------------------------------------------------------------------------------------|------------------------------|
| **演算子** | **説明**                                                                                        | **例**                  |
| `AND`        | **積**: 両方の条件を含むイベントが選択されます (何も追加しなければ、AND がデフォルトで採用されます)。 | authentication AND failure   |
| `OR`         | **和**: いずれかの条件を含むイベントが選択されます。                                             | authentication OR password   |
| `-`          | **除外**: 以下の用語はイベントに含まれません (個々の生テキスト検索に適用されます)。                                                  | authentication AND -password |

## 全文検索

<div class="alert alert-danger">全文検索機能は Log Management でのみ利用可能で、モニター、ダッシュボード、およびノートブックのクエリで動作します。全文検索構文は、インデックスフィルター、アーカイブフィルター、ログパイプラインフィルター、リハイドレーションフィルター、または Live Tail では使用することはできません。</div>

構文 `*:search_term` を使用して、ログメッセージを含むすべてのログ属性にわたって全文検索を実行します。

### 単一の用語の例

| 検索構文 | 検索タイプ  | 説明                                               |
| ------------- | ----------- | --------------------------------------------------------- |
| `*:hello`      | 全文   | すべてのログ属性から `hello` という文字列を検索します。 |
| `hello`       | フリーテキスト    | ログ メッセージのみを対象に、文字列 `hello` を完全一致で検索します。       |

### ワイルドカードを使った検索例

| 検索構文 | 検索タイプ  | 説明                                                                                 |
| ------------- | ----------- | ------------------------------------------------------------------------------------------- |
| `*:hello`      | 全文   | すべてのログ属性から `hello` という文字列を検索します。                                   |
| `*:hello*`    | 全文   | すべてのログ属性で、`hello` で始まる文字列を検索します。例: `hello_world`。  |

### 完全一致の複数用語の例

| 検索構文       | 検索タイプ  | 説明                                                                                        |
| ------------------- | ----------- |--------------------------------------------------------------------------------------------------- |
| `*:"hello world"`   | 全文   | すべてのログ属性で、文字列 `hello world` を完全一致で検索します。                                    |
| `hello world`       | フリーテキスト    | ログ メッセージ内の `hello` と `world` という単語のみを検索します。例: `hello beautiful world`。  |

## 特殊文字とスペースのエスケープ

次の文字は特殊文字と見なされ、`\` 文字でエスケープする必要があります: `-` `!` `&&` `||` `>` `>=` `<` `<=` `(` `)` `{` `}` `[` `]` `"` `*` `?` `:` `\` `#`、およびスペース。
- `/` は特殊文字とは見なされないため、エスケープは不要です。
- Logs Explorer 内の検索クエリでは `@` は使用できません。これは [属性検索](#attributes-search) に予約されているためです。

ログメッセージ内の特殊文字を検索することはできません。特殊文字が属性の中にある場合は、検索することができます。

特殊文字を検索するには、[Grok Parser][1] で特殊文字を属性にパースし、その属性を含むログを検索してください。


## 属性検索

特定の属性を検索するには、`@` を付けて属性検索であることを明示します。

たとえば、属性名が **url** で、**url** の値 `www.datadoghq.com` で絞り込む場合は、次のように入力します。

```
@url:www.datadoghq.com
```


**注**:

1. 属性やタグを検索するためのファセットの定義は**不要です**。

2. 属性検索は大文字と小文字を区別します。 [全文検索](#full-text-search)を使うと大文字と小文字を区別せずに検索できます。また、検索時に大文字と小文字を区別しない結果を得るために、Grok パーサーで `lowercase` フィルターを使用してパースすることもできます。

3. 特殊文字を含む属性値を検索するには、エスケープ処理または二重引用符が必要です。
    - たとえば、値が `hello:world` の属性 `my_attribute` は、`@my_attribute:hello\:world` または `@my_attribute:"hello:world"` を使用して検索します。
    - 単一の特殊文字またはスペースに一致させるには、`?` ワイルドカードを使用します。たとえば、値が `hello world` の属性 `my_attribute` は、`@my_attribute:hello?world` を使用して検索します。

例:

| 検索クエリ                                                         | 説明                                                                                                                                                         |
|----------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `@http.url_details.path:"/api/v1/test"`                              | 属性 `http.url_details.path` に `/api/v1/test` と一致するすべてのログを検索します。                                                                               |
| `@http.url:/api\-v1/*`                                             | `http.url` 属性に `/api-v1/` で始まる値を含むすべてのログを検索します。                                                                             |
| `@http.status_code:[200 TO 299] @http.url_details.path:/api\-v1/*` | `http.status_code` の値が 200 から 299 で、`http.url_details.path` 属性に `/api-v1/` で始まる値を含むすべてのログを検索します。 |
| `-@http.status_code:*`                                                | `http.status_code` 属性を含まないすべてのログを検索します |

### CIDR 表記による検索
CIDR (Classless Inter Domain Routing) は、IP アドレスの範囲 (CIDR ブロックとも呼ばれる) を簡潔に定義することができる表記法です。CIDR は、ネットワーク (VPC など) またはサブネットワーク (VPC 内のパブリック/プライベートサブネットなど) を定義するために最もよく使用されます。

ユーザーは `CIDR()` 関数を使用して、CIDR 表記を使用してログの属性をクエリすることができます。`CIDR()` 関数は、フィルタリングのパラメーターとしてログ属性を渡し、その後に 1 つまたは複数の CIDR ブロックを渡す必要があります。

#### 例
- `CIDR(@network.client.ip,13.0.0.0/8)` は、フィールド `network.client.ip` の IP アドレスが 13.0.0.0/8 CIDR ブロックに該当するログにマッチしてフィルターをかけます。
- `CIDR(@network.ip.list,13.0.0.0/8, 15.0.0.0/8)` は、配列属性 `network.ip.list` の IP アドレスが 13.0.0.0/8 または 15.0.0.0/8 CIDR ブロックに該当するログにマッチしてフィルターをかけます。
- `source:pan.firewall evt.name:reject CIDR(@network.client.ip, 13.0.0.0/8)` は、13.0.0.0/8 サブネットで発信されるパロアルトファイアウォールの拒否イベントにマッチしてフィルターにかけます。
- `source:vpc NOT(CIDR(@network.client.ip, 13.0.0.0/8)) CIDR(@network.destination.ip, 15.0.0.0/8)` は、サブネット間で環境内のネットワークトラフィックを分析するため、サブネット 13.0.0.0/8 から発生していないが、宛先サブネット 15.0.0.0/8 へ向けられている VPC ログをすべて表示します。

`CIDR()` 関数は、IPv4 と IPv6 の CIDR 表記をサポートし、ログエクスプローラー、Live Tail、ダッシュボードのログウィジェット、ログモニター、およびログ構成で動作します。

## ワイルドカード

フリーテキスト検索ではワイルドカードを使用することができます。ただし、ログエクスプローラーの `content` 列のテキストであるログメッセージ内の用語のみを検索します。ログ属性の値を検索したい場合は、[全文検索](#full-text-search)を参照してください。

### 複数文字のワイルドカード

ログメッセージ (ログエクスプローラーの `content` 列) で複数文字のワイルドカード検索を行うには、以下のように `*` 記号を使用します。

* `service:web*` は、`web` で始まるサービスを持つすべてのログメッセージに一致します。
* `web*` は、`web` で始まるすべてのログメッセージに一致します。
* `*web` は、`web` で終わるすべてのログメッセージに一致します。

**注**: ワイルドカードは、二重引用符の外側にあるワイルドカードとしてのみ機能します。例えば、`"*test*"` は、メッセージの中に `*test*` という文字列があるログにマッチします。`*test*` は、メッセージのどこかに test という文字列を持つログにマッチします。

ワイルドカード検索は、この構文を使用してタグおよび属性 (ファセット使用の有無を問わない) 内で機能します。次のクエリは、文字列 `mongo` で終わるすべてのサービスを返します。
<p> </p>
<p></p>

```
service:*mongo
```

ワイルドカード検索は、ログ属性の一部ではないログのプレーンテキストを検索するためにも使用できます。例えば、このクエリは文字列 `NETWORK` を含むコンテナ (メッセージ) を持つすべてのログを返します。

```
*NETWORK*
```

しかし、この検索語は、文字列 `NETWORK` がログ属性内にあり、ログメッセージの一部でない場合は、それを含むログを返しません。

### ワイルドカードを検索

特殊文字を含む属性値またはタグ値を検索する場合や、エスケープまたは二重引用符を必要とする場合は、`?` ワイルドカードを使用して 1 つの特殊文字またはスペースに一致させます。たとえば、値が `hello world` の属性 `my_attribute` を検索するには: `@my_attribute:hello?world`
<p> </p>

## 数値

数値属性を検索するには、まず[その属性をファセットとして追加][2]します。次に、数値演算子 (`<`、`>`、`<=`、または `>=`) を使用して、数値ファセットの検索を行うことができます。
例えば、応答時間が 100ms 超のログをすべて取得するには、次のようにします。
<p> </p>

```
@http.response_time:>100
```

特定の範囲内にある数値属性を検索することができます。たとえば、4xx エラーをすべて取得するには、次のようにします。

```
@http.status_code:[400 TO 499]
```

## タグ

ログは、タグを生成する[ホスト][3]と[インテグレーション][4]からタグを引き継ぎます。これらも、ファセットとして検索で使用できます。

* `test` は文字列「test」を検索します。
* `env:(prod OR test)` は、タグ `env:prod` またはタグ `env:test` を含むすべてのログに一致します。
* `(env:prod AND -version:beta)` は、タグ `env:prod` を含み、タグ `version:beta` は含まないすべてのログに一致します。

タグが[タグのベストプラクティス][5]に従わず、`key:value` 構文も使用していない場合は、次の検索クエリを使用します。

* `tags:<MY_TAG>`

## 配列

次の例では、ファセットで `Peter` 値をクリックすると、`users.names` 属性の値が `Peter` であるか、`Peter` を含む配列であるすべてのログが返されます。

{{< img src="logs/explorer/search/array_search.png" alt="配列とファセット" style="width:80%;">}}

**注**: 同等の構文を使用して、検索をファセットではない配列属性にも使用することができます。

以下の例では、Windows 用の CloudWatch ログは、`@Event.EventData.Data` の下に JSON オブジェクトの配列が含まれています。JSON オブジェクトの配列にファセットを作成することはできませんが、以下の構文で検索することができます。

* `@Event.EventData.Data.Name:ObjectServer` はキー`Name` と値 `ObjectServer` ですべてのログに一致します。

{{< img src="logs/explorer/search/facetless_query_json_arrray2.png" alt="JSON オブジェクト配列上のファセットなしクエリ" style="width:80%;">}}
<p> </p>

## 計算フィールド

計算フィールドはログ属性のように機能し、検索、集計、可視化、さらには他の計算フィールドの定義にも使用できます。計算フィールド名を参照するには、`#` プレフィックスを使用してください。

{{< img src="logs/explorer/calculated_fields/calculated_field.png" alt="Log Explorer で結果をフィルタリングするために使用される request_duration という計算フィールド" style="width:100%;" >}}

## 検索の保存

[保存ビュー][6]に、検索クエリ、列、対象期間、およびファセットが格納されます。

## その他の参考資料

{{< partial name="whats-next/whats-next.html" >}}

[1]: /ja/logs/log_configuration/parsing
[2]: /ja/logs/explorer/facets/
[3]: /ja/infrastructure/
[4]: /ja/integrations/#cat-log-collection
[5]: /ja/getting_started/tagging/#tags-best-practices
[6]: /ja/logs/explorer/saved_views/
[7]: /ja/logs/explorer/facets/#facet-panel
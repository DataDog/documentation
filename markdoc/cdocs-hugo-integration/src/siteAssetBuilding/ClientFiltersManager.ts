/**
 * A class containing functions for resolving the user's
 * current filters, and updating the page content in response
 * to selection changes.
 *
 * When a new page loads, it should call ClientFiltersManager.initialize()
 * in order to set up the ClientFiltersManager with the necessary data
 * for re-rendering the content and the filter UI
 * in response to user selection changes.
 *
 * There should only be one instance of the ClientFiltersManager
 * in the application, with the configuration
 * updating as various pages are loaded.
 *
 * The minified ClientFiltersManager is provided in the assets partial string
 * generated by CdocsHugoIntegration.buildAssetsPartial().
 * The contents of that partial should be included
 * in the head of the main page layout.
 */

import { buildCustomizationMenuUi } from '../fileRendering/customizationMenu';
import { ClientSideFiltersManifest } from 'cdocs-data/ClientSideFiltersManifest';
import { getTraitValsFromUrl } from 'cdocs-data/getTraitValsFromUrl';
import { writeTraitValsToUrl } from 'cdocs-data/writeTraitValsToUrl';
import { CdocsClientStorage } from 'cdocs-data/CdocsClientStorage';
import { resolveFilters } from 'cdocs-data/resolveFilters';
import { ClientFunction } from 'cdocs-markdoc/src/types';
import { reresolveFunctionNode } from '../markdocCustomization/renderer/reresolver';
import {
  expandClientFunction,
  MinifiedClientFunction
} from '../fileRendering/pageConfigMinification';

const PILLS_MENU_ID = 'cdoc-filters-pill-menu';
const DROPDOWN_MENU_ID = 'cdoc-filters-dropdown-menu';
const MENU_WRAPPER_ID = 'cdoc-filters-menu';
const OFFSCREEN_CLASS = 'cdoc-offscreen';

export class ClientFiltersManager {
  static #instance: ClientFiltersManager;

  private browserStorage: CdocsClientStorage;
  private filtersManifest?: ClientSideFiltersManifest;
  private filterSelectorEl?: HTMLElement;
  private selectedValsByTraitId: Record<string, string> = {};
  private ifFunctionsByRef: Record<string, ClientFunction> = {};

  /**
   * There is always only one instance,
   * and it is created lazily, so this will only run once,
   * and is not accessible from outside the class
   * in order to prevent instantiation.
   */
  private constructor() {
    this.browserStorage = new CdocsClientStorage({
      topLevelKey: 'datadog-docs-content-filters',
      maxKeyCount: 20
    });
  }

  /**
   * Return the existing instance,
   * or create a new one if none exists.
   */
  public static get instance(): ClientFiltersManager {
    if (!ClientFiltersManager.#instance) {
      ClientFiltersManager.#instance = new ClientFiltersManager();
      // @ts-ignore
      window.markdocBeforeRevealHooks = window.markdocBeforeRevealHooks || [];
      // @ts-ignore
      window.markdocAfterRerenderHooks = window.markdocAfterRerenderHooks || [];
    }

    return ClientFiltersManager.#instance;
  }

  /**
   * Reconfigure the ClientFiltersManager to manage a new page.
   *
   * Called by a given doc page on load.
   */
  initialize(p: {
    ifFunctionsByRef: Record<string, MinifiedClientFunction>;
    filtersManifest: ClientSideFiltersManifest;
  }) {
    this.filtersManifest = p.filtersManifest;
    this.selectedValsByTraitId = p.filtersManifest.defaultValsByTraitId || {};
    this.ifFunctionsByRef = {};

    const contentIsCustomizable = this.locateFilterSelectorEl();
    if (contentIsCustomizable) {
      // Unminify conditional function data
      Object.keys(p.ifFunctionsByRef).forEach((ref) => {
        this.ifFunctionsByRef[ref] = expandClientFunction(
          p.ifFunctionsByRef[ref]
        ) as ClientFunction;
      });

      const overrideApplied = this.applyFilterSelectionOverrides();
      if (overrideApplied) {
        this.rerender();
      } else {
        this.addFilterSelectorEventListeners();
      }
    }

    this.populateRightNav();
    this.fitCustomizationMenuToScreen();
    this.addWindowResizeListener();
    this.revealPage();
    this.updateEditButton();

    if (contentIsCustomizable) {
      this.syncUrlWithSelectedVals();
      this.browserStorage.setTraitVals(this.selectedValsByTraitId);
    }
  }

  /**
   * Update the URL with the selected filter values.
   */
  syncUrlWithSelectedVals() {
    const url = writeTraitValsToUrl({
      url: new URL(window.location.href),
      traitValsById: this.selectedValsByTraitId
    });

    window.history.replaceState({}, '', url.toString());
  }

  /**
   * When the user changes a filter value,
   * update the selected values data,
   * and rerender the chooser and page content.
   */
  handleFilterSelectionChange(e: Event) {
    const node = e.target;
    if (!(node instanceof Element)) {
      return;
    }
    const filterId = node.getAttribute('data-filter-id');
    if (!filterId) {
      return;
    }
    const optionId = node.getAttribute('data-option-id');
    if (!optionId) {
      return;
    }

    this.selectedValsByTraitId[filterId] = optionId;
    this.rerender();
    this.syncUrlWithSelectedVals();
    this.browserStorage.setTraitVals(this.selectedValsByTraitId);
  }

  /**
   * Check whether the element or any of its ancestors
   * have the class 'cdoc__hidden'.
   */
  elementIsHidden(element: Element) {
    // check whether the element or any of its parents are hidden
    let currentElement: Element | null = element;
    while (currentElement) {
      if (currentElement.classList.contains('cdoc__hidden')) {
        return true;
      }
      currentElement = currentElement.parentElement;
    }
  }

  /**
   * Populate the right nav with links to the headers
   * on the page.
   *
   * Should run after the page has been rendered.
   */
  populateRightNav() {
    let html = '<ul>';
    const headers = Array.from(
      document.querySelectorAll('#mainContent h2, #mainContent h3')
    );
    let lastSeenLevel = 2;
    headers.forEach((header) => {
      if (this.elementIsHidden(header)) {
        return;
      }

      // Start or end a list if the level has changed
      const level = parseInt(header.tagName[1]);
      if (level === lastSeenLevel) {
        html += '</li>';
      } else if (level > lastSeenLevel) {
        html += '<ul>';
      } else if (level < lastSeenLevel) {
        html += '</ul></li>';
      }
      lastSeenLevel = level;

      html += `<li><a href="#${header.id}">${header.textContent}</a>`;
    });
    html += '</li></ul>';
    const rightNav = document.getElementById('TableOfContents');
    if (!rightNav) {
      return;
    }
    rightNav.innerHTML = html;
  }

  /**
   * Refresh all page content.
   */
  rerender() {
    this.rerenderFilterMenu();
    this.rerenderPageContent();
    this.populateRightNav();
    //@ts-ignore
    markdocAfterRerenderHooks.forEach((hook) => hook());
  }

  /**
   * Rerender the section of the page that was derived
   * from the author's .mdoc.md file.
   */
  rerenderPageContent() {
    const newDisplayStatusByRef: Record<string, boolean> = {};

    // Update the resolved function values,
    // and make a list of refs that require a display status change
    Object.keys(this.ifFunctionsByRef).forEach((ref) => {
      const clientFunction = this.ifFunctionsByRef[ref];
      const oldValue = clientFunction.value;
      const resolvedFunction = reresolveFunctionNode(clientFunction, {
        variables: this.selectedValsByTraitId
      });
      this.ifFunctionsByRef[ref] = resolvedFunction;
      if (oldValue !== resolvedFunction.value) {
        newDisplayStatusByRef[ref] = resolvedFunction.value;
      }
    });

    const toggleables = document.getElementsByClassName('cdoc__toggleable');
    for (let i = 0; i < toggleables.length; i++) {
      const toggleable = toggleables[i];

      const ref = toggleable.getAttribute('data-if');

      if (!ref) {
        throw new Error('No ref found on toggleable element');
      }
      if (newDisplayStatusByRef[ref] === undefined) {
        continue;
      }

      if (newDisplayStatusByRef[ref]) {
        toggleable.classList.remove('cdoc__hidden');
      } else {
        toggleable.classList.add('cdoc__hidden');
      }
    }
  }

  addWindowResizeListener() {
    window.addEventListener('resize', () => {
      this.fitCustomizationMenuToScreen();
    });
  }

  /**
   * Expand or hide the dropdown menu when the user clicks on it,
   * or clicks on the document outside of it.
   */
  addDropdownEventListeners() {
    const dropdownContainers = document.getElementsByClassName('cdoc-dropdown');

    // Expand or hide dropdown on button click
    for (let i = 0; i < dropdownContainers.length; i++) {
      dropdownContainers[i].addEventListener('click', (e) => {
        const target = e.target as HTMLElement;

        // find the parent dropdown container
        let parent = target;
        while (!parent.classList.contains('cdoc-dropdown') && parent.parentElement) {
          parent = parent.parentElement;
        }

        const isExpanded = parent.classList.toggle('cdoc-dropdown__expanded');
        parent.setAttribute('aria-expanded', isExpanded.toString());
      });
    }

    // Handle Enter key presses on dropdown options
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        const target = e.target as HTMLElement;
        if (target.classList.contains('cdoc-filter__option')) {
          target.click();
        }
      }
    });

    // Hide dropdown on outside clicks
    document.addEventListener('click', (e) => {
      for (let i = 0; i < dropdownContainers.length; i++) {
        const dropdownContainer = dropdownContainers[i];
        if (!dropdownContainer.contains(e.target as Node)) {
          dropdownContainer.classList.remove('cdoc-dropdown__expanded');
          dropdownContainer.setAttribute('aria-expanded', 'false');
        }
      }
    });
  }

  /**
   * Listen for changes in the filter selector.
   */
  addFilterSelectorEventListeners() {
    const filterOptionPills = document.getElementsByClassName('cdoc-filter__option');
    for (let i = 0; i < filterOptionPills.length; i++) {
      filterOptionPills[i].addEventListener('click', (e) =>
        this.handleFilterSelectionChange(e)
      );
    }
    this.addDropdownEventListeners();
  }

  /**
   * Find the filter selector on a given page.
   */
  locateFilterSelectorEl() {
    const filterSelectorEl = document.getElementById('cdoc-selector');
    if (!filterSelectorEl) {
      return false;
    } else {
      this.filterSelectorEl = filterSelectorEl;
      return true;
    }
  }

  /**
   * Resolve all available filter sources (URL params, local storage,
   * default values, etc.) into a single set of selected values.
   */
  applyFilterSelectionOverrides() {
    const relevantTraitIds = Object.keys(this.selectedValsByTraitId);
    let traitValOverrideFound = false;

    const storedTraitValsById = this.browserStorage.getTraitVals();

    // Override default values with stored trait values
    Object.keys(storedTraitValsById).forEach((traitId) => {
      if (
        relevantTraitIds.includes(traitId) &&
        this.selectedValsByTraitId[traitId] !== storedTraitValsById[traitId]
      ) {
        this.selectedValsByTraitId[traitId] = storedTraitValsById[traitId];
        traitValOverrideFound = true;
      }
    });

    // Override stored filters with URL params
    const urlTraitValsById = getTraitValsFromUrl({
      url: new URL(window.location.href),
      traitIds: relevantTraitIds
    });

    Object.keys(urlTraitValsById).forEach((traitId) => {
      if (this.selectedValsByTraitId[traitId] !== urlTraitValsById[traitId]) {
        this.selectedValsByTraitId[traitId] = urlTraitValsById[traitId];
        traitValOverrideFound = true;
      }
    });

    return traitValOverrideFound;
  }

  /**
   * Override Hugo's default edit button to point to an .mdoc.md file,
   * since the .md file is generated code and not stored in the repo.
   */
  updateEditButton() {
    const editButton = document.getElementsByClassName('toc-edit-btn')[0];
    if (!editButton) {
      return;
    }
    const editButtonLink = editButton.getElementsByTagName('a')[0];
    if (!editButtonLink) {
      return;
    }
    editButtonLink.href = editButtonLink.href.replace(/\.md\/$/, '.mdoc.md/');
  }

  /**
   * Flip the page from hidden to visible
   * after making sure the TOC and other elements are
   * correctly synced with the user's current filters.
   */
  revealPage() {
    // @ts-ignore
    markdocBeforeRevealHooks.forEach((hook) => hook());

    if (this.filterSelectorEl) {
      this.filterSelectorEl.style.position = 'sticky';
      this.filterSelectorEl.style.top = '95px';
      this.filterSelectorEl.style.backgroundColor = 'white';
      this.filterSelectorEl.style.paddingTop = '10px';
      this.filterSelectorEl.style.visibility = 'visible';
      this.filterSelectorEl.style.zIndex = '1000';
    }

    const content = document.getElementById('cdoc-content');
    if (content) {
      content.style.visibility = 'visible';
    }
  }

  /**
   * Rerender the filter selector based on the current selections,
   * since some selections and options may have changed.
   */
  rerenderFilterMenu() {
    if (!this.filterSelectorEl || !this.filtersManifest) {
      throw new Error(
        'Cannot rerender filter selector without filtersManifest and filterSelectorEl'
      );
    }

    /**
     * Re-resolve the page filters, since a newly selected value
     * can have a cascading impact on the interpolated placeholder values,
     * and thus the valid options for each filter.
     */
    const resolvedPageFilters = resolveFilters({
      filtersManifest: this.filtersManifest,
      valsByTraitId: this.selectedValsByTraitId
    });

    /**
     * Update the selected values to align with the resolved filters,
     * in case any previously selected values
     * have become invalid and been overridden by defaults.
     */
    Object.keys(resolvedPageFilters).forEach((filterId) => {
      const resolvedFilter = resolvedPageFilters[filterId];
      this.selectedValsByTraitId[filterId] = resolvedFilter.currentValue;
    });

    const newFilterSelectorHtml = buildCustomizationMenuUi(resolvedPageFilters);
    this.filterSelectorEl.innerHTML = newFilterSelectorHtml;
    this.fitCustomizationMenuToScreen();
    this.addFilterSelectorEventListeners();
  }

  /**
   * Decide whether to render pills or dropdowns, depending
   * on the width of the customization menu.
   */
  fitCustomizationMenuToScreen() {
    const pillsMenu = document.getElementById(PILLS_MENU_ID);
    if (!pillsMenu) {
      return;
    }

    const pillsAreHidden = pillsMenu.classList.contains(OFFSCREEN_CLASS);

    const dropdownMenu = document.getElementById(DROPDOWN_MENU_ID);
    if (!dropdownMenu) {
      throw new Error('Dropdown menu not found');
    }

    const menuWrapper = document.getElementById(MENU_WRAPPER_ID);
    if (!menuWrapper) {
      throw new Error('Menu wrapper not found');
    }

    const pillsMenuIsOverflowing = pillsMenu.scrollWidth > menuWrapper.clientWidth;

    if (!pillsAreHidden && pillsMenuIsOverflowing) {
      pillsMenu.classList.add(OFFSCREEN_CLASS);
      dropdownMenu.classList.remove(OFFSCREEN_CLASS);
    } else if (pillsAreHidden && !pillsMenuIsOverflowing) {
      pillsMenu.classList.remove(OFFSCREEN_CLASS);
      dropdownMenu.classList.add(OFFSCREEN_CLASS);
    }
  }
}

import { MarkdocHugoIntegration } from '../../src';
import { describe, test, expect } from 'vitest';
import { SNAPSHOTS_DIR, INVALID_SITE_DIR } from '../config/constants';
import { FileNavigator } from '../../src/helperModules/FileNavigator';

const siteDir = INVALID_SITE_DIR;
const contentDir = siteDir + '/content';
const markupFiles = FileNavigator.findInDir(contentDir, /\.mdoc$/);

describe('MarkdocHugoIntegration', () => {
  const integration = new MarkdocHugoIntegration({
    config: {
      siteParams: {
        img_url: 'https://example.com'
      },
      env: 'development',
      languages: ['en'],
      siteConfig: { baseURL: 'https://example.com/' },
      siteDir
    }
  });

  // compile the bad files
  const { hasErrors, parsingErrorReportsByFilePath, validationErrorsByFilePath } =
    integration.compileMdocFiles();

  // sanitize the file paths so snapshots are consistent across machines
  const errorReports = { ...parsingErrorReportsByFilePath };
  Object.keys(errorReports).forEach((filePath) => {
    const sanitizedFilePath = filePath.replace(contentDir, '');
    errorReports[sanitizedFilePath] = errorReports[filePath];
    errorReports[sanitizedFilePath].forEach((errorReport) => {
      errorReport.file = errorReport.file.replace(contentDir, '');
    });
    delete errorReports[filePath];
  });

  const errors = { ...validationErrorsByFilePath };
  Object.keys(errors).forEach((filePath) => {
    const sanitizedFilePath = filePath.replace(contentDir, '');
    errors[sanitizedFilePath] = [];
    errors[filePath].forEach((error) => {
      error = error.replace(contentDir, '');
      errors[sanitizedFilePath].push(error);
    });
    delete errors[filePath];
  });

  test('the compilation should return false', () => {
    expect(hasErrors).toBe(true);
  });

  markupFiles.forEach((markupFile) => {
    const sanitizedFilename = markupFile.replace(contentDir, '');
    const parsingErrorReports = parsingErrorReportsByFilePath[markupFile];
    const validationError = validationErrorsByFilePath[markupFile];

    const fileHasError = !!parsingErrorReports || !!validationError;

    test(`the file ${sanitizedFilename} should have errors`, () => {
      expect(fileHasError).toBe(true);
    });

    if (parsingErrorReports) {
      test(`the parsing error reports for ${sanitizedFilename} match the snapshot`, () => {
        expect(JSON.stringify(parsingErrorReports, null, 2)).toMatchFileSnapshot(
          `${SNAPSHOTS_DIR}/invalidSite/${sanitizedFilename}/parsingErrors.snap.json`
        );
      });
    }

    if (validationError) {
      test(`the validation error for ${sanitizedFilename} matches the snapshot`, () => {
        expect(validationError).toMatchFileSnapshot(
          `${SNAPSHOTS_DIR}/invalidSite/${sanitizedFilename}/validationErrors.snap.txt`
        );
      });
    }
  });
});

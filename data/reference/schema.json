{
  "$schema": "https://json-schema.org/draft/2019-09/schema",
  "allOf": [
    {
      "properties": {
        "api": {
          "_metadata": {
            "docs::human_name": "API"
          },
          "default": {
            "address": "127.0.0.1:8686",
            "enabled": false,
            "playground": true
          },
          "description": "API options.",
          "properties": {
            "address": {
              "_metadata": {
                "docs::human_name": "Address",
                "docs::optional": true
              },
              "default": "127.0.0.1:8686",
              "description": "The socket address to listen on for the API endpoint.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "description": "An internet socket address, either IPv4 or IPv6.",
                  "type": "string"
                }
              ],
              "unevaluatedProperties": false
            },
            "enabled": {
              "_metadata": {
                "docs::human_name": "Enabled"
              },
              "default": false,
              "description": "Whether or not the API endpoint is available.",
              "type": "boolean"
            },
            "playground": {
              "_metadata": {
                "docs::human_name": "Playground"
              },
              "default": true,
              "description": "Whether or not to expose the GraphQL playground on the API endpoint.",
              "type": "boolean"
            }
          },
          "type": "object",
          "unevaluatedProperties": false
        },
        "enrichment_tables": {
          "_metadata": {
            "docs::human_name": "Enrichment Tables"
          },
          "additionalProperties": {
            "allOf": [
              {
                "_metadata": {
                  "docs::enum_tag_field": "type",
                  "docs::enum_tagging": "internal"
                },
                "description": "Configurable enrichment tables.",
                "oneOf": [
                  {
                    "_metadata": {
                      "docs::human_name": "File",
                      "logical_name": "File"
                    },
                    "allOf": [
                      {
                        "$ref": "#/definitions/vector::enrichment_tables::file::FileConfig",
                        "description": "Configuration for the `file` enrichment table."
                      },
                      {
                        "properties": {
                          "type": {
                            "_metadata": {
                              "docs::human_name": "Type"
                            },
                            "const": "file",
                            "description": "Exposes data from a static file as an enrichment table."
                          }
                        },
                        "required": [
                          "type"
                        ],
                        "type": "object"
                      }
                    ],
                    "description": "Exposes data from a static file as an enrichment table."
                  },
                  {
                    "_metadata": {
                      "docs::human_name": "GeoIP",
                      "logical_name": "Geoip"
                    },
                    "allOf": [
                      {
                        "$ref": "#/definitions/vector::enrichment_tables::geoip::GeoipConfig",
                        "description": "Configuration for the `geoip` enrichment table."
                      },
                      {
                        "properties": {
                          "type": {
                            "_metadata": {
                              "docs::human_name": "Type"
                            },
                            "const": "geoip",
                            "description": "[maxmind]: https://www.maxmind.com/\n[geoip2]: https://www.maxmind.com/en/geoip2-databases",
                            "title": "Exposes data from a [MaxMind][maxmind] [GeoIP2][geoip2] database as an enrichment table."
                          }
                        },
                        "required": [
                          "type"
                        ],
                        "type": "object"
                      }
                    ],
                    "description": "[maxmind]: https://www.maxmind.com/\n[geoip2]: https://www.maxmind.com/en/geoip2-databases",
                    "title": "Exposes data from a [MaxMind][maxmind] [GeoIP2][geoip2] database as an enrichment table."
                  }
                ]
              }
            ],
            "description": "Fully resolved enrichment table component.",
            "unevaluatedProperties": false
          },
          "default": {},
          "description": "All configured enrichment tables.",
          "type": "object"
        },
        "healthchecks": {
          "_metadata": {
            "docs::human_name": "Healthchecks"
          },
          "default": {
            "enabled": true,
            "require_healthy": false
          },
          "description": "Healthcheck options.",
          "properties": {
            "enabled": {
              "_metadata": {
                "docs::human_name": "Enabled"
              },
              "description": "Can be overridden on a per-sink basis.",
              "title": "Whether or not healthchecks are enabled for all sinks.",
              "type": "boolean"
            },
            "require_healthy": {
              "_metadata": {
                "docs::human_name": "Require Healthy"
              },
              "description": "When enabled and a sink reports not being healthy, Vector will exit during start-up.\n\nCan be alternatively set, and overridden by, the `--require-healthy` command-line flag.",
              "title": "Whether or not to require a sink to report as being healthy during startup.",
              "type": "boolean"
            }
          },
          "type": "object",
          "unevaluatedProperties": false
        },
        "provider": {
          "_metadata": {
            "docs::human_name": "Provider",
            "docs::optional": true
          },
          "description": "Configuration providers allow sourcing configuration information from a source other than\nthe typical configuration files that must be passed to Vector.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "_metadata": {
                "docs::enum_tag_field": "type",
                "docs::enum_tagging": "internal"
              },
              "description": "Configurable providers in Vector.",
              "oneOf": [
                {
                  "_metadata": {
                    "docs::human_name": "HTTP",
                    "logical_name": "Http"
                  },
                  "allOf": [
                    {
                      "$ref": "#/definitions/vector::providers::http::HttpConfig",
                      "description": "Configuration for the `http` provider."
                    },
                    {
                      "properties": {
                        "type": {
                          "_metadata": {
                            "docs::human_name": "Type"
                          },
                          "const": "http",
                          "description": "HTTP."
                        }
                      },
                      "required": [
                        "type"
                      ],
                      "type": "object"
                    }
                  ],
                  "description": "HTTP."
                }
              ]
            }
          ],
          "title": "Optional configuration provider to use.",
          "unevaluatedProperties": false
        },
        "schema": {
          "_metadata": {
            "docs::hidden": true,
            "docs::human_name": "Schema"
          },
          "default": {
            "enabled": false,
            "log_namespace": null,
            "validation": false
          },
          "description": "Schema options.",
          "properties": {
            "enabled": {
              "_metadata": {
                "docs::human_name": "Enabled"
              },
              "default": false,
              "description": "Whether or not schema is enabled.",
              "type": "boolean"
            },
            "log_namespace": {
              "_metadata": {
                "docs::human_name": "Log Namespace",
                "docs::optional": true
              },
              "description": "Whether or not to enable log namespacing.",
              "type": [
                "boolean",
                "null"
              ]
            },
            "validation": {
              "_metadata": {
                "docs::human_name": "Validation"
              },
              "default": false,
              "description": "Whether or not schema validation is enabled.",
              "type": "boolean"
            }
          },
          "type": "object",
          "unevaluatedProperties": false
        },
        "sinks": {
          "_metadata": {
            "docs::human_name": "Sinks"
          },
          "additionalProperties": {
            "$ref": "#/definitions/vector::config::sink::SinkOuter<alloc::string::String>"
          },
          "default": {},
          "description": "All configured sinks.",
          "type": "object"
        },
        "sources": {
          "_metadata": {
            "docs::human_name": "Sources"
          },
          "additionalProperties": {
            "$ref": "#/definitions/vector::config::source::SourceOuter"
          },
          "default": {},
          "description": "All configured sources.",
          "type": "object"
        },
        "tests": {
          "_metadata": {
            "docs::human_name": "Tests"
          },
          "default": [],
          "description": "All configured unit tests.",
          "items": {
            "description": "A unit test definition.",
            "properties": {
              "input": {
                "_metadata": {
                  "docs::human_name": "Input",
                  "docs::optional": true
                },
                "description": "An input event to test against.",
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "$ref": "#/definitions/vector::config::TestInput"
                  }
                ],
                "title": "A unit test input.",
                "unevaluatedProperties": false
              },
              "inputs": {
                "_metadata": {
                  "docs::human_name": "Inputs"
                },
                "default": [],
                "description": "A set of input events to test against.",
                "items": {
                  "$ref": "#/definitions/vector::config::TestInput"
                },
                "title": "A unit test input.",
                "type": "array"
              },
              "name": {
                "_metadata": {
                  "docs::human_name": "Name"
                },
                "description": "The name of the unit test.",
                "type": "string"
              },
              "no_outputs_from": {
                "_metadata": {
                  "docs::human_name": "No Outputs From"
                },
                "default": [],
                "description": "A set of component outputs that should not have emitted any events.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "outputs": {
                "_metadata": {
                  "docs::human_name": "Outputs"
                },
                "default": [],
                "description": "A set of expected output events after the test has run.",
                "items": {
                  "description": "An output describes what we expect a transform to emit when fed a certain event, or events, when\nrunning a unit test.",
                  "properties": {
                    "conditions": {
                      "_metadata": {
                        "docs::enum_tagging": "untagged",
                        "docs::human_name": "Conditions",
                        "docs::optional": true,
                        "docs::type_override": "condition"
                      },
                      "description": "The conditions to run against the output to validate that they were transformed as expected.",
                      "items": {
                        "$ref": "#/definitions/vector::conditions::AnyCondition"
                      },
                      "type": [
                        "array",
                        "null"
                      ]
                    },
                    "extract_from": {
                      "_metadata": {
                        "docs::enum_tagging": "untagged",
                        "docs::human_name": "Extract From"
                      },
                      "description": "The transform outputs to extract events from.",
                      "oneOf": [
                        {
                          "_metadata": {
                            "docs::human_name": "One",
                            "logical_name": "One"
                          },
                          "type": "string"
                        },
                        {
                          "_metadata": {
                            "docs::human_name": "Many",
                            "logical_name": "Many"
                          },
                          "items": {
                            "type": "string"
                          },
                          "type": "array"
                        }
                      ],
                      "unevaluatedProperties": false
                    }
                  },
                  "required": [
                    "extract_from"
                  ],
                  "title": "A unit test output.",
                  "type": "object",
                  "unevaluatedProperties": false
                },
                "title": "A unit test output.",
                "type": "array"
              }
            },
            "required": [
              "name"
            ],
            "type": "object",
            "unevaluatedProperties": false
          },
          "type": "array"
        },
        "transforms": {
          "_metadata": {
            "docs::human_name": "Transforms"
          },
          "additionalProperties": {
            "$ref": "#/definitions/vector::config::transform::TransformOuter<alloc::string::String>"
          },
          "default": {},
          "description": "All configured transforms.",
          "type": "object"
        }
      },
      "type": "object"
    },
    {
      "description": "Global configuration options.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how Vector handles event\nacknowledgement.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled for all sinks by default."
        },
        "data_dir": {
          "$ref": "#/definitions/core::option::Option<std::path::PathBuf>",
          "_metadata": {
            "docs::human_name": "Data Directory"
          },
          "default": "/var/lib/vector/",
          "description": "This is the directory where Vector will store any state data, such as disk buffers, file\ncheckpoints, and more.\n\nVector must have write permissions to this directory.",
          "title": "The directory used for persisting Vector state data."
        },
        "expire_metrics": {
          "_metadata": {
            "docs::human_name": "Expire Metrics",
            "docs::optional": true
          },
          "default": null,
          "deprecated": true,
          "description": "Not set by default, which allows all internal metrics to grow unbounded over time. If you\nhave a configuration that emits many high-cardinality metrics, you may want to consider\nsetting this to a value that ensures that metrics live long enough to be emitted and\ncaptured, but not so long that they continue to build up indefinitely, as this will consume\na small amount of memory for each metric.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "description": "An duration of time.",
              "properties": {
                "nsecs": {
                  "_metadata": {
                    "docs::human_name": "Nsecs"
                  },
                  "maximum": 4294967295,
                  "minimum": 0,
                  "type": "integer"
                },
                "secs": {
                  "_metadata": {
                    "docs::human_name": "Secs"
                  },
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "type": "integer"
                }
              },
              "required": [
                "nsecs",
                "secs"
              ],
              "type": "object"
            }
          ],
          "title": "The amount of time, in seconds, that internal metrics will persist after having not been\nupdated before they expire and are removed.",
          "unevaluatedProperties": false
        },
        "expire_metrics_secs": {
          "_metadata": {
            "docs::human_name": "Expire Metrics Secs",
            "docs::numeric_type": "float",
            "docs::optional": true
          },
          "default": null,
          "description": "Not set by default, which allows all internal metrics to grow unbounded over time. If you\nhave a configuration that emits many high-cardinality metrics, you may want to consider\nsetting this to a value that ensures that metrics live long enough to be emitted and\ncaptured, but not so long that they continue to build up indefinitely, as this will consume\na small amount of memory for each metric.",
          "maximum": 9007199254740991,
          "minimum": -9007199254740991,
          "title": "The amount of time, in seconds, that internal metrics will persist after having not been\nupdated before they expire and are removed.",
          "type": [
            "number",
            "null"
          ]
        },
        "log_schema": {
          "_metadata": {
            "docs::human_name": "Log Schema"
          },
          "default": {
            "host_key": ".host",
            "message_key": ".message",
            "metadata_key": ".metadata",
            "source_type_key": ".source_type",
            "timestamp_key": ".timestamp"
          },
          "description": "This is used if a component does not have its own specific log schema. All events use a log\nschema, whether or not the default is used, to assign event fields on incoming events.",
          "properties": {
            "host_key": {
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalTargetPath",
              "_metadata": {
                "docs::human_name": "Host Key"
              },
              "default": ".host",
              "description": "This field will generally represent a real host, or container, that generated the message,\nbut is somewhat source-dependent.",
              "title": "The name of the event field to treat as the host which sent the message."
            },
            "message_key": {
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalTargetPath",
              "_metadata": {
                "docs::human_name": "Message Key"
              },
              "default": ".message",
              "description": "This would be the field that holds the raw message, such as a raw log line.",
              "title": "The name of the event field to treat as the event message."
            },
            "metadata_key": {
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalTargetPath",
              "_metadata": {
                "docs::human_name": "Metadata Key"
              },
              "default": ".metadata",
              "description": "Generally, this field will be set by Vector to hold event-specific metadata, such as\nannotations by the `remap` transform when an error or abort is encountered.",
              "title": "The name of the event field to set the event metadata in."
            },
            "source_type_key": {
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalTargetPath",
              "_metadata": {
                "docs::human_name": "Source Type Key"
              },
              "default": ".source_type",
              "description": "This field will be set by the Vector source that the event was created in.",
              "title": "The name of the event field to set the source identifier in."
            },
            "timestamp_key": {
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalTargetPath",
              "_metadata": {
                "docs::human_name": "Timestamp Key"
              },
              "default": ".timestamp",
              "description": "The name of the event field to treat as the event timestamp."
            }
          },
          "title": "Default log schema for all events.",
          "type": "object",
          "unevaluatedProperties": false
        },
        "proxy": {
          "$ref": "#/definitions/vector_core::config::proxy::ProxyConfig",
          "_metadata": {
            "docs::human_name": "Proxy"
          },
          "default": {
            "enabled": true,
            "http": null,
            "https": null
          },
          "description": "Configure to proxy traffic through an HTTP(S) proxy when making external requests.\n\nSimilar to common proxy configuration convention, you can set different proxies\nto use based on the type of traffic being proxied, as well as set specific hosts that\nshould not be proxied.",
          "title": "Proxy configuration."
        },
        "telemetry": {
          "_metadata": {
            "docs::human_name": "Telemetry"
          },
          "default": {
            "tags": {
              "emit_service": false,
              "emit_source": false
            }
          },
          "description": "Determines whether `source` and `service` tags should be emitted with the\n`component_sent_*` and `component_received_*` events.",
          "properties": {
            "tags": {
              "_metadata": {
                "docs::human_name": "Tags"
              },
              "default": {
                "emit_service": false,
                "emit_source": false
              },
              "description": "Configures whether to emit certain tags",
              "properties": {
                "emit_service": {
                  "_metadata": {
                    "docs::human_name": "Emit Service"
                  },
                  "description": "True if the `service` tag should be emitted\nin the `component_received_*` and `component_sent_*`\ntelemetry.",
                  "type": "boolean"
                },
                "emit_source": {
                  "_metadata": {
                    "docs::human_name": "Emit Source"
                  },
                  "description": "True if the `source` tag should be emitted\nin the `component_received_*` and `component_sent_*`\ntelemetry.",
                  "type": "boolean"
                }
              },
              "type": "object",
              "unevaluatedProperties": false
            }
          },
          "title": "Telemetry options.",
          "type": "object",
          "unevaluatedProperties": false
        },
        "timezone": {
          "$ref": "#/definitions/core::option::Option<vrl::compiler::datetime::TimeZone>",
          "_metadata": {
            "docs::human_name": "Timezone"
          },
          "default": null,
          "description": "The time zone name may be any name in the [TZ database][tzdb] or `local` to indicate system\nlocal time.\n\n[tzdb]: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones",
          "title": "The name of the time zone to apply to timestamp conversions that do not contain an explicit time zone."
        }
      },
      "type": "object"
    }
  ],
  "definitions": {
    "codecs::MetricTagValues": {
      "_metadata": {
        "docs::enum_tagging": "external"
      },
      "description": "The user configuration to choose the metric tag strategy.",
      "oneOf": [
        {
          "_metadata": {
            "docs::human_name": "Single",
            "logical_name": "Single"
          },
          "const": "single",
          "description": "Tag values are exposed as single strings, the same as they were before this config\noption. Tags with multiple values show the last assigned value, and null values\nare ignored."
        },
        {
          "_metadata": {
            "docs::human_name": "Full",
            "logical_name": "Full"
          },
          "const": "full",
          "description": "All tags are exposed as arrays of either string or null values."
        }
      ],
      "unevaluatedProperties": false
    },
    "codecs::decoding::DeserializerConfig": {
      "_metadata": {
        "docs::enum_tag_description": "The codec to use for decoding events.",
        "docs::enum_tag_field": "codec",
        "docs::enum_tagging": "internal"
      },
      "description": "Configures how events are decoded from raw bytes.",
      "oneOf": [
        {
          "_metadata": {
            "docs::human_name": "Bytes",
            "logical_name": "Bytes"
          },
          "description": "Uses the raw bytes as-is.",
          "properties": {
            "codec": {
              "_metadata": {
                "docs::human_name": "Codec"
              },
              "const": "bytes",
              "description": "Uses the raw bytes as-is."
            }
          },
          "required": [
            "codec"
          ],
          "type": "object"
        },
        {
          "_metadata": {
            "docs::human_name": "JSON",
            "logical_name": "Json"
          },
          "allOf": [
            {
              "description": "Config used to build a `JsonDeserializer`.",
              "properties": {
                "json": {
                  "_metadata": {
                    "docs::human_name": "JSON"
                  },
                  "default": {
                    "lossy": true
                  },
                  "description": "JSON-specific decoding options.",
                  "properties": {
                    "lossy": {
                      "_metadata": {
                        "docs::human_name": "Lossy"
                      },
                      "default": true,
                      "description": "When true, invalid UTF-8 sequences are replaced with the [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD].\n\n[U+FFFD]: https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character",
                      "title": "Determines whether or not to replace invalid UTF-8 sequences instead of failing.",
                      "type": "boolean"
                    }
                  },
                  "type": "object",
                  "unevaluatedProperties": false
                }
              },
              "type": "object"
            },
            {
              "properties": {
                "codec": {
                  "_metadata": {
                    "docs::human_name": "Codec"
                  },
                  "const": "json",
                  "description": "[json]: https://www.json.org/",
                  "title": "Decodes the raw bytes as [JSON][json]."
                }
              },
              "required": [
                "codec"
              ],
              "type": "object"
            }
          ],
          "description": "[json]: https://www.json.org/",
          "title": "Decodes the raw bytes as [JSON][json]."
        },
        {
          "_metadata": {
            "docs::human_name": "Protobuf",
            "logical_name": "Protobuf"
          },
          "allOf": [
            {
              "description": "Config used to build a `ProtobufDeserializer`.",
              "properties": {
                "protobuf": {
                  "_metadata": {
                    "docs::human_name": "Protobuf"
                  },
                  "default": {
                    "desc_file": "",
                    "message_type": ""
                  },
                  "description": "Protobuf-specific decoding options.",
                  "properties": {
                    "desc_file": {
                      "$ref": "#/definitions/stdlib::PathBuf",
                      "_metadata": {
                        "docs::human_name": "Desc File"
                      },
                      "description": "Path to desc file"
                    },
                    "message_type": {
                      "_metadata": {
                        "docs::human_name": "Message Type"
                      },
                      "description": "message type. e.g package.message",
                      "type": "string"
                    }
                  },
                  "required": [
                    "desc_file",
                    "message_type"
                  ],
                  "type": "object",
                  "unevaluatedProperties": false
                }
              },
              "type": "object"
            },
            {
              "properties": {
                "codec": {
                  "_metadata": {
                    "docs::human_name": "Codec"
                  },
                  "const": "protobuf",
                  "description": "[protobuf]: https://protobuf.dev/",
                  "title": "Decodes the raw bytes as [protobuf][protobuf]."
                }
              },
              "required": [
                "codec"
              ],
              "type": "object"
            }
          ],
          "description": "[protobuf]: https://protobuf.dev/",
          "title": "Decodes the raw bytes as [protobuf][protobuf]."
        },
        {
          "_metadata": {
            "docs::human_name": "Syslog",
            "logical_name": "Syslog"
          },
          "allOf": [
            {
              "description": "Config used to build a `SyslogDeserializer`.",
              "properties": {
                "syslog": {
                  "_metadata": {
                    "docs::human_name": "Syslog"
                  },
                  "default": {
                    "lossy": true
                  },
                  "description": "Syslog-specific decoding options.",
                  "properties": {
                    "lossy": {
                      "_metadata": {
                        "docs::human_name": "Lossy"
                      },
                      "default": true,
                      "description": "When true, invalid UTF-8 sequences are replaced with the [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD].\n\n[U+FFFD]: https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character",
                      "title": "Determines whether or not to replace invalid UTF-8 sequences instead of failing.",
                      "type": "boolean"
                    }
                  },
                  "type": "object",
                  "unevaluatedProperties": false
                }
              },
              "type": "object"
            },
            {
              "properties": {
                "codec": {
                  "_metadata": {
                    "docs::human_name": "Codec"
                  },
                  "const": "syslog",
                  "description": "Decodes either as the [RFC 3164][rfc3164]-style format (\"old\" style) or the\n[RFC 5424][rfc5424]-style format (\"new\" style, includes structured data).\n\n[rfc3164]: https://www.ietf.org/rfc/rfc3164.txt\n[rfc5424]: https://www.ietf.org/rfc/rfc5424.txt",
                  "title": "Decodes the raw bytes as a Syslog message."
                }
              },
              "required": [
                "codec"
              ],
              "type": "object"
            }
          ],
          "description": "Decodes either as the [RFC 3164][rfc3164]-style format (\"old\" style) or the\n[RFC 5424][rfc5424]-style format (\"new\" style, includes structured data).\n\n[rfc3164]: https://www.ietf.org/rfc/rfc3164.txt\n[rfc5424]: https://www.ietf.org/rfc/rfc5424.txt",
          "title": "Decodes the raw bytes as a Syslog message."
        },
        {
          "_metadata": {
            "docs::human_name": "Native",
            "logical_name": "Native"
          },
          "description": "This codec is **[experimental][experimental]**.\n\n[vector_native_protobuf]: https://github.com/vectordotdev/vector/blob/master/lib/vector-core/proto/event.proto\n[experimental]: https://vector.dev/highlights/2022-03-31-native-event-codecs",
          "properties": {
            "codec": {
              "_metadata": {
                "docs::human_name": "Codec"
              },
              "const": "native",
              "description": "This codec is **[experimental][experimental]**.\n\n[vector_native_protobuf]: https://github.com/vectordotdev/vector/blob/master/lib/vector-core/proto/event.proto\n[experimental]: https://vector.dev/highlights/2022-03-31-native-event-codecs",
              "title": "Decodes the raw bytes as Vector’s [native Protocol Buffers format][vector_native_protobuf]."
            }
          },
          "required": [
            "codec"
          ],
          "title": "Decodes the raw bytes as Vector’s [native Protocol Buffers format][vector_native_protobuf].",
          "type": "object"
        },
        {
          "_metadata": {
            "docs::human_name": "Native JSON",
            "logical_name": "NativeJson"
          },
          "allOf": [
            {
              "description": "Config used to build a `NativeJsonDeserializer`.",
              "properties": {
                "native_json": {
                  "_metadata": {
                    "docs::human_name": "Native JSON"
                  },
                  "default": {
                    "lossy": true
                  },
                  "description": "Vector's native JSON-specific decoding options.",
                  "properties": {
                    "lossy": {
                      "_metadata": {
                        "docs::human_name": "Lossy"
                      },
                      "default": true,
                      "description": "When true, invalid UTF-8 sequences are replaced with the [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD].\n\n[U+FFFD]: https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character",
                      "title": "Determines whether or not to replace invalid UTF-8 sequences instead of failing.",
                      "type": "boolean"
                    }
                  },
                  "type": "object",
                  "unevaluatedProperties": false
                }
              },
              "type": "object"
            },
            {
              "properties": {
                "codec": {
                  "_metadata": {
                    "docs::human_name": "Codec"
                  },
                  "const": "native_json",
                  "description": "This codec is **[experimental][experimental]**.\n\n[vector_native_json]: https://github.com/vectordotdev/vector/blob/master/lib/codecs/tests/data/native_encoding/schema.cue\n[experimental]: https://vector.dev/highlights/2022-03-31-native-event-codecs",
                  "title": "Decodes the raw bytes as Vector’s [native JSON format][vector_native_json]."
                }
              },
              "required": [
                "codec"
              ],
              "type": "object"
            }
          ],
          "description": "This codec is **[experimental][experimental]**.\n\n[vector_native_json]: https://github.com/vectordotdev/vector/blob/master/lib/codecs/tests/data/native_encoding/schema.cue\n[experimental]: https://vector.dev/highlights/2022-03-31-native-event-codecs",
          "title": "Decodes the raw bytes as Vector’s [native JSON format][vector_native_json]."
        },
        {
          "_metadata": {
            "docs::human_name": "GELF",
            "logical_name": "Gelf"
          },
          "allOf": [
            {
              "description": "On GELF decoding behavior:\n  Graylog has a relaxed decoding. They are much more lenient than the spec would\n  suggest. We've elected to take a more strict approach to maintain backwards compatibility\n  in the event that we need to change the behavior to be more relaxed, so that prior versions\n  of vector will still work with the new relaxed decoding.\nConfig used to build a `GelfDeserializer`.",
              "properties": {
                "gelf": {
                  "_metadata": {
                    "docs::human_name": "GELF"
                  },
                  "default": {
                    "lossy": true
                  },
                  "description": "GELF-specific decoding options.",
                  "properties": {
                    "lossy": {
                      "_metadata": {
                        "docs::human_name": "Lossy"
                      },
                      "default": true,
                      "description": "When true, invalid UTF-8 sequences are replaced with the [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD].\n\n[U+FFFD]: https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character",
                      "title": "Determines whether or not to replace invalid UTF-8 sequences instead of failing.",
                      "type": "boolean"
                    }
                  },
                  "type": "object",
                  "unevaluatedProperties": false
                }
              },
              "type": "object"
            },
            {
              "properties": {
                "codec": {
                  "_metadata": {
                    "docs::human_name": "Codec"
                  },
                  "const": "gelf",
                  "description": "[gelf]: https://docs.graylog.org/docs/gelf",
                  "title": "Decodes the raw bytes as a [GELF][gelf] message."
                }
              },
              "required": [
                "codec"
              ],
              "type": "object"
            }
          ],
          "description": "[gelf]: https://docs.graylog.org/docs/gelf",
          "title": "Decodes the raw bytes as a [GELF][gelf] message."
        }
      ],
      "unevaluatedProperties": false
    },
    "codecs::decoding::FramingConfig": {
      "_metadata": {
        "docs::enum_tag_description": "The framing method.",
        "docs::enum_tag_field": "method",
        "docs::enum_tagging": "internal"
      },
      "description": "Framing handles how events are separated when encoded in a raw byte form, where each event is\na frame that must be prefixed, or delimited, in a way that marks where an event begins and\nends within the byte stream.",
      "oneOf": [
        {
          "_metadata": {
            "docs::human_name": "Bytes",
            "logical_name": "Bytes"
          },
          "description": "Byte frames are passed through as-is according to the underlying I/O boundaries (for example, split between messages or stream segments).",
          "properties": {
            "method": {
              "_metadata": {
                "docs::human_name": "Method"
              },
              "const": "bytes",
              "description": "Byte frames are passed through as-is according to the underlying I/O boundaries (for example, split between messages or stream segments)."
            }
          },
          "required": [
            "method"
          ],
          "type": "object"
        },
        {
          "_metadata": {
            "docs::human_name": "Character Delimited",
            "logical_name": "CharacterDelimited"
          },
          "allOf": [
            {
              "description": "Config used to build a `CharacterDelimitedDecoder`.",
              "properties": {
                "character_delimited": {
                  "_metadata": {
                    "docs::human_name": "Character Delimited"
                  },
                  "description": "Options for the character delimited decoder.",
                  "properties": {
                    "delimiter": {
                      "_metadata": {
                        "docs::human_name": "Delimiter",
                        "docs::numeric_type": "uint"
                      },
                      "description": "The character that delimits byte sequences.",
                      "maximum": 255,
                      "minimum": 0,
                      "type": "integer"
                    },
                    "max_length": {
                      "_metadata": {
                        "docs::human_name": "Max Length",
                        "docs::numeric_type": "uint",
                        "docs::optional": true
                      },
                      "description": "This length does *not* include the trailing delimiter.\n\nBy default, there is no maximum length enforced. If events are malformed, this can lead to\nadditional resource usage as events continue to be buffered in memory, and can potentially\nlead to memory exhaustion in extreme cases.\n\nIf there is a risk of processing malformed data, such as logs with user-controlled input,\nconsider setting the maximum length to a reasonably large value as a safety net. This\nensures that processing is not actually unbounded.",
                      "maximum": 9007199254740991,
                      "minimum": 0,
                      "title": "The maximum length of the byte buffer.",
                      "type": [
                        "integer",
                        "null"
                      ]
                    }
                  },
                  "required": [
                    "delimiter"
                  ],
                  "type": "object",
                  "unevaluatedProperties": false
                }
              },
              "required": [
                "character_delimited"
              ],
              "type": "object"
            },
            {
              "properties": {
                "method": {
                  "_metadata": {
                    "docs::human_name": "Method"
                  },
                  "const": "character_delimited",
                  "description": "Byte frames which are delimited by a chosen character."
                }
              },
              "required": [
                "method"
              ],
              "type": "object"
            }
          ],
          "description": "Byte frames which are delimited by a chosen character."
        },
        {
          "_metadata": {
            "docs::human_name": "Length Delimited",
            "logical_name": "LengthDelimited"
          },
          "description": "Byte frames which are prefixed by an unsigned big-endian 32-bit integer indicating the length.",
          "properties": {
            "method": {
              "_metadata": {
                "docs::human_name": "Method"
              },
              "const": "length_delimited",
              "description": "Byte frames which are prefixed by an unsigned big-endian 32-bit integer indicating the length."
            }
          },
          "required": [
            "method"
          ],
          "type": "object"
        },
        {
          "_metadata": {
            "docs::human_name": "Newline Delimited",
            "logical_name": "NewlineDelimited"
          },
          "allOf": [
            {
              "description": "Config used to build a `NewlineDelimitedDecoder`.",
              "properties": {
                "newline_delimited": {
                  "_metadata": {
                    "docs::human_name": "Newline Delimited"
                  },
                  "default": {},
                  "description": "Options for the newline delimited decoder.",
                  "properties": {
                    "max_length": {
                      "_metadata": {
                        "docs::human_name": "Max Length",
                        "docs::numeric_type": "uint",
                        "docs::optional": true
                      },
                      "description": "This length does *not* include the trailing delimiter.\n\nBy default, there is no maximum length enforced. If events are malformed, this can lead to\nadditional resource usage as events continue to be buffered in memory, and can potentially\nlead to memory exhaustion in extreme cases.\n\nIf there is a risk of processing malformed data, such as logs with user-controlled input,\nconsider setting the maximum length to a reasonably large value as a safety net. This\nensures that processing is not actually unbounded.",
                      "maximum": 9007199254740991,
                      "minimum": 0,
                      "title": "The maximum length of the byte buffer.",
                      "type": [
                        "integer",
                        "null"
                      ]
                    }
                  },
                  "type": "object",
                  "unevaluatedProperties": false
                }
              },
              "type": "object"
            },
            {
              "properties": {
                "method": {
                  "_metadata": {
                    "docs::human_name": "Method"
                  },
                  "const": "newline_delimited",
                  "description": "Byte frames which are delimited by a newline character."
                }
              },
              "required": [
                "method"
              ],
              "type": "object"
            }
          ],
          "description": "Byte frames which are delimited by a newline character."
        },
        {
          "_metadata": {
            "docs::human_name": "Octet Counting",
            "logical_name": "OctetCounting"
          },
          "allOf": [
            {
              "description": "Config used to build a `OctetCountingDecoder`.",
              "properties": {
                "octet_counting": {
                  "_metadata": {
                    "docs::human_name": "Octet Counting"
                  },
                  "default": {},
                  "description": "Options for the octet counting decoder.",
                  "properties": {
                    "max_length": {
                      "_metadata": {
                        "docs::human_name": "Max Length",
                        "docs::numeric_type": "uint",
                        "docs::optional": true
                      },
                      "description": "The maximum length of the byte buffer.",
                      "maximum": 9007199254740991,
                      "minimum": 0,
                      "type": [
                        "integer",
                        "null"
                      ]
                    }
                  },
                  "type": "object",
                  "unevaluatedProperties": false
                }
              },
              "type": "object"
            },
            {
              "properties": {
                "method": {
                  "_metadata": {
                    "docs::human_name": "Method"
                  },
                  "const": "octet_counting",
                  "description": "[octet_counting]: https://tools.ietf.org/html/rfc6587#section-3.4.1",
                  "title": "Byte frames according to the [octet counting][octet_counting] format."
                }
              },
              "required": [
                "method"
              ],
              "type": "object"
            }
          ],
          "description": "[octet_counting]: https://tools.ietf.org/html/rfc6587#section-3.4.1",
          "title": "Byte frames according to the [octet counting][octet_counting] format."
        }
      ],
      "title": "Framing configuration.",
      "unevaluatedProperties": false
    },
    "codecs::encoding::format::csv::CsvSerializerConfig": {
      "description": "Config used to build a `CsvSerializer`.",
      "properties": {
        "csv": {
          "_metadata": {
            "docs::human_name": "CSV"
          },
          "description": "The CSV Serializer Options.",
          "properties": {
            "capacity": {
              "_metadata": {
                "docs::human_name": "Capacity",
                "docs::numeric_type": "uint"
              },
              "default": 8192,
              "description": "Set the capacity (in bytes) of the internal buffer used in the CSV writer.\nThis defaults to a reasonable setting.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "type": "integer"
            },
            "delimiter": {
              "_metadata": {
                "docs::human_name": "Delimiter",
                "docs::numeric_type": "uint"
              },
              "default": 44,
              "description": "The field delimiter to use when writing CSV.",
              "maximum": 255,
              "minimum": 0,
              "type": "integer"
            },
            "double_quote": {
              "_metadata": {
                "docs::human_name": "Double Quote"
              },
              "default": true,
              "description": "This is enabled by default, but it may be disabled. When disabled, quotes in\nfield data are escaped instead of doubled.",
              "title": "Enable double quote escapes.",
              "type": "boolean"
            },
            "escape": {
              "_metadata": {
                "docs::human_name": "Escape",
                "docs::numeric_type": "uint"
              },
              "default": 34,
              "description": "In some variants of CSV, quotes are escaped using a special escape character\nlike \\ (instead of escaping quotes by doubling them).\n\nTo use this `double_quotes` needs to be disabled as well otherwise it is ignored",
              "maximum": 255,
              "minimum": 0,
              "title": "The escape character to use when writing CSV.",
              "type": "integer"
            },
            "fields": {
              "_metadata": {
                "docs::human_name": "Fields"
              },
              "description": "If a field is not present in the event, the output will be an empty string.\n\nValues of type `Array`, `Object`, and `Regex` are not supported and the\noutput will be an empty string.",
              "items": {
                "$ref": "#/definitions/vector_lookup::lookup_v2::ConfigTargetPath"
              },
              "title": "Configures the fields that will be encoded, as well as the order in which they\nappear in the output.",
              "type": "array"
            },
            "quote": {
              "_metadata": {
                "docs::human_name": "Quote",
                "docs::numeric_type": "uint"
              },
              "default": 34,
              "description": "The quote character to use when writing CSV.",
              "maximum": 255,
              "minimum": 0,
              "type": "integer"
            },
            "quote_style": {
              "_metadata": {
                "docs::enum_tagging": "external",
                "docs::human_name": "Quote Style"
              },
              "default": "necessary",
              "description": "The quoting style to use when writing CSV data.",
              "oneOf": [
                {
                  "_metadata": {
                    "docs::human_name": "Always",
                    "logical_name": "Always"
                  },
                  "const": "always",
                  "description": "This puts quotes around every field. Always."
                },
                {
                  "_metadata": {
                    "docs::human_name": "Necessary",
                    "logical_name": "Necessary"
                  },
                  "const": "necessary",
                  "description": "This puts quotes around fields only when necessary.\nThey are necessary when fields contain a quote, delimiter or record terminator.\nQuotes are also necessary when writing an empty record\n(which is indistinguishable from a record with one empty field)."
                },
                {
                  "_metadata": {
                    "docs::human_name": "Non Numeric",
                    "logical_name": "NonNumeric"
                  },
                  "const": "non_numeric",
                  "description": "This puts quotes around all fields that are non-numeric.\nNamely, when writing a field that does not parse as a valid float or integer,\nthen quotes will be used even if they aren’t strictly necessary."
                },
                {
                  "_metadata": {
                    "docs::human_name": "Never",
                    "logical_name": "Never"
                  },
                  "const": "never",
                  "description": "This never writes quotes, even if it would produce invalid CSV data."
                }
              ],
              "unevaluatedProperties": false
            }
          },
          "required": [
            "fields"
          ],
          "type": "object",
          "unevaluatedProperties": false
        }
      },
      "required": [
        "csv"
      ],
      "type": "object"
    },
    "codecs::encoding::format::json::JsonSerializerConfig": {
      "description": "Config used to build a `JsonSerializer`.",
      "properties": {
        "metric_tag_values": {
          "$ref": "#/definitions/codecs::MetricTagValues",
          "_metadata": {
            "docs::human_name": "Metric Tag Values"
          },
          "default": "single",
          "description": "When set to `single`, only the last non-bare value of tags are displayed with the\nmetric.  When set to `full`, all metric tags are exposed as separate assignments.",
          "title": "Controls how metric tag values are encoded."
        }
      },
      "type": "object"
    },
    "core::option::Option<codecs::decoding::FramingConfig>": {
      "_metadata": {
        "docs::optional": true
      },
      "description": "Framing handles how events are separated when encoded in a raw byte form, where each event is\na frame that must be prefixed, or delimited, in a way that marks where an event begins and\nends within the byte stream.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "_metadata": {
            "docs::enum_tag_description": "The framing method.",
            "docs::enum_tag_field": "method",
            "docs::enum_tagging": "internal"
          },
          "description": "Framing handles how events are separated when encoded in a raw byte form, where each event is\na frame that must be prefixed, or delimited, in a way that marks where an event begins and\nends within the byte stream.",
          "oneOf": [
            {
              "_metadata": {
                "docs::human_name": "Bytes",
                "logical_name": "Bytes"
              },
              "description": "Byte frames are passed through as-is according to the underlying I/O boundaries (for example, split between messages or stream segments).",
              "properties": {
                "method": {
                  "_metadata": {
                    "docs::human_name": "Method"
                  },
                  "const": "bytes",
                  "description": "Byte frames are passed through as-is according to the underlying I/O boundaries (for example, split between messages or stream segments)."
                }
              },
              "required": [
                "method"
              ],
              "type": "object"
            },
            {
              "_metadata": {
                "docs::human_name": "Character Delimited",
                "logical_name": "CharacterDelimited"
              },
              "allOf": [
                {
                  "description": "Config used to build a `CharacterDelimitedDecoder`.",
                  "properties": {
                    "character_delimited": {
                      "_metadata": {
                        "docs::human_name": "Character Delimited"
                      },
                      "description": "Options for the character delimited decoder.",
                      "properties": {
                        "delimiter": {
                          "_metadata": {
                            "docs::human_name": "Delimiter",
                            "docs::numeric_type": "uint"
                          },
                          "description": "The character that delimits byte sequences.",
                          "maximum": 255,
                          "minimum": 0,
                          "type": "integer"
                        },
                        "max_length": {
                          "_metadata": {
                            "docs::human_name": "Max Length",
                            "docs::numeric_type": "uint",
                            "docs::optional": true
                          },
                          "description": "This length does *not* include the trailing delimiter.\n\nBy default, there is no maximum length enforced. If events are malformed, this can lead to\nadditional resource usage as events continue to be buffered in memory, and can potentially\nlead to memory exhaustion in extreme cases.\n\nIf there is a risk of processing malformed data, such as logs with user-controlled input,\nconsider setting the maximum length to a reasonably large value as a safety net. This\nensures that processing is not actually unbounded.",
                          "maximum": 9007199254740991,
                          "minimum": 0,
                          "title": "The maximum length of the byte buffer.",
                          "type": [
                            "integer",
                            "null"
                          ]
                        }
                      },
                      "required": [
                        "delimiter"
                      ],
                      "type": "object",
                      "unevaluatedProperties": false
                    }
                  },
                  "required": [
                    "character_delimited"
                  ],
                  "type": "object"
                },
                {
                  "properties": {
                    "method": {
                      "_metadata": {
                        "docs::human_name": "Method"
                      },
                      "const": "character_delimited",
                      "description": "Byte frames which are delimited by a chosen character."
                    }
                  },
                  "required": [
                    "method"
                  ],
                  "type": "object"
                }
              ],
              "description": "Byte frames which are delimited by a chosen character."
            },
            {
              "_metadata": {
                "docs::human_name": "Length Delimited",
                "logical_name": "LengthDelimited"
              },
              "description": "Byte frames which are prefixed by an unsigned big-endian 32-bit integer indicating the length.",
              "properties": {
                "method": {
                  "_metadata": {
                    "docs::human_name": "Method"
                  },
                  "const": "length_delimited",
                  "description": "Byte frames which are prefixed by an unsigned big-endian 32-bit integer indicating the length."
                }
              },
              "required": [
                "method"
              ],
              "type": "object"
            },
            {
              "_metadata": {
                "docs::human_name": "Newline Delimited",
                "logical_name": "NewlineDelimited"
              },
              "allOf": [
                {
                  "description": "Config used to build a `NewlineDelimitedDecoder`.",
                  "properties": {
                    "newline_delimited": {
                      "_metadata": {
                        "docs::human_name": "Newline Delimited"
                      },
                      "default": {},
                      "description": "Options for the newline delimited decoder.",
                      "properties": {
                        "max_length": {
                          "_metadata": {
                            "docs::human_name": "Max Length",
                            "docs::numeric_type": "uint",
                            "docs::optional": true
                          },
                          "description": "This length does *not* include the trailing delimiter.\n\nBy default, there is no maximum length enforced. If events are malformed, this can lead to\nadditional resource usage as events continue to be buffered in memory, and can potentially\nlead to memory exhaustion in extreme cases.\n\nIf there is a risk of processing malformed data, such as logs with user-controlled input,\nconsider setting the maximum length to a reasonably large value as a safety net. This\nensures that processing is not actually unbounded.",
                          "maximum": 9007199254740991,
                          "minimum": 0,
                          "title": "The maximum length of the byte buffer.",
                          "type": [
                            "integer",
                            "null"
                          ]
                        }
                      },
                      "type": "object",
                      "unevaluatedProperties": false
                    }
                  },
                  "type": "object"
                },
                {
                  "properties": {
                    "method": {
                      "_metadata": {
                        "docs::human_name": "Method"
                      },
                      "const": "newline_delimited",
                      "description": "Byte frames which are delimited by a newline character."
                    }
                  },
                  "required": [
                    "method"
                  ],
                  "type": "object"
                }
              ],
              "description": "Byte frames which are delimited by a newline character."
            },
            {
              "_metadata": {
                "docs::human_name": "Octet Counting",
                "logical_name": "OctetCounting"
              },
              "allOf": [
                {
                  "description": "Config used to build a `OctetCountingDecoder`.",
                  "properties": {
                    "octet_counting": {
                      "_metadata": {
                        "docs::human_name": "Octet Counting"
                      },
                      "default": {},
                      "description": "Options for the octet counting decoder.",
                      "properties": {
                        "max_length": {
                          "_metadata": {
                            "docs::human_name": "Max Length",
                            "docs::numeric_type": "uint",
                            "docs::optional": true
                          },
                          "description": "The maximum length of the byte buffer.",
                          "maximum": 9007199254740991,
                          "minimum": 0,
                          "type": [
                            "integer",
                            "null"
                          ]
                        }
                      },
                      "type": "object",
                      "unevaluatedProperties": false
                    }
                  },
                  "type": "object"
                },
                {
                  "properties": {
                    "method": {
                      "_metadata": {
                        "docs::human_name": "Method"
                      },
                      "const": "octet_counting",
                      "description": "[octet_counting]: https://tools.ietf.org/html/rfc6587#section-3.4.1",
                      "title": "Byte frames according to the [octet counting][octet_counting] format."
                    }
                  },
                  "required": [
                    "method"
                  ],
                  "type": "object"
                }
              ],
              "description": "[octet_counting]: https://tools.ietf.org/html/rfc6587#section-3.4.1",
              "title": "Byte frames according to the [octet counting][octet_counting] format."
            }
          ],
          "title": "Framing configuration."
        }
      ],
      "title": "Framing configuration.",
      "unevaluatedProperties": false
    },
    "core::option::Option<std::path::PathBuf>": {
      "_metadata": {
        "docs::optional": true
      },
      "description": "A file path.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "$ref": "#/definitions/stdlib::PathBuf"
        }
      ],
      "unevaluatedProperties": false
    },
    "core::option::Option<vector::aws::region::RegionOrEndpoint>": {
      "_metadata": {
        "docs::optional": true
      },
      "description": "Configuration of the region/endpoint to use when interacting with an AWS service.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "$ref": "#/definitions/vector::aws::region::RegionOrEndpoint"
        }
      ],
      "unevaluatedProperties": false
    },
    "core::option::Option<vector::common::datadog::Region>": {
      "_metadata": {
        "docs::optional": true
      },
      "description": "A Datadog region.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "_metadata": {
            "docs::enum_tagging": "external"
          },
          "description": "A Datadog region.",
          "oneOf": [
            {
              "_metadata": {
                "docs::human_name": "US",
                "logical_name": "Us"
              },
              "const": "us",
              "description": "US region."
            },
            {
              "_metadata": {
                "docs::human_name": "EU",
                "logical_name": "Eu"
              },
              "const": "eu",
              "description": "EU region."
            }
          ]
        }
      ],
      "unevaluatedProperties": false
    },
    "core::option::Option<vector::conditions::AnyCondition>": {
      "_metadata": {
        "docs::optional": true
      },
      "description": "Many methods exist for matching events, such as using a VRL expression, a Datadog Search query string,\nor hard-coded matchers like \"must be a metric\" or \"fields A, B, and C must match these constraints\".\n\nAs VRL is the most common way to apply conditions to events, this type provides a shortcut to define VRL expressions\ndirectly in the configuration by passing the VRL expression as a string:\n\n```toml\ncondition = '.message == \"hooray\"'\n```\n\nWhen other condition types are required, they can be specified with an enum-style notation:\n\n```toml\ncondition.type = 'datadog_search'\ncondition.source = 'NOT \"foo\"'\n```",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "_metadata": {
            "docs::enum_tagging": "untagged",
            "docs::type_override": "condition"
          },
          "description": "Many methods exist for matching events, such as using a VRL expression, a Datadog Search query string,\nor hard-coded matchers like \"must be a metric\" or \"fields A, B, and C must match these constraints\".\n\nAs VRL is the most common way to apply conditions to events, this type provides a shortcut to define VRL expressions\ndirectly in the configuration by passing the VRL expression as a string:\n\n```toml\ncondition = '.message == \"hooray\"'\n```\n\nWhen other condition types are required, they can be specified with an enum-style notation:\n\n```toml\ncondition.type = 'datadog_search'\ncondition.source = 'NOT \"foo\"'\n```",
          "oneOf": [
            {
              "_metadata": {
                "docs::human_name": "String",
                "logical_name": "String"
              },
              "description": "A [Vector Remap Language](https://vector.dev/docs/reference/vrl) (VRL) [boolean expression](https://vector.dev/docs/reference/vrl#boolean-expressions).",
              "type": "string"
            },
            {
              "_metadata": {
                "docs::enum_tag_field": "type",
                "docs::enum_tagging": "internal",
                "docs::human_name": "Map",
                "logical_name": "Map"
              },
              "description": "A fully-specified condition.",
              "oneOf": [
                {
                  "_metadata": {
                    "docs::hidden": true,
                    "docs::human_name": "Is Log",
                    "logical_name": "IsLog"
                  },
                  "description": "Matches an event if it is a log.",
                  "properties": {
                    "type": {
                      "_metadata": {
                        "docs::human_name": "Type"
                      },
                      "const": "is_log",
                      "description": "Matches an event if it is a log."
                    }
                  },
                  "required": [
                    "type"
                  ],
                  "type": "object"
                },
                {
                  "_metadata": {
                    "docs::hidden": true,
                    "docs::human_name": "Is Metric",
                    "logical_name": "IsMetric"
                  },
                  "description": "Matches an event if it is a metric.",
                  "properties": {
                    "type": {
                      "_metadata": {
                        "docs::human_name": "Type"
                      },
                      "const": "is_metric",
                      "description": "Matches an event if it is a metric."
                    }
                  },
                  "required": [
                    "type"
                  ],
                  "type": "object"
                },
                {
                  "_metadata": {
                    "docs::hidden": true,
                    "docs::human_name": "Is Trace",
                    "logical_name": "IsTrace"
                  },
                  "description": "Matches an event if it is a trace.",
                  "properties": {
                    "type": {
                      "_metadata": {
                        "docs::human_name": "Type"
                      },
                      "const": "is_trace",
                      "description": "Matches an event if it is a trace."
                    }
                  },
                  "required": [
                    "type"
                  ],
                  "type": "object"
                },
                {
                  "_metadata": {
                    "docs::human_name": "VRL",
                    "logical_name": "Vrl"
                  },
                  "allOf": [
                    {
                      "description": "A condition that uses the [Vector Remap Language](https://vector.dev/docs/reference/vrl) (VRL) [boolean expression](https://vector.dev/docs/reference/vrl#boolean-expressions) against an event.",
                      "properties": {
                        "runtime": {
                          "_metadata": {
                            "docs::hidden": true,
                            "docs::human_name": "Runtime"
                          },
                          "default": "ast",
                          "description": "The runtime to use for executing VRL code.",
                          "type": "string"
                        },
                        "source": {
                          "_metadata": {
                            "docs::human_name": "Source"
                          },
                          "description": "The VRL boolean expression.",
                          "type": "string"
                        }
                      },
                      "required": [
                        "source"
                      ],
                      "type": "object"
                    },
                    {
                      "properties": {
                        "type": {
                          "_metadata": {
                            "docs::human_name": "Type"
                          },
                          "const": "vrl",
                          "description": "Matches an event with a [Vector Remap Language](https://vector.dev/docs/reference/vrl) (VRL) [boolean expression](https://vector.dev/docs/reference/vrl#boolean-expressions)."
                        }
                      },
                      "required": [
                        "type"
                      ],
                      "type": "object"
                    }
                  ],
                  "description": "Matches an event with a [Vector Remap Language](https://vector.dev/docs/reference/vrl) (VRL) [boolean expression](https://vector.dev/docs/reference/vrl#boolean-expressions)."
                },
                {
                  "_metadata": {
                    "docs::human_name": "Datadog Search",
                    "logical_name": "DatadogSearch"
                  },
                  "allOf": [
                    {
                      "description": "A condition that uses the [Datadog Search](https://docs.datadoghq.com/logs/explorer/search_syntax/) query syntax against an event.",
                      "properties": {
                        "source": {
                          "_metadata": {
                            "docs::human_name": "Source"
                          },
                          "description": "The query string.",
                          "type": "string"
                        }
                      },
                      "required": [
                        "source"
                      ],
                      "type": "object"
                    },
                    {
                      "properties": {
                        "type": {
                          "_metadata": {
                            "docs::human_name": "Type"
                          },
                          "const": "datadog_search",
                          "description": "Matches an event with a [Datadog Search](https://docs.datadoghq.com/logs/explorer/search_syntax/) query."
                        }
                      },
                      "required": [
                        "type"
                      ],
                      "type": "object"
                    }
                  ],
                  "description": "Matches an event with a [Datadog Search](https://docs.datadoghq.com/logs/explorer/search_syntax/) query."
                }
              ],
              "title": "An event matching condition."
            }
          ],
          "title": "An event matching condition."
        }
      ],
      "title": "An event matching condition.",
      "unevaluatedProperties": false
    },
    "core::option::Option<vector::http::Auth>": {
      "_metadata": {
        "docs::optional": true
      },
      "description": "HTTP authentication should be used with HTTPS only, as the authentication credentials are passed as an\nHTTP header without any additional encryption beyond what is provided by the transport itself.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "_metadata": {
            "docs::enum_tag_description": "The authentication strategy to use.",
            "docs::enum_tag_field": "strategy",
            "docs::enum_tagging": "internal"
          },
          "description": "HTTP authentication should be used with HTTPS only, as the authentication credentials are passed as an\nHTTP header without any additional encryption beyond what is provided by the transport itself.",
          "oneOf": [
            {
              "_metadata": {
                "docs::human_name": "Basic",
                "logical_name": "Basic"
              },
              "description": "The username and password are concatenated and encoded via [base64][base64].\n\n[base64]: https://en.wikipedia.org/wiki/Base64",
              "properties": {
                "password": {
                  "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
                  "_metadata": {
                    "docs::examples": [
                      "${PASSWORD}",
                      "password"
                    ],
                    "docs::human_name": "Password"
                  },
                  "description": "The basic authentication password."
                },
                "strategy": {
                  "_metadata": {
                    "docs::human_name": "Strategy"
                  },
                  "const": "basic",
                  "description": "The username and password are concatenated and encoded via [base64][base64].\n\n[base64]: https://en.wikipedia.org/wiki/Base64",
                  "title": "Basic authentication."
                },
                "user": {
                  "_metadata": {
                    "docs::examples": [
                      "${USERNAME}",
                      "username"
                    ],
                    "docs::human_name": "User"
                  },
                  "description": "The basic authentication username.",
                  "type": "string"
                }
              },
              "required": [
                "password",
                "strategy",
                "user"
              ],
              "title": "Basic authentication.",
              "type": "object"
            },
            {
              "_metadata": {
                "docs::human_name": "Bearer",
                "logical_name": "Bearer"
              },
              "description": "The bearer token value (OAuth2, JWT, etc.) is passed as-is.",
              "properties": {
                "strategy": {
                  "_metadata": {
                    "docs::human_name": "Strategy"
                  },
                  "const": "bearer",
                  "description": "The bearer token value (OAuth2, JWT, etc.) is passed as-is.",
                  "title": "Bearer authentication."
                },
                "token": {
                  "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
                  "_metadata": {
                    "docs::human_name": "Token"
                  },
                  "description": "The bearer authentication token."
                }
              },
              "required": [
                "strategy",
                "token"
              ],
              "title": "Bearer authentication.",
              "type": "object"
            }
          ],
          "title": "Configuration of the authentication strategy for HTTP requests."
        }
      ],
      "title": "Configuration of the authentication strategy for HTTP requests.",
      "unevaluatedProperties": false
    },
    "core::option::Option<vector::nats::NatsAuthConfig>": {
      "_metadata": {
        "docs::optional": true
      },
      "description": "Configuration of the authentication strategy when interacting with NATS.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "_metadata": {
            "docs::enum_tag_description": "The strategy used to authenticate with the NATS server.\n\nMore information on NATS authentication, and the various authentication strategies, can be found in the\nNATS [documentation][nats_auth_docs]. For TLS client certificate authentication specifically, see the\n`tls` settings.\n\n[nats_auth_docs]: https://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro",
            "docs::enum_tag_field": "strategy",
            "docs::enum_tagging": "internal"
          },
          "description": "Configuration of the authentication strategy when interacting with NATS.",
          "oneOf": [
            {
              "_metadata": {
                "docs::human_name": "User Password",
                "logical_name": "UserPassword"
              },
              "description": "Username/password authentication.",
              "properties": {
                "strategy": {
                  "_metadata": {
                    "docs::human_name": "Strategy"
                  },
                  "const": "user_password",
                  "description": "Username/password authentication."
                },
                "user_password": {
                  "_metadata": {
                    "docs::human_name": "User Password"
                  },
                  "description": "Username and password configuration.",
                  "properties": {
                    "password": {
                      "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
                      "_metadata": {
                        "docs::human_name": "Password"
                      },
                      "description": "Password."
                    },
                    "user": {
                      "_metadata": {
                        "docs::human_name": "User"
                      },
                      "description": "Username.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "password",
                    "user"
                  ],
                  "type": "object",
                  "unevaluatedProperties": false
                }
              },
              "required": [
                "strategy",
                "user_password"
              ],
              "type": "object"
            },
            {
              "_metadata": {
                "docs::human_name": "Token",
                "logical_name": "Token"
              },
              "description": "Token authentication.",
              "properties": {
                "strategy": {
                  "_metadata": {
                    "docs::human_name": "Strategy"
                  },
                  "const": "token",
                  "description": "Token authentication."
                },
                "token": {
                  "_metadata": {
                    "docs::human_name": "Token"
                  },
                  "description": "Token configuration.",
                  "properties": {
                    "value": {
                      "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
                      "_metadata": {
                        "docs::human_name": "Value"
                      },
                      "description": "Token."
                    }
                  },
                  "required": [
                    "value"
                  ],
                  "type": "object",
                  "unevaluatedProperties": false
                }
              },
              "required": [
                "strategy",
                "token"
              ],
              "type": "object"
            },
            {
              "_metadata": {
                "docs::human_name": "Credentials File",
                "logical_name": "CredentialsFile"
              },
              "description": "Credentials file authentication. (JWT-based)",
              "properties": {
                "credentials_file": {
                  "_metadata": {
                    "docs::human_name": "Credentials File"
                  },
                  "description": "Credentials file configuration.",
                  "properties": {
                    "path": {
                      "_metadata": {
                        "docs::examples": "/etc/nats/nats.creds",
                        "docs::human_name": "Path"
                      },
                      "description": "Path to credentials file.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "path"
                  ],
                  "type": "object",
                  "unevaluatedProperties": false
                },
                "strategy": {
                  "_metadata": {
                    "docs::human_name": "Strategy"
                  },
                  "const": "credentials_file",
                  "description": "Credentials file authentication. (JWT-based)"
                }
              },
              "required": [
                "credentials_file",
                "strategy"
              ],
              "type": "object"
            },
            {
              "_metadata": {
                "docs::human_name": "Nkey",
                "logical_name": "Nkey"
              },
              "description": "NKey authentication.",
              "properties": {
                "nkey": {
                  "_metadata": {
                    "docs::human_name": "Nkey"
                  },
                  "description": "NKeys configuration.",
                  "properties": {
                    "nkey": {
                      "_metadata": {
                        "docs::human_name": "Nkey"
                      },
                      "description": "Conceptually, this is equivalent to a public key.",
                      "title": "User.",
                      "type": "string"
                    },
                    "seed": {
                      "_metadata": {
                        "docs::human_name": "Seed"
                      },
                      "description": "Conceptually, this is equivalent to a private key.",
                      "title": "Seed.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "nkey",
                    "seed"
                  ],
                  "type": "object",
                  "unevaluatedProperties": false
                },
                "strategy": {
                  "_metadata": {
                    "docs::human_name": "Strategy"
                  },
                  "const": "nkey",
                  "description": "NKey authentication."
                }
              },
              "required": [
                "nkey",
                "strategy"
              ],
              "type": "object"
            }
          ]
        }
      ],
      "unevaluatedProperties": false
    },
    "core::option::Option<vector::sinks::gcs_common::config::GcsPredefinedAcl>": {
      "_metadata": {
        "docs::optional": true
      },
      "description": "For more information, see [Predefined ACLs][predefined_acls].\n\n[predefined_acls]: https://cloud.google.com/storage/docs/access-control/lists#predefined-acl",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "_metadata": {
            "docs::enum_tagging": "external"
          },
          "description": "For more information, see [Predefined ACLs][predefined_acls].\n\n[predefined_acls]: https://cloud.google.com/storage/docs/access-control/lists#predefined-acl",
          "oneOf": [
            {
              "_metadata": {
                "docs::human_name": "Authenticated Read",
                "logical_name": "AuthenticatedRead"
              },
              "const": "authenticated-read",
              "description": "The bucket/object owner is granted the `OWNER` permission, and anyone authenticated Google\naccount holder is granted the `READER` permission.",
              "title": "Bucket/object can be read by authenticated users."
            },
            {
              "_metadata": {
                "docs::human_name": "Bucket Owner Full Control",
                "logical_name": "BucketOwnerFullControl"
              },
              "const": "bucket-owner-full-control",
              "description": "Both the object owner and bucket owner are granted the `OWNER` permission.\n\nOnly relevant when specified for an object: this predefined ACL is otherwise ignored when\nspecified for a bucket.",
              "title": "Object is semi-private."
            },
            {
              "_metadata": {
                "docs::human_name": "Bucket Owner Read",
                "logical_name": "BucketOwnerRead"
              },
              "const": "bucket-owner-read",
              "description": "The object owner is granted the `OWNER` permission, and the bucket owner is granted the\n`READER` permission.\n\nOnly relevant when specified for an object: this predefined ACL is otherwise ignored when\nspecified for a bucket.",
              "title": "Object is private, except to the bucket owner."
            },
            {
              "_metadata": {
                "docs::human_name": "Private",
                "logical_name": "Private"
              },
              "const": "private",
              "description": "The bucket/object owner is granted the `OWNER` permission, and no one else has\naccess.",
              "title": "Bucket/object are private."
            },
            {
              "_metadata": {
                "docs::human_name": "Project Private",
                "logical_name": "ProjectPrivate"
              },
              "const": "project-private",
              "description": "Project owners and project editors are granted the `OWNER` permission, and anyone who is\npart of the project team is granted the `READER` permission.\n\nThis is the default.",
              "title": "Bucket/object are private within the project."
            },
            {
              "_metadata": {
                "docs::human_name": "Public Read",
                "logical_name": "PublicRead"
              },
              "const": "public-read",
              "description": "The bucket/object owner is granted the `OWNER` permission, and all other users, whether\nauthenticated or anonymous, are granted the `READER` permission.",
              "title": "Bucket/object can be read publically."
            }
          ],
          "title": "GCS Predefined ACLs."
        }
      ],
      "title": "GCS Predefined ACLs.",
      "unevaluatedProperties": false
    },
    "core::option::Option<vector::sinks::gcs_common::config::GcsStorageClass>": {
      "_metadata": {
        "docs::optional": true
      },
      "description": "For more information, see [Storage classes][storage_classes].\n\n[storage_classes]: https://cloud.google.com/storage/docs/storage-classes",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "_metadata": {
            "docs::enum_tagging": "external"
          },
          "description": "For more information, see [Storage classes][storage_classes].\n\n[storage_classes]: https://cloud.google.com/storage/docs/storage-classes",
          "oneOf": [
            {
              "_metadata": {
                "docs::human_name": "Standard",
                "logical_name": "Standard"
              },
              "const": "STANDARD",
              "description": "This is the default.",
              "title": "Standard storage."
            },
            {
              "_metadata": {
                "docs::human_name": "Nearline",
                "logical_name": "Nearline"
              },
              "const": "NEARLINE",
              "description": "Nearline storage."
            },
            {
              "_metadata": {
                "docs::human_name": "Coldline",
                "logical_name": "Coldline"
              },
              "const": "COLDLINE",
              "description": "Coldline storage."
            },
            {
              "_metadata": {
                "docs::human_name": "Archive",
                "logical_name": "Archive"
              },
              "const": "ARCHIVE",
              "description": "Archive storage."
            }
          ],
          "title": "GCS storage classes."
        }
      ],
      "title": "GCS storage classes.",
      "unevaluatedProperties": false
    },
    "core::option::Option<vector::sinks::influxdb::InfluxDb1Settings>": {
      "_metadata": {
        "docs::optional": true
      },
      "description": "Configuration settings for InfluxDB v0.x/v1.x.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "description": "Configuration settings for InfluxDB v0.x/v1.x.",
          "properties": {
            "consistency": {
              "_metadata": {
                "docs::examples": [
                  "any",
                  "one",
                  "quorum",
                  "all"
                ],
                "docs::human_name": "Consistency",
                "docs::optional": true
              },
              "description": "Only relevant when using InfluxDB v0.x/v1.x.",
              "title": "The consistency level to use for writes.",
              "type": [
                "string",
                "null"
              ]
            },
            "database": {
              "_metadata": {
                "docs::examples": [
                  "vector-database",
                  "iot-store"
                ],
                "docs::human_name": "Database"
              },
              "description": "Only relevant when using InfluxDB v0.x/v1.x.",
              "title": "The name of the database to write into.",
              "type": "string"
            },
            "password": {
              "$ref": "#/definitions/core::option::Option<vector_common::sensitive_string::SensitiveString>",
              "_metadata": {
                "docs::examples": [
                  "${INFLUXDB_PASSWORD}",
                  "influxdb4ever"
                ],
                "docs::human_name": "Password"
              },
              "description": "Only relevant when using InfluxDB v0.x/v1.x.",
              "title": "The password to authenticate with."
            },
            "retention_policy_name": {
              "_metadata": {
                "docs::examples": [
                  "autogen",
                  "one_day_only"
                ],
                "docs::human_name": "Retention Policy Name",
                "docs::optional": true
              },
              "description": "Only relevant when using InfluxDB v0.x/v1.x.",
              "title": "The target retention policy for writes.",
              "type": [
                "string",
                "null"
              ]
            },
            "username": {
              "_metadata": {
                "docs::examples": [
                  "todd",
                  "vector-source"
                ],
                "docs::human_name": "Username",
                "docs::optional": true
              },
              "description": "Only relevant when using InfluxDB v0.x/v1.x.",
              "title": "The username to authenticate with.",
              "type": [
                "string",
                "null"
              ]
            }
          },
          "required": [
            "database"
          ],
          "type": "object"
        }
      ]
    },
    "core::option::Option<vector::sinks::influxdb::InfluxDb2Settings>": {
      "_metadata": {
        "docs::optional": true
      },
      "description": "Configuration settings for InfluxDB v2.x.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "description": "Configuration settings for InfluxDB v2.x.",
          "properties": {
            "bucket": {
              "_metadata": {
                "docs::examples": [
                  "vector-bucket",
                  "4d2225e4d3d49f75"
                ],
                "docs::human_name": "Bucket"
              },
              "description": "Only relevant when using InfluxDB v2.x and above.",
              "title": "The name of the bucket to write into.",
              "type": "string"
            },
            "org": {
              "_metadata": {
                "docs::examples": [
                  "my-org",
                  "33f2cff0a28e5b63"
                ],
                "docs::human_name": "Org"
              },
              "description": "Only relevant when using InfluxDB v2.x and above.",
              "title": "The name of the organization to write into.",
              "type": "string"
            },
            "token": {
              "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
              "_metadata": {
                "docs::examples": [
                  "${INFLUXDB_TOKEN}",
                  "ef8d5de700e7989468166c40fc8a0ccd"
                ],
                "docs::human_name": "Token"
              },
              "description": "Only relevant when using InfluxDB v2.x and above.\n\n[token_docs]: https://v2.docs.influxdata.com/v2.0/security/tokens/",
              "title": "The [token][token_docs] to authenticate with."
            }
          },
          "required": [
            "bucket",
            "org",
            "token"
          ],
          "type": "object"
        }
      ]
    },
    "core::option::Option<vector::sinks::s3_common::config::S3CannedAcl>": {
      "_metadata": {
        "docs::optional": true
      },
      "description": "For more information, see [Canned ACL][canned_acl].\n\n[canned_acl]: https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "_metadata": {
            "docs::enum_tagging": "external"
          },
          "description": "For more information, see [Canned ACL][canned_acl].\n\n[canned_acl]: https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl",
          "oneOf": [
            {
              "_metadata": {
                "docs::human_name": "Private",
                "logical_name": "Private"
              },
              "const": "private",
              "description": "The bucket/object owner is granted the `FULL_CONTROL` permission, and no one else has\naccess.\n\nThis is the default.",
              "title": "Bucket/object are private."
            },
            {
              "_metadata": {
                "docs::human_name": "Public Read",
                "logical_name": "PublicRead"
              },
              "const": "public-read",
              "description": "The bucket/object owner is granted the `FULL_CONTROL` permission, and anyone in the\n`AllUsers` grantee group is granted the `READ` permission.",
              "title": "Bucket/object can be read publicly."
            },
            {
              "_metadata": {
                "docs::human_name": "Public Read Write",
                "logical_name": "PublicReadWrite"
              },
              "const": "public-read-write",
              "description": "The bucket/object owner is granted the `FULL_CONTROL` permission, and anyone in the\n`AllUsers` grantee group is granted the `READ` and `WRITE` permissions.\n\nThis is generally not recommended.",
              "title": "Bucket/object can be read and written publicly."
            },
            {
              "_metadata": {
                "docs::human_name": "AWS Exec Read",
                "logical_name": "AwsExecRead"
              },
              "const": "aws-exec-read",
              "description": "The bucket/object owner is granted the `FULL_CONTROL` permission, and the AWS EC2 service is\ngranted the `READ` permission for the purpose of reading Amazon Machine Image (AMI) bundles\nfrom the given bucket.",
              "title": "Bucket/object are private, and readable by EC2."
            },
            {
              "_metadata": {
                "docs::human_name": "Authenticated Read",
                "logical_name": "AuthenticatedRead"
              },
              "const": "authenticated-read",
              "description": "The bucket/object owner is granted the `FULL_CONTROL` permission, and anyone in the\n`AuthenticatedUsers` grantee group is granted the `READ` permission.",
              "title": "Bucket/object can be read by authenticated users."
            },
            {
              "_metadata": {
                "docs::human_name": "Bucket Owner Read",
                "logical_name": "BucketOwnerRead"
              },
              "const": "bucket-owner-read",
              "description": "The object owner is granted the `FULL_CONTROL` permission, and the bucket owner is granted the `READ` permission.\n\nOnly relevant when specified for an object: this canned ACL is otherwise ignored when\nspecified for a bucket.",
              "title": "Object is private, except to the bucket owner."
            },
            {
              "_metadata": {
                "docs::human_name": "Bucket Owner Full Control",
                "logical_name": "BucketOwnerFullControl"
              },
              "const": "bucket-owner-full-control",
              "description": "Both the object owner and bucket owner are granted the `FULL_CONTROL` permission.\n\nOnly relevant when specified for an object: this canned ACL is otherwise ignored when\nspecified for a bucket.",
              "title": "Object is semi-private."
            },
            {
              "_metadata": {
                "docs::human_name": "Log Delivery Write",
                "logical_name": "LogDeliveryWrite"
              },
              "const": "log-delivery-write",
              "description": "The `LogDelivery` grantee group is granted `WRITE` and `READ_ACP` permissions.\n\nOnly relevant when specified for a bucket: this canned ACL is otherwise ignored when\nspecified for an object.\n\nFor more information about logs, see [Amazon S3 Server Access Logging][serverlogs].\n\n[serverlogs]: https://docs.aws.amazon.com/AmazonS3/latest/dev/ServerLogs.html",
              "title": "Bucket can have logs written."
            }
          ],
          "title": "S3 Canned ACLs."
        }
      ],
      "title": "S3 Canned ACLs.",
      "unevaluatedProperties": false
    },
    "core::option::Option<vector::sinks::s3_common::config::S3ServerSideEncryption>": {
      "_metadata": {
        "docs::optional": true
      },
      "description": "More information on each algorithm can be found in the [AWS documentation][aws_docs].\n\n[aws_docs]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/serv-side-encryption.html",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "_metadata": {
            "docs::enum_tagging": "external"
          },
          "description": "More information on each algorithm can be found in the [AWS documentation][aws_docs].\n\n[aws_docs]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/serv-side-encryption.html",
          "oneOf": [
            {
              "_metadata": {
                "docs::human_name": "AES-256",
                "logical_name": "Aes256"
              },
              "const": "AES256",
              "description": "This corresponds to the `SSE-S3` option.",
              "title": "Each object is encrypted with AES-256 using a unique key."
            },
            {
              "_metadata": {
                "docs::human_name": "AWS KMS",
                "logical_name": "AwsKms"
              },
              "const": "aws:kms",
              "description": "Depending on whether or not a KMS key ID is specified, this corresponds either to the\n`SSE-KMS` option (keys generated/managed by KMS) or the `SSE-C` option (keys generated by\nthe customer, managed by KMS).",
              "title": "Each object is encrypted with AES-256 using keys managed by AWS KMS."
            }
          ],
          "title": "AWS S3 Server-Side Encryption algorithms."
        }
      ],
      "title": "AWS S3 Server-Side Encryption algorithms.",
      "unevaluatedProperties": false
    },
    "core::option::Option<vector::sinks::util::buffer::compression::Compression>": {
      "_metadata": {
        "docs::optional": true
      },
      "description": "All compression algorithms use the default compression level unless otherwise specified.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "_metadata": {
            "docs::advanced": true,
            "docs::enum_tagging": "external"
          },
          "description": "All compression algorithms use the default compression level unless otherwise specified.",
          "oneOf": [
            {
              "_metadata": {
                "docs::enum_tagging": "external"
              },
              "description": "Compression algorithm.",
              "oneOf": [
                {
                  "_metadata": {
                    "docs::human_name": "None",
                    "logical_name": "None"
                  },
                  "const": "none",
                  "description": "No compression."
                },
                {
                  "_metadata": {
                    "docs::human_name": "Gzip",
                    "logical_name": "Gzip"
                  },
                  "const": "gzip",
                  "description": "[gzip]: https://www.gzip.org/",
                  "title": "[Gzip][gzip] compression."
                },
                {
                  "_metadata": {
                    "docs::human_name": "Zlib",
                    "logical_name": "Zlib"
                  },
                  "const": "zlib",
                  "description": "[zlib]: https://zlib.net/",
                  "title": "[Zlib][zlib] compression."
                },
                {
                  "_metadata": {
                    "docs::human_name": "Zstd",
                    "logical_name": "Zstd"
                  },
                  "const": "zstd",
                  "description": "[zstd]: https://facebook.github.io/zstd/",
                  "title": "[Zstandard][zstd] compression."
                }
              ]
            },
            {
              "_metadata": {
                "docs::hidden": true
              },
              "description": "Compression algorithm and compression level.",
              "properties": {
                "algorithm": {
                  "_metadata": {
                    "docs::enum_tagging": "external",
                    "docs::human_name": "Algorithm"
                  },
                  "description": "Compression algorithm.",
                  "oneOf": [
                    {
                      "_metadata": {
                        "docs::human_name": "None",
                        "logical_name": "None"
                      },
                      "const": "none",
                      "description": "No compression."
                    },
                    {
                      "_metadata": {
                        "docs::human_name": "Gzip",
                        "logical_name": "Gzip"
                      },
                      "const": "gzip",
                      "description": "[gzip]: https://www.gzip.org/",
                      "title": "[Gzip][gzip] compression."
                    },
                    {
                      "_metadata": {
                        "docs::human_name": "Zlib",
                        "logical_name": "Zlib"
                      },
                      "const": "zlib",
                      "description": "[zlib]: https://zlib.net/",
                      "title": "[Zlib][zlib] compression."
                    },
                    {
                      "_metadata": {
                        "docs::human_name": "Zstd",
                        "logical_name": "Zstd"
                      },
                      "const": "zstd",
                      "description": "[zstd]: https://facebook.github.io/zstd/",
                      "title": "[Zstandard][zstd] compression."
                    }
                  ],
                  "unevaluatedProperties": false
                },
                "level": {
                  "_metadata": {
                    "docs::human_name": "Level"
                  },
                  "description": "Compression level.",
                  "enum": [
                    "none",
                    "fast",
                    "best",
                    "default",
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21
                  ]
                }
              },
              "required": [
                "algorithm"
              ],
              "type": "object"
            }
          ],
          "title": "Compression configuration."
        }
      ],
      "title": "Compression configuration.",
      "unevaluatedProperties": false
    },
    "core::option::Option<vector::sinks::util::uri::UriSerde>": {
      "_metadata": {
        "docs::optional": true
      },
      "description": "",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "$ref": "#/definitions/vector::sinks::util::uri::UriSerde"
        }
      ],
      "title": "The URI component of a request.",
      "unevaluatedProperties": false
    },
    "core::option::Option<vector::sources::util::http::auth::HttpSourceAuthConfig>": {
      "_metadata": {
        "docs::optional": true
      },
      "description": "HTTP Basic authentication configuration.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "description": "HTTP Basic authentication configuration.",
          "properties": {
            "password": {
              "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
              "_metadata": {
                "docs::examples": [
                  "hunter2",
                  "${PASSWORD}"
                ],
                "docs::human_name": "Password"
              },
              "description": "The password for basic authentication."
            },
            "username": {
              "_metadata": {
                "docs::examples": [
                  "AzureDiamond",
                  "admin"
                ],
                "docs::human_name": "Username"
              },
              "description": "The username for basic authentication.",
              "type": "string"
            }
          },
          "required": [
            "password",
            "username"
          ],
          "type": "object"
        }
      ],
      "unevaluatedProperties": false
    },
    "core::option::Option<vector::template::Template>": {
      "_metadata": {
        "docs::optional": true
      },
      "description": "In many cases, components can be configured so that part of the component's functionality can be\ncustomized on a per-event basis. For example, you have a sink that writes events to a file and you want to\nspecify which file an event should go to by using an event field as part of the\ninput to the filename used.\n\nBy using `Template`, users can specify either fixed strings or templated strings. Templated strings use a common syntax to\nrefer to fields in an event that is used as the input data when rendering the template. An example of a fixed string\nis `my-file.log`. An example of a template string is `my-file-{{key}}.log`, where `{{key}}`\nis the key's value when the template is rendered into a string.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "$ref": "#/definitions/vector::template::Template"
        }
      ],
      "title": "A templated field.",
      "unevaluatedProperties": false
    },
    "core::option::Option<vector_common::sensitive_string::SensitiveString>": {
      "_metadata": {
        "docs::optional": true
      },
      "description": "Wrapper for sensitive strings containing credentials",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString"
        }
      ],
      "unevaluatedProperties": false
    },
    "core::option::Option<vector_core::tcp::TcpKeepaliveConfig>": {
      "_metadata": {
        "docs::optional": true
      },
      "description": "TCP keepalive settings for socket-based components.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "_metadata": {
            "docs::human_name": "Wait Time"
          },
          "description": "TCP keepalive settings for socket-based components.",
          "properties": {
            "time_secs": {
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "seconds"
              },
              "description": "The time to wait before starting to send TCP keepalive probes on an idle connection.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "type": [
                "integer",
                "null"
              ]
            }
          },
          "type": "object"
        }
      ],
      "unevaluatedProperties": false
    },
    "core::option::Option<vector_core::tls::settings::TlsConfig>": {
      "_metadata": {
        "docs::optional": true
      },
      "description": "TLS configuration.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
        }
      ],
      "unevaluatedProperties": false
    },
    "core::option::Option<vector_core::tls::settings::TlsEnableableConfig>": {
      "_metadata": {
        "docs::optional": true
      },
      "description": "Configures the TLS options for incoming/outgoing connections.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "$ref": "#/definitions/vector_core::tls::settings::TlsEnableableConfig"
        }
      ],
      "unevaluatedProperties": false
    },
    "core::option::Option<vector_core::tls::settings::TlsSourceConfig>": {
      "_metadata": {
        "docs::optional": true
      },
      "description": "TlsEnableableConfig for `sources`, adding metadata from the client certificate.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "allOf": [
            {
              "properties": {
                "client_metadata_key": {
                  "$ref": "#/definitions/core::option::Option<vector_lookup::lookup_v2::optional_path::OptionalValuePath>",
                  "_metadata": {
                    "docs::human_name": "Client Metadata Key"
                  },
                  "description": "Event field for client certificate metadata."
                }
              },
              "type": "object"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsEnableableConfig",
              "description": "Configures the TLS options for incoming/outgoing connections."
            }
          ],
          "description": "TlsEnableableConfig for `sources`, adding metadata from the client certificate."
        }
      ],
      "unevaluatedProperties": false
    },
    "core::option::Option<vector_lookup::lookup_v2::ConfigValuePath>": {
      "_metadata": {
        "docs::optional": true
      },
      "description": "A wrapper around `OwnedValuePath` that allows it to be used in Vector config.\nThis requires a valid path to be used. If you want to allow optional paths,\nuse [optional_path::OptionalValuePath].",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "$ref": "#/definitions/vector_lookup::lookup_v2::ConfigValuePath"
        }
      ],
      "unevaluatedProperties": false
    },
    "core::option::Option<vector_lookup::lookup_v2::optional_path::OptionalTargetPath>": {
      "_metadata": {
        "docs::optional": true
      },
      "description": "An optional path that deserializes an empty string to `None`.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalTargetPath"
        }
      ],
      "unevaluatedProperties": false
    },
    "core::option::Option<vector_lookup::lookup_v2::optional_path::OptionalValuePath>": {
      "_metadata": {
        "docs::optional": true
      },
      "description": "An optional path that deserializes an empty string to `None`.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath"
        }
      ],
      "unevaluatedProperties": false
    },
    "core::option::Option<vrl::compiler::datetime::TimeZone>": {
      "_metadata": {
        "docs::optional": true
      },
      "description": "This can refer to any valid timezone as defined in the [TZ database][tzdb], or \"local\" which refers to the system local timezone.\n\n[tzdb]: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "_metadata": {
            "docs::enum_tagging": "untagged",
            "docs::examples": [
              "local",
              "America/New_York",
              "EST5EDT"
            ]
          },
          "description": "This can refer to any valid timezone as defined in the [TZ database][tzdb], or \"local\" which refers to the system local timezone.\n\n[tzdb]: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones",
          "oneOf": [
            {
              "_metadata": {
                "docs::human_name": "Named",
                "logical_name": "Named"
              },
              "description": "Must be a valid name in the [TZ database][tzdb].\n\n[tzdb]: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones",
              "title": "A named timezone.",
              "type": "string"
            }
          ],
          "title": "Timezone reference."
        }
      ],
      "title": "Timezone reference.",
      "unevaluatedProperties": false
    },
    "generate_schema::datadog_archives::DatadogArchivesSinkConfig": {
      "_metadata": {
        "docs::component_name": "datadog_archives",
        "docs::component_type": "sink"
      },
      "description": "Configuration for the `datadog_archives` sink.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled for this sink."
        },
        "aws_s3": {
          "_metadata": {
            "docs::human_name": "AWS S3",
            "docs::optional": true
          },
          "default": null,
          "description": "S3-specific configuration options.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "allOf": [
                {
                  "properties": {
                    "auth": {
                      "$ref": "#/definitions/vector::aws::auth::AwsAuthentication",
                      "_metadata": {
                        "docs::human_name": "Auth"
                      },
                      "default": {
                        "imds": {
                          "connect_timeout_seconds": 1,
                          "max_attempts": 4,
                          "read_timeout_seconds": 1
                        },
                        "load_timeout_secs": null,
                        "region": null
                      },
                      "description": "Configuration of the authentication strategy for interacting with AWS services."
                    }
                  },
                  "type": "object"
                },
                {
                  "description": "S3-specific bucket/object options.",
                  "properties": {
                    "acl": {
                      "$ref": "#/definitions/core::option::Option<vector::sinks::s3_common::config::S3CannedAcl>",
                      "_metadata": {
                        "docs::human_name": "ACL"
                      },
                      "description": "For more information, see [Canned ACL][canned_acl].\n\n[canned_acl]: https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl",
                      "title": "Canned ACL to apply to the created objects."
                    },
                    "grant_full_control": {
                      "_metadata": {
                        "docs::human_name": "Grant Full Control",
                        "docs::optional": true
                      },
                      "description": "This allows the grantee to read the created objects and their metadata, as well as read and\nmodify the ACL on the created objects.\n\n[grantee]: https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#specifying-grantee",
                      "title": "Grants `READ`, `READ_ACP`, and `WRITE_ACP` permissions on the created objects to the named [grantee].",
                      "type": [
                        "string",
                        "null"
                      ]
                    },
                    "grant_read": {
                      "_metadata": {
                        "docs::human_name": "Grant Read",
                        "docs::optional": true
                      },
                      "description": "This allows the grantee to read the created objects and their metadata.\n\n[grantee]: https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#specifying-grantee",
                      "title": "Grants `READ` permissions on the created objects to the named [grantee].",
                      "type": [
                        "string",
                        "null"
                      ]
                    },
                    "grant_read_acp": {
                      "_metadata": {
                        "docs::human_name": "Grant Read ACP",
                        "docs::optional": true
                      },
                      "description": "This allows the grantee to read the ACL on the created objects.\n\n[grantee]: https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#specifying-grantee",
                      "title": "Grants `READ_ACP` permissions on the created objects to the named [grantee].",
                      "type": [
                        "string",
                        "null"
                      ]
                    },
                    "grant_write_acp": {
                      "_metadata": {
                        "docs::human_name": "Grant Write ACP",
                        "docs::optional": true
                      },
                      "description": "This allows the grantee to modify the ACL on the created objects.\n\n[grantee]: https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#specifying-grantee",
                      "title": "Grants `WRITE_ACP` permissions on the created objects to the named [grantee].",
                      "type": [
                        "string",
                        "null"
                      ]
                    },
                    "server_side_encryption": {
                      "$ref": "#/definitions/core::option::Option<vector::sinks::s3_common::config::S3ServerSideEncryption>",
                      "_metadata": {
                        "docs::human_name": "Server Side Encryption"
                      },
                      "description": "The Server-side Encryption algorithm used when storing these objects."
                    },
                    "ssekms_key_id": {
                      "_metadata": {
                        "docs::human_name": "SSE-KMS Key ID",
                        "docs::optional": true
                      },
                      "description": "Only applies when `server_side_encryption` is configured to use KMS.\n\nIf not specified, Amazon S3 uses the AWS managed CMK in AWS to protect the data.",
                      "title": "Specifies the ID of the AWS Key Management Service (AWS KMS) symmetrical customer managed\ncustomer master key (CMK) that is used for the created objects.",
                      "type": [
                        "string",
                        "null"
                      ]
                    },
                    "storage_class": {
                      "$ref": "#/definitions/vector::sinks::s3_common::config::S3StorageClass",
                      "_metadata": {
                        "docs::human_name": "Storage Class"
                      },
                      "description": "For more information, see [Using Amazon S3 storage classes][storage_classes].\n\n[storage_classes]: https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html",
                      "title": "The storage class for the created objects."
                    },
                    "tags": {
                      "_metadata": {
                        "docs::additional_props_description": "A single tag.",
                        "docs::human_name": "Tags",
                        "docs::optional": true
                      },
                      "additionalProperties": {
                        "type": "string"
                      },
                      "description": "The tag-set for the object.",
                      "type": [
                        "object",
                        "null"
                      ]
                    }
                  },
                  "required": [
                    "storage_class"
                  ],
                  "type": "object"
                },
                {
                  "$ref": "#/definitions/vector::aws::region::RegionOrEndpoint",
                  "description": "Configuration of the region/endpoint to use when interacting with an AWS service."
                }
              ],
              "description": "S3-specific configuration options."
            }
          ],
          "unevaluatedProperties": false
        },
        "azure_blob": {
          "_metadata": {
            "docs::human_name": "Azure Blob",
            "docs::optional": true
          },
          "default": null,
          "description": "ABS-specific configuration options.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "description": "ABS-specific configuration options.",
              "properties": {
                "connection_string": {
                  "_metadata": {
                    "docs::human_name": "Connection String"
                  },
                  "description": "Authentication with access key is the only supported authentication method.",
                  "title": "The Azure Blob Storage Account connection string.",
                  "type": "string"
                }
              },
              "required": [
                "connection_string"
              ],
              "type": "object"
            }
          ],
          "unevaluatedProperties": false
        },
        "bucket": {
          "_metadata": {
            "docs::human_name": "Bucket"
          },
          "description": "The name of the bucket to store the archives in.",
          "type": "string"
        },
        "encoding": {
          "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer",
          "_metadata": {
            "docs::human_name": "Encoding"
          },
          "default": {},
          "description": "Transformations to prepare an event for serialization."
        },
        "gcp_cloud_storage": {
          "_metadata": {
            "docs::human_name": "GCP Cloud Storage",
            "docs::optional": true
          },
          "default": null,
          "description": "GCS-specific configuration options.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "allOf": [
                {
                  "properties": {
                    "acl": {
                      "$ref": "#/definitions/core::option::Option<vector::sinks::gcs_common::config::GcsPredefinedAcl>",
                      "_metadata": {
                        "docs::human_name": "ACL"
                      }
                    },
                    "metadata": {
                      "_metadata": {
                        "docs::additional_props_description": "A key/value pair.",
                        "docs::human_name": "Metadata",
                        "docs::optional": true
                      },
                      "additionalProperties": {
                        "type": "string"
                      },
                      "description": "For more information, see [Custom metadata][custom_metadata].\n\n[custom_metadata]: https://cloud.google.com/storage/docs/metadata#custom-metadata",
                      "title": "The set of metadata `key:value` pairs for the created objects.",
                      "type": [
                        "object",
                        "null"
                      ]
                    },
                    "storage_class": {
                      "$ref": "#/definitions/core::option::Option<vector::sinks::gcs_common::config::GcsStorageClass>",
                      "_metadata": {
                        "docs::human_name": "Storage Class"
                      }
                    }
                  },
                  "type": "object"
                },
                {
                  "$ref": "#/definitions/vector::gcp::GcpAuthConfig",
                  "description": "Configuration of the authentication strategy for interacting with GCP services."
                }
              ],
              "description": "GCS-specific configuration options."
            }
          ],
          "unevaluatedProperties": false
        },
        "key_prefix": {
          "_metadata": {
            "docs::human_name": "Key Prefix",
            "docs::optional": true
          },
          "description": "Prefixes are useful for partitioning objects, such as by creating an object key that\nstores objects under a particular directory. If using a prefix for this purpose, it must end\nin `/` to act as a directory path. A trailing `/` is **not** automatically added.",
          "title": "A prefix to apply to all object keys.",
          "type": [
            "string",
            "null"
          ]
        },
        "request": {
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          },
          "default": {
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "initial_concurrency": 1,
              "rtt_deviation_scale": 2.5
            },
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775808,
            "retry_attempts": 9223372036854775808,
            "retry_initial_backoff_secs": 1,
            "retry_max_duration_secs": 3600,
            "timeout_secs": 60
          },
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "title": "Middleware settings for outbound requests."
        },
        "service": {
          "_metadata": {
            "docs::human_name": "Service"
          },
          "description": "The name of the object storage service to use.",
          "type": "string"
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "required": [
        "bucket",
        "service"
      ],
      "type": "object"
    },
    "generate_schema::sds::config::SDSConfig": {
      "_metadata": {
        "docs::component_name": "sensitive_data_scanner",
        "docs::component_type": "transform"
      },
      "description": "Configuration for the `sensitive_data_scanner` transform.",
      "properties": {
        "description": {
          "_metadata": {
            "docs::human_name": "Description",
            "docs::optional": true
          },
          "description": "Optional description of this scanner.",
          "type": [
            "string",
            "null"
          ]
        },
        "rules": {
          "_metadata": {
            "docs::human_name": "Rules"
          },
          "description": "Array of rules containing all the scanning rules inside the scanning group.",
          "items": {
            "description": "A single scanning rule.",
            "properties": {
              "name": {
                "_metadata": {
                  "docs::human_name": "Name"
                },
                "description": "The name of this scanning rule.",
                "type": "string"
              },
              "on_match": {
                "_metadata": {
                  "docs::enum_tag_description": "What to do when a pattern is matched.",
                  "docs::enum_tag_field": "action",
                  "docs::enum_tagging": "internal",
                  "docs::human_name": "Define action on match"
                },
                "description": "Scrubbing and hashing are irreversible changes. Please be sure you want to replace the\nmatching values with the replacement text or hashed value.\n\n* Redact to replace all matching values entirely with a single token of your choice.\n\n* Partially redact to replace a specific portion of all matching values.\n\n* Hash to replace all matching values entirely with a non-reversible unique identifier.",
                "oneOf": [
                  {
                    "_metadata": {
                      "docs::human_name": "Redact",
                      "logical_name": "Redact"
                    },
                    "description": "Redact the matched data by replacing it with a fixed string.",
                    "properties": {
                      "action": {
                        "_metadata": {
                          "docs::human_name": "Action"
                        },
                        "const": "redact",
                        "description": "Redact the matched data by replacing it with a fixed string."
                      },
                      "replace": {
                        "_metadata": {
                          "docs::human_name": "Replace"
                        },
                        "description": "The replacement text.",
                        "type": "string"
                      }
                    },
                    "required": [
                      "action",
                      "replace"
                    ],
                    "type": "object"
                  },
                  {
                    "_metadata": {
                      "docs::human_name": "Hash",
                      "logical_name": "Hash"
                    },
                    "description": "Hash the matched data with the farmhash algorithm.",
                    "properties": {
                      "action": {
                        "_metadata": {
                          "docs::human_name": "Action"
                        },
                        "const": "hash",
                        "description": "Hash the matched data with the farmhash algorithm."
                      }
                    },
                    "required": [
                      "action"
                    ],
                    "type": "object"
                  },
                  {
                    "_metadata": {
                      "docs::human_name": "Partial Redact",
                      "logical_name": "PartialRedact"
                    },
                    "description": "Replace part of the matched data with asterisks.",
                    "properties": {
                      "action": {
                        "_metadata": {
                          "docs::human_name": "Action"
                        },
                        "const": "partial_redact",
                        "description": "Replace part of the matched data with asterisks."
                      },
                      "characters": {
                        "_metadata": {
                          "docs::human_name": "Characters",
                          "docs::numeric_type": "uint"
                        },
                        "description": "How many characters should be redacted?",
                        "maximum": 9007199254740991,
                        "minimum": 0,
                        "type": "integer"
                      },
                      "option": {
                        "_metadata": {
                          "docs::enum_tagging": "external",
                          "docs::human_name": "Option"
                        },
                        "description": "Which part of the matched data should be redacted?",
                        "oneOf": [
                          {
                            "_metadata": {
                              "docs::human_name": "First",
                              "logical_name": "First"
                            },
                            "const": "first",
                            "description": "Redact the first characters."
                          },
                          {
                            "_metadata": {
                              "docs::human_name": "Last",
                              "logical_name": "Last"
                            },
                            "const": "last",
                            "description": "Redact the last characters."
                          }
                        ],
                        "unevaluatedProperties": false
                      }
                    },
                    "required": [
                      "action",
                      "characters",
                      "option"
                    ],
                    "type": "object"
                  }
                ],
                "title": "Define action on match",
                "unevaluatedProperties": false
              },
              "pattern": {
                "_metadata": {
                  "docs::enum_tag_description": "Describes the source of the scanning pattern.",
                  "docs::enum_tag_field": "type",
                  "docs::enum_tagging": "internal",
                  "docs::human_name": "Pattern"
                },
                "description": "The sensitive data pattern to match in the events.",
                "oneOf": [
                  {
                    "_metadata": {
                      "docs::human_name": "Custom",
                      "logical_name": "Custom"
                    },
                    "description": "Use a custom regex rule to scan this pattern.",
                    "properties": {
                      "rule": {
                        "_metadata": {
                          "docs::human_name": "Define Regex"
                        },
                        "description": "The log content is checked against the regular expression below.",
                        "title": "The custom rule regex pattern.",
                        "type": "string"
                      },
                      "type": {
                        "_metadata": {
                          "docs::human_name": "Type"
                        },
                        "const": "custom",
                        "description": "Use a custom regex rule to scan this pattern."
                      }
                    },
                    "required": [
                      "rule",
                      "type"
                    ],
                    "type": "object"
                  },
                  {
                    "_metadata": {
                      "docs::human_name": "Scanning Rules Library",
                      "logical_name": "Library"
                    },
                    "description": "Look up a rule name in the library of pre-configured patterns.",
                    "properties": {
                      "name": {
                        "_metadata": {
                          "docs::enum_tagging": "external"
                        },
                        "description": "The name of the library pattern.",
                        "oneOf": [
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data:visa_credit_card,sensitive_data_category:credit_card",
                              "docs::human_name": "Visa Card Scanner4 X4 Digits",
                              "logical_name": "VisaCardScanner4x4digits"
                            },
                            "const": "Visa Card Scanner (4x4 digits)",
                            "description": "Scan for Visa Card numbers formatted as 4 groups of 4 contiguous digits. Matches are validated via the Luhn algorithm. \n\nExamples of matching formats:\n* 4111 1111 1111 1111\n* 4111-1111-1111-1111\n* 4111.1111.1111.1111\n* 4111,1111,1111,1111"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data:visa_credit_card,sensitive_data_category:credit_card",
                              "docs::human_name": "Visa Card Scanner2 X8 Digits",
                              "logical_name": "VisaCardScanner2x8digits"
                            },
                            "const": "Visa Card Scanner (2x8 digits)",
                            "description": "Scan for Visa Card numbers formatted as 2 groups of 8 contiguous digits. Matches are validated via the Luhn algorithm. \n\nExamples of matching formats:\n* 41111111 11111111\n* 41111111-11111111\n* 41111111.11111111\n* 41111111,11111111"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data:visa_credit_card,sensitive_data_category:credit_card",
                              "docs::human_name": "Visa Card Scanner1 X161 X19 Digits",
                              "logical_name": "VisaCardScanner1x161x19digits"
                            },
                            "const": "Visa Card Scanner (1x16 & 1x19 digits)",
                            "description": "Scan for Visa Card numbers formatted as 16 or 19 contiguous digits. Matches are validated via the Luhn algorithm. \n\nExamples of matching formats:\n* 4111111111111111\n* 4012888888881881"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data:master_card_credit_card,sensitive_data_category:credit_card",
                              "docs::human_name": "Master Card Scanner4 X4 Digits",
                              "logical_name": "MasterCardScanner4x4digits"
                            },
                            "const": "MasterCard Scanner (4x4 digits)",
                            "description": "Scan for MasterCard numbers formatted as 4 groups of 4 contiguous digits. Matches are validated via the Luhn algorithm.  \n\nExamples of matching formats:\n* 5105 1051 0510 5100\n* 5105-1051-0510-5100\n* 5105.1051.0510.5100\n* 5105,1051,0510,5100"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data:master_card_credit_card,sensitive_data_category:credit_card",
                              "docs::human_name": "Master Card Scanner2 X8 Digits",
                              "logical_name": "MasterCardScanner2x8digits"
                            },
                            "const": "MasterCard Scanner (2x8 digits)",
                            "description": "Scan for MasterCard numbers formatted as 2 groups of 8 contiguous digits. Matches are validated via the Luhn algorithm.\n\nExamples of matching formats:\n* 51051051 05105100\n* 51051051-05105100\n* 51051051.05105100\n* 51051051,05105100"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data:master_card_credit_card,sensitive_data_category:credit_card",
                              "docs::human_name": "Master Card Scanner1 X16 Digits",
                              "logical_name": "MasterCardScanner1x16digits"
                            },
                            "const": "MasterCard Scanner (1x16 digits)",
                            "description": "Scan for MasterCard numbers formatted as 16 contiguous digits. Matches are validated via the Luhn algorithm.\n\nExamples of matching formats:\n* 5105105105105100"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data:discover_credit_card,sensitive_data_category:credit_card",
                              "docs::human_name": "Discover Card Scanner4 X4 Digits",
                              "logical_name": "DiscoverCardScanner4x4digits"
                            },
                            "const": "Discover Card Scanner (4x4 digits)",
                            "description": "Scan for Discover Card numbers formatted as 4 groups of 4 contiguous digits. Matches are validated via the Luhn algorithm.  \n\nExamples of matching formats:\n* 6011 0009 9013 9424\n* 6011-0009-9013-9424\n* 6011.0009.9013.9424\n* 6011,0009,9013,9424"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data:discover_credit_card,sensitive_data_category:credit_card",
                              "docs::human_name": "Discover Card Scanner2 X8 Digits",
                              "logical_name": "DiscoverCardScanner2x8digits"
                            },
                            "const": "Discover Card Scanner (2x8 digits)",
                            "description": "Scan for Discover Card numbers formatted as 2 groups of 8 contiguous digits. Matches are validated via the Luhn algorithm.\n\nExamples of matching formats:\n* 60110009 90139424\n* 60110009-90139424\n* 60110009.90139424\n* 60110009,90139424"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data:discover_credit_card,sensitive_data_category:credit_card",
                              "docs::human_name": "Discover Card Scanner1 X16 Digits",
                              "logical_name": "DiscoverCardScanner1x16digits"
                            },
                            "const": "Discover Card Scanner (1x16 digits)",
                            "description": "Scan for Discover Card numbers formatted as 16 contiguous digits. Matches are validated via the Luhn algorithm.\n\nExamples of matching formats:\n* 6011000990139424"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data:american_express_credit_card,sensitive_data_category:credit_card",
                              "docs::human_name": "American Express Card Scanner465 Digits",
                              "logical_name": "AmericanExpressCardScanner465digits"
                            },
                            "const": "American Express Card Scanner (4+6+5 digits)",
                            "description": "Scan for American Express Card numbers formatted as 3 groups of 4, 6, and 5 contiguous digits. Matches are validated via the Luhn algorithm.\n\nExamples of matching formats:\n* 3782 822463 10005\n* 3782-822463-10005\n* 3782.822463.10005\n* 3782,822463,10005"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data:american_express_credit_card,sensitive_data_category:credit_card",
                              "docs::human_name": "American Express Card Scanner4443 Digits",
                              "logical_name": "AmericanExpressCardScanner4443digits"
                            },
                            "const": "American Express Card Scanner (4+4+4+3 digits)",
                            "description": "Scan for American Express Card numbers formatted as 3 groups of 4 contiguous digits followed by 3 contiguous digits. Matches are validated via the Luhn algorithm.\n\nExamples of matching formats:\n* 3782 8224 6310 005\n* 3782-8224-6310-005\n* 3782.8224.6310.005\n* 3782,8224.6310,005"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data:american_express_credit_card,sensitive_data_category:credit_card",
                              "docs::human_name": "American Express Card Scanner87 Digits",
                              "logical_name": "AmericanExpressCardScanner87digits"
                            },
                            "const": "American Express Card Scanner (8+7 digits)",
                            "description": "Scan for American Express Card numbers formatted as 2 groups of 8 and 7 contiguous digits. Matches are validated via the Luhn algorithm.\n\nExamples of matching formats:\n* 37828224 6310005\n* 37828224-6310005\n* 37828224.6310005\n* 37828224.6310005"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data:american_express_credit_card,sensitive_data_category:credit_card",
                              "docs::human_name": "American Express Card Scanner1 X15 Digits",
                              "logical_name": "AmericanExpressCardScanner1x15digits"
                            },
                            "const": "American Express Card Scanner (1x15 digits)",
                            "description": "Scan for American Express Card numbers formatted as 15 contiguous digits. Matches are validated via the Luhn algorithm.\n\nExamples of matching formats:\n* 378282246310005"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data:diners_credit_card,sensitive_data_category:credit_card",
                              "docs::human_name": "Diners Card Scanner464 Digits",
                              "logical_name": "DinersCardScanner464digits"
                            },
                            "const": "Diners Card Scanner (4+6+4 digits)",
                            "description": "Scan for Diners Card numbers formatted as 3 groups of 4, 6, and 4 contiguous digits. Matches are validated via the Luhn algorithm.\n\nExamples of matching formats:\n* 3056 930902 5904\n* 3056-930902-5904\n* 3056.930902.5904\n* 3056,930902,5904"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data:diners_credit_card,sensitive_data_category:credit_card",
                              "docs::human_name": "Diners Card Scanner4442 Digits",
                              "logical_name": "DinersCardScanner4442digits"
                            },
                            "const": "Diners Card Scanner (4+4+4+2 digits)",
                            "description": "Scan for Diners Card numbers formatted as 3 groups of 4 contiguous digits followed by 2 contiguous digits. Matches are validated via the Luhn algorithm.\n\nExamples of matching formats:\n* 3056 9309 0259 04\n* 3056-9309-0259-04\n* 3056.9309.0259.04\n* 3056,9309,0259,04"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data:diners_credit_card,sensitive_data_category:credit_card",
                              "docs::human_name": "Diners Card Scanner86 Digits",
                              "logical_name": "DinersCardScanner86digits"
                            },
                            "const": "Diners Card Scanner (8+6 digits)",
                            "description": "Scan for Diners Card numbers formatted as 2 groups of 8 and 6 contiguous digits. Matches are validated via the Luhn algorithm.\n\nExamples of matching formats:\n* 30569309 025904\n* 30569309-025904\n* 30569309.025904\n* 30569309,025904"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data:diners_credit_card,sensitive_data_category:credit_card",
                              "docs::human_name": "Diners Card Scanner1 X14 Digits",
                              "logical_name": "DinersCardScanner1x14digits"
                            },
                            "const": "Diners Card Scanner (1x14 digits)",
                            "description": "Scan for Diners Card numbers formatted as 14 contiguous digits. Matches are validated via the Luhn algorithm.\n\nExamples of matching formats:\n* 30569309025904"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data:jcb_credit_card,sensitive_data_category:credit_card",
                              "docs::human_name": "Jcb Card Scanner4 X4 Digits",
                              "logical_name": "JCBCardScanner4x4digits"
                            },
                            "const": "JCB Card Scanner (4x4 digits)",
                            "description": "Scan for JCB Card numbers formatted as 4 groups of 4 contiguous digits. Matches are validated via the Luhn algorithm.  \n\nExamples of matching formats:\n* 3530 1113 3330 0000\n* 3530-1113-3330-0000\n* 3530.1113.3330.0000\n* 3530,1113,3330,0000"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data:jcb_credit_card,sensitive_data_category:credit_card",
                              "docs::human_name": "Jcb Card Scanner2 X8 Digits",
                              "logical_name": "JCBCardScanner2x8digits"
                            },
                            "const": "JCB Card Scanner (2x8 digits)",
                            "description": "Scan for JCB Card numbers formatted as 2 groups of 8 contiguous digits. Matches are validated via the Luhn algorithm.\n\nExamples of matching formats:\n* 35301113 33300000\n* 35301113-33300000\n* 35301113.33300000\n* 35301113,33300000"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data:jcb_credit_card,sensitive_data_category:credit_card",
                              "docs::human_name": "Jcb Card Scanner1 X16 Digits",
                              "logical_name": "JCBCardScanner1x16digits"
                            },
                            "const": "JCB Card Scanner (1x16 digits)",
                            "description": "Scan for JCB Card numbers formatted as 16 contiguous digits. Matches are validated via the Luhn algorithm.\n\nExamples of matching formats:\n* 3530111333300000"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data:maestro_card,sensitive_data_category:credit_card",
                              "docs::human_name": "Maestro Card Scanner4 X4 Digits",
                              "logical_name": "MaestroCardScanner4x4digits"
                            },
                            "const": "Maestro Card Scanner (4x4 digits)",
                            "description": "Scan for Maestro Card numbers formatted as 4 groups of 4 contiguous digits. Matches are validated via the Luhn algorithm.  \n\nExamples of matching formats:\n* 6759 6498 2643 8453\n* 6759-6498-2643-8453\n* 6759.6498.2643.8453\n* 6759,6498,2643,8453"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data:maestro_card,sensitive_data_category:credit_card",
                              "docs::human_name": "Maestro Card Scanner2 X8 Digits",
                              "logical_name": "MaestroCardScanner2x8digits"
                            },
                            "const": "Maestro Card Scanner (2x8 digits)",
                            "description": "Scan for Maestro Card numbers formatted as 2 groups of 8 contiguous digits. Matches are validated via the Luhn algorithm.\n\nExamples of matching formats:\n* 67596498 26438453\n* 67596498-26438453\n* 67596498.26438453\n* 67596498,26438453"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data:maestro_card,sensitive_data_category:credit_card",
                              "docs::human_name": "Maestro Card Scanner1 X16 Digits",
                              "logical_name": "MaestroCardScanner1x16digits"
                            },
                            "const": "Maestro Card Scanner (1x16 digits)",
                            "description": "Scan for Maestro Card numbers formatted as 16 contiguous digits. Matches are validated via the Luhn algorithm.\n\nExamples of matching formats:\n* 6759649826438453"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data:email_address,sensitive_data_category:email_address",
                              "docs::human_name": "Standard Email Address Scanner",
                              "logical_name": "StandardEmailAddressScanner"
                            },
                            "const": "Standard Email Address Scanner",
                            "description": "Standard Email Address Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data:iban_code,sensitive_data_category:iban_code",
                              "docs::human_name": "Standard Iban Code Scanner",
                              "logical_name": "StandardIbanCodeScanner"
                            },
                            "const": "Standard Iban Code Scanner",
                            "description": "Standard Iban Code Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data:mac_address,sensitive_data_category:mac_address",
                              "docs::human_name": "Standard Mac Address Scanner",
                              "logical_name": "StandardMacAddressScanner"
                            },
                            "const": "Standard Mac Address Scanner",
                            "description": "Standard Mac Address Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:aws_access_key_id",
                              "docs::human_name": "AWS Access Key ID Scanner",
                              "logical_name": "AWSAccessKeyIDScanner"
                            },
                            "const": "AWS Access Key ID Scanner",
                            "description": "AWS Access Key ID Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:aws_secret_access_key",
                              "docs::human_name": "AWS Secret Access Key Scanner",
                              "logical_name": "AWSSecretAccessKeyScanner"
                            },
                            "const": "AWS Secret Access Key Scanner",
                            "description": "AWS Secret Access Key Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:facebook_access_token",
                              "docs::human_name": "Facebook Access Token Scanner",
                              "logical_name": "FacebookAccessTokenScanner"
                            },
                            "const": "Facebook Access Token Scanner",
                            "description": "Facebook Access Token Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:slack_access_token",
                              "docs::human_name": "Slack Access Token Scanner",
                              "logical_name": "SlackAccessTokenScanner"
                            },
                            "const": "Slack Access Token Scanner",
                            "description": "Slack Access Token Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:stripe_api_key",
                              "docs::human_name": "Stripe API Key Scanner",
                              "logical_name": "StripeAPIKeyScanner"
                            },
                            "const": "Stripe API Key Scanner",
                            "description": "Stripe API Key Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:stripe_restricted_api_key",
                              "docs::human_name": "Stripe Restricted API Key Scanner",
                              "logical_name": "StripeRestrictedAPIKeyScanner"
                            },
                            "const": "Stripe Restricted API Key Scanner",
                            "description": "Stripe Restricted API Key Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:twilio_api_key",
                              "docs::human_name": "Twilio API Key Scanner",
                              "logical_name": "TwilioAPIKeyScanner"
                            },
                            "const": "Twilio API Key Scanner",
                            "description": "Twilio API Key Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:square_access_token",
                              "docs::human_name": "Square Access Token Scanner",
                              "logical_name": "SquareAccessTokenScanner"
                            },
                            "const": "Square Access Token Scanner",
                            "description": "Square Access Token Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:square_oauth_secret",
                              "docs::human_name": "Square O Auth Secret Scanner",
                              "logical_name": "SquareOAuthSecretScanner"
                            },
                            "const": "Square OAuth Secret Scanner",
                            "description": "Square OAuth Secret Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:google_api_key",
                              "docs::human_name": "Google API Key Scanner",
                              "logical_name": "GoogleAPIKeyScanner"
                            },
                            "const": "Google API Key Scanner",
                            "description": "Google API Key Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:google_oauth_access_token",
                              "docs::human_name": "Google O Auth Access Token Scanner",
                              "logical_name": "GoogleOAuthAccessTokenScanner"
                            },
                            "const": "Google OAuth Access Token Scanner",
                            "description": "Google OAuth Access Token Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:rsa_private_key",
                              "docs::human_name": "Rsa Private Key Scanner",
                              "logical_name": "RSAPrivateKeyScanner"
                            },
                            "const": "RSA Private Key Scanner",
                            "description": "RSA Private Key Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:send_grid_api_token",
                              "docs::human_name": "Send Grid API Token Scanner",
                              "logical_name": "SendGridAPITokenScanner"
                            },
                            "const": "Send Grid API Token Scanner",
                            "description": "Send Grid API Token Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:heroku_api_key",
                              "docs::human_name": "Heroku API Key Scanner",
                              "logical_name": "HerokuAPIKeyScanner"
                            },
                            "const": "Heroku API Key Scanner",
                            "description": "Heroku API Key Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:ssh_key",
                              "docs::human_name": "Ssh Key Scanner",
                              "logical_name": "SSHKeyScanner"
                            },
                            "const": "SSH Key Scanner",
                            "description": "SSH Key Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:pgp_private_key",
                              "docs::human_name": "Pgp Private Key Scanner",
                              "logical_name": "PGPPrivateKeyScanner"
                            },
                            "const": "PGP Private Key Scanner",
                            "description": "PGP Private Key Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:paypal_braintree_access_token",
                              "docs::human_name": "Paypal Braintree Access Token Scanner",
                              "logical_name": "PaypalBraintreeAccessTokenScanner"
                            },
                            "const": "Paypal Braintree Access Token Scanner",
                            "description": "Paypal Braintree Access Token Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:dynatrace_token",
                              "docs::human_name": "Dynatrace Token Scanner",
                              "logical_name": "DynatraceTokenScanner"
                            },
                            "const": "Dynatrace Token Scanner",
                            "description": "Dynatrace Token Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:gitlab_token",
                              "docs::human_name": "Gitlab Token Scanner",
                              "logical_name": "GitlabTokenScanner"
                            },
                            "const": "Gitlab Token Scanner",
                            "description": "Gitlab Token Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:instagram_token",
                              "docs::human_name": "Instagram Token Scanner",
                              "logical_name": "InstagramTokenScanner"
                            },
                            "const": "Instagram Token Scanner",
                            "description": "Instagram Token Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:json_web_token",
                              "docs::human_name": "JSON Web Token Scanner",
                              "logical_name": "JSONWebTokenScanner"
                            },
                            "const": "JSON Web Token Scanner",
                            "description": "JSON Web Token Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:mailchimp_api_key",
                              "docs::human_name": "Mailchimp API Key Scanner",
                              "logical_name": "MailchimpAPIKeyScanner"
                            },
                            "const": "Mailchimp API Key Scanner",
                            "description": "Mailchimp API Key Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:mailgun_api_key",
                              "docs::human_name": "Mailgun API Key Scanner",
                              "logical_name": "MailgunAPIKeyScanner"
                            },
                            "const": "Mailgun API Key Scanner",
                            "description": "Mailgun API Key Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:okta_api_token",
                              "docs::human_name": "Okta API Token Scanner",
                              "logical_name": "OktaAPITokenScanner"
                            },
                            "const": "Okta API Token Scanner",
                            "description": "Okta API Token Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:amazon_mws_token",
                              "docs::human_name": "Amazon Marketplace Web Services Auth Token Scanner",
                              "logical_name": "AmazonMarketplaceWebServicesAuthTokenScanner"
                            },
                            "const": "Amazon Marketplace Web Services Auth Token Scanner",
                            "description": "Amazon Marketplace Web Services Auth Token Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:azure_personal_access_token",
                              "docs::human_name": "Azure Personal Access Token Scanner",
                              "logical_name": "AzurePersonalAccessTokenScanner"
                            },
                            "const": "Azure Personal Access Token Scanner",
                            "description": "Azure Personal Access Token Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:azure_sql_connection_string",
                              "docs::human_name": "Azure Sql Connection String Scanner",
                              "logical_name": "AzureSQLConnectionStringScanner"
                            },
                            "const": "Azure SQL Connection String Scanner",
                            "description": "Azure SQL Connection String Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:azure_subscription_key",
                              "docs::human_name": "Azure Subscription Key Scanner",
                              "logical_name": "AzureSubscriptionKeyScanner"
                            },
                            "const": "Azure Subscription Key Scanner",
                            "description": "Azure Subscription Key Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:bearer_token",
                              "docs::human_name": "Bearer Token Scanner",
                              "logical_name": "BearerTokenScanner"
                            },
                            "const": "Bearer Token Scanner",
                            "description": "Bearer Token Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:checkout_secret",
                              "docs::human_name": "Checkoutcom Secret Scanner",
                              "logical_name": "CheckoutcomSecretScanner"
                            },
                            "const": "Checkout.com Secret Scanner",
                            "description": "Checkout.com Secret Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:databricks_personal_access_token",
                              "docs::human_name": "Databricks Personal Access Token Scanner",
                              "logical_name": "DatabricksPersonalAccessTokenScanner"
                            },
                            "const": "Databricks Personal Access Token Scanner",
                            "description": "Databricks Personal Access Token Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:docker_swarm_join_token",
                              "docs::human_name": "Docker Swarm Join Token Scanner",
                              "logical_name": "DockerSwarmJoinTokenScanner"
                            },
                            "const": "Docker Swarm Join Token Scanner",
                            "description": "Docker Swarm Join Token Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:docker_swarm_unlock_key",
                              "docs::human_name": "Docker Swarm Unlock Key Scanner",
                              "logical_name": "DockerSwarmUnlockKeyScanner"
                            },
                            "const": "Docker Swarm Unlock Key Scanner",
                            "description": "Docker Swarm Unlock Key Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:github_access_token",
                              "docs::human_name": "Github Access Token Scanner",
                              "logical_name": "GithubAccessTokenScanner"
                            },
                            "const": "Github Access Token Scanner",
                            "description": "Github Access Token Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:github_refresh_token",
                              "docs::human_name": "Github Refresh Token Scanner",
                              "logical_name": "GithubRefreshTokenScanner"
                            },
                            "const": "Github Refresh Token Scanner",
                            "description": "Github Refresh Token Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:url,sensitive_data:http_url",
                              "docs::human_name": "Httpsurl Scanner",
                              "logical_name": "HTTPSURLScanner"
                            },
                            "const": "HTTP(S) URL Scanner",
                            "description": "HTTP(S) URL Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:ip_address,sensitive_data:ipv4_address",
                              "docs::human_name": "I Pv4 Address Scanner",
                              "logical_name": "IPv4AddressScanner"
                            },
                            "const": "IPv4 Address Scanner",
                            "description": "IPv4 Address Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:ip_address,sensitive_data:ipv6_address",
                              "docs::human_name": "I Pv6 Address Scanner",
                              "logical_name": "IPv6AddressScanner"
                            },
                            "const": "IPv6 Address Scanner",
                            "description": "IPv6 Address Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:jira_api_token",
                              "docs::human_name": "Jiraapi Token Scanner",
                              "logical_name": "JIRAAPITokenScanner"
                            },
                            "const": "JIRA API Token Scanner",
                            "description": "JIRA API Token Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:linkedin_secret",
                              "docs::human_name": "Linked In Secret Scanner",
                              "logical_name": "LinkedInSecretScanner"
                            },
                            "const": "LinkedIn Secret Scanner",
                            "description": "LinkedIn Secret Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:shopify_access_token",
                              "docs::human_name": "Shopify Access Token Scanner",
                              "logical_name": "ShopifyAccessTokenScanner"
                            },
                            "const": "Shopify Access Token Scanner",
                            "description": "Shopify Access Token Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:shopify_shared_secret",
                              "docs::human_name": "Shopify Shared Secret Scanner",
                              "logical_name": "ShopifySharedSecretScanner"
                            },
                            "const": "Shopify Shared Secret Scanner",
                            "description": "Shopify Shared Secret Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:slack_webhook_secret",
                              "docs::human_name": "Slack Webhook Secret Scanner",
                              "logical_name": "SlackWebhookSecretScanner"
                            },
                            "const": "Slack Webhook Secret Scanner",
                            "description": "Slack Webhook Secret Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:credentials,sensitive_data:twitter_secret",
                              "docs::human_name": "Twitter Secret Scanner",
                              "logical_name": "TwitterSecretScanner"
                            },
                            "const": "Twitter Secret Scanner",
                            "description": "Twitter Secret Scanner"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:pii,sensitive_data:passport_number",
                              "docs::human_name": "US Passport Scanner",
                              "logical_name": "USPassportScanner"
                            },
                            "const": "US Passport Scanner",
                            "description": "matches a case-insensitive keyword 'passport' (optionally followed by an underscore and one or more word characters) and then a sequence of characters representing a passport number in either a 9-character alphanumeric format or a 9-character format with 6 digits, an uppercase letter, and 2 more digits. This rule will scrub the whole pattern, including the keyword."
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:pii,sensitive_data:vin",
                              "docs::human_name": "US Vehicle Identification Number Scanner",
                              "logical_name": "USVehicleIdentificationNumberScanner"
                            },
                            "const": "US Vehicle Identification Number Scanner",
                            "description": "matches a case-insensitive keyword related to the Vehicle Identification Number (VIN), followed by a sequence of 17 characters that adhere to the standard VIN format (excluding letters I, O, and Q). This rule will scrub the whole pattern, including the keyword.\n\nExamples of matching formats:\n* Vehicle Identification Number: 1HGBH41JXMN109186\n* vehicle identification-number: 2FMDK36C18BA04895\n* vin: 3D7KA28693G723011"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:pii,sensitive_data:uk_nin",
                              "docs::human_name": "Uk National Insurance Number Scanner",
                              "logical_name": "UKNationalInsuranceNumberScanner"
                            },
                            "const": "UK National Insurance Number Scanner",
                            "description": "matches a case-insensitive keyword related to the UK's National Insurance Number (NIN), followed by a sequence of characters representing a valid NIN format, which consists of two uppercase letters, six digits, and an optional uppercase letter. This rule will scrub the whole pattern, including the keyword.\n\nExamples of matching formats:\n* National Insurance Number: AB123456C\n* NIN: XY654321A\n* insurance_number: GH987654Z"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:pii,sensitive_data:canadian_sin",
                              "docs::human_name": "Canadian Social Insurance Number Scanner",
                              "logical_name": "CanadianSocialInsuranceNumberScanner"
                            },
                            "const": "Canadian Social Insurance Number Scanner",
                            "description": "matches a case-insensitive keyword related to the Canadian Social Insurance Number (SIN), followed by a sequence of characters representing a valid SIN format, which consists of three groups of three digits separated by hyphens (e.g., 123-456-789). This rule will scrub the whole pattern, including the keyword. \n\nExamples of matching formats:\n* Social Insurance Number: 123-456-789\n* Social Insurance Number: 123-456-789\n* Canadian social_insurance: 456-789-123"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:network_and_device_info,sensitive_data:basic_auth",
                              "docs::human_name": "HTTP Basic Authentification Header Scanner",
                              "logical_name": "HTTPBasicAuthentificationHeaderScanner"
                            },
                            "const": "HTTP Basic Authentification Header Scanner",
                            "description": "matches the Authorization header of an HTTP request that uses the Basic authentication scheme. It specifically looks for the Authorization keyword, followed by the Basic keyword and a base64-encoded string. \n\nExamples of matching formats:\n* Authorization: Basic QWxhZGRpbjpPcGVuU2VzYW1l"
                          },
                          {
                            "_metadata": {
                              "docs::additional_props_sds_tags_added": "sensitive_data_category:network_and_device_info,sensitive_data:cookie",
                              "docs::human_name": "HTTP Cookie Scanner",
                              "logical_name": "HTTPCookieScanner"
                            },
                            "const": "HTTP Cookie Scanner",
                            "description": "matches the Set-Cookie header of an HTTP response. It captures the cookie name-value pairs and any optional attributes that are separated by semicolons.\n\nExamples of matching formats:\n* Set-Cookie: sessionid=123456; HttpOnly; Secure\n* Set-Cookie: username=JohnDoe"
                          }
                        ],
                        "unevaluatedProperties": false
                      },
                      "type": {
                        "const": "library",
                        "description": "Look up a rule name in the library of pre-configured patterns."
                      }
                    },
                    "required": [
                      "name",
                      "type"
                    ],
                    "type": "object"
                  }
                ],
                "unevaluatedProperties": false
              },
              "scope": {
                "_metadata": {
                  "docs::enum_tag_description": "What part of the incoming event will be scanned by this rule.",
                  "docs::enum_tag_field": "target",
                  "docs::enum_tagging": "internal",
                  "docs::human_name": "Scan entire event or portion of it"
                },
                "description": "By default, the regex is checked on all log attributes. For finer grained processing,\nidentify an inclusion or exclusion list of attributes with a comma-separated list, such as\n`admin.email, recipient`.",
                "oneOf": [
                  {
                    "_metadata": {
                      "docs::human_name": "Entire",
                      "logical_name": "Entire"
                    },
                    "description": "Entire Event",
                    "properties": {
                      "exclude": {
                        "_metadata": {
                          "docs::human_name": "Exclude attribute(s) from scanning"
                        },
                        "default": [],
                        "description": "The list of field names to exclude.",
                        "items": {
                          "$ref": "#/definitions/vector_lookup::lookup_v2::ConfigValuePath"
                        },
                        "type": "array"
                      },
                      "target": {
                        "_metadata": {
                          "docs::human_name": "Target"
                        },
                        "const": "entire event",
                        "description": "Entire Event"
                      }
                    },
                    "required": [
                      "target"
                    ],
                    "type": "object"
                  },
                  {
                    "_metadata": {
                      "docs::human_name": "Attribute",
                      "logical_name": "Attribute"
                    },
                    "description": "Specific Attributes",
                    "properties": {
                      "include": {
                        "_metadata": {
                          "docs::human_name": "Specify the attribute(s) you want to scan"
                        },
                        "default": [],
                        "description": "The list of field names to include.",
                        "items": {
                          "$ref": "#/definitions/vector_lookup::lookup_v2::ConfigValuePath"
                        },
                        "type": "array"
                      },
                      "target": {
                        "_metadata": {
                          "docs::human_name": "Target"
                        },
                        "const": "specific attributes",
                        "description": "Specific Attributes"
                      }
                    },
                    "required": [
                      "target"
                    ],
                    "type": "object"
                  }
                ],
                "title": "Scan entire event or portion of it",
                "unevaluatedProperties": false
              },
              "tags": {
                "_metadata": {
                  "docs::human_name": "Tags"
                },
                "default": [],
                "description": "An optional array of tags to associated with matched events.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            },
            "required": [
              "name",
              "on_match",
              "pattern",
              "scope"
            ],
            "type": "object",
            "unevaluatedProperties": false
          },
          "type": "array"
        }
      },
      "required": [
        "rules"
      ],
      "type": "object"
    },
    "serde_with::DurationFractionalSeconds": {
      "_metadata": {
        "docs::numeric_type": "float",
        "docs::type_unit": "seconds"
      },
      "description": "A span of time, in fractional seconds.",
      "maximum": 9007199254740991,
      "minimum": -9007199254740991,
      "type": "number"
    },
    "serde_with::DurationMilliSeconds": {
      "_metadata": {
        "docs::numeric_type": "uint",
        "docs::type_unit": "milliseconds"
      },
      "description": "A span of time, in whole milliseconds.",
      "maximum": 9007199254740991,
      "minimum": 0,
      "type": "integer"
    },
    "serde_with::DurationSeconds": {
      "_metadata": {
        "docs::numeric_type": "uint",
        "docs::type_unit": "seconds"
      },
      "description": "A span of time, in whole seconds.",
      "maximum": 9007199254740991,
      "minimum": 0,
      "type": "integer"
    },
    "stdlib::PathBuf": {
      "description": "A file path.",
      "pattern": "(\\/.*|[a-zA-Z]:\\\\(?:([^<>:\"\\/\\\\|?*]*[^<>:\"\\/\\\\|?*.]\\\\|..\\\\)*([^<>:\"\\/\\\\|?*]*[^<>:\"\\/\\\\|?*.]\\\\?|..\\\\))?)",
      "type": "string"
    },
    "stdlib::SocketAddr": {
      "description": "An internet socket address, either IPv4 or IPv6.",
      "type": "string"
    },
    "vector::amqp::AmqpConfig": {
      "description": "AMQP connection options.",
      "properties": {
        "connection_string": {
          "_metadata": {
            "docs::examples": "amqp://user:password@127.0.0.1:5672/%2f?timeout=10",
            "docs::human_name": "Connection String"
          },
          "description": "The URI has the format of\n`amqp://<user>:<password>@<host>:<port>/<vhost>?timeout=<seconds>`.\n\nThe default vhost can be specified by using a value of `%2f`.\n\nTo connect over TLS, a scheme of `amqps` can be specified instead. For example,\n`amqps://...`. Additional TLS settings, such as client certificate verification, can be\nconfigured under the `tls` section.",
          "title": "URI for the AMQP server.",
          "type": "string"
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "required": [
        "connection_string"
      ],
      "type": "object"
    },
    "vector::aws::auth::AwsAuthentication": {
      "_metadata": {
        "docs::enum_tagging": "untagged"
      },
      "anyOf": [
        {
          "_metadata": {
            "docs::human_name": "Access Key",
            "logical_name": "AccessKey"
          },
          "description": "Authenticate using a fixed access key and secret pair.",
          "properties": {
            "access_key_id": {
              "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
              "_metadata": {
                "docs::examples": "AKIAIOSFODNN7EXAMPLE",
                "docs::human_name": "Access Key ID"
              },
              "description": "The AWS access key ID."
            },
            "assume_role": {
              "_metadata": {
                "docs::examples": "arn:aws:iam::123456789098:role/my_role",
                "docs::human_name": "Assume Role",
                "docs::optional": true
              },
              "description": "[iam_role]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html",
              "title": "The ARN of an [IAM role][iam_role] to assume.",
              "type": [
                "string",
                "null"
              ]
            },
            "external_id": {
              "_metadata": {
                "docs::examples": "randomEXAMPLEidString",
                "docs::human_name": "External ID",
                "docs::optional": true
              },
              "description": "[external_id]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html",
              "title": "The optional unique external ID in conjunction with role to assume.",
              "type": [
                "string",
                "null"
              ]
            },
            "region": {
              "_metadata": {
                "docs::examples": "us-west-2",
                "docs::human_name": "Region",
                "docs::optional": true
              },
              "description": "If not set, this will default to the configured region\nfor the service itself.\n\n[aws_region]: https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints",
              "title": "The [AWS region][aws_region] to send STS requests to.",
              "type": [
                "string",
                "null"
              ]
            },
            "secret_access_key": {
              "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
              "_metadata": {
                "docs::examples": "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY",
                "docs::human_name": "Secret Access Key"
              },
              "description": "The AWS secret access key."
            }
          },
          "required": [
            "access_key_id",
            "secret_access_key"
          ],
          "type": "object"
        },
        {
          "_metadata": {
            "docs::human_name": "File",
            "logical_name": "File"
          },
          "description": "Additionally, the specific credential profile to use can be set.\nThe file format must match the credentials file format outlined in\n<https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html>.",
          "properties": {
            "credentials_file": {
              "_metadata": {
                "docs::examples": "/my/aws/credentials",
                "docs::human_name": "Credentials File"
              },
              "description": "Path to the credentials file.",
              "type": "string"
            },
            "profile": {
              "_metadata": {
                "docs::examples": "develop",
                "docs::human_name": "Profile"
              },
              "default": "default",
              "description": "Used to select AWS credentials from a provided credentials file.",
              "title": "The credentials profile to use.",
              "type": "string"
            }
          },
          "required": [
            "credentials_file"
          ],
          "title": "Authenticate using credentials stored in a file.",
          "type": "object"
        },
        {
          "_metadata": {
            "docs::human_name": "Role",
            "logical_name": "Role"
          },
          "description": "Assume the given role ARN.",
          "properties": {
            "assume_role": {
              "_metadata": {
                "docs::examples": "arn:aws:iam::123456789098:role/my_role",
                "docs::human_name": "Assume Role"
              },
              "description": "[iam_role]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html",
              "title": "The ARN of an [IAM role][iam_role] to assume.",
              "type": "string"
            },
            "external_id": {
              "_metadata": {
                "docs::examples": "randomEXAMPLEidString",
                "docs::human_name": "External ID",
                "docs::optional": true
              },
              "description": "[external_id]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html",
              "title": "The optional unique external ID in conjunction with role to assume.",
              "type": [
                "string",
                "null"
              ]
            },
            "imds": {
              "_metadata": {
                "docs::human_name": "IMDS"
              },
              "default": {
                "connect_timeout_seconds": 1,
                "max_attempts": 4,
                "read_timeout_seconds": 1
              },
              "description": "Configuration for authenticating with AWS through IMDS.",
              "properties": {
                "connect_timeout_seconds": {
                  "$ref": "#/definitions/serde_with::DurationSeconds",
                  "_metadata": {
                    "docs::human_name": "Connect Timeout Seconds"
                  },
                  "default": 1,
                  "description": "Connect timeout for IMDS."
                },
                "max_attempts": {
                  "_metadata": {
                    "docs::human_name": "Max Attempts",
                    "docs::numeric_type": "uint"
                  },
                  "default": 4,
                  "description": "Number of IMDS retries for fetching tokens and metadata.",
                  "maximum": 4294967295,
                  "minimum": 0,
                  "type": "integer"
                },
                "read_timeout_seconds": {
                  "$ref": "#/definitions/serde_with::DurationSeconds",
                  "_metadata": {
                    "docs::human_name": "Read Timeout Seconds"
                  },
                  "default": 1,
                  "description": "Read timeout for IMDS."
                }
              },
              "type": "object",
              "unevaluatedProperties": false
            },
            "load_timeout_secs": {
              "_metadata": {
                "docs::examples": 30,
                "docs::human_name": "Load Timeout",
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "seconds"
              },
              "description": "Relevant when the default credentials chain or `assume_role` is used.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "title": "Timeout for assuming the role, in seconds.",
              "type": [
                "integer",
                "null"
              ]
            },
            "region": {
              "_metadata": {
                "docs::examples": "us-west-2",
                "docs::human_name": "Region",
                "docs::optional": true
              },
              "description": "If not set, this defaults to the configured region\nfor the service itself.\n\n[aws_region]: https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints",
              "title": "The [AWS region][aws_region] to send STS requests to.",
              "type": [
                "string",
                "null"
              ]
            }
          },
          "required": [
            "assume_role"
          ],
          "type": "object"
        }
      ],
      "description": "Configuration of the authentication strategy for interacting with AWS services.",
      "unevaluatedProperties": false
    },
    "vector::aws::region::RegionOrEndpoint": {
      "default": {
        "endpoint": null,
        "region": null
      },
      "description": "Configuration of the region/endpoint to use when interacting with an AWS service.",
      "properties": {
        "endpoint": {
          "_metadata": {
            "docs::advanced": true,
            "docs::examples": "http://127.0.0.0:5000/path/to/service",
            "docs::human_name": "Endpoint",
            "docs::optional": true
          },
          "description": "Custom endpoint for use with AWS-compatible services.",
          "type": [
            "string",
            "null"
          ]
        },
        "region": {
          "_metadata": {
            "docs::examples": "us-east-1",
            "docs::human_name": "Region",
            "docs::optional": true
          },
          "description": "[aws_region]: https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints",
          "title": "The [AWS region][aws_region] of the target service.",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "type": "object"
    },
    "vector::codecs::encoding::config::EncodingConfig": {
      "allOf": [
        {
          "_metadata": {
            "docs::enum_tag_description": "The codec to use for encoding events.",
            "docs::enum_tag_field": "codec",
            "docs::enum_tagging": "internal"
          },
          "description": "Serializer configuration.",
          "oneOf": [
            {
              "_metadata": {
                "docs::human_name": "Avro",
                "logical_name": "Avro"
              },
              "description": "[apache_avro]: https://avro.apache.org/",
              "properties": {
                "avro": {
                  "_metadata": {
                    "docs::human_name": "Avro"
                  },
                  "description": "Apache Avro-specific encoder options.",
                  "properties": {
                    "schema": {
                      "_metadata": {
                        "docs::examples": "{ \"type\": \"record\", \"name\": \"log\", \"fields\": [{ \"name\": \"message\", \"type\": \"string\" }] }",
                        "docs::human_name": "Schema JSON"
                      },
                      "description": "The Avro schema.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "schema"
                  ],
                  "type": "object",
                  "unevaluatedProperties": false
                },
                "codec": {
                  "_metadata": {
                    "docs::human_name": "Codec"
                  },
                  "const": "avro",
                  "description": "[apache_avro]: https://avro.apache.org/",
                  "title": "Encodes an event as an [Apache Avro][apache_avro] message."
                }
              },
              "required": [
                "avro",
                "codec"
              ],
              "title": "Encodes an event as an [Apache Avro][apache_avro] message.",
              "type": "object"
            },
            {
              "_metadata": {
                "docs::human_name": "CSV",
                "logical_name": "Csv"
              },
              "allOf": [
                {
                  "$ref": "#/definitions/codecs::encoding::format::csv::CsvSerializerConfig",
                  "description": "Config used to build a `CsvSerializer`."
                },
                {
                  "properties": {
                    "codec": {
                      "_metadata": {
                        "docs::human_name": "Codec"
                      },
                      "const": "csv",
                      "description": "This codec must be configured with fields to encode.",
                      "title": "Encodes an event as a CSV message."
                    }
                  },
                  "required": [
                    "codec"
                  ],
                  "type": "object"
                }
              ],
              "description": "This codec must be configured with fields to encode.",
              "title": "Encodes an event as a CSV message."
            },
            {
              "_metadata": {
                "docs::human_name": "GELF",
                "logical_name": "Gelf"
              },
              "description": "[gelf]: https://docs.graylog.org/docs/gelf",
              "properties": {
                "codec": {
                  "_metadata": {
                    "docs::human_name": "Codec"
                  },
                  "const": "gelf",
                  "description": "[gelf]: https://docs.graylog.org/docs/gelf",
                  "title": "Encodes an event as a [GELF][gelf] message."
                }
              },
              "required": [
                "codec"
              ],
              "title": "Encodes an event as a [GELF][gelf] message.",
              "type": "object"
            },
            {
              "_metadata": {
                "docs::human_name": "JSON",
                "logical_name": "Json"
              },
              "allOf": [
                {
                  "$ref": "#/definitions/codecs::encoding::format::json::JsonSerializerConfig",
                  "description": "Config used to build a `JsonSerializer`."
                },
                {
                  "properties": {
                    "codec": {
                      "_metadata": {
                        "docs::human_name": "Codec"
                      },
                      "const": "json",
                      "description": "[json]: https://www.json.org/",
                      "title": "Encodes an event as [JSON][json]."
                    }
                  },
                  "required": [
                    "codec"
                  ],
                  "type": "object"
                }
              ],
              "description": "[json]: https://www.json.org/",
              "title": "Encodes an event as [JSON][json]."
            },
            {
              "_metadata": {
                "docs::human_name": "Logfmt",
                "logical_name": "Logfmt"
              },
              "description": "[logfmt]: https://brandur.org/logfmt",
              "properties": {
                "codec": {
                  "_metadata": {
                    "docs::human_name": "Codec"
                  },
                  "const": "logfmt",
                  "description": "[logfmt]: https://brandur.org/logfmt",
                  "title": "Encodes an event as a [logfmt][logfmt] message."
                }
              },
              "required": [
                "codec"
              ],
              "title": "Encodes an event as a [logfmt][logfmt] message.",
              "type": "object"
            },
            {
              "_metadata": {
                "docs::human_name": "Native",
                "logical_name": "Native"
              },
              "description": "This codec is **[experimental][experimental]**.\n\n[vector_native_protobuf]: https://github.com/vectordotdev/vector/blob/master/lib/vector-core/proto/event.proto\n[experimental]: https://vector.dev/highlights/2022-03-31-native-event-codecs",
              "properties": {
                "codec": {
                  "_metadata": {
                    "docs::human_name": "Codec"
                  },
                  "const": "native",
                  "description": "This codec is **[experimental][experimental]**.\n\n[vector_native_protobuf]: https://github.com/vectordotdev/vector/blob/master/lib/vector-core/proto/event.proto\n[experimental]: https://vector.dev/highlights/2022-03-31-native-event-codecs",
                  "title": "Encodes an event in the [native Protocol Buffers format][vector_native_protobuf]."
                }
              },
              "required": [
                "codec"
              ],
              "title": "Encodes an event in the [native Protocol Buffers format][vector_native_protobuf].",
              "type": "object"
            },
            {
              "_metadata": {
                "docs::human_name": "Native JSON",
                "logical_name": "NativeJson"
              },
              "description": "This codec is **[experimental][experimental]**.\n\n[vector_native_json]: https://github.com/vectordotdev/vector/blob/master/lib/codecs/tests/data/native_encoding/schema.cue\n[experimental]: https://vector.dev/highlights/2022-03-31-native-event-codecs",
              "properties": {
                "codec": {
                  "_metadata": {
                    "docs::human_name": "Codec"
                  },
                  "const": "native_json",
                  "description": "This codec is **[experimental][experimental]**.\n\n[vector_native_json]: https://github.com/vectordotdev/vector/blob/master/lib/codecs/tests/data/native_encoding/schema.cue\n[experimental]: https://vector.dev/highlights/2022-03-31-native-event-codecs",
                  "title": "Encodes an event in the [native JSON format][vector_native_json]."
                }
              },
              "required": [
                "codec"
              ],
              "title": "Encodes an event in the [native JSON format][vector_native_json].",
              "type": "object"
            },
            {
              "_metadata": {
                "docs::human_name": "Raw Message",
                "logical_name": "RawMessage"
              },
              "description": "This encoding uses the `message` field of a log event.\n\nBe careful if you are modifying your log events (for example, by using a `remap`\ntransform) and removing the message field while doing additional parsing on it, as this\ncould lead to the encoding emitting empty strings for the given event.",
              "properties": {
                "codec": {
                  "_metadata": {
                    "docs::human_name": "Codec"
                  },
                  "const": "raw_message",
                  "description": "This encoding uses the `message` field of a log event.\n\nBe careful if you are modifying your log events (for example, by using a `remap`\ntransform) and removing the message field while doing additional parsing on it, as this\ncould lead to the encoding emitting empty strings for the given event.",
                  "title": "No encoding."
                }
              },
              "required": [
                "codec"
              ],
              "title": "No encoding.",
              "type": "object"
            },
            {
              "_metadata": {
                "docs::human_name": "Text",
                "logical_name": "Text"
              },
              "allOf": [
                {
                  "description": "Config used to build a `TextSerializer`.",
                  "properties": {
                    "metric_tag_values": {
                      "$ref": "#/definitions/codecs::MetricTagValues",
                      "_metadata": {
                        "docs::human_name": "Metric Tag Values"
                      },
                      "default": "single",
                      "description": "When set to `single`, only the last non-bare value of tags are displayed with the\nmetric.  When set to `full`, all metric tags are exposed as separate assignments.",
                      "title": "Controls how metric tag values are encoded."
                    }
                  },
                  "type": "object"
                },
                {
                  "properties": {
                    "codec": {
                      "_metadata": {
                        "docs::human_name": "Codec"
                      },
                      "const": "text",
                      "description": "This encoding uses the `message` field of a log event. For metrics, it uses an\nencoding that resembles the Prometheus export format.\n\nBe careful if you are modifying your log events (for example, by using a `remap`\ntransform) and removing the message field while doing additional parsing on it, as this\ncould lead to the encoding emitting empty strings for the given event.",
                      "title": "Plain text encoding."
                    }
                  },
                  "required": [
                    "codec"
                  ],
                  "type": "object"
                }
              ],
              "description": "This encoding uses the `message` field of a log event. For metrics, it uses an\nencoding that resembles the Prometheus export format.\n\nBe careful if you are modifying your log events (for example, by using a `remap`\ntransform) and removing the message field while doing additional parsing on it, as this\ncould lead to the encoding emitting empty strings for the given event.",
              "title": "Plain text encoding."
            }
          ]
        },
        {
          "description": "Transformations to prepare an event for serialization.",
          "properties": {
            "except_fields": {
              "_metadata": {
                "docs::human_name": "Except Fields",
                "docs::optional": true
              },
              "default": null,
              "description": "List of fields that are excluded from the encoded event.",
              "items": {
                "$ref": "#/definitions/vector_lookup::lookup_v2::ConfigValuePath"
              },
              "type": [
                "array",
                "null"
              ]
            },
            "only_fields": {
              "_metadata": {
                "docs::human_name": "Only Fields",
                "docs::optional": true
              },
              "default": null,
              "description": "List of fields that are included in the encoded event.",
              "items": {
                "$ref": "#/definitions/vector_lookup::lookup_v2::ConfigValuePath"
              },
              "type": [
                "array",
                "null"
              ]
            },
            "timestamp_format": {
              "_metadata": {
                "docs::human_name": "Timestamp Format",
                "docs::optional": true
              },
              "default": null,
              "description": "Format used for timestamp fields.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "_metadata": {
                    "docs::enum_tagging": "external"
                  },
                  "description": "The format in which a timestamp should be represented.",
                  "oneOf": [
                    {
                      "_metadata": {
                        "docs::human_name": "Unix",
                        "logical_name": "Unix"
                      },
                      "const": "unix",
                      "description": "Represent the timestamp as a Unix timestamp."
                    },
                    {
                      "_metadata": {
                        "docs::human_name": "RFC3339",
                        "logical_name": "Rfc3339"
                      },
                      "const": "rfc3339",
                      "description": "Represent the timestamp as a RFC 3339 timestamp."
                    }
                  ]
                }
              ],
              "unevaluatedProperties": false
            }
          },
          "type": "object"
        }
      ],
      "description": "Configures how events are encoded into raw bytes.",
      "unevaluatedProperties": false
    },
    "vector::codecs::encoding::config::EncodingConfigWithFraming": {
      "description": "Encoding configuration.",
      "properties": {
        "encoding": {
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
          "_metadata": {
            "docs::human_name": "Encoding"
          },
          "description": "Configures how events are encoded into raw bytes."
        },
        "framing": {
          "_metadata": {
            "docs::human_name": "Framing",
            "docs::optional": true
          },
          "description": "Framing configuration.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "_metadata": {
                "docs::enum_tag_description": "The framing method.",
                "docs::enum_tag_field": "method",
                "docs::enum_tagging": "internal"
              },
              "description": "Framing configuration.",
              "oneOf": [
                {
                  "_metadata": {
                    "docs::human_name": "Bytes",
                    "logical_name": "Bytes"
                  },
                  "description": "Event data is not delimited at all.",
                  "properties": {
                    "method": {
                      "_metadata": {
                        "docs::human_name": "Method"
                      },
                      "const": "bytes",
                      "description": "Event data is not delimited at all."
                    }
                  },
                  "required": [
                    "method"
                  ],
                  "type": "object"
                },
                {
                  "_metadata": {
                    "docs::human_name": "Character Delimited",
                    "logical_name": "CharacterDelimited"
                  },
                  "allOf": [
                    {
                      "description": "Config used to build a `CharacterDelimitedEncoder`.",
                      "properties": {
                        "character_delimited": {
                          "_metadata": {
                            "docs::human_name": "Character Delimited"
                          },
                          "description": "Options for the character delimited encoder.",
                          "properties": {
                            "delimiter": {
                              "_metadata": {
                                "docs::human_name": "Delimiter",
                                "docs::numeric_type": "uint"
                              },
                              "description": "The ASCII (7-bit) character that delimits byte sequences.",
                              "maximum": 255,
                              "minimum": 0,
                              "type": "integer"
                            }
                          },
                          "required": [
                            "delimiter"
                          ],
                          "type": "object",
                          "unevaluatedProperties": false
                        }
                      },
                      "required": [
                        "character_delimited"
                      ],
                      "type": "object"
                    },
                    {
                      "properties": {
                        "method": {
                          "_metadata": {
                            "docs::human_name": "Method"
                          },
                          "const": "character_delimited",
                          "description": "Event data is delimited by a single ASCII (7-bit) character."
                        }
                      },
                      "required": [
                        "method"
                      ],
                      "type": "object"
                    }
                  ],
                  "description": "Event data is delimited by a single ASCII (7-bit) character."
                },
                {
                  "_metadata": {
                    "docs::human_name": "Length Delimited",
                    "logical_name": "LengthDelimited"
                  },
                  "description": "The prefix is a 32-bit unsigned integer, little endian.",
                  "properties": {
                    "method": {
                      "_metadata": {
                        "docs::human_name": "Method"
                      },
                      "const": "length_delimited",
                      "description": "The prefix is a 32-bit unsigned integer, little endian.",
                      "title": "Event data is prefixed with its length in bytes."
                    }
                  },
                  "required": [
                    "method"
                  ],
                  "title": "Event data is prefixed with its length in bytes.",
                  "type": "object"
                },
                {
                  "_metadata": {
                    "docs::human_name": "Newline Delimited",
                    "logical_name": "NewlineDelimited"
                  },
                  "description": "Event data is delimited by a newline (LF) character.",
                  "properties": {
                    "method": {
                      "_metadata": {
                        "docs::human_name": "Method"
                      },
                      "const": "newline_delimited",
                      "description": "Event data is delimited by a newline (LF) character."
                    }
                  },
                  "required": [
                    "method"
                  ],
                  "type": "object"
                }
              ]
            }
          ],
          "unevaluatedProperties": false
        }
      },
      "required": [
        "encoding"
      ],
      "type": "object"
    },
    "vector::codecs::encoding::transformer::Transformer": {
      "description": "Transformations to prepare an event for serialization.",
      "properties": {
        "except_fields": {
          "_metadata": {
            "docs::human_name": "Except Fields",
            "docs::optional": true
          },
          "default": null,
          "description": "List of fields that are excluded from the encoded event.",
          "items": {
            "$ref": "#/definitions/vector_lookup::lookup_v2::ConfigValuePath"
          },
          "type": [
            "array",
            "null"
          ]
        },
        "only_fields": {
          "_metadata": {
            "docs::human_name": "Only Fields",
            "docs::optional": true
          },
          "default": null,
          "description": "List of fields that are included in the encoded event.",
          "items": {
            "$ref": "#/definitions/vector_lookup::lookup_v2::ConfigValuePath"
          },
          "type": [
            "array",
            "null"
          ]
        },
        "timestamp_format": {
          "_metadata": {
            "docs::human_name": "Timestamp Format",
            "docs::optional": true
          },
          "default": null,
          "description": "Format used for timestamp fields.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "_metadata": {
                "docs::enum_tagging": "external"
              },
              "description": "The format in which a timestamp should be represented.",
              "oneOf": [
                {
                  "_metadata": {
                    "docs::human_name": "Unix",
                    "logical_name": "Unix"
                  },
                  "const": "unix",
                  "description": "Represent the timestamp as a Unix timestamp."
                },
                {
                  "_metadata": {
                    "docs::human_name": "RFC3339",
                    "logical_name": "Rfc3339"
                  },
                  "const": "rfc3339",
                  "description": "Represent the timestamp as a RFC 3339 timestamp."
                }
              ]
            }
          ],
          "unevaluatedProperties": false
        }
      },
      "type": "object",
      "unevaluatedProperties": false
    },
    "vector::conditions::AnyCondition": {
      "_metadata": {
        "docs::enum_tagging": "untagged",
        "docs::type_override": "condition"
      },
      "description": "Many methods exist for matching events, such as using a VRL expression, a Datadog Search query string,\nor hard-coded matchers like \"must be a metric\" or \"fields A, B, and C must match these constraints\".\n\nAs VRL is the most common way to apply conditions to events, this type provides a shortcut to define VRL expressions\ndirectly in the configuration by passing the VRL expression as a string:\n\n```toml\ncondition = '.message == \"hooray\"'\n```\n\nWhen other condition types are required, they can be specified with an enum-style notation:\n\n```toml\ncondition.type = 'datadog_search'\ncondition.source = 'NOT \"foo\"'\n```",
      "oneOf": [
        {
          "_metadata": {
            "docs::human_name": "String",
            "logical_name": "String"
          },
          "description": "A [Vector Remap Language](https://vector.dev/docs/reference/vrl) (VRL) [boolean expression](https://vector.dev/docs/reference/vrl#boolean-expressions).",
          "type": "string"
        },
        {
          "_metadata": {
            "docs::enum_tag_field": "type",
            "docs::enum_tagging": "internal",
            "docs::human_name": "Map",
            "logical_name": "Map"
          },
          "description": "A fully-specified condition.",
          "oneOf": [
            {
              "_metadata": {
                "docs::hidden": true,
                "docs::human_name": "Is Log",
                "logical_name": "IsLog"
              },
              "description": "Matches an event if it is a log.",
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "is_log",
                  "description": "Matches an event if it is a log."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            },
            {
              "_metadata": {
                "docs::hidden": true,
                "docs::human_name": "Is Metric",
                "logical_name": "IsMetric"
              },
              "description": "Matches an event if it is a metric.",
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "is_metric",
                  "description": "Matches an event if it is a metric."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            },
            {
              "_metadata": {
                "docs::hidden": true,
                "docs::human_name": "Is Trace",
                "logical_name": "IsTrace"
              },
              "description": "Matches an event if it is a trace.",
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "is_trace",
                  "description": "Matches an event if it is a trace."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            },
            {
              "_metadata": {
                "docs::human_name": "VRL",
                "logical_name": "Vrl"
              },
              "allOf": [
                {
                  "description": "A condition that uses the [Vector Remap Language](https://vector.dev/docs/reference/vrl) (VRL) [boolean expression](https://vector.dev/docs/reference/vrl#boolean-expressions) against an event.",
                  "properties": {
                    "runtime": {
                      "_metadata": {
                        "docs::hidden": true,
                        "docs::human_name": "Runtime"
                      },
                      "default": "ast",
                      "description": "The runtime to use for executing VRL code.",
                      "type": "string"
                    },
                    "source": {
                      "_metadata": {
                        "docs::human_name": "Source"
                      },
                      "description": "The VRL boolean expression.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "source"
                  ],
                  "type": "object"
                },
                {
                  "properties": {
                    "type": {
                      "_metadata": {
                        "docs::human_name": "Type"
                      },
                      "const": "vrl",
                      "description": "Matches an event with a [Vector Remap Language](https://vector.dev/docs/reference/vrl) (VRL) [boolean expression](https://vector.dev/docs/reference/vrl#boolean-expressions)."
                    }
                  },
                  "required": [
                    "type"
                  ],
                  "type": "object"
                }
              ],
              "description": "Matches an event with a [Vector Remap Language](https://vector.dev/docs/reference/vrl) (VRL) [boolean expression](https://vector.dev/docs/reference/vrl#boolean-expressions)."
            },
            {
              "_metadata": {
                "docs::human_name": "Datadog Search",
                "logical_name": "DatadogSearch"
              },
              "allOf": [
                {
                  "description": "A condition that uses the [Datadog Search](https://docs.datadoghq.com/logs/explorer/search_syntax/) query syntax against an event.",
                  "properties": {
                    "source": {
                      "_metadata": {
                        "docs::human_name": "Source"
                      },
                      "description": "The query string.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "source"
                  ],
                  "type": "object"
                },
                {
                  "properties": {
                    "type": {
                      "_metadata": {
                        "docs::human_name": "Type"
                      },
                      "const": "datadog_search",
                      "description": "Matches an event with a [Datadog Search](https://docs.datadoghq.com/logs/explorer/search_syntax/) query."
                    }
                  },
                  "required": [
                    "type"
                  ],
                  "type": "object"
                }
              ],
              "description": "Matches an event with a [Datadog Search](https://docs.datadoghq.com/logs/explorer/search_syntax/) query."
            }
          ],
          "title": "An event matching condition."
        }
      ],
      "title": "An event matching condition.",
      "unevaluatedProperties": false
    },
    "vector::config::TestInput": {
      "description": "An input describes not only the type of event to insert, but also which transform within the\nconfiguration to insert it to.",
      "properties": {
        "insert_at": {
          "_metadata": {
            "docs::human_name": "Insert At"
          },
          "description": "The name of the transform to insert the input event to.",
          "type": "string"
        },
        "log_fields": {
          "_metadata": {
            "docs::human_name": "Log Fields",
            "docs::optional": true
          },
          "additionalProperties": {
            "_metadata": {
              "docs::enum_tagging": "untagged"
            },
            "description": "Value for a log field.",
            "oneOf": [
              {
                "_metadata": {
                  "docs::human_name": "String",
                  "logical_name": "String"
                },
                "description": "A string.",
                "type": "string"
              },
              {
                "_metadata": {
                  "docs::human_name": "Integer",
                  "docs::numeric_type": "int",
                  "logical_name": "Integer"
                },
                "description": "An integer.",
                "maximum": 9007199254740991,
                "minimum": -9007199254740991,
                "type": "integer"
              },
              {
                "_metadata": {
                  "docs::human_name": "Float",
                  "docs::numeric_type": "float",
                  "logical_name": "Float"
                },
                "description": "A floating-point number.",
                "maximum": 9007199254740991,
                "minimum": -9007199254740991,
                "type": "number"
              },
              {
                "_metadata": {
                  "docs::human_name": "Boolean",
                  "logical_name": "Boolean"
                },
                "description": "A boolean.",
                "type": "boolean"
              }
            ],
            "unevaluatedProperties": false
          },
          "description": "Only relevant when `type` is `log`.",
          "title": "The set of log fields to use when creating a log input event.",
          "type": [
            "object",
            "null"
          ]
        },
        "metric": {
          "_metadata": {
            "docs::human_name": "Metric",
            "docs::optional": true
          },
          "description": "Only relevant when `type` is `metric`.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "allOf": [
                {
                  "allOf": [
                    {
                      "properties": {
                        "tags": {
                          "_metadata": {
                            "docs::human_name": "Tags",
                            "docs::optional": true
                          },
                          "description": "Tags for a metric series.",
                          "oneOf": [
                            {
                              "type": "null"
                            },
                            {
                              "additionalProperties": {
                                "_metadata": {
                                  "docs::enum_tagging": "external"
                                },
                                "description": "Tag values for a metric series.  This may be empty, a single value, or a set of values. This is\nused to provide the storage for `TagValueSet`.",
                                "oneOf": [
                                  {
                                    "_metadata": {
                                      "docs::human_name": "Empty",
                                      "logical_name": "Empty"
                                    },
                                    "const": "Empty",
                                    "description": "This represents a set containing no value."
                                  },
                                  {
                                    "_metadata": {
                                      "docs::human_name": "Single",
                                      "logical_name": "Single"
                                    },
                                    "description": "This represents a set containing a single value. This is stored separately to avoid the\noverhead of allocating a hash table for the common case of a single value for a tag.",
                                    "properties": {
                                      "Single": {
                                        "_metadata": {
                                          "docs::enum_tagging": "untagged",
                                          "docs::human_name": "Single"
                                        },
                                        "description": "A single tag value, either a bare tag or a value.",
                                        "oneOf": [
                                          {
                                            "_metadata": {
                                              "docs::human_name": "Bare",
                                              "logical_name": "Bare"
                                            },
                                            "description": "Bare tag value.",
                                            "type": "null"
                                          },
                                          {
                                            "_metadata": {
                                              "docs::human_name": "Value",
                                              "logical_name": "Value"
                                            },
                                            "description": "Tag value containing a string.",
                                            "type": "string"
                                          }
                                        ],
                                        "unevaluatedProperties": false
                                      }
                                    },
                                    "required": [
                                      "Single"
                                    ],
                                    "type": "object"
                                  },
                                  {
                                    "_metadata": {
                                      "docs::human_name": "Set",
                                      "logical_name": "Set"
                                    },
                                    "description": "This holds an actual set of values. This variant will be automatically created when a single\nvalue is added to, and reduced down to a single value when the length is reduced to 1.  An\nindex set is used for this set, as it preserves the insertion order of the contained\nelements. This allows us to retrieve the last element inserted which in turn allows us to\nemulate the set having a single value.",
                                    "properties": {
                                      "Set": {
                                        "_metadata": {
                                          "docs::human_name": "Set"
                                        },
                                        "items": {
                                          "_metadata": {
                                            "docs::enum_tagging": "untagged"
                                          },
                                          "description": "A single tag value, either a bare tag or a value.",
                                          "oneOf": [
                                            {
                                              "_metadata": {
                                                "docs::human_name": "Bare",
                                                "logical_name": "Bare"
                                              },
                                              "description": "Bare tag value.",
                                              "type": "null"
                                            },
                                            {
                                              "_metadata": {
                                                "docs::human_name": "Value",
                                                "logical_name": "Value"
                                              },
                                              "description": "Tag value containing a string.",
                                              "type": "string"
                                            }
                                          ],
                                          "unevaluatedProperties": false
                                        },
                                        "type": "array",
                                        "uniqueItems": true
                                      }
                                    },
                                    "required": [
                                      "Set"
                                    ],
                                    "type": "object"
                                  }
                                ],
                                "unevaluatedProperties": false
                              },
                              "description": "Tags for a metric series.",
                              "type": "object"
                            }
                          ],
                          "unevaluatedProperties": false
                        }
                      },
                      "type": "object"
                    },
                    {
                      "description": "Metric name.",
                      "properties": {
                        "name": {
                          "_metadata": {
                            "docs::human_name": "Name"
                          },
                          "description": "This would typically be a name for the metric itself, unrelated to where the metric\noriginates from. For example, if the metric represented the amount of used system memory, it\nmay be called `memory.used`.",
                          "title": "The name of the metric.",
                          "type": "string"
                        },
                        "namespace": {
                          "_metadata": {
                            "docs::human_name": "Namespace",
                            "docs::optional": true
                          },
                          "description": "Namespace represents a grouping for a metric where the name itself may otherwise be too\ngeneric. For example, while the name of a metric may be `memory.used` for the amount of used\nsystem memory, the namespace could differentiate that by being `system` for the total amount\nof used memory across the system, or `vector` for the amount of used system memory specific\nto Vector, and so on.",
                          "title": "The namespace of the metric.",
                          "type": [
                            "string",
                            "null"
                          ]
                        }
                      },
                      "required": [
                        "name"
                      ],
                      "type": "object"
                    }
                  ],
                  "description": "Metrics series."
                },
                {
                  "allOf": [
                    {
                      "properties": {
                        "kind": {
                          "_metadata": {
                            "docs::enum_tagging": "external",
                            "docs::human_name": "Kind"
                          },
                          "description": "Metrics can be either absolute of incremental. Absolute metrics represent a sort of \"last write wins\" scenario,\nwhere the latest absolute value seen is meant to be the actual metric value.  In contrast, and perhaps intuitively,\nincremental metrics are meant to be additive, such that we don't know what total value of the metric is, but we know\nthat we'll be adding or subtracting the given value from it.\n\nGenerally speaking, most metrics storage systems deal with incremental updates. A notable exception is Prometheus,\nwhich deals with, and expects, absolute values from clients.",
                          "oneOf": [
                            {
                              "_metadata": {
                                "docs::human_name": "Incremental",
                                "logical_name": "Incremental"
                              },
                              "const": "incremental",
                              "description": "Incremental metric."
                            },
                            {
                              "_metadata": {
                                "docs::human_name": "Absolute",
                                "logical_name": "Absolute"
                              },
                              "const": "absolute",
                              "description": "Absolute metric."
                            }
                          ],
                          "title": "Metric kind.",
                          "unevaluatedProperties": false
                        }
                      },
                      "required": [
                        "kind"
                      ],
                      "type": "object"
                    },
                    {
                      "description": "Metric time.",
                      "properties": {
                        "interval_ms": {
                          "_metadata": {
                            "docs::human_name": "Interval Ms",
                            "docs::numeric_type": "uint",
                            "docs::optional": true
                          },
                          "description": "Intervals represent the time window over which this metric applies, and is generally only\nused for tracking rates (change over time) on counters.",
                          "maximum": 4294967295,
                          "minimum": 1,
                          "title": "The interval, in milliseconds, of this metric.",
                          "type": [
                            "integer",
                            "null"
                          ]
                        },
                        "timestamp": {
                          "_metadata": {
                            "docs::human_name": "Timestamp",
                            "docs::optional": true
                          },
                          "description": "Metrics may sometimes have no timestamp, or have no meaningful value if the metric is an\naggregation or transformed heavily enough from its original form such that the original\ntimestamp would not represent a meaningful value.",
                          "title": "The timestamp of when the metric was created.",
                          "type": [
                            "string",
                            "null"
                          ]
                        }
                      },
                      "type": "object"
                    },
                    {
                      "_metadata": {
                        "docs::enum_tagging": "external"
                      },
                      "description": "Metric value.\nContainer for the actual value of a metric.",
                      "oneOf": [
                        {
                          "_metadata": {
                            "docs::human_name": "Counter",
                            "logical_name": "Counter"
                          },
                          "description": "A cumulative numerical value that can only increase or be reset to zero.",
                          "properties": {
                            "counter": {
                              "_metadata": {
                                "docs::human_name": "Counter"
                              },
                              "properties": {
                                "value": {
                                  "_metadata": {
                                    "docs::human_name": "Value",
                                    "docs::numeric_type": "float"
                                  },
                                  "description": "The value of the counter.",
                                  "maximum": 9007199254740991,
                                  "minimum": -9007199254740991,
                                  "type": "number"
                                }
                              },
                              "required": [
                                "value"
                              ],
                              "type": "object",
                              "unevaluatedProperties": false
                            }
                          },
                          "required": [
                            "counter"
                          ],
                          "type": "object"
                        },
                        {
                          "_metadata": {
                            "docs::human_name": "Gauge",
                            "logical_name": "Gauge"
                          },
                          "description": "A single numerical value that can arbitrarily go up and down.",
                          "properties": {
                            "gauge": {
                              "_metadata": {
                                "docs::human_name": "Gauge"
                              },
                              "properties": {
                                "value": {
                                  "_metadata": {
                                    "docs::human_name": "Value",
                                    "docs::numeric_type": "float"
                                  },
                                  "description": "The value of the gauge.",
                                  "maximum": 9007199254740991,
                                  "minimum": -9007199254740991,
                                  "type": "number"
                                }
                              },
                              "required": [
                                "value"
                              ],
                              "type": "object",
                              "unevaluatedProperties": false
                            }
                          },
                          "required": [
                            "gauge"
                          ],
                          "type": "object"
                        },
                        {
                          "_metadata": {
                            "docs::human_name": "Set",
                            "logical_name": "Set"
                          },
                          "description": "A set of (unordered) unique values for a key.",
                          "properties": {
                            "set": {
                              "_metadata": {
                                "docs::human_name": "Set"
                              },
                              "properties": {
                                "values": {
                                  "_metadata": {
                                    "docs::human_name": "Values"
                                  },
                                  "description": "The values in the set.",
                                  "items": {
                                    "type": "string"
                                  },
                                  "type": "array",
                                  "uniqueItems": true
                                }
                              },
                              "required": [
                                "values"
                              ],
                              "type": "object",
                              "unevaluatedProperties": false
                            }
                          },
                          "required": [
                            "set"
                          ],
                          "type": "object"
                        },
                        {
                          "_metadata": {
                            "docs::human_name": "Distribution",
                            "logical_name": "Distribution"
                          },
                          "description": "A set of observations without any aggregation or sampling.",
                          "properties": {
                            "distribution": {
                              "_metadata": {
                                "docs::human_name": "Distribution"
                              },
                              "properties": {
                                "samples": {
                                  "_metadata": {
                                    "docs::human_name": "Samples"
                                  },
                                  "description": "The observed values within this distribution.",
                                  "items": {
                                    "description": "A single observation.",
                                    "properties": {
                                      "rate": {
                                        "_metadata": {
                                          "docs::human_name": "Rate",
                                          "docs::numeric_type": "uint"
                                        },
                                        "description": "The rate at which the value was observed.",
                                        "maximum": 4294967295,
                                        "minimum": 0,
                                        "type": "integer"
                                      },
                                      "value": {
                                        "_metadata": {
                                          "docs::human_name": "Value",
                                          "docs::numeric_type": "float"
                                        },
                                        "description": "The value of the observation.",
                                        "maximum": 9007199254740991,
                                        "minimum": -9007199254740991,
                                        "type": "number"
                                      }
                                    },
                                    "required": [
                                      "rate",
                                      "value"
                                    ],
                                    "type": "object",
                                    "unevaluatedProperties": false
                                  },
                                  "type": "array"
                                },
                                "statistic": {
                                  "_metadata": {
                                    "docs::enum_tagging": "external",
                                    "docs::human_name": "Statistic"
                                  },
                                  "description": "The type of statistics to derive for this distribution.",
                                  "oneOf": [
                                    {
                                      "_metadata": {
                                        "docs::human_name": "Histogram",
                                        "logical_name": "Histogram"
                                      },
                                      "const": "histogram",
                                      "description": "A histogram representation."
                                    },
                                    {
                                      "_metadata": {
                                        "docs::human_name": "Summary",
                                        "logical_name": "Summary"
                                      },
                                      "const": "summary",
                                      "description": "Corresponds to Datadog's Distribution Metric\n<https://docs.datadoghq.com/developers/metrics/types/?tab=distribution#definition>"
                                    }
                                  ],
                                  "unevaluatedProperties": false
                                }
                              },
                              "required": [
                                "samples",
                                "statistic"
                              ],
                              "type": "object",
                              "unevaluatedProperties": false
                            }
                          },
                          "required": [
                            "distribution"
                          ],
                          "type": "object"
                        },
                        {
                          "_metadata": {
                            "docs::human_name": "Aggregated Histogram",
                            "logical_name": "AggregatedHistogram"
                          },
                          "description": "It also contains the total count of all observations and their sum to allow calculating the mean.",
                          "properties": {
                            "aggregated_histogram": {
                              "_metadata": {
                                "docs::human_name": "Aggregated Histogram"
                              },
                              "properties": {
                                "buckets": {
                                  "_metadata": {
                                    "docs::human_name": "Buckets"
                                  },
                                  "description": "The buckets within this histogram.",
                                  "items": {
                                    "description": "Histogram buckets represent the `count` of observations where the value of the observations does\nnot exceed the specified `upper_limit`.",
                                    "properties": {
                                      "count": {
                                        "_metadata": {
                                          "docs::human_name": "Count",
                                          "docs::numeric_type": "uint"
                                        },
                                        "description": "The number of values tracked in this bucket.",
                                        "maximum": 9007199254740991,
                                        "minimum": 0,
                                        "type": "integer"
                                      },
                                      "upper_limit": {
                                        "_metadata": {
                                          "docs::human_name": "Upper Limit",
                                          "docs::numeric_type": "float"
                                        },
                                        "description": "The upper limit of values in the bucket.",
                                        "maximum": 9007199254740991,
                                        "minimum": -9007199254740991,
                                        "type": "number"
                                      }
                                    },
                                    "required": [
                                      "count",
                                      "upper_limit"
                                    ],
                                    "title": "A histogram bucket.",
                                    "type": "object",
                                    "unevaluatedProperties": false
                                  },
                                  "title": "A histogram bucket.",
                                  "type": "array"
                                },
                                "count": {
                                  "_metadata": {
                                    "docs::human_name": "Count",
                                    "docs::numeric_type": "uint"
                                  },
                                  "description": "The total number of observations contained within this histogram.",
                                  "maximum": 9007199254740991,
                                  "minimum": 0,
                                  "type": "integer"
                                },
                                "sum": {
                                  "_metadata": {
                                    "docs::human_name": "Sum",
                                    "docs::numeric_type": "float"
                                  },
                                  "description": "The sum of all observations contained within this histogram.",
                                  "maximum": 9007199254740991,
                                  "minimum": -9007199254740991,
                                  "type": "number"
                                }
                              },
                              "required": [
                                "buckets",
                                "count",
                                "sum"
                              ],
                              "type": "object",
                              "unevaluatedProperties": false
                            }
                          },
                          "required": [
                            "aggregated_histogram"
                          ],
                          "title": "A set of observations which are counted into buckets.",
                          "type": "object"
                        },
                        {
                          "_metadata": {
                            "docs::human_name": "Aggregated Summary",
                            "logical_name": "AggregatedSummary"
                          },
                          "description": "Each quantile contains the upper value of the quantile (0 <= φ <= 1). It also contains the total count of all\nobservations and their sum to allow calculating the mean.",
                          "properties": {
                            "aggregated_summary": {
                              "_metadata": {
                                "docs::human_name": "Aggregated Summary"
                              },
                              "properties": {
                                "count": {
                                  "_metadata": {
                                    "docs::human_name": "Count",
                                    "docs::numeric_type": "uint"
                                  },
                                  "description": "The total number of observations contained within this summary.",
                                  "maximum": 9007199254740991,
                                  "minimum": 0,
                                  "type": "integer"
                                },
                                "quantiles": {
                                  "_metadata": {
                                    "docs::human_name": "Quantiles"
                                  },
                                  "description": "The quantiles measured from this summary.",
                                  "items": {
                                    "description": "Quantiles themselves are \"cut points dividing the range of a probability distribution into\ncontinuous intervals with equal probabilities\". [[1][quantiles_wikipedia]].\n\nWe use quantiles to measure the value along these probability distributions for representing\nclient-side aggregations of distributions, which represent a collection of observations over a\nspecific time window.\n\nIn general, we typically use the term \"quantile\" to represent the concept of _percentiles_,\nwhich deal with whole integers -- 0, 1, 2, .., 99, 100 -- even though quantiles are\nfloating-point numbers and can represent higher-precision cut points, such as 0.9999, or the\n99.99th percentile.\n\n[quantiles_wikipedia]: https://en.wikipedia.org/wiki/Quantile",
                                    "properties": {
                                      "quantile": {
                                        "_metadata": {
                                          "docs::human_name": "Quantile",
                                          "docs::numeric_type": "float"
                                        },
                                        "description": "This value must be between 0.0 and 1.0, inclusive.",
                                        "maximum": 9007199254740991,
                                        "minimum": -9007199254740991,
                                        "title": "The value of the quantile.",
                                        "type": "number"
                                      },
                                      "value": {
                                        "_metadata": {
                                          "docs::human_name": "Value",
                                          "docs::numeric_type": "float"
                                        },
                                        "description": "The estimated value of the given quantile within the probability distribution.",
                                        "maximum": 9007199254740991,
                                        "minimum": -9007199254740991,
                                        "type": "number"
                                      }
                                    },
                                    "required": [
                                      "quantile",
                                      "value"
                                    ],
                                    "title": "A single quantile observation.",
                                    "type": "object",
                                    "unevaluatedProperties": false
                                  },
                                  "title": "A single quantile observation.",
                                  "type": "array"
                                },
                                "sum": {
                                  "_metadata": {
                                    "docs::human_name": "Sum",
                                    "docs::numeric_type": "float"
                                  },
                                  "description": "The sum of all observations contained within this histogram.",
                                  "maximum": 9007199254740991,
                                  "minimum": -9007199254740991,
                                  "type": "number"
                                }
                              },
                              "required": [
                                "count",
                                "quantiles",
                                "sum"
                              ],
                              "type": "object",
                              "unevaluatedProperties": false
                            }
                          },
                          "required": [
                            "aggregated_summary"
                          ],
                          "title": "A set of observations which are represented by quantiles.",
                          "type": "object"
                        },
                        {
                          "_metadata": {
                            "docs::human_name": "Sketch",
                            "logical_name": "Sketch"
                          },
                          "description": "Sketches represent the data in a way that queries over it have bounded error guarantees without needing to hold\nevery single sample in memory. They are also, typically, able to be merged with other sketches of the same type\nsuch that client-side _and_ server-side aggregation can be accomplished without loss of accuracy in the queries.",
                          "properties": {
                            "sketch": {
                              "_metadata": {
                                "docs::human_name": "Sketch"
                              },
                              "properties": {
                                "sketch": {
                                  "_metadata": {
                                    "docs::enum_tagging": "external",
                                    "docs::human_name": "Sketch"
                                  },
                                  "description": "A generalized metrics sketch.",
                                  "oneOf": [
                                    {
                                      "_metadata": {
                                        "docs::human_name": "Agent Dd Sketch",
                                        "logical_name": "AgentDDSketch"
                                      },
                                      "description": "While DDSketch has open-source implementations based on the white paper, the version used in\nthe Datadog Agent itself is subtly different. This version is suitable for sending directly\nto Datadog's sketch ingest endpoint.\n\n[ddsketch]: https://www.vldb.org/pvldb/vol12/p2195-masson.pdf\n[ddagent]: https://github.com/DataDog/datadog-agent",
                                      "properties": {
                                        "AgentDDSketch": {
                                          "_metadata": {
                                            "docs::human_name": "Agent Dd Sketch"
                                          },
                                          "description": "This implementation is subtly different from the open-source implementations of `DDSketch`, as\nDatadog made some slight tweaks to configuration values and in-memory layout to optimize it for\ninsertion performance within the agent.\n\nWe've mimicked the agent version of `DDSketch` here in order to support a future where we can\ntake sketches shipped by the agent, handle them internally, merge them, and so on, without any\nloss of accuracy, eventually forwarding them to Datadog ourselves.\n\nAs such, this implementation is constrained in the same ways: the configuration parameters\ncannot be changed, the collapsing strategy is fixed, and we support a limited number of methods\nfor inserting into the sketch.\n\nImportantly, we have a special function, again taken from the agent version, to allow us to\ninterpolate histograms, specifically our own aggregated histograms, into a sketch so that we can\nemit useful default quantiles, rather than having to ship the buckets -- upper bound and count\n-- to a downstream system that might have no native way to do the same thing, basically\nproviding no value as they have no way to render useful data from them.\n\n[ddsketch]: https://www.vldb.org/pvldb/vol12/p2195-masson.pdf\n[ddagent]: https://github.com/DataDog/datadog-agent",
                                          "properties": {
                                            "avg": {
                                              "_metadata": {
                                                "docs::human_name": "Avg",
                                                "docs::numeric_type": "float"
                                              },
                                              "description": "The average value of all observations within the sketch.",
                                              "maximum": 9007199254740991,
                                              "minimum": -9007199254740991,
                                              "type": "number"
                                            },
                                            "bins": {
                                              "_metadata": {
                                                "docs::human_name": "Bins"
                                              },
                                              "description": "The bins within the sketch.",
                                              "properties": {
                                                "k": {
                                                  "_metadata": {
                                                    "docs::human_name": "K",
                                                    "docs::numeric_type": "int"
                                                  },
                                                  "description": "The bin keys.",
                                                  "items": {
                                                    "_metadata": {
                                                      "docs::numeric_type": "int"
                                                    },
                                                    "maximum": 32767,
                                                    "minimum": -32768,
                                                    "type": "integer"
                                                  },
                                                  "type": "array"
                                                },
                                                "n": {
                                                  "_metadata": {
                                                    "docs::human_name": "N",
                                                    "docs::numeric_type": "uint"
                                                  },
                                                  "description": "The bin counts.",
                                                  "items": {
                                                    "_metadata": {
                                                      "docs::numeric_type": "uint"
                                                    },
                                                    "maximum": 65535,
                                                    "minimum": 0,
                                                    "type": "integer"
                                                  },
                                                  "type": "array"
                                                }
                                              },
                                              "required": [
                                                "k",
                                                "n"
                                              ],
                                              "title": "A split representation of sketch bins.",
                                              "type": "object",
                                              "unevaluatedProperties": false
                                            },
                                            "count": {
                                              "_metadata": {
                                                "docs::human_name": "Count",
                                                "docs::numeric_type": "uint"
                                              },
                                              "description": "The number of observations within the sketch.",
                                              "maximum": 4294967295,
                                              "minimum": 0,
                                              "type": "integer"
                                            },
                                            "max": {
                                              "_metadata": {
                                                "docs::human_name": "Max",
                                                "docs::numeric_type": "float"
                                              },
                                              "description": "The maximum value of all observations within the sketch.",
                                              "maximum": 9007199254740991,
                                              "minimum": -9007199254740991,
                                              "type": "number"
                                            },
                                            "min": {
                                              "_metadata": {
                                                "docs::human_name": "Min",
                                                "docs::numeric_type": "float"
                                              },
                                              "description": "The minimum value of all observations within the sketch.",
                                              "maximum": 9007199254740991,
                                              "minimum": -9007199254740991,
                                              "type": "number"
                                            },
                                            "sum": {
                                              "_metadata": {
                                                "docs::human_name": "Sum",
                                                "docs::numeric_type": "float"
                                              },
                                              "description": "The sum of all observations within the sketch.",
                                              "maximum": 9007199254740991,
                                              "minimum": -9007199254740991,
                                              "type": "number"
                                            }
                                          },
                                          "required": [
                                            "avg",
                                            "bins",
                                            "count",
                                            "max",
                                            "min",
                                            "sum"
                                          ],
                                          "title": "[DDSketch][ddsketch] implementation based on the [Datadog Agent][ddagent].",
                                          "type": "object",
                                          "unevaluatedProperties": false
                                        }
                                      },
                                      "required": [
                                        "AgentDDSketch"
                                      ],
                                      "title": "[DDSketch][ddsketch] implementation based on the [Datadog Agent][ddagent].",
                                      "type": "object"
                                    }
                                  ],
                                  "unevaluatedProperties": false
                                }
                              },
                              "required": [
                                "sketch"
                              ],
                              "type": "object",
                              "unevaluatedProperties": false
                            }
                          },
                          "required": [
                            "sketch"
                          ],
                          "title": "A data structure that can answer questions about the cumulative distribution of the contained samples in\nspace-efficient way.",
                          "type": "object"
                        }
                      ]
                    }
                  ],
                  "description": "Metric data."
                }
              ],
              "description": "A metric."
            }
          ],
          "title": "The metric to use as an input event.",
          "unevaluatedProperties": false
        },
        "type": {
          "_metadata": {
            "docs::human_name": "Type"
          },
          "default": "raw",
          "description": "Can be either `raw`, `log`, or `metric.",
          "title": "The type of the input event.",
          "type": "string"
        },
        "value": {
          "_metadata": {
            "docs::human_name": "Value",
            "docs::optional": true
          },
          "description": "Use this only when the input event should be a raw event (i.e. unprocessed/undecoded log\nevent) and when the input type is set to `raw`.",
          "title": "The raw string value to use as the input event.",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "insert_at"
      ],
      "title": "A unit test input.",
      "type": "object"
    },
    "vector::config::id::Inputs<alloc::string::String>": {
      "_metadata": {
        "docs::examples": [
          "my-source-or-transform-id",
          "prefix-*"
        ]
      },
      "description": "Wildcards (`*`) are supported.\n\nSee [configuration][configuration] for more info.\n\n[sources]: https://vector.dev/docs/reference/configuration/sources/\n[transforms]: https://vector.dev/docs/reference/configuration/transforms/\n[configuration]: https://vector.dev/docs/reference/configuration/",
      "items": {
        "type": "string"
      },
      "title": "A list of upstream [source][sources] or [transform][transforms] IDs.",
      "type": "array"
    },
    "vector::config::sink::SinkOuter<alloc::string::String>": {
      "_metadata": {
        "docs::component_base_type": "sink"
      },
      "allOf": [
        {
          "properties": {
            "buffer": {
              "_metadata": {
                "docs::enum_tagging": "untagged",
                "docs::human_name": "Buffer"
              },
              "default": {
                "max_events": 500,
                "type": "memory",
                "when_full": "block"
              },
              "description": "More information about the individual buffer types, and buffer behavior, can be found in the\n[Buffering Model][buffering_model] section.\n\n[buffering_model]: /docs/about/under-the-hood/architecture/buffering-model/",
              "oneOf": [
                {
                  "_metadata": {
                    "docs::enum_tag_description": "The type of buffer to use.",
                    "docs::enum_tag_field": "type",
                    "docs::enum_tagging": "internal",
                    "docs::human_name": "Single",
                    "logical_name": "Single"
                  },
                  "description": "A single stage buffer topology.",
                  "oneOf": [
                    {
                      "_metadata": {
                        "docs::human_name": "Memory",
                        "logical_name": "Memory"
                      },
                      "description": "This is more performant, but less durable. Data will be lost if Vector is restarted\nforcefully or crashes.",
                      "properties": {
                        "max_events": {
                          "_metadata": {
                            "docs::human_name": "Max Events",
                            "docs::numeric_type": "uint"
                          },
                          "default": 500,
                          "description": "The maximum number of events allowed in the buffer.",
                          "maximum": 9007199254740991,
                          "minimum": 1,
                          "type": "integer"
                        },
                        "type": {
                          "_metadata": {
                            "docs::human_name": "Type"
                          },
                          "const": "memory",
                          "description": "This is more performant, but less durable. Data will be lost if Vector is restarted\nforcefully or crashes.",
                          "title": "Events are buffered in memory."
                        },
                        "when_full": {
                          "_metadata": {
                            "docs::enum_tagging": "external",
                            "docs::human_name": "When Full"
                          },
                          "default": "block",
                          "description": "Event handling behavior when a buffer is full.",
                          "oneOf": [
                            {
                              "_metadata": {
                                "docs::human_name": "Block",
                                "logical_name": "Block"
                              },
                              "const": "block",
                              "description": "This applies backpressure up the topology, signalling that sources should slow down\nthe acceptance/consumption of events. This means that while no data is lost, data will pile\nup at the edge.",
                              "title": "Wait for free space in the buffer."
                            },
                            {
                              "_metadata": {
                                "docs::human_name": "Drop Newest",
                                "logical_name": "DropNewest"
                              },
                              "const": "drop_newest",
                              "description": "The event will be intentionally dropped. This mode is typically used when performance is the\nhighest priority, and it is preferable to temporarily lose events rather than cause a\nslowdown in the acceptance/consumption of events.",
                              "title": "Drops the event instead of waiting for free space in buffer."
                            },
                            {
                              "_metadata": {
                                "docs::hidden": true,
                                "docs::human_name": "Overflow",
                                "logical_name": "Overflow"
                              },
                              "const": "overflow",
                              "description": "If the current buffer stage is full, attempt to send this event to the next buffer stage.\nThat stage may also be configured overflow, and so on, but ultimately the last stage in a\nbuffer topology must use one of the other handling behaviors. This means that next stage may\npotentially be able to buffer the event, but it may also block or drop the event.\n\nThis mode can only be used when two or more buffer stages are configured.",
                              "title": "Overflows to the next stage in the buffer topology."
                            }
                          ],
                          "unevaluatedProperties": false
                        }
                      },
                      "required": [
                        "type"
                      ],
                      "title": "Events are buffered in memory.",
                      "type": "object"
                    },
                    {
                      "_metadata": {
                        "docs::human_name": "Disk V2",
                        "logical_name": "DiskV2"
                      },
                      "description": "This is less performant, but more durable. Data that has been synchronized to disk will not\nbe lost if Vector is restarted forcefully or crashes.\n\nData is synchronized to disk every 500ms.",
                      "properties": {
                        "max_size": {
                          "_metadata": {
                            "docs::human_name": "Max Size",
                            "docs::numeric_type": "uint",
                            "docs::type_unit": "bytes"
                          },
                          "description": "Must be at least ~256 megabytes (268435488 bytes).",
                          "maximum": 9007199254740991,
                          "minimum": 268435488,
                          "title": "The maximum size of the buffer on disk.",
                          "type": "integer"
                        },
                        "type": {
                          "_metadata": {
                            "docs::human_name": "Type"
                          },
                          "const": "disk",
                          "description": "This is less performant, but more durable. Data that has been synchronized to disk will not\nbe lost if Vector is restarted forcefully or crashes.\n\nData is synchronized to disk every 500ms.",
                          "title": "Events are buffered on disk."
                        },
                        "when_full": {
                          "_metadata": {
                            "docs::enum_tagging": "external",
                            "docs::human_name": "When Full"
                          },
                          "default": "block",
                          "description": "Event handling behavior when a buffer is full.",
                          "oneOf": [
                            {
                              "_metadata": {
                                "docs::human_name": "Block",
                                "logical_name": "Block"
                              },
                              "const": "block",
                              "description": "This applies backpressure up the topology, signalling that sources should slow down\nthe acceptance/consumption of events. This means that while no data is lost, data will pile\nup at the edge.",
                              "title": "Wait for free space in the buffer."
                            },
                            {
                              "_metadata": {
                                "docs::human_name": "Drop Newest",
                                "logical_name": "DropNewest"
                              },
                              "const": "drop_newest",
                              "description": "The event will be intentionally dropped. This mode is typically used when performance is the\nhighest priority, and it is preferable to temporarily lose events rather than cause a\nslowdown in the acceptance/consumption of events.",
                              "title": "Drops the event instead of waiting for free space in buffer."
                            },
                            {
                              "_metadata": {
                                "docs::hidden": true,
                                "docs::human_name": "Overflow",
                                "logical_name": "Overflow"
                              },
                              "const": "overflow",
                              "description": "If the current buffer stage is full, attempt to send this event to the next buffer stage.\nThat stage may also be configured overflow, and so on, but ultimately the last stage in a\nbuffer topology must use one of the other handling behaviors. This means that next stage may\npotentially be able to buffer the event, but it may also block or drop the event.\n\nThis mode can only be used when two or more buffer stages are configured.",
                              "title": "Overflows to the next stage in the buffer topology."
                            }
                          ],
                          "unevaluatedProperties": false
                        }
                      },
                      "required": [
                        "max_size",
                        "type"
                      ],
                      "title": "Events are buffered on disk.",
                      "type": "object"
                    }
                  ]
                },
                {
                  "_metadata": {
                    "docs::enum_tag_description": "The type of buffer to use.",
                    "docs::enum_tag_field": "type",
                    "docs::enum_tagging": "internal",
                    "docs::human_name": "Chained",
                    "logical_name": "Chained"
                  },
                  "description": "A chained buffer topology.",
                  "items": {
                    "_metadata": {
                      "docs::enum_tag_description": "The type of buffer to use.",
                      "docs::enum_tag_field": "type",
                      "docs::enum_tagging": "internal"
                    },
                    "description": "A specific type of buffer stage.",
                    "oneOf": [
                      {
                        "_metadata": {
                          "docs::human_name": "Memory",
                          "logical_name": "Memory"
                        },
                        "description": "This is more performant, but less durable. Data will be lost if Vector is restarted\nforcefully or crashes.",
                        "properties": {
                          "max_events": {
                            "_metadata": {
                              "docs::human_name": "Max Events",
                              "docs::numeric_type": "uint"
                            },
                            "default": 500,
                            "description": "The maximum number of events allowed in the buffer.",
                            "maximum": 9007199254740991,
                            "minimum": 1,
                            "type": "integer"
                          },
                          "type": {
                            "_metadata": {
                              "docs::human_name": "Type"
                            },
                            "const": "memory",
                            "description": "This is more performant, but less durable. Data will be lost if Vector is restarted\nforcefully or crashes.",
                            "title": "Events are buffered in memory."
                          },
                          "when_full": {
                            "_metadata": {
                              "docs::enum_tagging": "external",
                              "docs::human_name": "When Full"
                            },
                            "default": "block",
                            "description": "Event handling behavior when a buffer is full.",
                            "oneOf": [
                              {
                                "_metadata": {
                                  "docs::human_name": "Block",
                                  "logical_name": "Block"
                                },
                                "const": "block",
                                "description": "This applies backpressure up the topology, signalling that sources should slow down\nthe acceptance/consumption of events. This means that while no data is lost, data will pile\nup at the edge.",
                                "title": "Wait for free space in the buffer."
                              },
                              {
                                "_metadata": {
                                  "docs::human_name": "Drop Newest",
                                  "logical_name": "DropNewest"
                                },
                                "const": "drop_newest",
                                "description": "The event will be intentionally dropped. This mode is typically used when performance is the\nhighest priority, and it is preferable to temporarily lose events rather than cause a\nslowdown in the acceptance/consumption of events.",
                                "title": "Drops the event instead of waiting for free space in buffer."
                              },
                              {
                                "_metadata": {
                                  "docs::hidden": true,
                                  "docs::human_name": "Overflow",
                                  "logical_name": "Overflow"
                                },
                                "const": "overflow",
                                "description": "If the current buffer stage is full, attempt to send this event to the next buffer stage.\nThat stage may also be configured overflow, and so on, but ultimately the last stage in a\nbuffer topology must use one of the other handling behaviors. This means that next stage may\npotentially be able to buffer the event, but it may also block or drop the event.\n\nThis mode can only be used when two or more buffer stages are configured.",
                                "title": "Overflows to the next stage in the buffer topology."
                              }
                            ],
                            "unevaluatedProperties": false
                          }
                        },
                        "required": [
                          "type"
                        ],
                        "title": "Events are buffered in memory.",
                        "type": "object"
                      },
                      {
                        "_metadata": {
                          "docs::human_name": "Disk V2",
                          "logical_name": "DiskV2"
                        },
                        "description": "This is less performant, but more durable. Data that has been synchronized to disk will not\nbe lost if Vector is restarted forcefully or crashes.\n\nData is synchronized to disk every 500ms.",
                        "properties": {
                          "max_size": {
                            "_metadata": {
                              "docs::human_name": "Max Size",
                              "docs::numeric_type": "uint",
                              "docs::type_unit": "bytes"
                            },
                            "description": "Must be at least ~256 megabytes (268435488 bytes).",
                            "maximum": 9007199254740991,
                            "minimum": 268435488,
                            "title": "The maximum size of the buffer on disk.",
                            "type": "integer"
                          },
                          "type": {
                            "_metadata": {
                              "docs::human_name": "Type"
                            },
                            "const": "disk",
                            "description": "This is less performant, but more durable. Data that has been synchronized to disk will not\nbe lost if Vector is restarted forcefully or crashes.\n\nData is synchronized to disk every 500ms.",
                            "title": "Events are buffered on disk."
                          },
                          "when_full": {
                            "_metadata": {
                              "docs::enum_tagging": "external",
                              "docs::human_name": "When Full"
                            },
                            "default": "block",
                            "description": "Event handling behavior when a buffer is full.",
                            "oneOf": [
                              {
                                "_metadata": {
                                  "docs::human_name": "Block",
                                  "logical_name": "Block"
                                },
                                "const": "block",
                                "description": "This applies backpressure up the topology, signalling that sources should slow down\nthe acceptance/consumption of events. This means that while no data is lost, data will pile\nup at the edge.",
                                "title": "Wait for free space in the buffer."
                              },
                              {
                                "_metadata": {
                                  "docs::human_name": "Drop Newest",
                                  "logical_name": "DropNewest"
                                },
                                "const": "drop_newest",
                                "description": "The event will be intentionally dropped. This mode is typically used when performance is the\nhighest priority, and it is preferable to temporarily lose events rather than cause a\nslowdown in the acceptance/consumption of events.",
                                "title": "Drops the event instead of waiting for free space in buffer."
                              },
                              {
                                "_metadata": {
                                  "docs::hidden": true,
                                  "docs::human_name": "Overflow",
                                  "logical_name": "Overflow"
                                },
                                "const": "overflow",
                                "description": "If the current buffer stage is full, attempt to send this event to the next buffer stage.\nThat stage may also be configured overflow, and so on, but ultimately the last stage in a\nbuffer topology must use one of the other handling behaviors. This means that next stage may\npotentially be able to buffer the event, but it may also block or drop the event.\n\nThis mode can only be used when two or more buffer stages are configured.",
                                "title": "Overflows to the next stage in the buffer topology."
                              }
                            ],
                            "unevaluatedProperties": false
                          }
                        },
                        "required": [
                          "max_size",
                          "type"
                        ],
                        "title": "Events are buffered on disk.",
                        "type": "object"
                      }
                    ],
                    "unevaluatedProperties": false
                  },
                  "type": "array"
                }
              ],
              "title": "Configures the buffering behavior for this sink.",
              "unevaluatedProperties": false
            },
            "healthcheck": {
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Healthcheck"
              },
              "default": {
                "enabled": true,
                "uri": null
              },
              "description": "Healthcheck configuration.",
              "properties": {
                "enabled": {
                  "_metadata": {
                    "docs::human_name": "Enabled"
                  },
                  "description": "Whether or not to check the health of the sink when Vector starts up.",
                  "type": "boolean"
                },
                "uri": {
                  "$ref": "#/definitions/core::option::Option<vector::sinks::util::uri::UriSerde>",
                  "_metadata": {
                    "docs::human_name": "URI"
                  },
                  "description": "This must be a valid URI, which requires at least the scheme and host. All other\ncomponents -- port, path, etc -- are allowed as well.",
                  "format": "uri",
                  "title": "The full URI to make HTTP healthcheck requests to."
                }
              },
              "type": "object",
              "unevaluatedProperties": false
            },
            "healthcheck_uri": {
              "$ref": "#/definitions/core::option::Option<vector::sinks::util::uri::UriSerde>",
              "_metadata": {
                "docs::hidden": true,
                "docs::human_name": "Healthcheck URI"
              },
              "deprecated": true,
              "description": "This must be a valid URI, which requires at least the scheme and host. All other\ncomponents -- port, path, etc -- are allowed as well.",
              "format": "uri",
              "title": "The full URI to make HTTP healthcheck requests to."
            },
            "inputs": {
              "$ref": "#/definitions/vector::config::id::Inputs<alloc::string::String>",
              "_metadata": {
                "docs::human_name": "Inputs"
              },
              "description": "Wildcards (`*`) are supported.\n\nSee [configuration][configuration] for more info.\n\n[sources]: https://vector.dev/docs/reference/configuration/sources/\n[transforms]: https://vector.dev/docs/reference/configuration/transforms/\n[configuration]: https://vector.dev/docs/reference/configuration/",
              "title": "A list of upstream [source][sources] or [transform][transforms] IDs."
            },
            "proxy": {
              "$ref": "#/definitions/vector_core::config::proxy::ProxyConfig",
              "_metadata": {
                "docs::human_name": "Proxy"
              },
              "default": {
                "enabled": true,
                "http": null,
                "https": null
              },
              "description": "Configure to proxy traffic through an HTTP(S) proxy when making external requests.\n\nSimilar to common proxy configuration convention, you can set different proxies\nto use based on the type of traffic being proxied, as well as set specific hosts that\nshould not be proxied.",
              "title": "Proxy configuration."
            }
          },
          "required": [
            "inputs"
          ],
          "type": "object"
        },
        {
          "$ref": "#/definitions/vector::sinks::Sinks",
          "_metadata": {
            "docs::hidden": true
          },
          "description": "Configurable sinks in Vector."
        }
      ],
      "description": "Fully resolved sink component.",
      "unevaluatedProperties": false
    },
    "vector::config::source::SourceOuter": {
      "_metadata": {
        "docs::component_base_type": "source"
      },
      "allOf": [
        {
          "properties": {
            "proxy": {
              "$ref": "#/definitions/vector_core::config::proxy::ProxyConfig",
              "_metadata": {
                "docs::human_name": "Proxy"
              },
              "default": {
                "enabled": true,
                "http": null,
                "https": null
              },
              "description": "Configure to proxy traffic through an HTTP(S) proxy when making external requests.\n\nSimilar to common proxy configuration convention, you can set different proxies\nto use based on the type of traffic being proxied, as well as set specific hosts that\nshould not be proxied.",
              "title": "Proxy configuration."
            }
          },
          "type": "object"
        },
        {
          "$ref": "#/definitions/vector::sources::Sources",
          "_metadata": {
            "docs::hidden": true
          },
          "description": "Configurable sources in Vector."
        }
      ],
      "description": "Fully resolved source component.",
      "unevaluatedProperties": false
    },
    "vector::config::transform::TransformOuter<alloc::string::String>": {
      "_metadata": {
        "docs::component_base_type": "transform"
      },
      "allOf": [
        {
          "properties": {
            "inputs": {
              "$ref": "#/definitions/vector::config::id::Inputs<alloc::string::String>",
              "_metadata": {
                "docs::human_name": "Inputs"
              },
              "description": "Wildcards (`*`) are supported.\n\nSee [configuration][configuration] for more info.\n\n[sources]: https://vector.dev/docs/reference/configuration/sources/\n[transforms]: https://vector.dev/docs/reference/configuration/transforms/\n[configuration]: https://vector.dev/docs/reference/configuration/",
              "title": "A list of upstream [source][sources] or [transform][transforms] IDs."
            }
          },
          "required": [
            "inputs"
          ],
          "type": "object"
        },
        {
          "$ref": "#/definitions/vector::transforms::Transforms",
          "_metadata": {
            "docs::hidden": true
          },
          "description": "Configurable transforms in Vector."
        }
      ],
      "description": "Fully resolved transform component.",
      "unevaluatedProperties": false
    },
    "vector::config::unit_test::unit_test_components::UnitTestSinkConfig": {
      "_metadata": {
        "docs::component_name": "unit_test",
        "docs::component_type": "sink"
      },
      "description": "Configuration for the `unit_test` sink.",
      "properties": {
        "test_name": {
          "_metadata": {
            "docs::human_name": "Test Name"
          },
          "description": "Name of the test that this sink is being used for.",
          "type": "string"
        },
        "transform_ids": {
          "_metadata": {
            "docs::human_name": "Transform IDs"
          },
          "description": "List of names of the transform/branch associated with this sink.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "test_name",
        "transform_ids"
      ],
      "type": "object"
    },
    "vector::config::unit_test::unit_test_components::UnitTestSourceConfig": {
      "_metadata": {
        "docs::component_name": "unit_test",
        "docs::component_type": "source"
      },
      "description": "Configuration for the `unit_test` source.",
      "type": "object"
    },
    "vector::config::unit_test::unit_test_components::UnitTestStreamSinkConfig": {
      "_metadata": {
        "docs::component_name": "unit_test_stream",
        "docs::component_type": "sink"
      },
      "description": "Configuration for the `unit_test_stream` sink.",
      "type": "object"
    },
    "vector::config::unit_test::unit_test_components::UnitTestStreamSourceConfig": {
      "_metadata": {
        "docs::component_name": "unit_test_stream",
        "docs::component_type": "source"
      },
      "description": "Configuration for the `unit_test_stream` source.",
      "type": "object"
    },
    "vector::enrichment_tables::file::FileConfig": {
      "_metadata": {
        "docs::component_name": "file",
        "docs::component_type": "enrichment_table"
      },
      "description": "Configuration for the `file` enrichment table.",
      "properties": {
        "file": {
          "_metadata": {
            "docs::human_name": "File"
          },
          "description": "File-specific settings.",
          "properties": {
            "encoding": {
              "_metadata": {
                "docs::enum_tag_field": "type",
                "docs::enum_tagging": "internal",
                "docs::human_name": "Encoding"
              },
              "description": "File encoding configuration.",
              "oneOf": [
                {
                  "_metadata": {
                    "docs::human_name": "CSV",
                    "logical_name": "Csv"
                  },
                  "description": "[csv]: https://wikipedia.org/wiki/Comma-separated_values",
                  "properties": {
                    "delimiter": {
                      "_metadata": {
                        "docs::human_name": "Delimiter"
                      },
                      "default": ",",
                      "description": "The delimiter used to separate fields in each row of the CSV file.",
                      "maxLength": 1,
                      "minLength": 1,
                      "type": "string"
                    },
                    "include_headers": {
                      "_metadata": {
                        "docs::human_name": "Include Headers"
                      },
                      "default": true,
                      "description": "When set to `true`, the first row of the CSV file will be read as the header row, and\nthe values will be used for the names of each column. This is the default behavior.\n\nWhen set to `false`, columns are referred to by their numerical index.",
                      "title": "Whether or not the file contains column headers.",
                      "type": "boolean"
                    },
                    "type": {
                      "_metadata": {
                        "docs::human_name": "Type"
                      },
                      "const": "csv",
                      "description": "[csv]: https://wikipedia.org/wiki/Comma-separated_values",
                      "title": "Decodes the file as a [CSV][csv] (comma-separated values) file."
                    }
                  },
                  "required": [
                    "type"
                  ],
                  "title": "Decodes the file as a [CSV][csv] (comma-separated values) file.",
                  "type": "object"
                }
              ],
              "unevaluatedProperties": false
            },
            "path": {
              "$ref": "#/definitions/stdlib::PathBuf",
              "_metadata": {
                "docs::human_name": "Path"
              },
              "description": "Currently, only [CSV][csv] files are supported.\n\n[csv]: https://en.wikipedia.org/wiki/Comma-separated_values",
              "title": "The path of the enrichment table file."
            }
          },
          "required": [
            "encoding",
            "path"
          ],
          "type": "object",
          "unevaluatedProperties": false
        },
        "schema": {
          "_metadata": {
            "docs::human_name": "Schema"
          },
          "additionalProperties": {
            "type": "string"
          },
          "default": {},
          "description": "This is used to coerce log fields from strings into their proper types. The available types are listed in the `Types` list below.\n\nTimestamp coercions need to be prefaced with `timestamp|`, for example `\"timestamp|%F\"`. Timestamp specifiers can use either of the following:\n\n1. One of the built-in-formats listed in the `Timestamp Formats` table below.\n2. The [time format specifiers][chrono_fmt] from Rust’s `chrono` library.\n\n### Types\n\n- **`bool`**\n- **`string`**\n- **`float`**\n- **`integer`**\n- **`date`**\n- **`timestamp`** (see the table below for formats)\n\n### Timestamp Formats\n\n| Format               | Description                                                                      | Example                          |\n|----------------------|----------------------------------------------------------------------------------|----------------------------------|\n| `%F %T`              | `YYYY-MM-DD HH:MM:SS`                                                            | `2020-12-01 02:37:54`            |\n| `%v %T`              | `DD-Mmm-YYYY HH:MM:SS`                                                           | `01-Dec-2020 02:37:54`           |\n| `%FT%T`              | [ISO 8601][iso8601]/[RFC 3339][rfc3339], without time zone                       | `2020-12-01T02:37:54`            |\n| `%FT%TZ`             | [ISO 8601][iso8601]/[RFC 3339][rfc3339], UTC                                     | `2020-12-01T09:37:54Z`           |\n| `%+`                 | [ISO 8601][iso8601]/[RFC 3339][rfc3339], UTC, with time zone                     | `2020-12-01T02:37:54-07:00`      |\n| `%a, %d %b %Y %T`    | [RFC 822][rfc822]/[RFC 2822][rfc2822], without time zone                         | `Tue, 01 Dec 2020 02:37:54`      |\n| `%a %b %e %T %Y`     | [ctime][ctime] format                                                            | `Tue Dec 1 02:37:54 2020`        |\n| `%s`                 | [UNIX timestamp][unix_ts]                                                        | `1606790274`                     |\n| `%a %d %b %T %Y`     | [date][date] command, without time zone                                          | `Tue 01 Dec 02:37:54 2020`       |\n| `%a %d %b %T %Z %Y`  | [date][date] command, with time zone                                             | `Tue 01 Dec 02:37:54 PST 2020`   |\n| `%a %d %b %T %z %Y`  | [date][date] command, with numeric time zone                                     | `Tue 01 Dec 02:37:54 -0700 2020` |\n| `%a %d %b %T %#z %Y` | [date][date] command, with numeric time zone (minutes can be missing or present) | `Tue 01 Dec 02:37:54 -07 2020`   |\n\n[date]: https://man7.org/linux/man-pages/man1/date.1.html\n[ctime]: https://www.cplusplus.com/reference/ctime\n[unix_ts]: https://en.wikipedia.org/wiki/Unix_time\n[rfc822]: https://tools.ietf.org/html/rfc822#section-5\n[rfc2822]: https://tools.ietf.org/html/rfc2822#section-3.3\n[iso8601]: https://en.wikipedia.org/wiki/ISO_8601\n[rfc3339]: https://tools.ietf.org/html/rfc3339\n[chrono_fmt]: https://docs.rs/chrono/latest/chrono/format/strftime/index.html#specifiers",
          "title": "Key/value pairs representing mapped log field names and types.",
          "type": "object"
        }
      },
      "required": [
        "file"
      ],
      "type": "object"
    },
    "vector::enrichment_tables::geoip::GeoipConfig": {
      "_metadata": {
        "docs::component_name": "geoip",
        "docs::component_type": "enrichment_table"
      },
      "description": "Configuration for the `geoip` enrichment table.",
      "properties": {
        "locale": {
          "_metadata": {
            "docs::human_name": "Locale"
          },
          "default": "en",
          "description": "MaxMind includes localized versions of some of the fields within their database, such as\ncountry name. This setting can control which of those localized versions are returned by the\ntransform.\n\nMore information on which portions of the geolocation data are localized, and what languages\nare available, can be found [here][locale_docs].\n\n[locale_docs]: https://support.maxmind.com/hc/en-us/articles/4414877149467-IP-Geolocation-Data#h_01FRRGRYTGZB29ERDBZCX3MR8Q",
          "title": "The locale to use when querying the database.",
          "type": "string"
        },
        "path": {
          "_metadata": {
            "docs::human_name": "Path"
          },
          "description": "Other databases, such as the country database, are not supported.\n\n[geoip2]: https://dev.maxmind.com/geoip/geoip2/downloadable\n[geolite2]: https://dev.maxmind.com/geoip/geoip2/geolite2/#Download_Access",
          "title": "Path to the [MaxMind GeoIP2][geoip2] or [GeoLite2 binary city database file][geolite2]\n(**GeoLite2-City.mmdb**).",
          "type": "string"
        }
      },
      "required": [
        "path"
      ],
      "type": "object"
    },
    "vector::gcp::GcpAuthConfig": {
      "description": "Configuration of the authentication strategy for interacting with GCP services.",
      "properties": {
        "api_key": {
          "$ref": "#/definitions/core::option::Option<vector_common::sensitive_string::SensitiveString>",
          "_metadata": {
            "docs::human_name": "API Key"
          },
          "description": "Either an API key or a path to a service account credentials JSON file can be specified.\n\nIf both are unset, the `GOOGLE_APPLICATION_CREDENTIALS` environment variable is checked for a filename. If no\nfilename is named, an attempt is made to fetch an instance service account for the compute instance the program is\nrunning on. If this is not on a GCE instance, then you must define it with an API key or service account\ncredentials JSON file.\n\n[gcp_api_key]: https://cloud.google.com/docs/authentication/api-keys",
          "title": "An [API key][gcp_api_key]."
        },
        "credentials_path": {
          "_metadata": {
            "docs::human_name": "Credentials Path",
            "docs::optional": true
          },
          "description": "Either an API key or a path to a service account credentials JSON file can be specified.\n\nIf both are unset, the `GOOGLE_APPLICATION_CREDENTIALS` environment variable is checked for a filename. If no\nfilename is named, an attempt is made to fetch an instance service account for the compute instance the program is\nrunning on. If this is not on a GCE instance, then you must define it with an API key or service account\ncredentials JSON file.\n\n[gcp_service_account_credentials]: https://cloud.google.com/docs/authentication/production#manually",
          "title": "Path to a [service account][gcp_service_account_credentials] credentials JSON file.",
          "type": [
            "string",
            "null"
          ]
        },
        "skip_authentication": {
          "_metadata": {
            "docs::hidden": true,
            "docs::human_name": "Skip Authentication"
          },
          "default": false,
          "description": "Skip all authentication handling. For use with integration tests only.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "vector::kafka::KafkaAuthConfig": {
      "description": "Kafka authentication configuration.",
      "properties": {
        "sasl": {
          "_metadata": {
            "docs::human_name": "SASL",
            "docs::optional": true
          },
          "description": "Configuration for SASL authentication when interacting with Kafka.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "description": "Configuration for SASL authentication when interacting with Kafka.",
              "properties": {
                "enabled": {
                  "_metadata": {
                    "docs::human_name": "Enabled",
                    "docs::optional": true
                  },
                  "description": "Only `PLAIN`- and `SCRAM`-based mechanisms are supported when configuring SASL authentication using `sasl.*`. For\nother mechanisms, `librdkafka_options.*` must be used directly to configure other `librdkafka`-specific values.\nIf using `sasl.kerberos.*` as an example, where `*` is `service.name`, `principal`, `kinit.md`, etc., then\n`librdkafka_options.*` as a result becomes `librdkafka_options.sasl.kerberos.service.name`,\n`librdkafka_options.sasl.kerberos.principal`, etc.\n\nSee the [librdkafka documentation](https://github.com/edenhill/librdkafka/blob/master/CONFIGURATION.md) for details.\n\nSASL authentication is not supported on Windows.",
                  "title": "Enables SASL authentication.",
                  "type": [
                    "boolean",
                    "null"
                  ]
                },
                "mechanism": {
                  "_metadata": {
                    "docs::examples": [
                      "SCRAM-SHA-256",
                      "SCRAM-SHA-512"
                    ],
                    "docs::human_name": "Mechanism",
                    "docs::optional": true
                  },
                  "description": "The SASL mechanism to use.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "password": {
                  "$ref": "#/definitions/core::option::Option<vector_common::sensitive_string::SensitiveString>",
                  "_metadata": {
                    "docs::examples": "password",
                    "docs::human_name": "Password"
                  },
                  "description": "The SASL password."
                },
                "username": {
                  "_metadata": {
                    "docs::examples": "username",
                    "docs::human_name": "Username",
                    "docs::optional": true
                  },
                  "description": "The SASL username.",
                  "type": [
                    "string",
                    "null"
                  ]
                }
              },
              "type": "object"
            }
          ],
          "unevaluatedProperties": false
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "TLS"
          }
        }
      },
      "type": "object"
    },
    "vector::providers::http::HttpConfig": {
      "_metadata": {
        "docs::component_name": "http",
        "docs::component_type": "provider"
      },
      "allOf": [
        {
          "properties": {
            "poll_interval_secs": {
              "_metadata": {
                "docs::human_name": "Poll Interval Secs",
                "docs::numeric_type": "uint"
              },
              "description": "How often to poll the provider, in seconds.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "type": "integer"
            },
            "proxy": {
              "$ref": "#/definitions/vector_core::config::proxy::ProxyConfig",
              "_metadata": {
                "docs::human_name": "Proxy"
              },
              "default": {
                "enabled": true,
                "http": null,
                "https": null
              },
              "description": "Configure to proxy traffic through an HTTP(S) proxy when making external requests.\n\nSimilar to common proxy configuration convention, you can set different proxies\nto use based on the type of traffic being proxied, as well as set specific hosts that\nshould not be proxied.",
              "title": "Proxy configuration."
            },
            "request": {
              "_metadata": {
                "docs::human_name": "Request"
              },
              "description": "Request settings.",
              "properties": {
                "headers": {
                  "_metadata": {
                    "docs::human_name": "Headers"
                  },
                  "additionalProperties": {
                    "type": "string"
                  },
                  "default": {},
                  "description": "HTTP headers to add to the request.",
                  "type": "object"
                }
              },
              "type": "object",
              "unevaluatedProperties": false
            },
            "url": {
              "_metadata": {
                "docs::human_name": "URL",
                "docs::optional": true
              },
              "description": "URL for the HTTP provider.",
              "format": "uri",
              "type": [
                "string",
                "null"
              ]
            }
          },
          "type": "object"
        },
        {
          "_metadata": {
            "docs::optional": true
          },
          "description": "TLS configuration.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
            }
          ]
        }
      ],
      "default": {
        "poll_interval_secs": 30,
        "request": {
          "headers": {}
        },
        "url": null
      },
      "description": "Configuration for the `http` provider."
    },
    "vector::secrets::exec::ExecBackend": {
      "_metadata": {
        "docs::component_name": "exec",
        "docs::component_type": "secrets"
      },
      "description": "Configuration for the `exec` secrets backend.",
      "properties": {
        "command": {
          "_metadata": {
            "docs::human_name": "Command"
          },
          "description": "The path to the script or binary must be the first argument.",
          "items": {
            "type": "string"
          },
          "title": "Command arguments to execute.",
          "type": "array"
        },
        "timeout": {
          "_metadata": {
            "docs::human_name": "Timeout",
            "docs::numeric_type": "uint"
          },
          "default": 5,
          "description": "The timeout, in seconds, to wait for the command to complete.",
          "maximum": 9007199254740991,
          "minimum": 0,
          "type": "integer"
        }
      },
      "required": [
        "command"
      ],
      "type": "object"
    },
    "vector::secrets::test::TestBackend": {
      "_metadata": {
        "docs::component_name": "test",
        "docs::component_type": "secrets"
      },
      "description": "Configuration for the `test` secrets backend.",
      "properties": {
        "replacement": {
          "_metadata": {
            "docs::human_name": "Replacement"
          },
          "description": "Fixed value to replace all secrets with.",
          "type": "string"
        }
      },
      "required": [
        "replacement"
      ],
      "type": "object"
    },
    "vector::sinks::Sinks": {
      "_metadata": {
        "docs::enum_tag_field": "type",
        "docs::enum_tagging": "internal"
      },
      "description": "Configurable sinks in Vector.",
      "oneOf": [
        {
          "_metadata": {
            "docs::human_name": "AMQP",
            "logical_name": "AmqpSink"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::amqp::config::AmqpSinkConfig",
              "description": "Supports AMQP version 0.9.1",
              "title": "Configuration for the `amqp` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "amqp",
                  "description": "Send events to AMQP 0.9.1 compatible brokers like RabbitMQ."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Send events to AMQP 0.9.1 compatible brokers like RabbitMQ."
        },
        {
          "_metadata": {
            "docs::human_name": "AppSignal",
            "logical_name": "Appsignal"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::appsignal::config::AppsignalConfig",
              "description": "Configuration for the `appsignal` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "appsignal",
                  "description": "Deliver log and metric event data to AppSignal."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Deliver log and metric event data to AppSignal."
        },
        {
          "_metadata": {
            "docs::human_name": "AWS CloudWatch Logs",
            "logical_name": "CloudwatchLogsSink"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::aws_cloudwatch_logs::config::CloudwatchLogsSinkConfig",
              "description": "Configuration for the `aws_cloudwatch_logs` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "aws_cloudwatch_logs",
                  "description": "Publish log events to AWS CloudWatch Logs."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Publish log events to AWS CloudWatch Logs."
        },
        {
          "_metadata": {
            "docs::human_name": "AWS CloudWatch Metrics",
            "logical_name": "CloudWatchMetricsSink"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::aws_cloudwatch_metrics::CloudWatchMetricsSinkConfig",
              "description": "Configuration for the `aws_cloudwatch_metrics` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "aws_cloudwatch_metrics",
                  "description": "Publish metric events to AWS CloudWatch Metrics."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Publish metric events to AWS CloudWatch Metrics."
        },
        {
          "_metadata": {
            "docs::human_name": "AWS Kinesis Firehose",
            "logical_name": "KinesisFirehoseSink"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::aws_kinesis::firehose::config::KinesisFirehoseSinkConfig",
              "description": "Configuration for the `aws_kinesis_firehose` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "aws_kinesis_firehose",
                  "description": "Publish logs to AWS Kinesis Data Firehose topics."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Publish logs to AWS Kinesis Data Firehose topics."
        },
        {
          "_metadata": {
            "docs::human_name": "AWS Kinesis Streams",
            "logical_name": "KinesisStreamsSink"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::aws_kinesis::streams::config::KinesisStreamsSinkConfig",
              "description": "Configuration for the `aws_kinesis_streams` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "aws_kinesis_streams",
                  "description": "Publish logs to AWS Kinesis Streams topics."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Publish logs to AWS Kinesis Streams topics."
        },
        {
          "_metadata": {
            "docs::human_name": "AWS S3",
            "logical_name": "S3Sink"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::aws_s3::config::S3SinkConfig",
              "description": "Configuration for the `aws_s3` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "aws_s3",
                  "description": "Store observability events in the AWS S3 object storage system."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Store observability events in the AWS S3 object storage system."
        },
        {
          "_metadata": {
            "docs::human_name": "AWS SQS",
            "logical_name": "SqsSink"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::aws_s_s::sqs::config::SqsSinkConfig",
              "description": "Configuration for the `aws_sqs` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "aws_sqs",
                  "description": "Publish observability events to AWS Simple Queue Service topics."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Publish observability events to AWS Simple Queue Service topics."
        },
        {
          "_metadata": {
            "docs::human_name": "Axiom",
            "logical_name": "Axiom"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::axiom::AxiomConfig",
              "description": "Configuration for the `axiom` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "axiom",
                  "description": "Deliver log events to Axiom."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Deliver log events to Axiom."
        },
        {
          "_metadata": {
            "docs::human_name": "Azure Blob",
            "logical_name": "AzureBlobSink"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::azure_blob::config::AzureBlobSinkConfig",
              "description": "Configuration for the `azure_blob` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "azure_blob",
                  "description": "Store your observability data in Azure Blob Storage."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Store your observability data in Azure Blob Storage."
        },
        {
          "_metadata": {
            "docs::human_name": "Azure Monitor Logs",
            "logical_name": "AzureMonitorLogs"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::azure_monitor_logs::config::AzureMonitorLogsConfig",
              "description": "Configuration for the `azure_monitor_logs` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "azure_monitor_logs",
                  "description": "Publish log events to the Azure Monitor Logs service."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Publish log events to the Azure Monitor Logs service."
        },
        {
          "_metadata": {
            "docs::human_name": "Blackhole",
            "logical_name": "Blackhole"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::blackhole::config::BlackholeConfig",
              "description": "Configuration for the `blackhole` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "blackhole",
                  "description": "Send observability events nowhere, which can be useful for debugging purposes."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Send observability events nowhere, which can be useful for debugging purposes."
        },
        {
          "_metadata": {
            "docs::human_name": "ClickHouse",
            "logical_name": "Clickhouse"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::clickhouse::config::ClickhouseConfig",
              "description": "Configuration for the `clickhouse` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "clickhouse",
                  "description": "Deliver log data to a ClickHouse database."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Deliver log data to a ClickHouse database."
        },
        {
          "_metadata": {
            "docs::human_name": "Console",
            "logical_name": "ConsoleSink"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::console::config::ConsoleSinkConfig",
              "description": "Configuration for the `console` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "console",
                  "description": "Display observability events in the console, which can be useful for debugging purposes."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Display observability events in the console, which can be useful for debugging purposes."
        },
        {
          "_metadata": {
            "docs::human_name": "Databend",
            "logical_name": "Databend"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::databend::config::DatabendConfig",
              "description": "Configuration for the `databend` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "databend",
                  "description": "Deliver log data to a Databend database."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Deliver log data to a Databend database."
        },
        {
          "_metadata": {
            "docs::human_name": "Datadog Archives",
            "logical_name": "DatadogArchivesSink"
          },
          "allOf": [
            {
              "$ref": "#/definitions/generate_schema::datadog_archives::DatadogArchivesSinkConfig",
              "description": "Configuration for the `datadog_archives` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "datadog_archives",
                  "description": "Send events to a Datadog Log Archive."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Send events to a Datadog Log Archive."
        },
        {
          "_metadata": {
            "docs::human_name": "Datadog Events",
            "logical_name": "DatadogEvents"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::datadog::events::config::DatadogEventsConfig",
              "description": "Configuration for the `datadog_events` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "datadog_events",
                  "description": "Publish observability events to the Datadog Events API."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Publish observability events to the Datadog Events API."
        },
        {
          "_metadata": {
            "docs::human_name": "Datadog Logs",
            "logical_name": "DatadogLogs"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::datadog::logs::config::DatadogLogsConfig",
              "description": "Configuration for the `datadog_logs` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "datadog_logs",
                  "description": "Publish log events to Datadog."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Publish log events to Datadog."
        },
        {
          "_metadata": {
            "docs::human_name": "Datadog Metrics",
            "logical_name": "DatadogMetrics"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::datadog::metrics::config::DatadogMetricsConfig",
              "description": "Configuration for the `datadog_metrics` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "datadog_metrics",
                  "description": "Publish metric events to Datadog."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Publish metric events to Datadog."
        },
        {
          "_metadata": {
            "docs::human_name": "Datadog Traces",
            "logical_name": "DatadogTraces"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::datadog::traces::config::DatadogTracesConfig",
              "description": "Configuration for the `datadog_traces` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "datadog_traces",
                  "description": "Publish trace events to Datadog."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Publish trace events to Datadog."
        },
        {
          "_metadata": {
            "docs::human_name": "Elasticsearch",
            "logical_name": "Elasticsearch"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::elasticsearch::config::ElasticsearchConfig",
              "description": "Configuration for the `elasticsearch` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "elasticsearch",
                  "description": "Index observability events in Elasticsearch."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Index observability events in Elasticsearch."
        },
        {
          "_metadata": {
            "docs::human_name": "GCP Chronicle Unstructured",
            "logical_name": "ChronicleUnstructured"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::gcp::chronicle_unstructured::ChronicleUnstructuredConfig",
              "description": "Configuration for the `gcp_chronicle_unstructured` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "gcp_chronicle_unstructured",
                  "description": "Store unstructured log events in Google Chronicle."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Store unstructured log events in Google Chronicle."
        },
        {
          "_metadata": {
            "docs::human_name": "GCP Cloud Storage",
            "logical_name": "GcsSink"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::gcp::cloud_storage::GcsSinkConfig",
              "description": "Configuration for the `gcp_cloud_storage` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "gcp_cloud_storage",
                  "description": "Store observability events in GCP Cloud Storage."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Store observability events in GCP Cloud Storage."
        },
        {
          "_metadata": {
            "docs::human_name": "GCP Pub/Sub",
            "logical_name": "Pubsub"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::gcp::pubsub::PubsubConfig",
              "description": "Configuration for the `gcp_pubsub` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "gcp_pubsub",
                  "description": "Publish observability events to GCP's Pub/Sub messaging system."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Publish observability events to GCP's Pub/Sub messaging system."
        },
        {
          "_metadata": {
            "docs::human_name": "GCP Stackdriver Logs",
            "logical_name": "Stackdriver"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::gcp::stackdriver::logs::config::StackdriverConfig",
              "description": "Configuration for the `gcp_stackdriver_logs` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "gcp_stackdriver_logs",
                  "description": "Deliver logs to GCP's Cloud Operations suite."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Deliver logs to GCP's Cloud Operations suite."
        },
        {
          "_metadata": {
            "docs::human_name": "GCP Stackdriver Metrics",
            "logical_name": "Stackdriver"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::gcp::stackdriver_metrics::StackdriverConfig",
              "description": "Configuration for the `gcp_stackdriver_metrics` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "gcp_stackdriver_metrics",
                  "description": "Deliver metrics to GCP's Cloud Monitoring system."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Deliver metrics to GCP's Cloud Monitoring system."
        },
        {
          "_metadata": {
            "docs::human_name": "Honeycomb",
            "logical_name": "Honeycomb"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::honeycomb::config::HoneycombConfig",
              "description": "Configuration for the `honeycomb` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "honeycomb",
                  "description": "Deliver log events to Honeycomb."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Deliver log events to Honeycomb."
        },
        {
          "_metadata": {
            "docs::human_name": "HTTP",
            "logical_name": "HttpSink"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::http::config::HttpSinkConfig",
              "description": "Configuration for the `http` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "http",
                  "description": "Deliver observability event data to an HTTP server."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Deliver observability event data to an HTTP server."
        },
        {
          "_metadata": {
            "docs::human_name": "Humio Logs",
            "logical_name": "HumioLogs"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::humio::logs::HumioLogsConfig",
              "description": "Configuration for the `humio_logs` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "humio_logs",
                  "description": "Deliver log event data to Humio."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Deliver log event data to Humio."
        },
        {
          "_metadata": {
            "docs::human_name": "Humio Metrics",
            "logical_name": "HumioMetrics"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::humio::metrics::HumioMetricsConfig",
              "description": "Configuration for the `humio_metrics` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "humio_metrics",
                  "description": "Deliver metric event data to Humio."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Deliver metric event data to Humio."
        },
        {
          "_metadata": {
            "docs::human_name": "InfluxDB Logs",
            "logical_name": "InfluxDbLogs"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::influxdb::logs::InfluxDbLogsConfig",
              "description": "Configuration for the `influxdb_logs` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "influxdb_logs",
                  "description": "Deliver log event data to InfluxDB."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Deliver log event data to InfluxDB."
        },
        {
          "_metadata": {
            "docs::human_name": "InfluxDB Metrics",
            "logical_name": "InfluxDb"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::influxdb::metrics::InfluxDbConfig",
              "description": "Configuration for the `influxdb_metrics` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "influxdb_metrics",
                  "description": "Deliver metric event data to InfluxDB."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Deliver metric event data to InfluxDB."
        },
        {
          "_metadata": {
            "docs::human_name": "Kafka",
            "logical_name": "KafkaSink"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::kafka::config::KafkaSinkConfig",
              "description": "Configuration for the `kafka` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "kafka",
                  "description": "Publish observability event data to Apache Kafka topics."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Publish observability event data to Apache Kafka topics."
        },
        {
          "_metadata": {
            "docs::human_name": "LogDNA",
            "logical_name": "Logdna"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::mezmo::LogdnaConfig",
              "description": "Configuration for the `logdna` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "logdna",
                  "description": "Deliver log event data to LogDNA."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Deliver log event data to LogDNA."
        },
        {
          "_metadata": {
            "docs::human_name": "Loki",
            "logical_name": "Loki"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::loki::config::LokiConfig",
              "description": "Configuration for the `loki` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "loki",
                  "description": "Deliver log event data to the Loki aggregation system."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Deliver log event data to the Loki aggregation system."
        },
        {
          "_metadata": {
            "docs::human_name": "Mezmo",
            "logical_name": "Mezmo"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::mezmo::MezmoConfig",
              "description": "Configuration for the `mezmo` (formerly `logdna`) sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "mezmo",
                  "description": "Deliver log event data to Mezmo."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Deliver log event data to Mezmo."
        },
        {
          "_metadata": {
            "docs::human_name": "NATS",
            "logical_name": "NatsSink"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::nats::config::NatsSinkConfig",
              "description": "Configuration for the `nats` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "nats",
                  "description": "Publish observability data to subjects on the NATS messaging system."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Publish observability data to subjects on the NATS messaging system."
        },
        {
          "_metadata": {
            "docs::human_name": "New Relic",
            "logical_name": "NewRelic"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::new_relic::config::NewRelicConfig",
              "description": "Configuration for the `new_relic` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "new_relic",
                  "description": "Deliver events to New Relic."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Deliver events to New Relic."
        },
        {
          "_metadata": {
            "docs::human_name": "Papertrail",
            "logical_name": "Papertrail"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::papertrail::PapertrailConfig",
              "description": "Configuration for the `papertrail` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "papertrail",
                  "description": "Deliver log events to Papertrail from SolarWinds."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Deliver log events to Papertrail from SolarWinds."
        },
        {
          "_metadata": {
            "docs::human_name": "Prometheus Exporter",
            "logical_name": "PrometheusExporter"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::prometheus::exporter::PrometheusExporterConfig",
              "description": "Configuration for the `prometheus_exporter` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "prometheus_exporter",
                  "description": "Expose metric events on a Prometheus compatible endpoint."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Expose metric events on a Prometheus compatible endpoint."
        },
        {
          "_metadata": {
            "docs::human_name": "Prometheus Remote Write",
            "logical_name": "RemoteWrite"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::prometheus::remote_write::RemoteWriteConfig",
              "description": "Configuration for the `prometheus_remote_write` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "prometheus_remote_write",
                  "description": "Deliver metric data to a Prometheus remote write endpoint."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Deliver metric data to a Prometheus remote write endpoint."
        },
        {
          "_metadata": {
            "docs::human_name": "Pulsar",
            "logical_name": "PulsarSink"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::pulsar::config::PulsarSinkConfig",
              "description": "Configuration for the `pulsar` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "pulsar",
                  "description": "Publish observability events to Apache Pulsar topics."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Publish observability events to Apache Pulsar topics."
        },
        {
          "_metadata": {
            "docs::human_name": "Redis",
            "logical_name": "RedisSink"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::redis::config::RedisSinkConfig",
              "description": "Configuration for the `redis` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "redis",
                  "description": "Publish observability data to Redis."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Publish observability data to Redis."
        },
        {
          "_metadata": {
            "docs::human_name": "Sematext Logs",
            "logical_name": "SematextLogs"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::sematext::logs::SematextLogsConfig",
              "description": "Configuration for the `sematext_logs` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "sematext_logs",
                  "description": "Publish log events to Sematext."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Publish log events to Sematext."
        },
        {
          "_metadata": {
            "docs::human_name": "Sematext Metrics",
            "logical_name": "SematextMetrics"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::sematext::metrics::SematextMetricsConfig",
              "description": "Configuration for the `sematext_metrics` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "sematext_metrics",
                  "description": "Publish metric events to Sematext."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Publish metric events to Sematext."
        },
        {
          "_metadata": {
            "docs::human_name": "Socket",
            "logical_name": "SocketSink"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::socket::SocketSinkConfig",
              "description": "Configuration for the `socket` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "socket",
                  "description": "Deliver logs to a remote socket endpoint."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Deliver logs to a remote socket endpoint."
        },
        {
          "_metadata": {
            "docs::human_name": "Splunk HEC Logs",
            "logical_name": "HecLogsSink"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::splunk_hec::logs::config::HecLogsSinkConfig",
              "description": "Configuration for the `splunk_hec_logs` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "splunk_hec_logs",
                  "description": "Deliver log data to Splunk's HTTP Event Collector."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Deliver log data to Splunk's HTTP Event Collector."
        },
        {
          "_metadata": {
            "docs::human_name": "Splunk HEC Metrics",
            "logical_name": "HecMetricsSink"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::splunk_hec::metrics::config::HecMetricsSinkConfig",
              "description": "Configuration of the `splunk_hec_metrics` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "splunk_hec_metrics",
                  "description": "Deliver metric data to Splunk's HTTP Event Collector."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Deliver metric data to Splunk's HTTP Event Collector."
        },
        {
          "_metadata": {
            "docs::human_name": "StatsD",
            "logical_name": "StatsdSink"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::statsd::config::StatsdSinkConfig",
              "description": "Configuration for the `statsd` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "statsd",
                  "description": "Deliver metric data to a StatsD aggregator."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Deliver metric data to a StatsD aggregator."
        },
        {
          "_metadata": {
            "docs::human_name": "Unit Test",
            "logical_name": "UnitTestSink"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::config::unit_test::unit_test_components::UnitTestSinkConfig",
              "description": "Configuration for the `unit_test` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "unit_test",
                  "description": "Unit test."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Unit test."
        },
        {
          "_metadata": {
            "docs::human_name": "Unit Test Stream",
            "logical_name": "UnitTestStreamSink"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::config::unit_test::unit_test_components::UnitTestStreamSinkConfig",
              "description": "Configuration for the `unit_test_stream` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "unit_test_stream",
                  "description": "Unit test stream."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Unit test stream."
        },
        {
          "_metadata": {
            "docs::human_name": "Vector",
            "logical_name": "Vector"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::vector::config::VectorConfig",
              "description": "Configuration for the `vector` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "vector",
                  "description": "Relay observability data to a Vector instance."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Relay observability data to a Vector instance."
        },
        {
          "_metadata": {
            "docs::human_name": "WebHDFS",
            "logical_name": "WebHdfs"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sinks::webhdfs::config::WebHdfsConfig",
              "description": "Configuration for the `webhdfs` sink."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "webhdfs",
                  "description": "WebHDFS."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "WebHDFS."
        }
      ]
    },
    "vector::sinks::amqp::config::AmqpSinkConfig": {
      "_metadata": {
        "docs::component_name": "amqp",
        "docs::component_type": "sink"
      },
      "allOf": [
        {
          "properties": {
            "acknowledgements": {
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              },
              "default": {
                "enabled": null
              },
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "title": "Controls how acknowledgements are handled for this sink."
            },
            "encoding": {
              "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
              "_metadata": {
                "docs::human_name": "Encoding"
              },
              "description": "Configures how events are encoded into raw bytes."
            },
            "exchange": {
              "$ref": "#/definitions/vector::template::Template",
              "_metadata": {
                "docs::human_name": "Exchange"
              },
              "description": "The exchange to publish messages to."
            },
            "properties": {
              "_metadata": {
                "docs::human_name": "Properties",
                "docs::optional": true
              },
              "description": "AMQP message properties.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "description": "AMQP properties configuration.",
                  "properties": {
                    "content_encoding": {
                      "_metadata": {
                        "docs::human_name": "Content Encoding",
                        "docs::optional": true
                      },
                      "description": "Content-Encoding for the AMQP messages.",
                      "type": [
                        "string",
                        "null"
                      ]
                    },
                    "content_type": {
                      "_metadata": {
                        "docs::human_name": "Content Type",
                        "docs::optional": true
                      },
                      "description": "Content-Type for the AMQP messages.",
                      "type": [
                        "string",
                        "null"
                      ]
                    }
                  },
                  "title": "Configure the AMQP message properties.",
                  "type": "object"
                }
              ],
              "title": "Configure the AMQP message properties.",
              "unevaluatedProperties": false
            },
            "routing_key": {
              "$ref": "#/definitions/core::option::Option<vector::template::Template>",
              "_metadata": {
                "docs::human_name": "Routing Key"
              },
              "description": "Template used to generate a routing key which corresponds to a queue binding."
            }
          },
          "required": [
            "encoding",
            "exchange"
          ],
          "type": "object"
        },
        {
          "$ref": "#/definitions/vector::amqp::AmqpConfig",
          "description": "AMQP connection options."
        }
      ],
      "description": "Supports AMQP version 0.9.1",
      "title": "Configuration for the `amqp` sink."
    },
    "vector::sinks::appsignal::config::AppsignalConfig": {
      "_metadata": {
        "docs::component_name": "appsignal",
        "docs::component_type": "sink"
      },
      "description": "Configuration for the `appsignal` sink.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled for this sink."
        },
        "batch": {
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Batch"
          },
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "description": "Event batching behavior.",
          "properties": {
            "max_bytes": {
              "_metadata": {
                "docs::human_name": "Max Bytes",
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "bytes"
              },
              "default": 450000,
              "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "title": "The maximum size of a batch that is processed by a sink.",
              "type": [
                "integer",
                "null"
              ]
            },
            "max_events": {
              "_metadata": {
                "docs::human_name": "Max Events",
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "events"
              },
              "default": 100,
              "description": "The maximum size of a batch before it is flushed.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "type": [
                "integer",
                "null"
              ]
            },
            "timeout_secs": {
              "_metadata": {
                "docs::human_name": "Timeout",
                "docs::numeric_type": "float",
                "docs::optional": true,
                "docs::type_unit": "seconds"
              },
              "default": 1,
              "description": "The maximum age of a batch before it is flushed.",
              "maximum": 9007199254740991,
              "minimum": -9007199254740991,
              "type": [
                "number",
                "null"
              ]
            }
          },
          "type": "object",
          "unevaluatedProperties": false
        },
        "compression": {
          "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
          "_metadata": {
            "docs::human_name": "Compression"
          },
          "default": "gzip",
          "description": "All compression algorithms use the default compression level unless otherwise specified.",
          "title": "Compression configuration."
        },
        "encoding": {
          "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer",
          "_metadata": {
            "docs::human_name": "Encoding"
          },
          "default": {},
          "description": "Transformations to prepare an event for serialization."
        },
        "endpoint": {
          "_metadata": {
            "docs::examples": "https://appsignal-endpoint.net",
            "docs::human_name": "Endpoint"
          },
          "default": "https://appsignal-endpoint.net",
          "description": "The URI for the AppSignal API to send data to.",
          "format": "uri",
          "type": "string"
        },
        "push_api_key": {
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "docs::examples": [
              "00000000-0000-0000-0000-000000000000",
              "${APPSIGNAL_PUSH_API_KEY}"
            ],
            "docs::human_name": "Push API Key"
          },
          "description": "A valid app-level AppSignal Push API key."
        },
        "request": {
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          },
          "default": {
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "initial_concurrency": 1,
              "rtt_deviation_scale": 2.5
            },
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775808,
            "retry_attempts": 9223372036854775808,
            "retry_initial_backoff_secs": 1,
            "retry_max_duration_secs": 3600,
            "timeout_secs": 60
          },
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "title": "Middleware settings for outbound requests."
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "required": [
        "push_api_key"
      ],
      "type": "object"
    },
    "vector::sinks::aws_cloudwatch_logs::config::CloudwatchLogsSinkConfig": {
      "_metadata": {
        "docs::component_name": "aws_cloudwatch_logs",
        "docs::component_type": "sink"
      },
      "allOf": [
        {
          "properties": {
            "acknowledgements": {
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              },
              "default": {
                "enabled": null
              },
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "title": "Controls how acknowledgements are handled for this sink."
            },
            "assume_role": {
              "_metadata": {
                "docs::hidden": true,
                "docs::human_name": "Assume Role",
                "docs::optional": true
              },
              "deprecated": true,
              "description": "[iam_role]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html",
              "title": "The ARN of an [IAM role][iam_role] to assume at startup.",
              "type": [
                "string",
                "null"
              ]
            },
            "auth": {
              "$ref": "#/definitions/vector::aws::auth::AwsAuthentication",
              "_metadata": {
                "docs::human_name": "Auth"
              },
              "default": {
                "imds": {
                  "connect_timeout_seconds": 1,
                  "max_attempts": 4,
                  "read_timeout_seconds": 1
                },
                "load_timeout_secs": null,
                "region": null
              },
              "description": "Configuration of the authentication strategy for interacting with AWS services."
            },
            "batch": {
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Batch"
              },
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "description": "Event batching behavior.",
              "properties": {
                "max_bytes": {
                  "_metadata": {
                    "docs::human_name": "Max Bytes",
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes"
                  },
                  "default": 1048576,
                  "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "title": "The maximum size of a batch that is processed by a sink.",
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "max_events": {
                  "_metadata": {
                    "docs::human_name": "Max Events",
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "events"
                  },
                  "default": 10000,
                  "description": "The maximum size of a batch before it is flushed.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "timeout_secs": {
                  "_metadata": {
                    "docs::human_name": "Timeout",
                    "docs::numeric_type": "float",
                    "docs::optional": true,
                    "docs::type_unit": "seconds"
                  },
                  "default": 1,
                  "description": "The maximum age of a batch before it is flushed.",
                  "maximum": 9007199254740991,
                  "minimum": -9007199254740991,
                  "type": [
                    "number",
                    "null"
                  ]
                }
              },
              "type": "object",
              "unevaluatedProperties": false
            },
            "compression": {
              "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
              "_metadata": {
                "docs::human_name": "Compression"
              },
              "default": "none",
              "description": "All compression algorithms use the default compression level unless otherwise specified.",
              "title": "Compression configuration."
            },
            "create_missing_group": {
              "_metadata": {
                "docs::human_name": "Create Missing Group"
              },
              "default": true,
              "description": "This ignores `create_missing_stream` directly after creating the group and creates\nthe first stream.\n\n[log_group]: https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html",
              "title": "Dynamically create a [log group][log_group] if it does not already exist.",
              "type": "boolean"
            },
            "create_missing_stream": {
              "_metadata": {
                "docs::human_name": "Create Missing Stream"
              },
              "default": true,
              "description": "[log_stream]: https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html",
              "title": "Dynamically create a [log stream][log_stream] if it does not already exist.",
              "type": "boolean"
            },
            "encoding": {
              "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
              "_metadata": {
                "docs::human_name": "Encoding"
              },
              "description": "Configures how events are encoded into raw bytes."
            },
            "group_name": {
              "$ref": "#/definitions/vector::template::Template",
              "_metadata": {
                "docs::examples": [
                  "group-name",
                  "{{ file }}"
                ],
                "docs::human_name": "Group Name"
              },
              "description": "[group_name]: https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html",
              "title": "The [group name][group_name] of the target CloudWatch Logs stream."
            },
            "request": {
              "$ref": "#/definitions/vector::sinks::util::http::RequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              },
              "default": {
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "initial_concurrency": 1,
                  "rtt_deviation_scale": 2.5
                },
                "headers": {},
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775808,
                "retry_attempts": 9223372036854775808,
                "retry_initial_backoff_secs": 1,
                "retry_max_duration_secs": 3600,
                "timeout_secs": 60
              },
              "description": "Outbound HTTP request settings."
            },
            "stream_name": {
              "$ref": "#/definitions/vector::template::Template",
              "_metadata": {
                "docs::examples": [
                  "{{ host }}",
                  "%Y-%m-%d",
                  "stream-name"
                ],
                "docs::human_name": "Stream Name"
              },
              "description": "There can only be one writer to a log stream at a time. If multiple instances are writing to\nthe same log group, the stream name must include an identifier that is guaranteed to be\nunique per instance.\n\n[stream_name]: https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html",
              "title": "The [stream name][stream_name] of the target CloudWatch Logs stream."
            },
            "tls": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              }
            }
          },
          "required": [
            "encoding",
            "group_name",
            "stream_name"
          ],
          "type": "object"
        },
        {
          "$ref": "#/definitions/vector::aws::region::RegionOrEndpoint",
          "description": "[aws_region]: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html",
          "title": "The [AWS region][aws_region] of the target service."
        }
      ],
      "description": "Configuration for the `aws_cloudwatch_logs` sink."
    },
    "vector::sinks::aws_cloudwatch_metrics::CloudWatchMetricsSinkConfig": {
      "_metadata": {
        "docs::component_name": "aws_cloudwatch_metrics",
        "docs::component_type": "sink"
      },
      "allOf": [
        {
          "properties": {
            "acknowledgements": {
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              },
              "default": {
                "enabled": null
              },
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "title": "Controls how acknowledgements are handled for this sink."
            },
            "assume_role": {
              "_metadata": {
                "docs::hidden": true,
                "docs::human_name": "Assume Role",
                "docs::optional": true
              },
              "deprecated": true,
              "description": "[iam_role]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html",
              "title": "The ARN of an [IAM role][iam_role] to assume at startup.",
              "type": [
                "string",
                "null"
              ]
            },
            "auth": {
              "$ref": "#/definitions/vector::aws::auth::AwsAuthentication",
              "_metadata": {
                "docs::human_name": "Auth"
              },
              "default": {
                "imds": {
                  "connect_timeout_seconds": 1,
                  "max_attempts": 4,
                  "read_timeout_seconds": 1
                },
                "load_timeout_secs": null,
                "region": null
              },
              "description": "Configuration of the authentication strategy for interacting with AWS services."
            },
            "batch": {
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Batch"
              },
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "description": "Event batching behavior.",
              "properties": {
                "max_bytes": {
                  "_metadata": {
                    "docs::human_name": "Max Bytes",
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes"
                  },
                  "default": null,
                  "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "title": "The maximum size of a batch that is processed by a sink.",
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "max_events": {
                  "_metadata": {
                    "docs::human_name": "Max Events",
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "events"
                  },
                  "default": 20,
                  "description": "The maximum size of a batch before it is flushed.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "timeout_secs": {
                  "_metadata": {
                    "docs::human_name": "Timeout",
                    "docs::numeric_type": "float",
                    "docs::optional": true,
                    "docs::type_unit": "seconds"
                  },
                  "default": 1,
                  "description": "The maximum age of a batch before it is flushed.",
                  "maximum": 9007199254740991,
                  "minimum": -9007199254740991,
                  "type": [
                    "number",
                    "null"
                  ]
                }
              },
              "type": "object",
              "unevaluatedProperties": false
            },
            "compression": {
              "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
              "_metadata": {
                "docs::human_name": "Compression"
              },
              "default": "none",
              "description": "All compression algorithms use the default compression level unless otherwise specified.",
              "title": "Compression configuration."
            },
            "default_namespace": {
              "_metadata": {
                "docs::examples": "service",
                "docs::human_name": "Default Namespace"
              },
              "description": "Metrics with the same name can only be differentiated by their namespace, and not all\nmetrics have their own namespace.\n\n[namespace]: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Namespace",
              "title": "The default [namespace][namespace] to use for metrics that do not have one.",
              "type": "string"
            },
            "request": {
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              },
              "default": {
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "initial_concurrency": 1,
                  "rtt_deviation_scale": 2.5
                },
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775808,
                "retry_attempts": 9223372036854775808,
                "retry_initial_backoff_secs": 1,
                "retry_max_duration_secs": 3600,
                "timeout_secs": 60
              },
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "title": "Middleware settings for outbound requests."
            },
            "tls": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              }
            }
          },
          "required": [
            "default_namespace"
          ],
          "type": "object"
        },
        {
          "$ref": "#/definitions/vector::aws::region::RegionOrEndpoint",
          "description": "[aws_region]: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html",
          "title": "The [AWS region][aws_region] of the target service."
        }
      ],
      "description": "Configuration for the `aws_cloudwatch_metrics` sink."
    },
    "vector::sinks::aws_kinesis::config::KinesisSinkBaseConfig": {
      "allOf": [
        {
          "properties": {
            "acknowledgements": {
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              },
              "default": {
                "enabled": null
              },
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "title": "Controls how acknowledgements are handled for this sink."
            },
            "auth": {
              "$ref": "#/definitions/vector::aws::auth::AwsAuthentication",
              "_metadata": {
                "docs::human_name": "Auth"
              },
              "default": {
                "imds": {
                  "connect_timeout_seconds": 1,
                  "max_attempts": 4,
                  "read_timeout_seconds": 1
                },
                "load_timeout_secs": null,
                "region": null
              },
              "description": "Configuration of the authentication strategy for interacting with AWS services."
            },
            "compression": {
              "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
              "_metadata": {
                "docs::human_name": "Compression"
              },
              "default": "none",
              "description": "All compression algorithms use the default compression level unless otherwise specified.",
              "title": "Compression configuration."
            },
            "encoding": {
              "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
              "_metadata": {
                "docs::human_name": "Encoding"
              },
              "description": "Configures how events are encoded into raw bytes."
            },
            "request": {
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              },
              "default": {
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "initial_concurrency": 1,
                  "rtt_deviation_scale": 2.5
                },
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775808,
                "retry_attempts": 9223372036854775808,
                "retry_initial_backoff_secs": 1,
                "retry_max_duration_secs": 3600,
                "timeout_secs": 60
              },
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "title": "Middleware settings for outbound requests."
            },
            "request_retry_partial": {
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Request Retry Partial"
              },
              "default": false,
              "description": "Whether or not to retry successful requests containing partial failures.",
              "type": "boolean"
            },
            "stream_name": {
              "_metadata": {
                "docs::examples": "my-stream",
                "docs::human_name": "Stream Name"
              },
              "description": "[stream_name]: https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html",
              "title": "The [stream name][stream_name] of the target Kinesis Firehose delivery stream.",
              "type": "string"
            },
            "tls": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              }
            }
          },
          "required": [
            "encoding",
            "stream_name"
          ],
          "type": "object"
        },
        {
          "$ref": "#/definitions/vector::aws::region::RegionOrEndpoint",
          "description": "Configuration of the region/endpoint to use when interacting with an AWS service."
        }
      ],
      "description": "Base configuration for the `aws_kinesis_` sinks.\nThe actual specific sink configuration types should either wrap this in a newtype wrapper,\nor should extend it in a new struct with `serde(flatten)`."
    },
    "vector::sinks::aws_kinesis::firehose::config::KinesisFirehoseSinkConfig": {
      "_metadata": {
        "docs::component_name": "aws_kinesis_firehose",
        "docs::component_type": "sink"
      },
      "allOf": [
        {
          "properties": {
            "batch": {
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Batch"
              },
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "description": "Event batching behavior.",
              "properties": {
                "max_bytes": {
                  "_metadata": {
                    "docs::human_name": "Max Bytes",
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes"
                  },
                  "default": 4194304,
                  "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "title": "The maximum size of a batch that is processed by a sink.",
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "max_events": {
                  "_metadata": {
                    "docs::human_name": "Max Events",
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "events"
                  },
                  "default": 500,
                  "description": "The maximum size of a batch before it is flushed.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "timeout_secs": {
                  "_metadata": {
                    "docs::human_name": "Timeout",
                    "docs::numeric_type": "float",
                    "docs::optional": true,
                    "docs::type_unit": "seconds"
                  },
                  "default": 1,
                  "description": "The maximum age of a batch before it is flushed.",
                  "maximum": 9007199254740991,
                  "minimum": -9007199254740991,
                  "type": [
                    "number",
                    "null"
                  ]
                }
              },
              "type": "object",
              "unevaluatedProperties": false
            }
          },
          "type": "object"
        },
        {
          "$ref": "#/definitions/vector::sinks::aws_kinesis::config::KinesisSinkBaseConfig",
          "description": "Base configuration for the `aws_kinesis_` sinks.\nThe actual specific sink configuration types should either wrap this in a newtype wrapper,\nor should extend it in a new struct with `serde(flatten)`."
        }
      ],
      "description": "Configuration for the `aws_kinesis_firehose` sink."
    },
    "vector::sinks::aws_kinesis::streams::config::KinesisStreamsSinkConfig": {
      "_metadata": {
        "docs::component_name": "aws_kinesis_streams",
        "docs::component_type": "sink"
      },
      "allOf": [
        {
          "properties": {
            "batch": {
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Batch"
              },
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "description": "Event batching behavior.",
              "properties": {
                "max_bytes": {
                  "_metadata": {
                    "docs::human_name": "Max Bytes",
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes"
                  },
                  "default": 5000000,
                  "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "title": "The maximum size of a batch that is processed by a sink.",
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "max_events": {
                  "_metadata": {
                    "docs::human_name": "Max Events",
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "events"
                  },
                  "default": 500,
                  "description": "The maximum size of a batch before it is flushed.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "timeout_secs": {
                  "_metadata": {
                    "docs::human_name": "Timeout",
                    "docs::numeric_type": "float",
                    "docs::optional": true,
                    "docs::type_unit": "seconds"
                  },
                  "default": 1,
                  "description": "The maximum age of a batch before it is flushed.",
                  "maximum": 9007199254740991,
                  "minimum": -9007199254740991,
                  "type": [
                    "number",
                    "null"
                  ]
                }
              },
              "type": "object",
              "unevaluatedProperties": false
            },
            "partition_key_field": {
              "$ref": "#/definitions/core::option::Option<vector_lookup::lookup_v2::ConfigValuePath>",
              "_metadata": {
                "docs::examples": "user_id",
                "docs::human_name": "Partition Key Field"
              },
              "description": "If not specified, a unique partition key is generated for each Kinesis record.",
              "title": "The log field used as the Kinesis record’s partition key value."
            }
          },
          "type": "object"
        },
        {
          "$ref": "#/definitions/vector::sinks::aws_kinesis::config::KinesisSinkBaseConfig",
          "description": "Base configuration for the `aws_kinesis_` sinks.\nThe actual specific sink configuration types should either wrap this in a newtype wrapper,\nor should extend it in a new struct with `serde(flatten)`."
        }
      ],
      "description": "Configuration for the `aws_kinesis_streams` sink."
    },
    "vector::sinks::aws_s3::config::S3SinkConfig": {
      "_metadata": {
        "docs::component_name": "aws_s3",
        "docs::component_type": "sink"
      },
      "allOf": [
        {
          "properties": {
            "acknowledgements": {
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              },
              "default": {
                "enabled": null
              },
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "title": "Controls how acknowledgements are handled for this sink."
            },
            "auth": {
              "$ref": "#/definitions/vector::aws::auth::AwsAuthentication",
              "_metadata": {
                "docs::human_name": "Auth"
              },
              "default": {
                "imds": {
                  "connect_timeout_seconds": 1,
                  "max_attempts": 4,
                  "read_timeout_seconds": 1
                },
                "load_timeout_secs": null,
                "region": null
              },
              "description": "Configuration of the authentication strategy for interacting with AWS services."
            },
            "batch": {
              "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::BulkSizeBasedDefaultBatchSettings>",
              "_metadata": {
                "docs::human_name": "Batch"
              },
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "description": "Event batching behavior."
            },
            "bucket": {
              "_metadata": {
                "docs::examples": "my-bucket",
                "docs::human_name": "Bucket"
              },
              "description": "This must not include a leading `s3://` or a trailing `/`.",
              "title": "The S3 bucket name.",
              "type": "string"
            },
            "compression": {
              "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
              "_metadata": {
                "docs::human_name": "Compression"
              },
              "default": "gzip",
              "description": "All compression algorithms use the default compression level unless otherwise specified.\n\nSome cloud storage API clients and browsers handle decompression transparently, so\ndepending on how they are accessed, files may not always appear to be compressed.",
              "title": "Compression configuration."
            },
            "filename_append_uuid": {
              "_metadata": {
                "docs::human_name": "Append UUID to Filename"
              },
              "default": true,
              "description": "The UUID is appended to the timestamp portion of the object key, such that if the object key\ngenerated is `date=2022-07-18/1658176486`, setting this field to `true` results\nin an object key that looks like `date=2022-07-18/1658176486-30f6652c-71da-4f9f-800d-a1189c47c547`.\n\nThis ensures there are no name collisions, and can be useful in high-volume workloads where\nobject keys must be unique.",
              "title": "Whether or not to append a UUID v4 token to the end of the object key.",
              "type": "boolean"
            },
            "filename_extension": {
              "_metadata": {
                "docs::examples": "json",
                "docs::human_name": "Filename Extension",
                "docs::optional": true
              },
              "description": "This overrides setting the extension based on the configured `compression`.",
              "title": "The filename extension to use in the object key.",
              "type": [
                "string",
                "null"
              ]
            },
            "filename_time_format": {
              "_metadata": {
                "docs::human_name": "Filename Time Format"
              },
              "default": "%s",
              "description": "By default, object keys are appended with a timestamp that reflects when the objects are\nsent to S3, such that the resulting object key is functionally equivalent to joining the key\nprefix with the formatted timestamp, such as `date=2022-07-18/1658176486`.\n\nThis would represent a `key_prefix` set to `date=%F/` and the timestamp of Mon Jul 18 2022\n20:34:44 GMT+0000, with the `filename_time_format` being set to `%s`, which renders\ntimestamps in seconds since the Unix epoch.\n\nSupports the common [`strftime`][chrono_strftime_specifiers] specifiers found in most\nlanguages.\n\nWhen set to an empty string, no timestamp is appended to the key prefix.\n\n[chrono_strftime_specifiers]: https://docs.rs/chrono/latest/chrono/format/strftime/index.html#specifiers",
              "title": "The timestamp format for the time component of the object key.",
              "type": "string"
            },
            "key_prefix": {
              "_metadata": {
                "docs::examples": [
                  "date=%F/hour=%H",
                  "year=%Y/month=%m/day=%d",
                  "application_id={{ application_id }}/date=%F"
                ],
                "docs::human_name": "Key Prefix",
                "docs::templateable": true
              },
              "default": "date=%F",
              "description": "Prefixes are useful for partitioning objects, such as by creating an object key that\nstores objects under a particular directory. If using a prefix for this purpose, it must end\nin `/` to act as a directory path. A trailing `/` is **not** automatically added.",
              "title": "A prefix to apply to all object keys.",
              "type": "string"
            },
            "request": {
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              },
              "default": {
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "initial_concurrency": 1,
                  "rtt_deviation_scale": 2.5
                },
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775808,
                "retry_attempts": 9223372036854775808,
                "retry_initial_backoff_secs": 1,
                "retry_max_duration_secs": 3600,
                "timeout_secs": 60
              },
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "title": "Middleware settings for outbound requests."
            },
            "tls": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              }
            }
          },
          "required": [
            "bucket"
          ],
          "type": "object"
        },
        {
          "description": "Per-operation configuration when writing objects to S3.",
          "properties": {
            "acl": {
              "$ref": "#/definitions/core::option::Option<vector::sinks::s3_common::config::S3CannedAcl>",
              "_metadata": {
                "docs::human_name": "ACL"
              },
              "description": "For more information, see [Canned ACL][canned_acl].\n\n[canned_acl]: https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl",
              "title": "Canned ACL to apply to the created objects."
            },
            "content_encoding": {
              "_metadata": {
                "docs::examples": "gzip",
                "docs::human_name": "Content Encoding",
                "docs::optional": true
              },
              "description": "Directly comparable to the `Content-Encoding` HTTP header.\n\nIf not specified, the compression scheme used dictates this value.",
              "title": "Overrides what content encoding has been applied to the object.",
              "type": [
                "string",
                "null"
              ]
            },
            "content_type": {
              "_metadata": {
                "docs::examples": "application/gzip",
                "docs::human_name": "Content Type",
                "docs::optional": true
              },
              "description": "Directly comparable to the `Content-Type` HTTP header.\n\nIf not specified, the compression scheme used dictates this value.\nWhen `compression` is set to `none`, the value `text/x-log` is used.",
              "title": "Overrides the MIME type of the object.",
              "type": [
                "string",
                "null"
              ]
            },
            "grant_full_control": {
              "_metadata": {
                "docs::examples": [
                  "79a59df900b949e55d96a1e698fbacedfd6e09d98eacf8f8d5218e7cd47ef2be",
                  "person@email.com",
                  "http://acs.amazonaws.com/groups/global/AllUsers"
                ],
                "docs::human_name": "Grant Full Control",
                "docs::optional": true
              },
              "description": "This allows the grantee to read the created objects and their metadata, as well as read and\nmodify the ACL on the created objects.\n\n[grantee]: https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#specifying-grantee",
              "title": "Grants `READ`, `READ_ACP`, and `WRITE_ACP` permissions on the created objects to the named [grantee].",
              "type": [
                "string",
                "null"
              ]
            },
            "grant_read": {
              "_metadata": {
                "docs::examples": [
                  "79a59df900b949e55d96a1e698fbacedfd6e09d98eacf8f8d5218e7cd47ef2be",
                  "person@email.com",
                  "http://acs.amazonaws.com/groups/global/AllUsers"
                ],
                "docs::human_name": "Grant Read",
                "docs::optional": true
              },
              "description": "This allows the grantee to read the created objects and their metadata.\n\n[grantee]: https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#specifying-grantee",
              "title": "Grants `READ` permissions on the created objects to the named [grantee].",
              "type": [
                "string",
                "null"
              ]
            },
            "grant_read_acp": {
              "_metadata": {
                "docs::examples": [
                  "79a59df900b949e55d96a1e698fbacedfd6e09d98eacf8f8d5218e7cd47ef2be",
                  "person@email.com",
                  "http://acs.amazonaws.com/groups/global/AllUsers"
                ],
                "docs::human_name": "Grant Read ACP",
                "docs::optional": true
              },
              "description": "This allows the grantee to read the ACL on the created objects.\n\n[grantee]: https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#specifying-grantee",
              "title": "Grants `READ_ACP` permissions on the created objects to the named [grantee].",
              "type": [
                "string",
                "null"
              ]
            },
            "grant_write_acp": {
              "_metadata": {
                "docs::examples": [
                  "79a59df900b949e55d96a1e698fbacedfd6e09d98eacf8f8d5218e7cd47ef2be",
                  "person@email.com",
                  "http://acs.amazonaws.com/groups/global/AllUsers"
                ],
                "docs::human_name": "Grant Write ACP",
                "docs::optional": true
              },
              "description": "This allows the grantee to modify the ACL on the created objects.\n\n[grantee]: https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#specifying-grantee",
              "title": "Grants `WRITE_ACP` permissions on the created objects to the named [grantee].",
              "type": [
                "string",
                "null"
              ]
            },
            "server_side_encryption": {
              "$ref": "#/definitions/core::option::Option<vector::sinks::s3_common::config::S3ServerSideEncryption>",
              "_metadata": {
                "docs::human_name": "Server Side Encryption"
              },
              "description": "The Server-side Encryption algorithm used when storing these objects."
            },
            "ssekms_key_id": {
              "_metadata": {
                "docs::examples": "abcd1234",
                "docs::human_name": "SSE-KMS Key ID",
                "docs::optional": true,
                "docs::templateable": true
              },
              "description": "Only applies when `server_side_encryption` is configured to use KMS.\n\nIf not specified, Amazon S3 uses the AWS managed CMK in AWS to protect the data.",
              "title": "Specifies the ID of the AWS Key Management Service (AWS KMS) symmetrical customer managed\ncustomer master key (CMK) that is used for the created objects.",
              "type": [
                "string",
                "null"
              ]
            },
            "storage_class": {
              "$ref": "#/definitions/vector::sinks::s3_common::config::S3StorageClass",
              "_metadata": {
                "docs::human_name": "Storage Class"
              },
              "default": "STANDARD",
              "description": "See the [S3 Storage Classes][s3_storage_classes] for more details.\n\n[s3_storage_classes]: https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html",
              "title": "The storage class for the created objects."
            },
            "tags": {
              "_metadata": {
                "docs::additional_props_description": "A single tag.",
                "docs::examples": {
                  "Classification": "confidential",
                  "PHI": "True",
                  "Project": "Blue"
                },
                "docs::human_name": "Tags",
                "docs::optional": true
              },
              "additionalProperties": {
                "type": "string"
              },
              "description": "The tag-set for the object.",
              "type": [
                "object",
                "null"
              ]
            }
          },
          "type": "object"
        },
        {
          "$ref": "#/definitions/vector::aws::region::RegionOrEndpoint",
          "description": "Configuration of the region/endpoint to use when interacting with an AWS service."
        },
        {
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfigWithFraming",
          "description": "Encoding configuration."
        }
      ],
      "description": "Configuration for the `aws_s3` sink."
    },
    "vector::sinks::aws_s_s::sqs::config::SqsSinkConfig": {
      "_metadata": {
        "docs::component_name": "aws_sqs",
        "docs::component_type": "sink"
      },
      "allOf": [
        {
          "properties": {
            "queue_url": {
              "_metadata": {
                "docs::examples": "https://sqs.us-east-2.amazonaws.com/123456789012/MyQueue",
                "docs::human_name": "Queue URL"
              },
              "description": "The URL of the Amazon SQS queue to which messages are sent.",
              "format": "uri",
              "type": "string"
            }
          },
          "required": [
            "queue_url"
          ],
          "type": "object"
        },
        {
          "$ref": "#/definitions/vector::aws::region::RegionOrEndpoint",
          "description": "Configuration of the region/endpoint to use when interacting with an AWS service."
        },
        {
          "description": "Base Configuration `aws_s_s` for sns and sqs sink.",
          "properties": {
            "acknowledgements": {
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              },
              "default": {
                "enabled": null
              },
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "title": "Controls how acknowledgements are handled for this sink."
            },
            "assume_role": {
              "_metadata": {
                "docs::hidden": true,
                "docs::human_name": "Assume Role",
                "docs::optional": true
              },
              "deprecated": true,
              "description": "[iam_role]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html",
              "title": "The ARN of an [IAM role][iam_role] to assume at startup.",
              "type": [
                "string",
                "null"
              ]
            },
            "auth": {
              "$ref": "#/definitions/vector::aws::auth::AwsAuthentication",
              "_metadata": {
                "docs::human_name": "Auth"
              },
              "default": {
                "imds": {
                  "connect_timeout_seconds": 1,
                  "max_attempts": 4,
                  "read_timeout_seconds": 1
                },
                "load_timeout_secs": null,
                "region": null
              },
              "description": "Configuration of the authentication strategy for interacting with AWS services."
            },
            "encoding": {
              "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
              "_metadata": {
                "docs::human_name": "Encoding"
              },
              "description": "Configures how events are encoded into raw bytes."
            },
            "message_deduplication_id": {
              "_metadata": {
                "docs::examples": "{{ transaction_id }}",
                "docs::human_name": "Message Deduplication ID",
                "docs::optional": true
              },
              "description": "This value is a template which should result in a unique string for each event. See the [AWS\ndocumentation][deduplication_id_docs] for more about how AWS does message deduplication.\n\n[deduplication_id_docs]: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/using-messagededuplicationid-property.html",
              "title": "The message deduplication ID value to allow AWS to identify duplicate messages.",
              "type": [
                "string",
                "null"
              ]
            },
            "message_group_id": {
              "_metadata": {
                "docs::examples": [
                  "vector",
                  "vector-%Y-%m-%d"
                ],
                "docs::human_name": "Message Group ID",
                "docs::optional": true
              },
              "description": "Can be applied only to FIFO queues.",
              "title": "The tag that specifies that a message belongs to a specific message group.",
              "type": [
                "string",
                "null"
              ]
            },
            "request": {
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              },
              "default": {
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "initial_concurrency": 1,
                  "rtt_deviation_scale": 2.5
                },
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775808,
                "retry_attempts": 9223372036854775808,
                "retry_initial_backoff_secs": 1,
                "retry_max_duration_secs": 3600,
                "timeout_secs": 60
              },
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "title": "Middleware settings for outbound requests."
            },
            "tls": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              }
            }
          },
          "required": [
            "encoding"
          ],
          "type": "object"
        }
      ],
      "description": "Configuration for the `aws_sqs` sink."
    },
    "vector::sinks::axiom::AxiomConfig": {
      "_metadata": {
        "docs::component_name": "axiom",
        "docs::component_type": "sink"
      },
      "description": "Configuration for the `axiom` sink.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled for this sink."
        },
        "compression": {
          "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
          "_metadata": {
            "docs::human_name": "Compression"
          },
          "default": "none",
          "description": "All compression algorithms use the default compression level unless otherwise specified.",
          "title": "Compression configuration."
        },
        "dataset": {
          "_metadata": {
            "docs::examples": [
              "${AXIOM_DATASET}",
              "vector.dev"
            ],
            "docs::human_name": "Dataset"
          },
          "description": "The Axiom dataset to write to.",
          "type": "string"
        },
        "org_id": {
          "_metadata": {
            "docs::examples": [
              "${AXIOM_ORG_ID}",
              "123abc"
            ],
            "docs::human_name": "Org ID",
            "docs::optional": true
          },
          "description": "Only required when using personal tokens.",
          "title": "The Axiom organization ID.",
          "type": [
            "string",
            "null"
          ]
        },
        "request": {
          "$ref": "#/definitions/vector::sinks::util::http::RequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          },
          "default": {
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "initial_concurrency": 1,
              "rtt_deviation_scale": 2.5
            },
            "headers": {},
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775808,
            "retry_attempts": 9223372036854775808,
            "retry_initial_backoff_secs": 1,
            "retry_max_duration_secs": 3600,
            "timeout_secs": 60
          },
          "description": "Outbound HTTP request settings."
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        },
        "token": {
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "docs::examples": [
              "${AXIOM_TOKEN}",
              "123abc"
            ],
            "docs::human_name": "Token"
          },
          "description": "The Axiom API token."
        },
        "url": {
          "_metadata": {
            "docs::examples": [
              "https://axiom.my-domain.com",
              "${AXIOM_URL}"
            ],
            "docs::human_name": "URL",
            "docs::optional": true
          },
          "description": "Only required if not using Axiom Cloud.",
          "format": "uri",
          "title": "URI of the Axiom endpoint to send data to.",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "required": [
        "dataset",
        "token"
      ],
      "type": "object"
    },
    "vector::sinks::azure_blob::config::AzureBlobSinkConfig": {
      "_metadata": {
        "docs::component_name": "azure_blob",
        "docs::component_type": "sink"
      },
      "allOf": [
        {
          "properties": {
            "acknowledgements": {
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              },
              "default": {
                "enabled": null
              },
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "title": "Controls how acknowledgements are handled for this sink."
            },
            "batch": {
              "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::BulkSizeBasedDefaultBatchSettings>",
              "_metadata": {
                "docs::human_name": "Batch"
              },
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "description": "Event batching behavior."
            },
            "blob_append_uuid": {
              "_metadata": {
                "docs::human_name": "Blob Append UUID",
                "docs::optional": true
              },
              "description": "The UUID is appended to the timestamp portion of the object key, such that if the blob key\ngenerated is `date=2022-07-18/1658176486`, setting this field to `true` results\nin an blob key that looks like\n`date=2022-07-18/1658176486-30f6652c-71da-4f9f-800d-a1189c47c547`.\n\nThis ensures there are no name collisions, and can be useful in high-volume workloads where\nblob keys must be unique.",
              "title": "Whether or not to append a UUID v4 token to the end of the blob key.",
              "type": [
                "boolean",
                "null"
              ]
            },
            "blob_prefix": {
              "$ref": "#/definitions/vector::template::Template",
              "_metadata": {
                "docs::examples": [
                  "date/%F/hour/%H/",
                  "year=%Y/month=%m/day=%d/",
                  "kubernetes/{{ metadata.cluster }}/{{ metadata.application_name }}/"
                ],
                "docs::human_name": "Blob Prefix"
              },
              "default": "blob/%F/",
              "description": "Prefixes are useful for partitioning objects, such as by creating a blob key that\nstores blobs under a particular directory. If using a prefix for this purpose, it must end\nin `/` to act as a directory path. A trailing `/` is **not** automatically added.",
              "title": "A prefix to apply to all blob keys."
            },
            "blob_time_format": {
              "_metadata": {
                "docs::human_name": "Blob Time Format",
                "docs::optional": true,
                "docs::syntax_override": "strftime"
              },
              "description": "By default, blob keys are appended with a timestamp that reflects when the blob are sent to\nAzure Blob Storage, such that the resulting blob key is functionally equivalent to joining\nthe blob prefix with the formatted timestamp, such as `date=2022-07-18/1658176486`.\n\nThis would represent a `blob_prefix` set to `date=%F/` and the timestamp of Mon Jul 18 2022\n20:34:44 GMT+0000, with the `filename_time_format` being set to `%s`, which renders\ntimestamps in seconds since the Unix epoch.\n\nSupports the common [`strftime`][chrono_strftime_specifiers] specifiers found in most\nlanguages.\n\nWhen set to an empty string, no timestamp is appended to the blob prefix.\n\n[chrono_strftime_specifiers]: https://docs.rs/chrono/latest/chrono/format/strftime/index.html#specifiers",
              "title": "The timestamp format for the time component of the blob key.",
              "type": [
                "string",
                "null"
              ]
            },
            "compression": {
              "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
              "_metadata": {
                "docs::human_name": "Compression"
              },
              "default": "gzip",
              "description": "All compression algorithms use the default compression level unless otherwise specified.",
              "title": "Compression configuration."
            },
            "connection_string": {
              "$ref": "#/definitions/core::option::Option<vector_common::sensitive_string::SensitiveString>",
              "_metadata": {
                "docs::examples": "DefaultEndpointsProtocol=https;AccountName=mylogstorage;AccountKey=storageaccountkeybase64encoded;EndpointSuffix=core.windows.net",
                "docs::human_name": "Connection String"
              },
              "description": "Authentication with access key is the only supported authentication method.\n\nEither `storage_account`, or this field, must be specified.",
              "title": "The Azure Blob Storage Account connection string."
            },
            "container_name": {
              "_metadata": {
                "docs::examples": "my-logs",
                "docs::human_name": "Container Name"
              },
              "description": "The Azure Blob Storage Account container name.",
              "type": "string"
            },
            "endpoint": {
              "_metadata": {
                "docs::examples": [
                  "https://test.blob.core.usgovcloudapi.net/",
                  "https://test.blob.core.windows.net/"
                ],
                "docs::human_name": "Endpoint",
                "docs::optional": true
              },
              "description": "This is used to override the default blob storage endpoint URL in cases where you are using\ncredentials read from the environment/managed identities or access tokens without using an\nexplicit connection_string (which already explicitly supports overriding the blob endpoint\nURL).\n\nThis may only be used with `storage_account` and is ignored when used with\n`connection_string`.",
              "title": "The Azure Blob Storage Endpoint URL.",
              "type": [
                "string",
                "null"
              ]
            },
            "request": {
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              },
              "default": {
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "initial_concurrency": 1,
                  "rtt_deviation_scale": 2.5
                },
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775808,
                "retry_attempts": 9223372036854775808,
                "retry_initial_backoff_secs": 1,
                "retry_max_duration_secs": 3600,
                "timeout_secs": 60
              },
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "title": "Middleware settings for outbound requests."
            },
            "storage_account": {
              "_metadata": {
                "docs::examples": "mylogstorage",
                "docs::human_name": "Storage Account",
                "docs::optional": true
              },
              "description": "Attempts to load credentials for the account in the following ways, in order:\n\n- read from environment variables ([more information][env_cred_docs])\n- looks for a [Managed Identity][managed_ident_docs]\n- uses the `az` CLI tool to get an access token ([more information][az_cli_docs])\n\nEither `connection_string`, or this field, must be specified.\n\n[env_cred_docs]: https://docs.rs/azure_identity/latest/azure_identity/struct.EnvironmentCredential.html\n[managed_ident_docs]: https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview\n[az_cli_docs]: https://docs.microsoft.com/en-us/cli/azure/account?view=azure-cli-latest#az-account-get-access-token",
              "title": "The Azure Blob Storage Account name.",
              "type": [
                "string",
                "null"
              ]
            }
          },
          "required": [
            "container_name"
          ],
          "type": "object"
        },
        {
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfigWithFraming",
          "description": "Encoding configuration."
        }
      ],
      "description": "Configuration for the `azure_blob` sink."
    },
    "vector::sinks::azure_monitor_logs::config::AzureMonitorLogsConfig": {
      "_metadata": {
        "docs::component_name": "azure_monitor_logs",
        "docs::component_type": "sink"
      },
      "description": "Configuration for the `azure_monitor_logs` sink.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled for this sink."
        },
        "azure_resource_id": {
          "_metadata": {
            "docs::examples": [
              "/subscriptions/11111111-1111-1111-1111-111111111111/resourceGroups/otherResourceGroup/providers/Microsoft.Storage/storageAccounts/examplestorage",
              "/subscriptions/11111111-1111-1111-1111-111111111111/resourceGroups/examplegroup/providers/Microsoft.SQL/servers/serverName/databases/databaseName"
            ],
            "docs::human_name": "Azure Resource ID",
            "docs::optional": true
          },
          "description": "[resource_id]: https://docs.microsoft.com/en-us/azure/azure-monitor/platform/data-collector-api#request-headers",
          "title": "The [Resource ID][resource_id] of the Azure resource the data should be associated with.",
          "type": [
            "string",
            "null"
          ]
        },
        "batch": {
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::RealtimeSizeBasedDefaultBatchSettings>",
          "_metadata": {
            "docs::human_name": "Batch"
          },
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "description": "Event batching behavior."
        },
        "customer_id": {
          "_metadata": {
            "docs::examples": [
              "5ce893d9-2c32-4b6c-91a9-b0887c2de2d6",
              "97ce69d9-b4be-4241-8dbd-d265edcf06c4"
            ],
            "docs::human_name": "Customer ID"
          },
          "description": "[uniq_id]: https://docs.microsoft.com/en-us/azure/azure-monitor/platform/data-collector-api#request-uri-parameters",
          "title": "The [unique identifier][uniq_id] for the Log Analytics workspace.",
          "type": "string"
        },
        "encoding": {
          "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer",
          "_metadata": {
            "docs::human_name": "Encoding"
          },
          "default": {},
          "description": "Transformations to prepare an event for serialization."
        },
        "host": {
          "_metadata": {
            "docs::examples": [
              "ods.opinsights.azure.us",
              "ods.opinsights.azure.cn"
            ],
            "docs::human_name": "Host"
          },
          "default": "ods.opinsights.azure.com",
          "description": "[alt_host]: https://docs.azure.cn/en-us/articles/guidance/developerdifferences#check-endpoints-in-azure",
          "title": "[Alternative host][alt_host] for dedicated Azure regions.",
          "type": "string"
        },
        "log_type": {
          "_metadata": {
            "docs::examples": [
              "MyTableName",
              "MyRecordType"
            ],
            "docs::human_name": "Log Type"
          },
          "description": "Can only contain letters, numbers, and underscores (_), and may not exceed 100 characters.\n\n[record_type]: https://docs.microsoft.com/en-us/azure/azure-monitor/platform/data-collector-api#request-headers",
          "pattern": "[a-zA-Z0-9_]{1,100}",
          "title": "The [record type][record_type] of the data that is being submitted.",
          "type": "string"
        },
        "request": {
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          },
          "default": {
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "initial_concurrency": 1,
              "rtt_deviation_scale": 2.5
            },
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775808,
            "retry_attempts": 9223372036854775808,
            "retry_initial_backoff_secs": 1,
            "retry_max_duration_secs": 3600,
            "timeout_secs": 60
          },
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "title": "Middleware settings for outbound requests."
        },
        "shared_key": {
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "docs::examples": [
              "SERsIYhgMVlJB6uPsq49gCxNiruf6v0vhMYE+lfzbSGcXjdViZdV/e5pEMTYtw9f8SkVLf4LFlLCc2KxtRZfCA==",
              "${AZURE_MONITOR_SHARED_KEY_ENV_VAR}"
            ],
            "docs::human_name": "Shared Key"
          },
          "description": "[shared_key]: https://docs.microsoft.com/en-us/azure/azure-monitor/platform/data-collector-api#authorization",
          "title": "The [primary or the secondary key][shared_key] for the Log Analytics workspace."
        },
        "time_generated_key": {
          "$ref": "#/definitions/core::option::Option<vector_lookup::lookup_v2::optional_path::OptionalValuePath>",
          "_metadata": {
            "docs::examples": "time_generated",
            "docs::human_name": "Time Generated Key"
          },
          "description": "The setting of `log_schema.timestamp_key`, usually `timestamp`, is used here by default.\nThis field should be used in rare cases where `TimeGenerated` should point to a specific log\nfield. For example, use this field to set the log field `source_timestamp` as holding the\nvalue that should be used as `TimeGenerated` on the Azure side.\n\n[1]: https://learn.microsoft.com/en-us/azure/azure-monitor/logs/log-standard-columns#timegenerated",
          "title": "Use this option to customize the log field used as [`TimeGenerated`][1] in Azure."
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "required": [
        "customer_id",
        "log_type",
        "shared_key"
      ],
      "type": "object"
    },
    "vector::sinks::blackhole::config::BlackholeConfig": {
      "_metadata": {
        "docs::component_name": "blackhole",
        "docs::component_type": "sink"
      },
      "default": {
        "print_interval_secs": 1,
        "rate": null
      },
      "description": "Configuration for the `blackhole` sink.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled for this sink."
        },
        "print_interval_secs": {
          "$ref": "#/definitions/serde_with::DurationSeconds",
          "_metadata": {
            "docs::examples": 10,
            "docs::human_name": "Print Interval"
          },
          "default": 1,
          "description": "Set to `0` to disable reporting.",
          "title": "The interval between reporting a summary of activity."
        },
        "rate": {
          "_metadata": {
            "docs::examples": 1000,
            "docs::human_name": "Rate",
            "docs::numeric_type": "uint",
            "docs::optional": true
          },
          "description": "By default, there is no limit.",
          "maximum": 9007199254740991,
          "minimum": 0,
          "title": "The number of events, per second, that the sink is allowed to consume.",
          "type": [
            "integer",
            "null"
          ]
        }
      },
      "type": "object"
    },
    "vector::sinks::clickhouse::config::ClickhouseConfig": {
      "_metadata": {
        "docs::component_name": "clickhouse",
        "docs::component_type": "sink"
      },
      "description": "Configuration for the `clickhouse` sink.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled for this sink."
        },
        "auth": {
          "$ref": "#/definitions/core::option::Option<vector::http::Auth>",
          "_metadata": {
            "docs::human_name": "Auth"
          }
        },
        "batch": {
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::RealtimeSizeBasedDefaultBatchSettings>",
          "_metadata": {
            "docs::human_name": "Batch"
          },
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "description": "Event batching behavior."
        },
        "compression": {
          "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
          "_metadata": {
            "docs::human_name": "Compression"
          },
          "default": "gzip",
          "description": "All compression algorithms use the default compression level unless otherwise specified.",
          "title": "Compression configuration."
        },
        "database": {
          "$ref": "#/definitions/core::option::Option<vector::template::Template>",
          "_metadata": {
            "docs::examples": "mydatabase",
            "docs::human_name": "Database"
          },
          "description": "The database that contains the table that data is inserted into."
        },
        "date_time_best_effort": {
          "_metadata": {
            "docs::human_name": "Date Time Best Effort"
          },
          "default": false,
          "description": "Sets `date_time_input_format` to `best_effort`, allowing ClickHouse to properly parse RFC3339/ISO 8601.",
          "type": "boolean"
        },
        "encoding": {
          "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer",
          "_metadata": {
            "docs::human_name": "Encoding"
          },
          "default": {},
          "description": "Transformations to prepare an event for serialization."
        },
        "endpoint": {
          "$ref": "#/definitions/vector::sinks::util::uri::UriSerde",
          "_metadata": {
            "docs::examples": "http://localhost:8123",
            "docs::human_name": "Endpoint"
          },
          "description": "The endpoint of the ClickHouse server."
        },
        "request": {
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          },
          "default": {
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "initial_concurrency": 1,
              "rtt_deviation_scale": 2.5
            },
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775808,
            "retry_attempts": 9223372036854775808,
            "retry_initial_backoff_secs": 1,
            "retry_max_duration_secs": 3600,
            "timeout_secs": 60
          },
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "title": "Middleware settings for outbound requests."
        },
        "skip_unknown_fields": {
          "_metadata": {
            "docs::human_name": "Skip Unknown Fields"
          },
          "default": false,
          "description": "Sets `input_format_skip_unknown_fields`, allowing ClickHouse to discard fields not present in the table schema.",
          "type": "boolean"
        },
        "table": {
          "$ref": "#/definitions/vector::template::Template",
          "_metadata": {
            "docs::examples": "mytable",
            "docs::human_name": "Table"
          },
          "description": "The table that data is inserted into."
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "required": [
        "endpoint",
        "table"
      ],
      "type": "object"
    },
    "vector::sinks::console::config::ConsoleSinkConfig": {
      "_metadata": {
        "docs::component_name": "console",
        "docs::component_type": "sink"
      },
      "allOf": [
        {
          "properties": {
            "acknowledgements": {
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              },
              "default": {
                "enabled": null
              },
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "title": "Controls how acknowledgements are handled for this sink."
            },
            "target": {
              "_metadata": {
                "docs::enum_tagging": "external",
                "docs::human_name": "Target"
              },
              "default": "stdout",
              "description": "[standard_streams]: https://en.wikipedia.org/wiki/Standard_streams",
              "oneOf": [
                {
                  "_metadata": {
                    "docs::human_name": "Stdout",
                    "logical_name": "Stdout"
                  },
                  "const": "stdout",
                  "description": "[stdout]: https://en.wikipedia.org/wiki/Standard_streams#Standard_output_(stdout)",
                  "title": "Write output to [STDOUT][stdout]."
                },
                {
                  "_metadata": {
                    "docs::human_name": "Stderr",
                    "logical_name": "Stderr"
                  },
                  "const": "stderr",
                  "description": "[stderr]: https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)",
                  "title": "Write output to [STDERR][stderr]."
                }
              ],
              "title": "The [standard stream][standard_streams] to write to.",
              "unevaluatedProperties": false
            }
          },
          "type": "object"
        },
        {
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfigWithFraming",
          "description": "Encoding configuration."
        }
      ],
      "description": "Configuration for the `console` sink."
    },
    "vector::sinks::databend::config::DatabendConfig": {
      "_metadata": {
        "docs::component_name": "databend",
        "docs::component_type": "sink"
      },
      "description": "Configuration for the `databend` sink.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled for this sink."
        },
        "auth": {
          "$ref": "#/definitions/core::option::Option<vector::http::Auth>",
          "_metadata": {
            "docs::human_name": "Auth"
          }
        },
        "batch": {
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::RealtimeSizeBasedDefaultBatchSettings>",
          "_metadata": {
            "docs::human_name": "Batch"
          },
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "description": "Event batching behavior."
        },
        "compression": {
          "_metadata": {
            "docs::enum_tag_description": "The compression algorithm to use for sending.",
            "docs::enum_tagging": "external",
            "docs::human_name": "Compression"
          },
          "default": "none",
          "description": "Compression configuration.",
          "oneOf": [
            {
              "_metadata": {
                "docs::human_name": "None",
                "logical_name": "None"
              },
              "const": "none",
              "description": "No compression."
            },
            {
              "_metadata": {
                "docs::human_name": "Gzip",
                "logical_name": "Gzip"
              },
              "const": "gzip",
              "description": "[gzip]: https://www.gzip.org/",
              "title": "[Gzip][gzip] compression."
            }
          ],
          "unevaluatedProperties": false
        },
        "database": {
          "_metadata": {
            "docs::examples": "mydatabase",
            "docs::human_name": "Database"
          },
          "default": "default",
          "description": "The database that contains the table that data is inserted into.",
          "type": "string"
        },
        "encoding": {
          "_metadata": {
            "docs::human_name": "Encoding"
          },
          "allOf": [
            {
              "_metadata": {
                "docs::enum_tag_description": "The codec to use for encoding events.",
                "docs::enum_tag_field": "codec",
                "docs::enum_tagging": "internal"
              },
              "description": "Serializer configuration for Databend.",
              "oneOf": [
                {
                  "_metadata": {
                    "docs::human_name": "CSV",
                    "logical_name": "Csv"
                  },
                  "allOf": [
                    {
                      "$ref": "#/definitions/codecs::encoding::format::csv::CsvSerializerConfig",
                      "description": "Options for the CSV encoder."
                    },
                    {
                      "properties": {
                        "codec": {
                          "_metadata": {
                            "docs::human_name": "Codec"
                          },
                          "const": "csv",
                          "description": "This codec must be configured with fields to encode.",
                          "title": "Encodes an event as a CSV message."
                        }
                      },
                      "required": [
                        "codec"
                      ],
                      "type": "object"
                    }
                  ],
                  "description": "This codec must be configured with fields to encode.",
                  "title": "Encodes an event as a CSV message."
                },
                {
                  "_metadata": {
                    "docs::human_name": "JSON",
                    "logical_name": "Json"
                  },
                  "allOf": [
                    {
                      "$ref": "#/definitions/codecs::encoding::format::json::JsonSerializerConfig",
                      "description": "Encoding options specific to the Json serializer."
                    },
                    {
                      "properties": {
                        "codec": {
                          "_metadata": {
                            "docs::human_name": "Codec"
                          },
                          "const": "json",
                          "description": "[json]: https://www.json.org/",
                          "title": "Encodes an event as [JSON][json]."
                        }
                      },
                      "required": [
                        "codec"
                      ],
                      "type": "object"
                    }
                  ],
                  "description": "[json]: https://www.json.org/",
                  "title": "Encodes an event as [JSON][json]."
                }
              ]
            },
            {
              "description": "Transformations to prepare an event for serialization.",
              "properties": {
                "except_fields": {
                  "_metadata": {
                    "docs::human_name": "Except Fields",
                    "docs::optional": true
                  },
                  "default": null,
                  "description": "List of fields that are excluded from the encoded event.",
                  "items": {
                    "$ref": "#/definitions/vector_lookup::lookup_v2::ConfigValuePath"
                  },
                  "type": [
                    "array",
                    "null"
                  ]
                },
                "only_fields": {
                  "_metadata": {
                    "docs::human_name": "Only Fields",
                    "docs::optional": true
                  },
                  "default": null,
                  "description": "List of fields that are included in the encoded event.",
                  "items": {
                    "$ref": "#/definitions/vector_lookup::lookup_v2::ConfigValuePath"
                  },
                  "type": [
                    "array",
                    "null"
                  ]
                },
                "timestamp_format": {
                  "_metadata": {
                    "docs::human_name": "Timestamp Format",
                    "docs::optional": true
                  },
                  "default": null,
                  "description": "Format used for timestamp fields.",
                  "oneOf": [
                    {
                      "type": "null"
                    },
                    {
                      "_metadata": {
                        "docs::enum_tagging": "external"
                      },
                      "description": "The format in which a timestamp should be represented.",
                      "oneOf": [
                        {
                          "_metadata": {
                            "docs::human_name": "Unix",
                            "logical_name": "Unix"
                          },
                          "const": "unix",
                          "description": "Represent the timestamp as a Unix timestamp."
                        },
                        {
                          "_metadata": {
                            "docs::human_name": "RFC3339",
                            "logical_name": "Rfc3339"
                          },
                          "const": "rfc3339",
                          "description": "Represent the timestamp as a RFC 3339 timestamp."
                        }
                      ]
                    }
                  ],
                  "unevaluatedProperties": false
                }
              },
              "type": "object"
            }
          ],
          "default": {
            "codec": "json"
          },
          "description": "Configures how events are encoded into raw bytes.",
          "unevaluatedProperties": false
        },
        "endpoint": {
          "$ref": "#/definitions/vector::sinks::util::uri::UriSerde",
          "_metadata": {
            "docs::examples": "http://localhost:8000",
            "docs::human_name": "Endpoint"
          },
          "description": "The endpoint of the Databend server."
        },
        "request": {
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          },
          "default": {
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "initial_concurrency": 1,
              "rtt_deviation_scale": 2.5
            },
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775808,
            "retry_attempts": 9223372036854775808,
            "retry_initial_backoff_secs": 1,
            "retry_max_duration_secs": 3600,
            "timeout_secs": 60
          },
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "title": "Middleware settings for outbound requests."
        },
        "table": {
          "_metadata": {
            "docs::examples": "mytable",
            "docs::human_name": "Table"
          },
          "description": "The table that data is inserted into.",
          "type": "string"
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "required": [
        "endpoint",
        "table"
      ],
      "type": "object"
    },
    "vector::sinks::datadog::DatadogCommonConfig": {
      "description": "Shared configuration for Datadog sinks.\nContains the maximum set of common settings that applies to all DD sink components.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled for this sink."
        },
        "default_api_key": {
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "docs::examples": [
              "${DATADOG_API_KEY_ENV_VAR}",
              "ef8d5de700e7989468166c40fc8a0ccd"
            ],
            "docs::human_name": "Default API Key"
          },
          "description": "If an event has a Datadog [API key][api_key] set explicitly in its metadata, it takes\nprecedence over this setting.\n\n[api_key]: https://docs.datadoghq.com/api/?lang=bash#authentication",
          "title": "The default Datadog [API key][api_key] to use in authentication of HTTP requests."
        },
        "endpoint": {
          "_metadata": {
            "docs::advanced": true,
            "docs::examples": [
              "http://127.0.0.1:8080",
              "http://example.com:12345"
            ],
            "docs::human_name": "Endpoint",
            "docs::optional": true
          },
          "default": null,
          "description": "The endpoint must contain an HTTP scheme, and may specify a\nhostname or IP address and port.\n\nIf set, overrides the `site` option.",
          "title": "The endpoint to send observability data to.",
          "type": [
            "string",
            "null"
          ]
        },
        "site": {
          "_metadata": {
            "docs::examples": [
              "us3.datadoghq.com",
              "datadoghq.eu"
            ],
            "docs::human_name": "Site"
          },
          "default": "datadoghq.com",
          "description": "[dd_site]: https://docs.datadoghq.com/getting_started/site",
          "title": "The Datadog [site][dd_site] to send observability data to.",
          "type": "string"
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          },
          "default": null
        }
      },
      "required": [
        "default_api_key"
      ],
      "type": "object"
    },
    "vector::sinks::datadog::events::config::DatadogEventsConfig": {
      "_metadata": {
        "docs::component_name": "datadog_events",
        "docs::component_type": "sink"
      },
      "allOf": [
        {
          "properties": {
            "region": {
              "$ref": "#/definitions/core::option::Option<vector::common::datadog::Region>",
              "_metadata": {
                "deprecated_message": "This option has been deprecated, use the `site` option instead.",
                "docs::human_name": "Region"
              },
              "default": null,
              "deprecated": true,
              "description": "The Datadog region to send events to."
            },
            "request": {
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              },
              "default": {
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "initial_concurrency": 1,
                  "rtt_deviation_scale": 2.5
                },
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775808,
                "retry_attempts": 9223372036854775808,
                "retry_initial_backoff_secs": 1,
                "retry_max_duration_secs": 3600,
                "timeout_secs": 60
              },
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "title": "Middleware settings for outbound requests."
            }
          },
          "type": "object"
        },
        {
          "$ref": "#/definitions/vector::sinks::datadog::DatadogCommonConfig",
          "description": "Shared configuration for Datadog sinks.\nContains the maximum set of common settings that applies to all DD sink components."
        }
      ],
      "description": "Configuration for the `datadog_events` sink."
    },
    "vector::sinks::datadog::logs::config::DatadogLogsConfig": {
      "_metadata": {
        "docs::component_name": "datadog_logs",
        "docs::component_type": "sink"
      },
      "allOf": [
        {
          "properties": {
            "batch": {
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Batch"
              },
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "description": "Event batching behavior.",
              "properties": {
                "max_bytes": {
                  "_metadata": {
                    "docs::human_name": "Max Bytes",
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes"
                  },
                  "default": 4250000,
                  "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "title": "The maximum size of a batch that is processed by a sink.",
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "max_events": {
                  "_metadata": {
                    "docs::human_name": "Max Events",
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "events"
                  },
                  "default": 1000,
                  "description": "The maximum size of a batch before it is flushed.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "timeout_secs": {
                  "_metadata": {
                    "docs::human_name": "Timeout",
                    "docs::numeric_type": "float",
                    "docs::optional": true,
                    "docs::type_unit": "seconds"
                  },
                  "default": 5,
                  "description": "The maximum age of a batch before it is flushed.",
                  "maximum": 9007199254740991,
                  "minimum": -9007199254740991,
                  "type": [
                    "number",
                    "null"
                  ]
                }
              },
              "type": "object",
              "unevaluatedProperties": false
            },
            "compression": {
              "$ref": "#/definitions/core::option::Option<vector::sinks::util::buffer::compression::Compression>",
              "_metadata": {
                "docs::human_name": "Compression"
              },
              "default": null
            },
            "encoding": {
              "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer",
              "_metadata": {
                "docs::human_name": "Encoding"
              },
              "default": {},
              "description": "Transformations to prepare an event for serialization."
            },
            "region": {
              "$ref": "#/definitions/core::option::Option<vector::common::datadog::Region>",
              "_metadata": {
                "deprecated_message": "This option has been deprecated, use the `site` option instead.",
                "docs::human_name": "Region"
              },
              "default": null,
              "deprecated": true,
              "description": "The Datadog region to send logs to."
            },
            "request": {
              "$ref": "#/definitions/vector::sinks::util::http::RequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              },
              "default": {
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "initial_concurrency": 1,
                  "rtt_deviation_scale": 2.5
                },
                "headers": {},
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775808,
                "retry_attempts": 9223372036854775808,
                "retry_initial_backoff_secs": 1,
                "retry_max_duration_secs": 3600,
                "timeout_secs": 60
              },
              "description": "Outbound HTTP request settings."
            }
          },
          "type": "object"
        },
        {
          "$ref": "#/definitions/vector::sinks::datadog::DatadogCommonConfig",
          "description": "Shared configuration for Datadog sinks.\nContains the maximum set of common settings that applies to all DD sink components."
        }
      ],
      "description": "Configuration for the `datadog_logs` sink."
    },
    "vector::sinks::datadog::metrics::config::DatadogMetricsConfig": {
      "_metadata": {
        "docs::component_name": "datadog_metrics",
        "docs::component_type": "sink"
      },
      "allOf": [
        {
          "properties": {
            "batch": {
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Batch"
              },
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "description": "Event batching behavior.",
              "properties": {
                "max_bytes": {
                  "_metadata": {
                    "docs::human_name": "Max Bytes",
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes"
                  },
                  "default": null,
                  "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "title": "The maximum size of a batch that is processed by a sink.",
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "max_events": {
                  "_metadata": {
                    "docs::human_name": "Max Events",
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "events"
                  },
                  "default": 100000,
                  "description": "The maximum size of a batch before it is flushed.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "timeout_secs": {
                  "_metadata": {
                    "docs::human_name": "Timeout",
                    "docs::numeric_type": "float",
                    "docs::optional": true,
                    "docs::type_unit": "seconds"
                  },
                  "default": 2,
                  "description": "The maximum age of a batch before it is flushed.",
                  "maximum": 9007199254740991,
                  "minimum": -9007199254740991,
                  "type": [
                    "number",
                    "null"
                  ]
                }
              },
              "type": "object",
              "unevaluatedProperties": false
            },
            "default_namespace": {
              "_metadata": {
                "docs::examples": "myservice",
                "docs::human_name": "Default Namespace",
                "docs::optional": true
              },
              "default": null,
              "description": "This namespace is only used if a metric has no existing namespace. When a namespace is\npresent, it is used as a prefix to the metric name, and separated with a period (`.`).",
              "title": "Sets the default namespace for any metrics sent.",
              "type": [
                "string",
                "null"
              ]
            },
            "region": {
              "$ref": "#/definitions/core::option::Option<vector::common::datadog::Region>",
              "_metadata": {
                "deprecated_message": "This option has been deprecated, use the `site` option instead.",
                "docs::human_name": "Region"
              },
              "default": null,
              "deprecated": true,
              "description": "The Datadog region to send metrics to."
            },
            "request": {
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              },
              "default": {
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "initial_concurrency": 1,
                  "rtt_deviation_scale": 2.5
                },
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775808,
                "retry_attempts": 9223372036854775808,
                "retry_initial_backoff_secs": 1,
                "retry_max_duration_secs": 3600,
                "timeout_secs": 60
              },
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "title": "Middleware settings for outbound requests."
            }
          },
          "type": "object"
        },
        {
          "$ref": "#/definitions/vector::sinks::datadog::DatadogCommonConfig",
          "description": "Shared configuration for Datadog sinks.\nContains the maximum set of common settings that applies to all DD sink components."
        }
      ],
      "description": "Configuration for the `datadog_metrics` sink."
    },
    "vector::sinks::datadog::traces::config::DatadogTracesConfig": {
      "_metadata": {
        "docs::component_name": "datadog_traces",
        "docs::component_type": "sink"
      },
      "allOf": [
        {
          "properties": {
            "batch": {
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Batch"
              },
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "description": "Event batching behavior.",
              "properties": {
                "max_bytes": {
                  "_metadata": {
                    "docs::human_name": "Max Bytes",
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes"
                  },
                  "default": 3000000,
                  "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "title": "The maximum size of a batch that is processed by a sink.",
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "max_events": {
                  "_metadata": {
                    "docs::human_name": "Max Events",
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "events"
                  },
                  "default": 1000,
                  "description": "The maximum size of a batch before it is flushed.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "timeout_secs": {
                  "_metadata": {
                    "docs::human_name": "Timeout",
                    "docs::numeric_type": "float",
                    "docs::optional": true,
                    "docs::type_unit": "seconds"
                  },
                  "default": 10,
                  "description": "The maximum age of a batch before it is flushed.",
                  "maximum": 9007199254740991,
                  "minimum": -9007199254740991,
                  "type": [
                    "number",
                    "null"
                  ]
                }
              },
              "type": "object",
              "unevaluatedProperties": false
            },
            "compression": {
              "$ref": "#/definitions/core::option::Option<vector::sinks::util::buffer::compression::Compression>",
              "_metadata": {
                "docs::human_name": "Compression"
              },
              "default": null
            },
            "request": {
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              },
              "default": {
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "initial_concurrency": 1,
                  "rtt_deviation_scale": 2.5
                },
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775808,
                "retry_attempts": 9223372036854775808,
                "retry_initial_backoff_secs": 1,
                "retry_max_duration_secs": 3600,
                "timeout_secs": 60
              },
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "title": "Middleware settings for outbound requests."
            }
          },
          "type": "object"
        },
        {
          "$ref": "#/definitions/vector::sinks::datadog::DatadogCommonConfig",
          "description": "Shared configuration for Datadog sinks.\nContains the maximum set of common settings that applies to all DD sink components."
        }
      ],
      "description": "Configuration for the `datadog_traces` sink."
    },
    "vector::sinks::elasticsearch::config::ElasticsearchConfig": {
      "_metadata": {
        "docs::component_name": "elasticsearch",
        "docs::component_type": "sink"
      },
      "description": "Configuration for the `elasticsearch` sink.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled for this sink."
        },
        "api_version": {
          "_metadata": {
            "docs::enum_tagging": "external",
            "docs::human_name": "API Version"
          },
          "default": "auto",
          "description": "The API version of Elasticsearch.",
          "oneOf": [
            {
              "_metadata": {
                "docs::human_name": "Auto",
                "logical_name": "Auto"
              },
              "const": "auto",
              "description": "If the [cluster state version endpoint][es_version] isn't reachable, a warning is logged to\nstdout, and the version is assumed to be V6 if the `suppress_type_name` option is set to\n`true`. Otherwise, the version is assumed to be V8. In the future, the sink instead\nreturns an error during configuration parsing, since a wrongly assumed version could lead to\nincorrect API calls.\n\n[es_version]: https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-state.html#cluster-state-api-path-params",
              "title": "Auto-detect the API version."
            },
            {
              "_metadata": {
                "docs::human_name": "V6",
                "logical_name": "V6"
              },
              "const": "v6",
              "description": "Use the Elasticsearch 6.x API."
            },
            {
              "_metadata": {
                "docs::human_name": "V7",
                "logical_name": "V7"
              },
              "const": "v7",
              "description": "Use the Elasticsearch 7.x API."
            },
            {
              "_metadata": {
                "docs::human_name": "V8",
                "logical_name": "V8"
              },
              "const": "v8",
              "description": "Use the Elasticsearch 8.x API."
            }
          ],
          "unevaluatedProperties": false
        },
        "auth": {
          "_metadata": {
            "docs::human_name": "Auth",
            "docs::optional": true
          },
          "description": "Elasticsearch Authentication strategies.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "_metadata": {
                "docs::enum_tag_description": "The authentication strategy to use.",
                "docs::enum_tag_field": "strategy",
                "docs::enum_tagging": "internal"
              },
              "description": "Elasticsearch Authentication strategies.",
              "oneOf": [
                {
                  "_metadata": {
                    "docs::human_name": "Basic",
                    "logical_name": "Basic"
                  },
                  "description": "HTTP Basic Authentication.",
                  "properties": {
                    "password": {
                      "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
                      "_metadata": {
                        "docs::examples": [
                          "${ELASTICSEARCH_PASSWORD}",
                          "password"
                        ],
                        "docs::human_name": "Password"
                      },
                      "description": "Basic authentication password."
                    },
                    "strategy": {
                      "_metadata": {
                        "docs::human_name": "Strategy"
                      },
                      "const": "basic",
                      "description": "HTTP Basic Authentication."
                    },
                    "user": {
                      "_metadata": {
                        "docs::examples": [
                          "${ELASTICSEARCH_USERNAME}",
                          "username"
                        ],
                        "docs::human_name": "User"
                      },
                      "description": "Basic authentication username.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "password",
                    "strategy",
                    "user"
                  ],
                  "type": "object"
                },
                {
                  "_metadata": {
                    "docs::human_name": "AWS",
                    "logical_name": "Aws"
                  },
                  "allOf": [
                    {
                      "_metadata": {
                        "docs::enum_tagging": "untagged"
                      },
                      "anyOf": [
                        {
                          "_metadata": {
                            "docs::human_name": "Access Key",
                            "logical_name": "AccessKey"
                          },
                          "description": "Authenticate using a fixed access key and secret pair.",
                          "properties": {
                            "access_key_id": {
                              "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
                              "_metadata": {
                                "docs::examples": "AKIAIOSFODNN7EXAMPLE",
                                "docs::human_name": "Access Key ID"
                              },
                              "description": "The AWS access key ID."
                            },
                            "assume_role": {
                              "_metadata": {
                                "docs::examples": "arn:aws:iam::123456789098:role/my_role",
                                "docs::human_name": "Assume Role",
                                "docs::optional": true
                              },
                              "description": "[iam_role]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html",
                              "title": "The ARN of an [IAM role][iam_role] to assume.",
                              "type": [
                                "string",
                                "null"
                              ]
                            },
                            "external_id": {
                              "_metadata": {
                                "docs::examples": "randomEXAMPLEidString",
                                "docs::human_name": "External ID",
                                "docs::optional": true
                              },
                              "description": "[external_id]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html",
                              "title": "The optional unique external ID in conjunction with role to assume.",
                              "type": [
                                "string",
                                "null"
                              ]
                            },
                            "region": {
                              "_metadata": {
                                "docs::examples": "us-west-2",
                                "docs::human_name": "Region",
                                "docs::optional": true
                              },
                              "description": "If not set, this will default to the configured region\nfor the service itself.\n\n[aws_region]: https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints",
                              "title": "The [AWS region][aws_region] to send STS requests to.",
                              "type": [
                                "string",
                                "null"
                              ]
                            },
                            "secret_access_key": {
                              "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
                              "_metadata": {
                                "docs::examples": "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY",
                                "docs::human_name": "Secret Access Key"
                              },
                              "description": "The AWS secret access key."
                            }
                          },
                          "required": [
                            "access_key_id",
                            "secret_access_key"
                          ],
                          "type": "object"
                        },
                        {
                          "_metadata": {
                            "docs::human_name": "File",
                            "logical_name": "File"
                          },
                          "description": "Additionally, the specific credential profile to use can be set.\nThe file format must match the credentials file format outlined in\n<https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html>.",
                          "properties": {
                            "credentials_file": {
                              "_metadata": {
                                "docs::examples": "/my/aws/credentials",
                                "docs::human_name": "Credentials File"
                              },
                              "description": "Path to the credentials file.",
                              "type": "string"
                            },
                            "profile": {
                              "_metadata": {
                                "docs::examples": "develop",
                                "docs::human_name": "Profile"
                              },
                              "default": "default",
                              "description": "Used to select AWS credentials from a provided credentials file.",
                              "title": "The credentials profile to use.",
                              "type": "string"
                            }
                          },
                          "required": [
                            "credentials_file"
                          ],
                          "title": "Authenticate using credentials stored in a file.",
                          "type": "object"
                        },
                        {
                          "_metadata": {
                            "docs::human_name": "Role",
                            "logical_name": "Role"
                          },
                          "description": "Assume the given role ARN.",
                          "properties": {
                            "assume_role": {
                              "_metadata": {
                                "docs::examples": "arn:aws:iam::123456789098:role/my_role",
                                "docs::human_name": "Assume Role"
                              },
                              "description": "[iam_role]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html",
                              "title": "The ARN of an [IAM role][iam_role] to assume.",
                              "type": "string"
                            },
                            "external_id": {
                              "_metadata": {
                                "docs::examples": "randomEXAMPLEidString",
                                "docs::human_name": "External ID",
                                "docs::optional": true
                              },
                              "description": "[external_id]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html",
                              "title": "The optional unique external ID in conjunction with role to assume.",
                              "type": [
                                "string",
                                "null"
                              ]
                            },
                            "imds": {
                              "_metadata": {
                                "docs::human_name": "IMDS"
                              },
                              "default": {
                                "connect_timeout_seconds": 1,
                                "max_attempts": 4,
                                "read_timeout_seconds": 1
                              },
                              "description": "Configuration for authenticating with AWS through IMDS.",
                              "properties": {
                                "connect_timeout_seconds": {
                                  "$ref": "#/definitions/serde_with::DurationSeconds",
                                  "_metadata": {
                                    "docs::human_name": "Connect Timeout Seconds"
                                  },
                                  "default": 1,
                                  "description": "Connect timeout for IMDS."
                                },
                                "max_attempts": {
                                  "_metadata": {
                                    "docs::human_name": "Max Attempts",
                                    "docs::numeric_type": "uint"
                                  },
                                  "default": 4,
                                  "description": "Number of IMDS retries for fetching tokens and metadata.",
                                  "maximum": 4294967295,
                                  "minimum": 0,
                                  "type": "integer"
                                },
                                "read_timeout_seconds": {
                                  "$ref": "#/definitions/serde_with::DurationSeconds",
                                  "_metadata": {
                                    "docs::human_name": "Read Timeout Seconds"
                                  },
                                  "default": 1,
                                  "description": "Read timeout for IMDS."
                                }
                              },
                              "type": "object",
                              "unevaluatedProperties": false
                            },
                            "load_timeout_secs": {
                              "_metadata": {
                                "docs::examples": 30,
                                "docs::human_name": "Load Timeout",
                                "docs::numeric_type": "uint",
                                "docs::optional": true,
                                "docs::type_unit": "seconds"
                              },
                              "description": "Relevant when the default credentials chain or `assume_role` is used.",
                              "maximum": 9007199254740991,
                              "minimum": 0,
                              "title": "Timeout for assuming the role, in seconds.",
                              "type": [
                                "integer",
                                "null"
                              ]
                            },
                            "region": {
                              "_metadata": {
                                "docs::examples": "us-west-2",
                                "docs::human_name": "Region",
                                "docs::optional": true
                              },
                              "description": "If not set, this defaults to the configured region\nfor the service itself.\n\n[aws_region]: https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints",
                              "title": "The [AWS region][aws_region] to send STS requests to.",
                              "type": [
                                "string",
                                "null"
                              ]
                            }
                          },
                          "required": [
                            "assume_role"
                          ],
                          "type": "object"
                        }
                      ],
                      "description": "Configuration of the authentication strategy for interacting with AWS services."
                    },
                    {
                      "properties": {
                        "strategy": {
                          "_metadata": {
                            "docs::human_name": "Strategy"
                          },
                          "const": "aws",
                          "description": "Amazon OpenSearch Service-specific authentication."
                        }
                      },
                      "required": [
                        "strategy"
                      ],
                      "type": "object"
                    }
                  ],
                  "description": "Amazon OpenSearch Service-specific authentication."
                }
              ]
            }
          ],
          "unevaluatedProperties": false
        },
        "aws": {
          "$ref": "#/definitions/core::option::Option<vector::aws::region::RegionOrEndpoint>",
          "_metadata": {
            "docs::human_name": "AWS"
          },
          "default": null
        },
        "batch": {
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::RealtimeSizeBasedDefaultBatchSettings>",
          "_metadata": {
            "docs::human_name": "Batch"
          },
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "description": "Event batching behavior."
        },
        "bulk": {
          "_metadata": {
            "docs::human_name": "Bulk"
          },
          "default": {
            "action": "index",
            "index": "vector-%Y.%m.%d"
          },
          "description": "Elasticsearch bulk mode configuration.",
          "properties": {
            "action": {
              "$ref": "#/definitions/vector::template::Template",
              "_metadata": {
                "docs::examples": [
                  "create",
                  "{{ action }}"
                ],
                "docs::human_name": "Action"
              },
              "default": "index",
              "description": "Only `index` and `create` actions are supported.\n\n[es_bulk]: https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html",
              "title": "Action to use when making requests to the [Elasticsearch Bulk API][es_bulk]."
            },
            "index": {
              "$ref": "#/definitions/vector::template::Template",
              "_metadata": {
                "docs::examples": [
                  "application-{{ application_id }}-%Y-%m-%d",
                  "{{ index }}"
                ],
                "docs::human_name": "Index"
              },
              "default": "vector-%Y.%m.%d",
              "description": "The name of the index to write events to."
            }
          },
          "type": "object",
          "unevaluatedProperties": false
        },
        "compression": {
          "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
          "_metadata": {
            "docs::human_name": "Compression"
          },
          "default": "none",
          "description": "All compression algorithms use the default compression level unless otherwise specified.",
          "title": "Compression configuration."
        },
        "data_stream": {
          "_metadata": {
            "docs::human_name": "Data Stream",
            "docs::optional": true
          },
          "default": null,
          "description": "Elasticsearch data stream mode configuration.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "description": "Elasticsearch data stream mode configuration.",
              "properties": {
                "auto_routing": {
                  "_metadata": {
                    "docs::human_name": "Auto Routing"
                  },
                  "default": true,
                  "description": "The format of the data stream name is `<type>-<dataset>-<namespace>`, where each value comes\nfrom the `data_stream` configuration field of the same name.\n\nIf enabled, the value of the `data_stream.type`, `data_stream.dataset`, and\n`data_stream.namespace` event fields are used if they are present. Otherwise, the values\nset in this configuration are used.",
                  "title": "Automatically routes events by deriving the data stream name using specific event fields.",
                  "type": "boolean"
                },
                "dataset": {
                  "$ref": "#/definitions/vector::template::Template",
                  "_metadata": {
                    "docs::examples": [
                      "generic",
                      "nginx",
                      "{{ service }}"
                    ],
                    "docs::human_name": "Dataset"
                  },
                  "default": "generic",
                  "description": "The data stream dataset used to construct the data stream at index time."
                },
                "namespace": {
                  "$ref": "#/definitions/vector::template::Template",
                  "_metadata": {
                    "docs::examples": "{{ environment }}",
                    "docs::human_name": "Namespace"
                  },
                  "default": "default",
                  "description": "The data stream namespace used to construct the data stream at index time."
                },
                "sync_fields": {
                  "_metadata": {
                    "docs::human_name": "Sync Fields"
                  },
                  "default": true,
                  "description": "This ensures that fields match the name of the data stream that is receiving events.",
                  "title": "Automatically adds and syncs the `data_stream.*` event fields if they are missing from the event.",
                  "type": "boolean"
                },
                "type": {
                  "$ref": "#/definitions/vector::template::Template",
                  "_metadata": {
                    "docs::examples": [
                      "metrics",
                      "synthetics",
                      "{{ type }}"
                    ],
                    "docs::human_name": "Type"
                  },
                  "default": "logs",
                  "description": "The data stream type used to construct the data stream at index time."
                }
              },
              "type": "object"
            }
          ],
          "unevaluatedProperties": false
        },
        "distribution": {
          "_metadata": {
            "docs::human_name": "Distribution",
            "docs::optional": true
          },
          "default": null,
          "description": "Options for determining the health of an endpoint.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "description": "Options for determining the health of an endpoint.",
              "properties": {
                "retry_initial_backoff_secs": {
                  "_metadata": {
                    "docs::human_name": "Retry Initial Backoff",
                    "docs::numeric_type": "uint",
                    "docs::type_unit": "seconds"
                  },
                  "default": 1,
                  "description": "Initial delay between attempts to reactivate endpoints once they become unhealthy.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "type": "integer"
                },
                "retry_max_duration_secs": {
                  "$ref": "#/definitions/serde_with::DurationSeconds",
                  "_metadata": {
                    "docs::human_name": "Max Retry Duration"
                  },
                  "default": 3600,
                  "description": "Maximum delay between attempts to reactivate endpoints once they become unhealthy."
                }
              },
              "type": "object"
            }
          ],
          "unevaluatedProperties": false
        },
        "doc_type": {
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Doc Type"
          },
          "default": "_doc",
          "description": "This is only relevant for Elasticsearch <= 6.X. If you are using >= 7.0 you do not need to\nset this option since Elasticsearch has removed it.\n\n[doc_type]: https://www.elastic.co/guide/en/elasticsearch/reference/6.8/actions-index.html",
          "title": "The [`doc_type`][doc_type] for your index data.",
          "type": "string"
        },
        "encoding": {
          "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Encoding"
          },
          "default": {},
          "description": "Transformations to prepare an event for serialization."
        },
        "endpoint": {
          "_metadata": {
            "deprecated_message": "This option has been deprecated, the `endpoints` option should be used instead.",
            "docs::human_name": "Endpoint",
            "docs::optional": true
          },
          "default": null,
          "deprecated": true,
          "description": "The endpoint must contain an HTTP scheme, and may specify a\nhostname or IP address and port.",
          "title": "The Elasticsearch endpoint to send logs to.",
          "type": [
            "string",
            "null"
          ]
        },
        "endpoints": {
          "_metadata": {
            "docs::examples": [
              "http://10.24.32.122:9000",
              "https://example.com",
              "https://user:password@example.com"
            ],
            "docs::human_name": "Endpoints"
          },
          "default": [],
          "description": "The endpoint must contain an HTTP scheme, and may specify a\nhostname or IP address and port.",
          "items": {
            "type": "string"
          },
          "title": "A list of Elasticsearch endpoints to send logs to.",
          "type": "array"
        },
        "id_key": {
          "$ref": "#/definitions/core::option::Option<vector_lookup::lookup_v2::ConfigValuePath>",
          "_metadata": {
            "docs::advanced": true,
            "docs::examples": [
              "id",
              "_id"
            ],
            "docs::human_name": "ID Key"
          },
          "default": null,
          "description": "By default, the `_id` field is not set, which allows Elasticsearch to set this\nautomatically. Setting your own Elasticsearch IDs can [hinder performance][perf_doc].\n\n[es_id]: https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-id-field.html\n[perf_doc]: https://www.elastic.co/guide/en/elasticsearch/reference/master/tune-for-indexing-speed.html#_use_auto_generated_ids",
          "title": "The name of the event key that should map to Elasticsearch’s [`_id` field][es_id]."
        },
        "metrics": {
          "_metadata": {
            "docs::human_name": "Metrics",
            "docs::optional": true
          },
          "default": null,
          "description": "Configuration for the `metric_to_log` transform.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::transforms::metric_to_log::MetricToLogConfig"
            }
          ],
          "unevaluatedProperties": false
        },
        "mode": {
          "_metadata": {
            "docs::enum_tagging": "external",
            "docs::human_name": "Mode"
          },
          "default": "bulk",
          "description": "Elasticsearch Indexing mode.",
          "oneOf": [
            {
              "_metadata": {
                "docs::human_name": "Bulk",
                "logical_name": "Bulk"
              },
              "const": "bulk",
              "description": "Ingests documents in bulk, using the bulk API `index` action."
            },
            {
              "_metadata": {
                "docs::human_name": "Data Stream",
                "logical_name": "DataStream"
              },
              "const": "data_stream",
              "description": "Elasticsearch Data Streams only support the `create` action.",
              "title": "Ingests documents in bulk, using the bulk API `create` action."
            }
          ],
          "unevaluatedProperties": false
        },
        "pipeline": {
          "_metadata": {
            "docs::advanced": true,
            "docs::examples": "pipeline-name",
            "docs::human_name": "Pipeline",
            "docs::optional": true
          },
          "default": null,
          "description": "The name of the pipeline to apply.",
          "type": [
            "string",
            "null"
          ]
        },
        "query": {
          "_metadata": {
            "docs::additional_props_description": "A query string parameter.",
            "docs::advanced": true,
            "docs::examples": {
              "X-Powered-By": "Vector"
            },
            "docs::human_name": "Query",
            "docs::optional": true
          },
          "additionalProperties": {
            "type": "string"
          },
          "default": null,
          "description": "Custom parameters to add to the query string for each HTTP request sent to Elasticsearch.",
          "type": [
            "object",
            "null"
          ]
        },
        "request": {
          "$ref": "#/definitions/vector::sinks::util::http::RequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          },
          "default": {
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "initial_concurrency": 1,
              "rtt_deviation_scale": 2.5
            },
            "headers": {},
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775808,
            "retry_attempts": 9223372036854775808,
            "retry_initial_backoff_secs": 1,
            "retry_max_duration_secs": 3600,
            "timeout_secs": 60
          },
          "description": "Outbound HTTP request settings."
        },
        "request_retry_partial": {
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Request Retry Partial"
          },
          "default": false,
          "description": "To avoid duplicates in Elasticsearch, please use option `id_key`.",
          "title": "Whether or not to retry successful requests containing partial failures.",
          "type": "boolean"
        },
        "suppress_type_name": {
          "_metadata": {
            "deprecated_message": "This option has been deprecated, the `api_version` option should be used instead.",
            "docs::human_name": "Suppress Type Name"
          },
          "default": false,
          "deprecated": true,
          "description": "The `type` field was deprecated in Elasticsearch 7.x and removed in Elasticsearch 8.x.\n\nIf enabled, the `doc_type` option is ignored.",
          "title": "Whether or not to send the `type` field to Elasticsearch.",
          "type": "boolean"
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          },
          "default": null
        }
      },
      "type": "object"
    },
    "vector::sinks::gcp::chronicle_unstructured::ChronicleUnstructuredConfig": {
      "_metadata": {
        "docs::component_name": "gcp_chronicle_unstructured",
        "docs::component_type": "sink"
      },
      "allOf": [
        {
          "properties": {
            "acknowledgements": {
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              },
              "default": {
                "enabled": null
              },
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "title": "Controls how acknowledgements are handled for this sink."
            },
            "batch": {
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Batch"
              },
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "description": "Event batching behavior.",
              "properties": {
                "max_bytes": {
                  "_metadata": {
                    "docs::human_name": "Max Bytes",
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes"
                  },
                  "default": 1000000,
                  "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "title": "The maximum size of a batch that is processed by a sink.",
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "max_events": {
                  "_metadata": {
                    "docs::human_name": "Max Events",
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "events"
                  },
                  "default": null,
                  "description": "The maximum size of a batch before it is flushed.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "timeout_secs": {
                  "_metadata": {
                    "docs::human_name": "Timeout",
                    "docs::numeric_type": "float",
                    "docs::optional": true,
                    "docs::type_unit": "seconds"
                  },
                  "default": 15,
                  "description": "The maximum age of a batch before it is flushed.",
                  "maximum": 9007199254740991,
                  "minimum": -9007199254740991,
                  "type": [
                    "number",
                    "null"
                  ]
                }
              },
              "type": "object",
              "unevaluatedProperties": false
            },
            "customer_id": {
              "_metadata": {
                "docs::examples": "c8c65bfa-5f2c-42d4-9189-64bb7b939f2c",
                "docs::human_name": "Customer ID"
              },
              "description": "The Unique identifier (UUID) corresponding to the Chronicle instance.",
              "format": "uuid",
              "type": "string"
            },
            "encoding": {
              "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
              "_metadata": {
                "docs::human_name": "Encoding"
              },
              "description": "Configures how events are encoded into raw bytes."
            },
            "endpoint": {
              "_metadata": {
                "docs::examples": [
                  "127.0.0.1:8080",
                  "example.com:12345"
                ],
                "docs::human_name": "Endpoint",
                "docs::optional": true
              },
              "description": "The endpoint to send data to.",
              "type": [
                "string",
                "null"
              ]
            },
            "log_type": {
              "$ref": "#/definitions/vector::template::Template",
              "_metadata": {
                "docs::examples": [
                  "WINDOWS_DNS",
                  "{{ log_type }}"
                ],
                "docs::human_name": "Log Type"
              },
              "description": "This must be one of the [supported log types][unstructured_log_types_doc], otherwise\nChronicle rejects the entry with an error.\n\n[unstructured_log_types_doc]: https://cloud.google.com/chronicle/docs/ingestion/parser-list/supported-default-parsers",
              "title": "The type of log entries in a request."
            },
            "region": {
              "_metadata": {
                "docs::human_name": "Region",
                "docs::optional": true
              },
              "description": "The GCP region to use.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "_metadata": {
                    "docs::enum_tagging": "external"
                  },
                  "description": "Google Chronicle regions.",
                  "oneOf": [
                    {
                      "_metadata": {
                        "docs::human_name": "EU",
                        "logical_name": "Eu"
                      },
                      "const": "eu",
                      "description": "EU region."
                    },
                    {
                      "_metadata": {
                        "docs::human_name": "US",
                        "logical_name": "Us"
                      },
                      "const": "us",
                      "description": "US region."
                    },
                    {
                      "_metadata": {
                        "docs::human_name": "Asia",
                        "logical_name": "Asia"
                      },
                      "const": "asia",
                      "description": "APAC region."
                    }
                  ]
                }
              ],
              "unevaluatedProperties": false
            },
            "request": {
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              },
              "default": {
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "initial_concurrency": 1,
                  "rtt_deviation_scale": 2.5
                },
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775808,
                "retry_attempts": 9223372036854775808,
                "retry_initial_backoff_secs": 1,
                "retry_max_duration_secs": 3600,
                "timeout_secs": 60
              },
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "title": "Middleware settings for outbound requests."
            },
            "tls": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              }
            }
          },
          "required": [
            "customer_id",
            "encoding",
            "log_type"
          ],
          "type": "object"
        },
        {
          "$ref": "#/definitions/vector::gcp::GcpAuthConfig",
          "description": "Configuration of the authentication strategy for interacting with GCP services."
        }
      ],
      "description": "Configuration for the `gcp_chronicle_unstructured` sink."
    },
    "vector::sinks::gcp::cloud_storage::GcsSinkConfig": {
      "_metadata": {
        "docs::component_name": "gcp_cloud_storage",
        "docs::component_type": "sink"
      },
      "allOf": [
        {
          "properties": {
            "acknowledgements": {
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              },
              "default": {
                "enabled": null
              },
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "title": "Controls how acknowledgements are handled for this sink."
            },
            "acl": {
              "$ref": "#/definitions/core::option::Option<vector::sinks::gcs_common::config::GcsPredefinedAcl>",
              "_metadata": {
                "docs::human_name": "ACL"
              },
              "description": "For more information, see [Predefined ACLs][predefined_acls].\n\n[predefined_acls]: https://cloud.google.com/storage/docs/access-control/lists#predefined-acl",
              "title": "The Predefined ACL to apply to created objects."
            },
            "batch": {
              "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::BulkSizeBasedDefaultBatchSettings>",
              "_metadata": {
                "docs::human_name": "Batch"
              },
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "description": "Event batching behavior."
            },
            "bucket": {
              "_metadata": {
                "docs::examples": "my-bucket",
                "docs::human_name": "Bucket"
              },
              "description": "The GCS bucket name.",
              "type": "string"
            },
            "compression": {
              "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
              "_metadata": {
                "docs::human_name": "Compression"
              },
              "default": "none",
              "description": "All compression algorithms use the default compression level unless otherwise specified.",
              "title": "Compression configuration."
            },
            "filename_append_uuid": {
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Filename Append UUID"
              },
              "default": true,
              "description": "The UUID is appended to the timestamp portion of the object key, such that if the object key\ngenerated is `date=2022-07-18/1658176486`, setting this field to `true` results\nin an object key that looks like `date=2022-07-18/1658176486-30f6652c-71da-4f9f-800d-a1189c47c547`.\n\nThis ensures there are no name collisions, and can be useful in high-volume workloads where\nobject keys must be unique.",
              "title": "Whether or not to append a UUID v4 token to the end of the object key.",
              "type": "boolean"
            },
            "filename_extension": {
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Filename Extension",
                "docs::optional": true
              },
              "description": "If not specified, the extension is determined by the compression scheme used.",
              "title": "The filename extension to use in the object key.",
              "type": [
                "string",
                "null"
              ]
            },
            "filename_time_format": {
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Filename Time Format"
              },
              "default": "%s",
              "description": "By default, object keys are appended with a timestamp that reflects when the objects are\nsent to S3, such that the resulting object key is functionally equivalent to joining the key\nprefix with the formatted timestamp, such as `date=2022-07-18/1658176486`.\n\nThis would represent a `key_prefix` set to `date=%F/` and the timestamp of Mon Jul 18 2022\n20:34:44 GMT+0000, with the `filename_time_format` being set to `%s`, which renders\ntimestamps in seconds since the Unix epoch.\n\nSupports the common [`strftime`][chrono_strftime_specifiers] specifiers found in most\nlanguages.\n\nWhen set to an empty string, no timestamp is appended to the key prefix.\n\n[chrono_strftime_specifiers]: https://docs.rs/chrono/latest/chrono/format/strftime/index.html#specifiers",
              "title": "The timestamp format for the time component of the object key.",
              "type": "string"
            },
            "key_prefix": {
              "_metadata": {
                "docs::advanced": true,
                "docs::examples": [
                  "date=%F/",
                  "date=%F/hour=%H/",
                  "year=%Y/month=%m/day=%d/",
                  "application_id={{ application_id }}/date=%F/"
                ],
                "docs::human_name": "Key Prefix",
                "docs::optional": true,
                "docs::templateable": true
              },
              "description": "Prefixes are useful for partitioning objects, such as by creating an object key that\nstores objects under a particular directory. If using a prefix for this purpose, it must end\nin `/` in order to act as a directory path. A trailing `/` is **not** automatically added.",
              "title": "A prefix to apply to all object keys.",
              "type": [
                "string",
                "null"
              ]
            },
            "metadata": {
              "_metadata": {
                "docs::additional_props_description": "A key/value pair.",
                "docs::advanced": true,
                "docs::human_name": "Metadata",
                "docs::optional": true
              },
              "additionalProperties": {
                "type": "string"
              },
              "description": "For more information, see the [custom metadata][custom_metadata] documentation.\n\n[custom_metadata]: https://cloud.google.com/storage/docs/metadata#custom-metadata",
              "title": "The set of metadata `key:value` pairs for the created objects.",
              "type": [
                "object",
                "null"
              ]
            },
            "request": {
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              },
              "default": {
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "initial_concurrency": 1,
                  "rtt_deviation_scale": 2.5
                },
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775808,
                "retry_attempts": 9223372036854775808,
                "retry_initial_backoff_secs": 1,
                "retry_max_duration_secs": 3600,
                "timeout_secs": 60
              },
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "title": "Middleware settings for outbound requests."
            },
            "storage_class": {
              "$ref": "#/definitions/core::option::Option<vector::sinks::gcs_common::config::GcsStorageClass>",
              "_metadata": {
                "docs::human_name": "Storage Class"
              },
              "description": "For more information, see the [storage classes][storage_classes] documentation.\n\n[storage_classes]: https://cloud.google.com/storage/docs/storage-classes",
              "title": "The storage class for created objects."
            },
            "tls": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              }
            }
          },
          "required": [
            "bucket"
          ],
          "type": "object"
        },
        {
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfigWithFraming",
          "description": "Encoding configuration."
        },
        {
          "$ref": "#/definitions/vector::gcp::GcpAuthConfig",
          "description": "Configuration of the authentication strategy for interacting with GCP services."
        }
      ],
      "description": "Configuration for the `gcp_cloud_storage` sink."
    },
    "vector::sinks::gcp::pubsub::PubsubConfig": {
      "_metadata": {
        "docs::component_name": "gcp_pubsub",
        "docs::component_type": "sink"
      },
      "allOf": [
        {
          "properties": {
            "acknowledgements": {
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              },
              "default": {
                "enabled": null
              },
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "title": "Controls how acknowledgements are handled for this sink."
            },
            "batch": {
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Batch"
              },
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "description": "Event batching behavior.",
              "properties": {
                "max_bytes": {
                  "_metadata": {
                    "docs::human_name": "Max Bytes",
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes"
                  },
                  "default": 10000000,
                  "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "title": "The maximum size of a batch that is processed by a sink.",
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "max_events": {
                  "_metadata": {
                    "docs::human_name": "Max Events",
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "events"
                  },
                  "default": 1000,
                  "description": "The maximum size of a batch before it is flushed.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "timeout_secs": {
                  "_metadata": {
                    "docs::human_name": "Timeout",
                    "docs::numeric_type": "float",
                    "docs::optional": true,
                    "docs::type_unit": "seconds"
                  },
                  "default": 1,
                  "description": "The maximum age of a batch before it is flushed.",
                  "maximum": 9007199254740991,
                  "minimum": -9007199254740991,
                  "type": [
                    "number",
                    "null"
                  ]
                }
              },
              "type": "object",
              "unevaluatedProperties": false
            },
            "encoding": {
              "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
              "_metadata": {
                "docs::human_name": "Encoding"
              },
              "description": "Configures how events are encoded into raw bytes."
            },
            "endpoint": {
              "_metadata": {
                "docs::examples": "https://us-central1-pubsub.googleapis.com",
                "docs::human_name": "Endpoint"
              },
              "default": "https://pubsub.googleapis.com",
              "description": "The scheme (`http` or `https`) must be specified. No path should be included since the paths defined\nby the [`GCP Pub/Sub`][pubsub_api] API are used.\n\nThe trailing slash `/` must not be included.\n\n[pubsub_api]: https://cloud.google.com/pubsub/docs/reference/rest",
              "title": "The endpoint to which to publish events.",
              "type": "string"
            },
            "project": {
              "_metadata": {
                "docs::examples": "vector-123456",
                "docs::human_name": "Project"
              },
              "description": "The project name to which to publish events.",
              "type": "string"
            },
            "request": {
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              },
              "default": {
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "initial_concurrency": 1,
                  "rtt_deviation_scale": 2.5
                },
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775808,
                "retry_attempts": 9223372036854775808,
                "retry_initial_backoff_secs": 1,
                "retry_max_duration_secs": 3600,
                "timeout_secs": 60
              },
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "title": "Middleware settings for outbound requests."
            },
            "tls": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              },
              "default": null
            },
            "topic": {
              "_metadata": {
                "docs::examples": "this-is-a-topic",
                "docs::human_name": "Topic"
              },
              "description": "The topic within the project to which to publish events.",
              "type": "string"
            }
          },
          "required": [
            "encoding",
            "project",
            "topic"
          ],
          "type": "object"
        },
        {
          "$ref": "#/definitions/vector::gcp::GcpAuthConfig",
          "default": {
            "api_key": null,
            "credentials_path": null
          },
          "description": "Configuration of the authentication strategy for interacting with GCP services."
        }
      ],
      "description": "Configuration for the `gcp_pubsub` sink."
    },
    "vector::sinks::gcp::stackdriver::logs::config::StackdriverConfig": {
      "_metadata": {
        "docs::component_name": "gcp_stackdriver_logs",
        "docs::component_type": "sink"
      },
      "allOf": [
        {
          "properties": {
            "acknowledgements": {
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              },
              "default": {
                "enabled": null
              },
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "title": "Controls how acknowledgements are handled for this sink."
            },
            "batch": {
              "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::RealtimeSizeBasedDefaultBatchSettings>",
              "_metadata": {
                "docs::human_name": "Batch"
              },
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "description": "Event batching behavior."
            },
            "encoding": {
              "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer",
              "_metadata": {
                "docs::human_name": "Encoding"
              },
              "default": {},
              "description": "Transformations to prepare an event for serialization."
            },
            "log_id": {
              "$ref": "#/definitions/vector::template::Template",
              "_metadata": {
                "docs::human_name": "Log ID"
              },
              "description": "This is a name you create to identify this log stream.",
              "title": "The log ID to which to publish logs."
            },
            "request": {
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              },
              "default": {
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "initial_concurrency": 1,
                  "rtt_deviation_scale": 2.5
                },
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775808,
                "retry_attempts": 9223372036854775808,
                "retry_initial_backoff_secs": 1,
                "retry_max_duration_secs": 3600,
                "timeout_secs": 60
              },
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "title": "Middleware settings for outbound requests."
            },
            "resource": {
              "_metadata": {
                "docs::human_name": "Resource"
              },
              "allOf": [
                {
                  "properties": {
                    "type": {
                      "_metadata": {
                        "docs::human_name": "Type"
                      },
                      "description": "For example, the type of a Compute Engine VM instance is `gce_instance`.\nSee the [Google Cloud Platform monitored resource documentation][gcp_resources] for\nmore details.\n\n[gcp_resources]: https://cloud.google.com/monitoring/api/resources",
                      "title": "The monitored resource type.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "type"
                  ],
                  "type": "object"
                },
                {
                  "_metadata": {
                    "docs::additional_props_description": "A type-specific label.",
                    "docs::examples": {
                      "instanceId": "Twilight",
                      "zone": "{{ zone }}"
                    }
                  },
                  "additionalProperties": {
                    "$ref": "#/definitions/vector::template::Template"
                  },
                  "description": "Type-specific labels.",
                  "type": "object"
                }
              ],
              "description": "The monitored resource to associate the logs with.",
              "title": "A monitored resource.",
              "unevaluatedProperties": false
            },
            "severity_key": {
              "$ref": "#/definitions/core::option::Option<vector_lookup::lookup_v2::ConfigValuePath>",
              "_metadata": {
                "docs::examples": "severity",
                "docs::human_name": "Severity Key"
              },
              "description": "The named field is removed from the log event if present, and must be either an integer\nbetween 0 and 800 or a string containing one of the [severity level names][sev_names] (case\nis ignored) or a common prefix such as `err`.\n\nIf no severity key is specified, the severity of outgoing records is set to 0 (`DEFAULT`).\n\nSee the [GCP Stackdriver Logging LogSeverity description][logsev_docs] for more details on\nthe value of the `severity` field.\n\n[sev_names]: https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logseverity\n[logsev_docs]: https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logseverity",
              "title": "The field of the log event from which to take the outgoing log’s `severity` field."
            },
            "tls": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              }
            }
          },
          "required": [
            "log_id",
            "resource"
          ],
          "type": "object"
        },
        {
          "_metadata": {
            "docs::enum_tagging": "external"
          },
          "description": "Logging locations.",
          "oneOf": [
            {
              "_metadata": {
                "docs::examples": "012345-6789AB-CDEF01",
                "docs::human_name": "Billing Account",
                "logical_name": "BillingAccount"
              },
              "description": "Exactly one of `billing_account_id`, `folder_id`, `organization_id`, or `project_id` must be set.",
              "properties": {
                "billing_account_id": {
                  "_metadata": {
                    "docs::human_name": "Billing Account ID"
                  },
                  "type": "string"
                }
              },
              "required": [
                "billing_account_id"
              ],
              "title": "The billing account ID to which to publish logs.",
              "type": "object"
            },
            {
              "_metadata": {
                "docs::examples": "My Folder",
                "docs::human_name": "Folder",
                "logical_name": "Folder"
              },
              "description": "See the [Google Cloud Platform folder documentation][folder_docs] for more details.\n\nExactly one of `billing_account_id`, `folder_id`, `organization_id`, or `project_id` must be set.\n\n[folder_docs]: https://cloud.google.com/resource-manager/docs/creating-managing-folders",
              "properties": {
                "folder_id": {
                  "_metadata": {
                    "docs::human_name": "Folder ID"
                  },
                  "type": "string"
                }
              },
              "required": [
                "folder_id"
              ],
              "title": "The folder ID to which to publish logs.",
              "type": "object"
            },
            {
              "_metadata": {
                "docs::examples": "622418129737",
                "docs::human_name": "Organization",
                "logical_name": "Organization"
              },
              "description": "This would be the identifier assigned to your organization on Google Cloud Platform.\n\nExactly one of `billing_account_id`, `folder_id`, `organization_id`, or `project_id` must be set.",
              "properties": {
                "organization_id": {
                  "_metadata": {
                    "docs::human_name": "Organization ID"
                  },
                  "type": "string"
                }
              },
              "required": [
                "organization_id"
              ],
              "title": "The organization ID to which to publish logs.",
              "type": "object"
            },
            {
              "_metadata": {
                "docs::examples": "vector-123456",
                "docs::human_name": "Project",
                "logical_name": "Project"
              },
              "description": "See the [Google Cloud Platform project management documentation][project_docs] for more details.\n\nExactly one of `billing_account_id`, `folder_id`, `organization_id`, or `project_id` must be set.\n\n[project_docs]: https://cloud.google.com/resource-manager/docs/creating-managing-projects",
              "properties": {
                "project_id": {
                  "_metadata": {
                    "docs::human_name": "Project ID"
                  },
                  "type": "string"
                }
              },
              "required": [
                "project_id"
              ],
              "title": "The project ID to which to publish logs.",
              "type": "object"
            }
          ]
        },
        {
          "$ref": "#/definitions/vector::gcp::GcpAuthConfig",
          "description": "Configuration of the authentication strategy for interacting with GCP services."
        }
      ],
      "description": "Configuration for the `gcp_stackdriver_logs` sink."
    },
    "vector::sinks::gcp::stackdriver_metrics::StackdriverConfig": {
      "_metadata": {
        "docs::component_name": "gcp_stackdriver_metrics",
        "docs::component_type": "sink"
      },
      "allOf": [
        {
          "properties": {
            "acknowledgements": {
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              },
              "default": {
                "enabled": null
              },
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "title": "Controls how acknowledgements are handled for this sink."
            },
            "batch": {
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Batch"
              },
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "description": "Event batching behavior.",
              "properties": {
                "max_bytes": {
                  "_metadata": {
                    "docs::human_name": "Max Bytes",
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes"
                  },
                  "default": null,
                  "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "title": "The maximum size of a batch that is processed by a sink.",
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "max_events": {
                  "_metadata": {
                    "docs::human_name": "Max Events",
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "events"
                  },
                  "default": 1,
                  "description": "The maximum size of a batch before it is flushed.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "timeout_secs": {
                  "_metadata": {
                    "docs::human_name": "Timeout",
                    "docs::numeric_type": "float",
                    "docs::optional": true,
                    "docs::type_unit": "seconds"
                  },
                  "default": 1,
                  "description": "The maximum age of a batch before it is flushed.",
                  "maximum": 9007199254740991,
                  "minimum": -9007199254740991,
                  "type": [
                    "number",
                    "null"
                  ]
                }
              },
              "type": "object",
              "unevaluatedProperties": false
            },
            "default_namespace": {
              "_metadata": {
                "docs::human_name": "Default Namespace"
              },
              "default": "namespace",
              "description": "Metrics with the same name can only be differentiated by their namespace, and not all\nmetrics have their own namespace.",
              "title": "The default namespace to use for metrics that do not have one.",
              "type": "string"
            },
            "project_id": {
              "_metadata": {
                "docs::human_name": "Project ID"
              },
              "description": "See the [Google Cloud Platform project management documentation][project_docs] for more details.\n\n[project_docs]: https://cloud.google.com/resource-manager/docs/creating-managing-projects",
              "title": "The project ID to which to publish metrics.",
              "type": "string"
            },
            "request": {
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              },
              "default": {
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "initial_concurrency": 1,
                  "rtt_deviation_scale": 2.5
                },
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775808,
                "retry_attempts": 9223372036854775808,
                "retry_initial_backoff_secs": 1,
                "retry_max_duration_secs": 3600,
                "timeout_secs": 60
              },
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "title": "Middleware settings for outbound requests."
            },
            "resource": {
              "_metadata": {
                "docs::human_name": "Resource"
              },
              "allOf": [
                {
                  "properties": {
                    "type": {
                      "_metadata": {
                        "docs::examples": [
                          "global",
                          "gce_instance"
                        ],
                        "docs::human_name": "Type"
                      },
                      "description": "For example, the type of a Compute Engine VM instance is `gce_instance`.",
                      "title": "The monitored resource type.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "type"
                  ],
                  "type": "object"
                },
                {
                  "_metadata": {
                    "docs::additional_props_description": "Values for all of the labels listed in the associated monitored resource descriptor.\n\nFor example, Compute Engine VM instances use the labels `projectId`, `instanceId`, and `zone`.",
                    "docs::examples": {
                      "instanceId": "Twilight",
                      "projectId": "vector-123456",
                      "zone": "us-central1-a"
                    }
                  },
                  "additionalProperties": {
                    "type": "string"
                  },
                  "description": "Type-specific labels.",
                  "type": "object"
                }
              ],
              "description": "The monitored resource to associate the metrics with.",
              "title": "A monitored resource.",
              "unevaluatedProperties": false
            },
            "tls": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              }
            }
          },
          "required": [
            "project_id",
            "resource"
          ],
          "type": "object"
        },
        {
          "$ref": "#/definitions/vector::gcp::GcpAuthConfig",
          "description": "Configuration of the authentication strategy for interacting with GCP services."
        }
      ],
      "description": "Configuration for the `gcp_stackdriver_metrics` sink."
    },
    "vector::sinks::honeycomb::config::HoneycombConfig": {
      "_metadata": {
        "docs::component_name": "honeycomb",
        "docs::component_type": "sink"
      },
      "description": "Configuration for the `honeycomb` sink.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled for this sink."
        },
        "api_key": {
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "docs::examples": [
              "${HONEYCOMB_API_KEY}",
              "some-api-key"
            ],
            "docs::human_name": "API Key"
          },
          "description": "The API key that is used to authenticate against Honeycomb."
        },
        "batch": {
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Batch"
          },
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "description": "Event batching behavior.",
          "properties": {
            "max_bytes": {
              "_metadata": {
                "docs::human_name": "Max Bytes",
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "bytes"
              },
              "default": 100000,
              "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "title": "The maximum size of a batch that is processed by a sink.",
              "type": [
                "integer",
                "null"
              ]
            },
            "max_events": {
              "_metadata": {
                "docs::human_name": "Max Events",
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "events"
              },
              "default": null,
              "description": "The maximum size of a batch before it is flushed.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "type": [
                "integer",
                "null"
              ]
            },
            "timeout_secs": {
              "_metadata": {
                "docs::human_name": "Timeout",
                "docs::numeric_type": "float",
                "docs::optional": true,
                "docs::type_unit": "seconds"
              },
              "default": 1,
              "description": "The maximum age of a batch before it is flushed.",
              "maximum": 9007199254740991,
              "minimum": -9007199254740991,
              "type": [
                "number",
                "null"
              ]
            }
          },
          "type": "object",
          "unevaluatedProperties": false
        },
        "dataset": {
          "_metadata": {
            "docs::examples": "my-honeycomb-dataset",
            "docs::human_name": "Dataset"
          },
          "description": "The dataset to which logs are sent.",
          "type": "string"
        },
        "encoding": {
          "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer",
          "_metadata": {
            "docs::human_name": "Encoding"
          },
          "default": {},
          "description": "Transformations to prepare an event for serialization."
        },
        "request": {
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          },
          "default": {
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "initial_concurrency": 1,
              "rtt_deviation_scale": 2.5
            },
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775808,
            "retry_attempts": 9223372036854775808,
            "retry_initial_backoff_secs": 1,
            "retry_max_duration_secs": 3600,
            "timeout_secs": 60
          },
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "title": "Middleware settings for outbound requests."
        }
      },
      "required": [
        "api_key",
        "dataset"
      ],
      "type": "object"
    },
    "vector::sinks::http::config::HttpSinkConfig": {
      "_metadata": {
        "docs::component_name": "http",
        "docs::component_type": "sink"
      },
      "allOf": [
        {
          "properties": {
            "acknowledgements": {
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              },
              "default": {
                "enabled": null
              },
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "title": "Controls how acknowledgements are handled for this sink."
            },
            "auth": {
              "$ref": "#/definitions/core::option::Option<vector::http::Auth>",
              "_metadata": {
                "docs::human_name": "Auth"
              }
            },
            "batch": {
              "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::RealtimeSizeBasedDefaultBatchSettings>",
              "_metadata": {
                "docs::human_name": "Batch"
              },
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "description": "Event batching behavior."
            },
            "compression": {
              "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
              "_metadata": {
                "docs::human_name": "Compression"
              },
              "default": "none",
              "description": "All compression algorithms use the default compression level unless otherwise specified.",
              "title": "Compression configuration."
            },
            "headers": {
              "_metadata": {
                "deprecated_message": "This option has been deprecated, use `request.headers` instead.",
                "docs::additional_props_description": "An HTTP request header and it's value.",
                "docs::human_name": "Headers",
                "docs::optional": true
              },
              "additionalProperties": {
                "type": "string"
              },
              "deprecated": true,
              "description": "A list of custom headers to add to each request.",
              "type": [
                "object",
                "null"
              ]
            },
            "method": {
              "_metadata": {
                "docs::enum_tagging": "external",
                "docs::human_name": "Method"
              },
              "default": "post",
              "description": "The HTTP method to use when making the request.",
              "oneOf": [
                {
                  "_metadata": {
                    "docs::human_name": "Get",
                    "logical_name": "Get"
                  },
                  "const": "get",
                  "description": "GET."
                },
                {
                  "_metadata": {
                    "docs::human_name": "Head",
                    "logical_name": "Head"
                  },
                  "const": "head",
                  "description": "HEAD."
                },
                {
                  "_metadata": {
                    "docs::human_name": "Post",
                    "logical_name": "Post"
                  },
                  "const": "post",
                  "description": "POST."
                },
                {
                  "_metadata": {
                    "docs::human_name": "Put",
                    "logical_name": "Put"
                  },
                  "const": "put",
                  "description": "PUT."
                },
                {
                  "_metadata": {
                    "docs::human_name": "Delete",
                    "logical_name": "Delete"
                  },
                  "const": "delete",
                  "description": "DELETE."
                },
                {
                  "_metadata": {
                    "docs::human_name": "Options",
                    "logical_name": "Options"
                  },
                  "const": "options",
                  "description": "OPTIONS."
                },
                {
                  "_metadata": {
                    "docs::human_name": "Trace",
                    "logical_name": "Trace"
                  },
                  "const": "trace",
                  "description": "TRACE."
                },
                {
                  "_metadata": {
                    "docs::human_name": "Patch",
                    "logical_name": "Patch"
                  },
                  "const": "patch",
                  "description": "PATCH."
                }
              ],
              "title": "HTTP method.",
              "unevaluatedProperties": false
            },
            "payload_prefix": {
              "_metadata": {
                "docs::examples": "{\"data\":",
                "docs::human_name": "Payload Prefix"
              },
              "default": "",
              "description": "This option is ignored if the encoding is not character delimited JSON.\n\nIf specified, the `payload_suffix` must also be specified and together they must produce a valid JSON object.",
              "title": "A string to prefix the payload with.",
              "type": "string"
            },
            "payload_suffix": {
              "_metadata": {
                "docs::examples": "}",
                "docs::human_name": "Payload Suffix"
              },
              "default": "",
              "description": "This option is ignored if the encoding is not character delimited JSON.\n\nIf specified, the `payload_prefix` must also be specified and together they must produce a valid JSON object.",
              "title": "A string to suffix the payload with.",
              "type": "string"
            },
            "request": {
              "$ref": "#/definitions/vector::sinks::util::http::RequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              },
              "default": {
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "initial_concurrency": 1,
                  "rtt_deviation_scale": 2.5
                },
                "headers": {},
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775808,
                "retry_attempts": 9223372036854775808,
                "retry_initial_backoff_secs": 1,
                "retry_max_duration_secs": 3600,
                "timeout_secs": 60
              },
              "description": "Outbound HTTP request settings."
            },
            "tls": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              }
            },
            "uri": {
              "$ref": "#/definitions/vector::sinks::util::uri::UriSerde",
              "_metadata": {
                "docs::examples": "https://10.22.212.22:9000/endpoint",
                "docs::human_name": "URI"
              },
              "description": "This should include the protocol and host, but can also include the port, path, and any other valid part of a URI.",
              "title": "The full URI to make HTTP requests to."
            }
          },
          "required": [
            "uri"
          ],
          "type": "object"
        },
        {
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfigWithFraming",
          "description": "Encoding configuration."
        }
      ],
      "description": "Configuration for the `http` sink."
    },
    "vector::sinks::humio::logs::HumioLogsConfig": {
      "_metadata": {
        "docs::component_name": "humio_logs",
        "docs::component_type": "sink"
      },
      "description": "Configuration for the `humio_logs` sink.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled for this sink."
        },
        "batch": {
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::splunk_hec::common::util::SplunkHecDefaultBatchSettings>",
          "_metadata": {
            "docs::human_name": "Batch"
          },
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "description": "Event batching behavior."
        },
        "compression": {
          "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
          "_metadata": {
            "docs::human_name": "Compression"
          },
          "default": "none",
          "description": "All compression algorithms use the default compression level unless otherwise specified.",
          "title": "Compression configuration."
        },
        "encoding": {
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
          "_metadata": {
            "docs::human_name": "Encoding"
          },
          "description": "Configures how events are encoded into raw bytes."
        },
        "endpoint": {
          "_metadata": {
            "docs::examples": [
              "http://127.0.0.1",
              "https://example.com"
            ],
            "docs::human_name": "Endpoint"
          },
          "default": "https://cloud.humio.com",
          "description": "The scheme (`http` or `https`) must be specified. No path should be included since the paths defined\nby the [`Splunk`][splunk] API are used.\n\n[splunk]: https://docs.splunk.com/Documentation/Splunk/8.0.0/Data/HECRESTendpoints",
          "title": "The base URL of the Humio instance.",
          "type": "string"
        },
        "event_type": {
          "$ref": "#/definitions/core::option::Option<vector::template::Template>",
          "_metadata": {
            "docs::examples": [
              "json",
              "none",
              "{{ event_type }}"
            ],
            "docs::human_name": "Event Type"
          },
          "description": "If unset, Humio defaults it to none.",
          "title": "The type of events sent to this sink. Humio uses this as the name of the parser to use to ingest the data."
        },
        "host_key": {
          "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
          "_metadata": {
            "docs::human_name": "Host Key"
          },
          "default": "host",
          "description": "By default, the [global `log_schema.host_key` option][global_host_key] is used.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
          "title": "Overrides the name of the log field used to retrieve the hostname to send to Humio."
        },
        "index": {
          "$ref": "#/definitions/core::option::Option<vector::template::Template>",
          "_metadata": {
            "docs::examples": [
              "{{ host }}",
              "custom_index"
            ],
            "docs::human_name": "Index"
          },
          "default": null,
          "description": "In public-facing APIs, this must (if present) be equal to the repository used to create the ingest token used for authentication.\n\nIn private cluster setups, Humio can be configured to allow these to be different.\n\nFor more information, see [Humio’s Format of Data][humio_data_format].\n\n[humio_data_format]: https://docs.humio.com/integrations/data-shippers/hec/#format-of-data",
          "title": "Optional name of the repository to ingest into."
        },
        "indexed_fields": {
          "_metadata": {
            "docs::human_name": "Indexed Fields"
          },
          "default": [],
          "description": "Can be used to tag events by specifying fields starting with `#`.\n\nFor more information, see [Humio’s Format of Data][humio_data_format].\n\n[humio_data_format]: https://docs.humio.com/integrations/data-shippers/hec/#format-of-data",
          "items": {
            "$ref": "#/definitions/vector_lookup::lookup_v2::ConfigValuePath"
          },
          "title": "Event fields to be added to Humio’s extra fields.",
          "type": "array"
        },
        "request": {
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          },
          "default": {
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "initial_concurrency": 1,
              "rtt_deviation_scale": 2.5
            },
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775808,
            "retry_attempts": 9223372036854775808,
            "retry_initial_backoff_secs": 1,
            "retry_max_duration_secs": 3600,
            "timeout_secs": 60
          },
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "title": "Middleware settings for outbound requests."
        },
        "source": {
          "$ref": "#/definitions/core::option::Option<vector::template::Template>",
          "_metadata": {
            "docs::human_name": "Source"
          },
          "description": "Typically the filename the logs originated from. Maps to `@source` in Humio.",
          "title": "The source of events sent to this sink."
        },
        "timestamp_key": {
          "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
          "_metadata": {
            "docs::human_name": "Timestamp Key"
          },
          "default": "timestamp",
          "description": "By default, the [global `log_schema.timestamp_key` option][global_timestamp_key] is used.\n\n[global_timestamp_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.timestamp_key",
          "title": "Overrides the name of the log field used to retrieve the timestamp to send to Humio."
        },
        "timestamp_nanos_key": {
          "_metadata": {
            "docs::human_name": "Timestamp Nanos Key",
            "docs::optional": true
          },
          "default": "@timestamp.nanos",
          "description": "Overrides the name of the log field used to retrieve the nanosecond-enabled timestamp to send to Humio.",
          "type": [
            "string",
            "null"
          ]
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        },
        "token": {
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "docs::examples": [
              "${HUMIO_TOKEN}",
              "A94A8FE5CCB19BA61C4C08"
            ],
            "docs::human_name": "Token"
          },
          "description": "The Humio ingestion token."
        }
      },
      "required": [
        "encoding",
        "token"
      ],
      "type": "object"
    },
    "vector::sinks::humio::metrics::HumioMetricsConfig": {
      "_metadata": {
        "docs::component_name": "humio_metrics",
        "docs::component_type": "sink"
      },
      "allOf": [
        {
          "properties": {
            "acknowledgements": {
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              },
              "default": {
                "enabled": null
              },
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "title": "Controls how acknowledgements are handled for this sink."
            },
            "batch": {
              "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::splunk_hec::common::util::SplunkHecDefaultBatchSettings>",
              "_metadata": {
                "docs::human_name": "Batch"
              },
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "description": "Event batching behavior."
            },
            "compression": {
              "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
              "_metadata": {
                "docs::human_name": "Compression"
              },
              "default": "none",
              "description": "All compression algorithms use the default compression level unless otherwise specified.",
              "title": "Compression configuration."
            },
            "endpoint": {
              "_metadata": {
                "docs::examples": [
                  "http://127.0.0.1",
                  "https://example.com"
                ],
                "docs::human_name": "Endpoint"
              },
              "default": "https://cloud.humio.com",
              "description": "The scheme (`http` or `https`) must be specified. No path should be included since the paths defined\nby the [`Splunk`][splunk] API are used.\n\n[splunk]: https://docs.splunk.com/Documentation/Splunk/8.0.0/Data/HECRESTendpoints",
              "title": "The base URL of the Humio instance.",
              "type": "string"
            },
            "event_type": {
              "$ref": "#/definitions/core::option::Option<vector::template::Template>",
              "_metadata": {
                "docs::examples": [
                  "json",
                  "none",
                  "{{ event_type }}"
                ],
                "docs::human_name": "Event Type"
              },
              "description": "If unset, Humio defaults it to none.",
              "title": "The type of events sent to this sink. Humio uses this as the name of the parser to use to ingest the data."
            },
            "host_key": {
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
              "_metadata": {
                "docs::human_name": "Host Key"
              },
              "default": "host",
              "description": "By default, the [global `log_schema.host_key` option][global_host_key] is used.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
              "title": "Overrides the name of the log field used to retrieve the hostname to send to Humio."
            },
            "index": {
              "$ref": "#/definitions/core::option::Option<vector::template::Template>",
              "_metadata": {
                "docs::examples": [
                  "{{ host }}",
                  "custom_index"
                ],
                "docs::human_name": "Index"
              },
              "default": null,
              "description": "In public-facing APIs, this must (if present) be equal to the repository used to create the ingest token used for authentication.\n\nIn private cluster setups, Humio can be configured to allow these to be different.\n\nFor more information, see [Humio’s Format of Data][humio_data_format].\n\n[humio_data_format]: https://docs.humio.com/integrations/data-shippers/hec/#format-of-data",
              "title": "Optional name of the repository to ingest into."
            },
            "indexed_fields": {
              "_metadata": {
                "docs::human_name": "Indexed Fields"
              },
              "default": [],
              "description": "Can be used to tag events by specifying fields starting with `#`.\n\nFor more information, see [Humio’s Format of Data][humio_data_format].\n\n[humio_data_format]: https://docs.humio.com/integrations/data-shippers/hec/#format-of-data",
              "items": {
                "$ref": "#/definitions/vector_lookup::lookup_v2::ConfigValuePath"
              },
              "title": "Event fields to be added to Humio’s extra fields.",
              "type": "array"
            },
            "request": {
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              },
              "default": {
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "initial_concurrency": 1,
                  "rtt_deviation_scale": 2.5
                },
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775808,
                "retry_attempts": 9223372036854775808,
                "retry_initial_backoff_secs": 1,
                "retry_max_duration_secs": 3600,
                "timeout_secs": 60
              },
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "title": "Middleware settings for outbound requests."
            },
            "source": {
              "$ref": "#/definitions/core::option::Option<vector::template::Template>",
              "_metadata": {
                "docs::human_name": "Source"
              },
              "description": "Typically the filename the metrics originated from. Maps to `@source` in Humio.",
              "title": "The source of events sent to this sink."
            },
            "tls": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              }
            },
            "token": {
              "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
              "_metadata": {
                "docs::examples": [
                  "${HUMIO_TOKEN}",
                  "A94A8FE5CCB19BA61C4C08"
                ],
                "docs::human_name": "Token"
              },
              "description": "The Humio ingestion token."
            }
          },
          "required": [
            "token"
          ],
          "type": "object"
        },
        {
          "$ref": "#/definitions/vector::transforms::metric_to_log::MetricToLogConfig",
          "description": "Configuration for the `metric_to_log` transform."
        }
      ],
      "description": "Configuration for the `humio_metrics` sink."
    },
    "vector::sinks::influxdb::logs::InfluxDbLogsConfig": {
      "_metadata": {
        "docs::component_name": "influxdb_logs",
        "docs::component_type": "sink"
      },
      "allOf": [
        {
          "properties": {
            "acknowledgements": {
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              },
              "default": {
                "enabled": null
              },
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "title": "Controls how acknowledgements are handled for this sink."
            },
            "batch": {
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Batch"
              },
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "description": "Event batching behavior.",
              "properties": {
                "max_bytes": {
                  "_metadata": {
                    "docs::human_name": "Max Bytes",
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes"
                  },
                  "default": 1000000,
                  "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "title": "The maximum size of a batch that is processed by a sink.",
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "max_events": {
                  "_metadata": {
                    "docs::human_name": "Max Events",
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "events"
                  },
                  "default": null,
                  "description": "The maximum size of a batch before it is flushed.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "timeout_secs": {
                  "_metadata": {
                    "docs::human_name": "Timeout",
                    "docs::numeric_type": "float",
                    "docs::optional": true,
                    "docs::type_unit": "seconds"
                  },
                  "default": 1,
                  "description": "The maximum age of a batch before it is flushed.",
                  "maximum": 9007199254740991,
                  "minimum": -9007199254740991,
                  "type": [
                    "number",
                    "null"
                  ]
                }
              },
              "type": "object",
              "unevaluatedProperties": false
            },
            "encoding": {
              "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer",
              "_metadata": {
                "docs::human_name": "Encoding"
              },
              "default": {},
              "description": "Transformations to prepare an event for serialization."
            },
            "endpoint": {
              "_metadata": {
                "docs::examples": "http://localhost:8086",
                "docs::human_name": "Endpoint"
              },
              "description": "This should be a full HTTP URI, including the scheme, host, and port.",
              "title": "The endpoint to send data to.",
              "type": "string"
            },
            "host_key": {
              "$ref": "#/definitions/core::option::Option<vector_lookup::lookup_v2::optional_path::OptionalValuePath>",
              "_metadata": {
                "docs::examples": "hostname",
                "docs::human_name": "Host Key"
              },
              "description": "The setting of `log_schema.host_key`, usually `host`, is used here by default.",
              "title": "Use this option to customize the key containing the hostname."
            },
            "measurement": {
              "_metadata": {
                "docs::examples": "vector-logs",
                "docs::human_name": "Measurement",
                "docs::optional": true
              },
              "description": "The name of the InfluxDB measurement that is written to.",
              "type": [
                "string",
                "null"
              ]
            },
            "message_key": {
              "$ref": "#/definitions/core::option::Option<vector_lookup::lookup_v2::optional_path::OptionalValuePath>",
              "_metadata": {
                "docs::examples": "text",
                "docs::human_name": "Message Key"
              },
              "description": "The setting of `log_schema.message_key`, usually `message`, is used here by default.",
              "title": "Use this option to customize the key containing the message."
            },
            "namespace": {
              "_metadata": {
                "deprecated_message": "This field is deprecated, and `measurement` should be used instead.",
                "docs::examples": "service",
                "docs::human_name": "Namespace",
                "docs::optional": true
              },
              "deprecated": true,
              "description": "When specified, the measurement name is `<namespace>.vector`.",
              "title": "The namespace of the measurement name to use.",
              "type": [
                "string",
                "null"
              ]
            },
            "request": {
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              },
              "default": {
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "initial_concurrency": 1,
                  "rtt_deviation_scale": 2.5
                },
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775808,
                "retry_attempts": 9223372036854775808,
                "retry_initial_backoff_secs": 1,
                "retry_max_duration_secs": 3600,
                "timeout_secs": 60
              },
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "title": "Middleware settings for outbound requests."
            },
            "source_type_key": {
              "$ref": "#/definitions/core::option::Option<vector_lookup::lookup_v2::optional_path::OptionalValuePath>",
              "_metadata": {
                "docs::examples": "source",
                "docs::human_name": "Source Type Key"
              },
              "description": "The setting of `log_schema.source_type_key`, usually `source_type`, is used here by default.",
              "title": "Use this option to customize the key containing the source_type."
            },
            "tags": {
              "_metadata": {
                "docs::examples": [
                  "field1",
                  "parent.child_field"
                ],
                "docs::human_name": "Tags"
              },
              "default": [],
              "description": "By default Vector adds `metric_type` as well as the configured `log_schema.host_key` and\n`log_schema.source_type_key` options.",
              "items": {
                "type": "string"
              },
              "title": "The list of names of log fields that should be added as tags to each measurement.",
              "type": "array"
            },
            "tls": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              }
            }
          },
          "required": [
            "endpoint"
          ],
          "type": "object"
        },
        {
          "$ref": "#/definitions/core::option::Option<vector::sinks::influxdb::InfluxDb1Settings>"
        },
        {
          "$ref": "#/definitions/core::option::Option<vector::sinks::influxdb::InfluxDb2Settings>"
        }
      ],
      "description": "Configuration for the `influxdb_logs` sink."
    },
    "vector::sinks::influxdb::metrics::InfluxDbConfig": {
      "_metadata": {
        "docs::component_name": "influxdb_metrics",
        "docs::component_type": "sink"
      },
      "allOf": [
        {
          "properties": {
            "acknowledgements": {
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              },
              "default": {
                "enabled": null
              },
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "title": "Controls how acknowledgements are handled for this sink."
            },
            "batch": {
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Batch"
              },
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "description": "Event batching behavior.",
              "properties": {
                "max_bytes": {
                  "_metadata": {
                    "docs::human_name": "Max Bytes",
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes"
                  },
                  "default": null,
                  "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "title": "The maximum size of a batch that is processed by a sink.",
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "max_events": {
                  "_metadata": {
                    "docs::human_name": "Max Events",
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "events"
                  },
                  "default": 20,
                  "description": "The maximum size of a batch before it is flushed.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "timeout_secs": {
                  "_metadata": {
                    "docs::human_name": "Timeout",
                    "docs::numeric_type": "float",
                    "docs::optional": true,
                    "docs::type_unit": "seconds"
                  },
                  "default": 1,
                  "description": "The maximum age of a batch before it is flushed.",
                  "maximum": 9007199254740991,
                  "minimum": -9007199254740991,
                  "type": [
                    "number",
                    "null"
                  ]
                }
              },
              "type": "object",
              "unevaluatedProperties": false
            },
            "default_namespace": {
              "_metadata": {
                "docs::examples": "service",
                "docs::human_name": "Default Namespace",
                "docs::optional": true
              },
              "description": "This namespace is only used if a metric has no existing namespace. When a namespace is\npresent, it is used as a prefix to the metric name, and separated with a period (`.`).",
              "title": "Sets the default namespace for any metrics sent.",
              "type": [
                "string",
                "null"
              ]
            },
            "endpoint": {
              "_metadata": {
                "docs::examples": "http://localhost:8086/",
                "docs::human_name": "Endpoint"
              },
              "description": "This should be a full HTTP URI, including the scheme, host, and port.",
              "title": "The endpoint to send data to.",
              "type": "string"
            },
            "quantiles": {
              "_metadata": {
                "docs::human_name": "Quantiles",
                "docs::numeric_type": "float"
              },
              "default": [
                0.5,
                0.75,
                0.9,
                0.95,
                0.99
              ],
              "description": "The list of quantiles to calculate when sending distribution metrics.",
              "items": {
                "_metadata": {
                  "docs::numeric_type": "float"
                },
                "maximum": 9007199254740991,
                "minimum": -9007199254740991,
                "type": "number"
              },
              "type": "array"
            },
            "request": {
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              },
              "default": {
                "adaptive_concurrency": {
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "initial_concurrency": 1,
                  "rtt_deviation_scale": 2.5
                },
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775808,
                "retry_attempts": 9223372036854775808,
                "retry_initial_backoff_secs": 1,
                "retry_max_duration_secs": 3600,
                "timeout_secs": 60
              },
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "title": "Middleware settings for outbound requests."
            },
            "tags": {
              "_metadata": {
                "docs::additional_props_description": "A tag key/value pair.",
                "docs::examples": {
                  "region": "us-west-1"
                },
                "docs::human_name": "Tags",
                "docs::optional": true
              },
              "additionalProperties": {
                "type": "string"
              },
              "description": "A map of additional tags, in the key/value pair format, to add to each measurement.",
              "type": [
                "object",
                "null"
              ]
            },
            "tls": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              }
            }
          },
          "required": [
            "endpoint"
          ],
          "type": "object"
        },
        {
          "$ref": "#/definitions/core::option::Option<vector::sinks::influxdb::InfluxDb1Settings>"
        },
        {
          "$ref": "#/definitions/core::option::Option<vector::sinks::influxdb::InfluxDb2Settings>"
        }
      ],
      "description": "Configuration for the `influxdb_metrics` sink."
    },
    "vector::sinks::kafka::config::KafkaSinkConfig": {
      "_metadata": {
        "docs::component_name": "kafka",
        "docs::component_type": "sink"
      },
      "allOf": [
        {
          "properties": {
            "acknowledgements": {
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              },
              "default": {
                "enabled": null
              },
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "title": "Controls how acknowledgements are handled for this sink."
            },
            "batch": {
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Batch"
              },
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "description": "Event batching behavior.",
              "properties": {
                "max_bytes": {
                  "_metadata": {
                    "docs::human_name": "Max Bytes",
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes"
                  },
                  "default": null,
                  "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "title": "The maximum size of a batch that is processed by a sink.",
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "max_events": {
                  "_metadata": {
                    "docs::human_name": "Max Events",
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "events"
                  },
                  "default": null,
                  "description": "The maximum size of a batch before it is flushed.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "timeout_secs": {
                  "_metadata": {
                    "docs::human_name": "Timeout",
                    "docs::numeric_type": "float",
                    "docs::optional": true,
                    "docs::type_unit": "seconds"
                  },
                  "default": 1,
                  "description": "The maximum age of a batch before it is flushed.",
                  "maximum": 9007199254740991,
                  "minimum": -9007199254740991,
                  "type": [
                    "number",
                    "null"
                  ]
                }
              },
              "type": "object",
              "unevaluatedProperties": false
            },
            "bootstrap_servers": {
              "_metadata": {
                "docs::examples": "10.14.22.123:9092,10.14.23.332:9092",
                "docs::human_name": "Bootstrap Servers"
              },
              "description": "These are the servers in a Kafka cluster that a client should use to bootstrap its\nconnection to the cluster, allowing discovery of all the other hosts in the cluster.\n\nMust be in the form of `host:port`, and comma-separated.",
              "title": "A comma-separated list of Kafka bootstrap servers.",
              "type": "string"
            },
            "compression": {
              "_metadata": {
                "docs::advanced": true,
                "docs::enum_tagging": "external",
                "docs::human_name": "Compression"
              },
              "default": "none",
              "description": "Supported compression types for Kafka.",
              "oneOf": [
                {
                  "_metadata": {
                    "docs::human_name": "None",
                    "logical_name": "None"
                  },
                  "const": "none",
                  "description": "No compression."
                },
                {
                  "_metadata": {
                    "docs::human_name": "Gzip",
                    "logical_name": "Gzip"
                  },
                  "const": "gzip",
                  "description": "Gzip."
                },
                {
                  "_metadata": {
                    "docs::human_name": "Snappy",
                    "logical_name": "Snappy"
                  },
                  "const": "snappy",
                  "description": "Snappy."
                },
                {
                  "_metadata": {
                    "docs::human_name": "LZ4",
                    "logical_name": "Lz4"
                  },
                  "const": "lz4",
                  "description": "LZ4."
                },
                {
                  "_metadata": {
                    "docs::human_name": "Zstd",
                    "logical_name": "Zstd"
                  },
                  "const": "zstd",
                  "description": "Zstandard."
                }
              ],
              "unevaluatedProperties": false
            },
            "encoding": {
              "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
              "_metadata": {
                "docs::human_name": "Encoding"
              },
              "description": "Configures how events are encoded into raw bytes."
            },
            "headers_key": {
              "_metadata": {
                "docs::advanced": true,
                "docs::examples": "headers",
                "docs::human_name": "Headers Key",
                "docs::optional": true
              },
              "description": "If omitted, no headers are written.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/definitions/vector_lookup::lookup_v2::ConfigTargetPath"
                }
              ],
              "title": "The log field name to use for the Kafka headers.",
              "unevaluatedProperties": false
            },
            "key_field": {
              "_metadata": {
                "docs::advanced": true,
                "docs::examples": [
                  "user_id",
                  ".my_topic",
                  "%my_topic"
                ],
                "docs::human_name": "Key Field",
                "docs::optional": true
              },
              "description": "If the field does not exist in the log or in the tags, a blank value is used. If\nunspecified, the key is not sent.\n\nKafka uses a hash of the key to choose the partition or uses round-robin if the record has\nno key.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/definitions/vector_lookup::lookup_v2::ConfigTargetPath"
                }
              ],
              "title": "The log field name or tag key to use for the topic key.",
              "unevaluatedProperties": false
            },
            "librdkafka_options": {
              "_metadata": {
                "docs::additional_props_description": "A librdkafka configuration option.",
                "docs::advanced": true,
                "docs::examples": {
                  "client.id": "${ENV_VAR}",
                  "fetch.error.backoff.ms": "1000",
                  "socket.send.buffer.bytes": "100"
                },
                "docs::human_name": "Librdkafka Options"
              },
              "additionalProperties": {
                "type": "string"
              },
              "default": {},
              "description": "For more information on configuration options, see [Configuration properties][config_props_docs].\n\n[config_props_docs]: https://github.com/edenhill/librdkafka/blob/master/CONFIGURATION.md",
              "title": "A map of advanced options to pass directly to the underlying `librdkafka` client.",
              "type": "object"
            },
            "message_timeout_ms": {
              "$ref": "#/definitions/serde_with::DurationMilliSeconds",
              "_metadata": {
                "docs::advanced": true,
                "docs::examples": [
                  150000,
                  450000
                ],
                "docs::human_name": "Message Timeout"
              },
              "default": 300000,
              "description": "Local message timeout, in milliseconds."
            },
            "socket_timeout_ms": {
              "$ref": "#/definitions/serde_with::DurationMilliSeconds",
              "_metadata": {
                "docs::advanced": true,
                "docs::examples": [
                  30000,
                  60000
                ],
                "docs::human_name": "Socket Timeout"
              },
              "default": 60000,
              "description": "Default timeout, in milliseconds, for network requests."
            },
            "topic": {
              "$ref": "#/definitions/vector::template::Template",
              "_metadata": {
                "docs::examples": [
                  "topic-1234",
                  "logs-{{unit}}-%Y-%m-%d"
                ],
                "docs::human_name": "Topic",
                "docs::templateable": true
              },
              "description": "The Kafka topic name to write events to."
            }
          },
          "required": [
            "bootstrap_servers",
            "encoding",
            "topic"
          ],
          "type": "object"
        },
        {
          "$ref": "#/definitions/vector::kafka::KafkaAuthConfig",
          "description": "Kafka authentication configuration."
        }
      ],
      "description": "Configuration for the `kafka` sink."
    },
    "vector::sinks::loki::config::LokiConfig": {
      "_metadata": {
        "docs::component_name": "loki",
        "docs::component_type": "sink"
      },
      "description": "Configuration for the `loki` sink.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled for this sink."
        },
        "auth": {
          "$ref": "#/definitions/core::option::Option<vector::http::Auth>",
          "_metadata": {
            "docs::human_name": "Auth"
          }
        },
        "batch": {
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Batch"
          },
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "description": "Event batching behavior.",
          "properties": {
            "max_bytes": {
              "_metadata": {
                "docs::human_name": "Max Bytes",
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "bytes"
              },
              "default": 1000000,
              "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "title": "The maximum size of a batch that is processed by a sink.",
              "type": [
                "integer",
                "null"
              ]
            },
            "max_events": {
              "_metadata": {
                "docs::human_name": "Max Events",
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "events"
              },
              "default": 100000,
              "description": "The maximum size of a batch before it is flushed.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "type": [
                "integer",
                "null"
              ]
            },
            "timeout_secs": {
              "_metadata": {
                "docs::human_name": "Timeout",
                "docs::numeric_type": "float",
                "docs::optional": true,
                "docs::type_unit": "seconds"
              },
              "default": 1,
              "description": "The maximum age of a batch before it is flushed.",
              "maximum": 9007199254740991,
              "minimum": -9007199254740991,
              "type": [
                "number",
                "null"
              ]
            }
          },
          "type": "object",
          "unevaluatedProperties": false
        },
        "compression": {
          "_metadata": {
            "docs::enum_tagging": "untagged",
            "docs::human_name": "Compression"
          },
          "default": "snappy",
          "description": "Compression configuration.",
          "oneOf": [
            {
              "_metadata": {
                "docs::advanced": true,
                "docs::enum_tagging": "external",
                "docs::human_name": "Original",
                "logical_name": "Original"
              },
              "description": "Basic compression.",
              "oneOf": [
                {
                  "_metadata": {
                    "docs::enum_tagging": "external"
                  },
                  "description": "Compression algorithm.",
                  "oneOf": [
                    {
                      "_metadata": {
                        "docs::human_name": "None",
                        "logical_name": "None"
                      },
                      "const": "none",
                      "description": "No compression."
                    },
                    {
                      "_metadata": {
                        "docs::human_name": "Gzip",
                        "logical_name": "Gzip"
                      },
                      "const": "gzip",
                      "description": "[gzip]: https://www.gzip.org/",
                      "title": "[Gzip][gzip] compression."
                    },
                    {
                      "_metadata": {
                        "docs::human_name": "Zlib",
                        "logical_name": "Zlib"
                      },
                      "const": "zlib",
                      "description": "[zlib]: https://zlib.net/",
                      "title": "[Zlib][zlib] compression."
                    },
                    {
                      "_metadata": {
                        "docs::human_name": "Zstd",
                        "logical_name": "Zstd"
                      },
                      "const": "zstd",
                      "description": "[zstd]: https://facebook.github.io/zstd/",
                      "title": "[Zstandard][zstd] compression."
                    }
                  ]
                },
                {
                  "_metadata": {
                    "docs::hidden": true
                  },
                  "description": "Compression algorithm and compression level.",
                  "properties": {
                    "algorithm": {
                      "_metadata": {
                        "docs::enum_tagging": "external",
                        "docs::human_name": "Algorithm"
                      },
                      "description": "Compression algorithm.",
                      "oneOf": [
                        {
                          "_metadata": {
                            "docs::human_name": "None",
                            "logical_name": "None"
                          },
                          "const": "none",
                          "description": "No compression."
                        },
                        {
                          "_metadata": {
                            "docs::human_name": "Gzip",
                            "logical_name": "Gzip"
                          },
                          "const": "gzip",
                          "description": "[gzip]: https://www.gzip.org/",
                          "title": "[Gzip][gzip] compression."
                        },
                        {
                          "_metadata": {
                            "docs::human_name": "Zlib",
                            "logical_name": "Zlib"
                          },
                          "const": "zlib",
                          "description": "[zlib]: https://zlib.net/",
                          "title": "[Zlib][zlib] compression."
                        },
                        {
                          "_metadata": {
                            "docs::human_name": "Zstd",
                            "logical_name": "Zstd"
                          },
                          "const": "zstd",
                          "description": "[zstd]: https://facebook.github.io/zstd/",
                          "title": "[Zstandard][zstd] compression."
                        }
                      ],
                      "unevaluatedProperties": false
                    },
                    "level": {
                      "_metadata": {
                        "docs::human_name": "Level"
                      },
                      "description": "Compression level.",
                      "enum": [
                        "none",
                        "fast",
                        "best",
                        "default",
                        0,
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20,
                        21
                      ]
                    }
                  },
                  "required": [
                    "algorithm"
                  ],
                  "type": "object"
                }
              ],
              "title": "Compression configuration."
            },
            {
              "_metadata": {
                "docs::enum_tagging": "external",
                "docs::human_name": "Extended",
                "logical_name": "Extended"
              },
              "description": "Loki-specific compression.",
              "oneOf": [
                {
                  "_metadata": {
                    "docs::human_name": "Snappy",
                    "logical_name": "Snappy"
                  },
                  "const": "snappy",
                  "description": "This implies sending push requests as Protocol Buffers.",
                  "title": "Snappy compression."
                }
              ]
            }
          ],
          "unevaluatedProperties": false
        },
        "encoding": {
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
          "_metadata": {
            "docs::human_name": "Encoding"
          },
          "description": "Configures how events are encoded into raw bytes."
        },
        "endpoint": {
          "$ref": "#/definitions/vector::sinks::util::uri::UriSerde",
          "_metadata": {
            "docs::examples": "http://localhost:3100",
            "docs::human_name": "Endpoint"
          },
          "description": "The `path` value is appended to this.",
          "title": "The base URL of the Loki instance."
        },
        "labels": {
          "_metadata": {
            "docs::additional_props_description": "A Loki label.",
            "docs::examples": {
              "\"*\"": "{{ metadata }}",
              "\"pod_labels_*\"": "{{ kubernetes.pod_labels }}",
              "source": "vector",
              "{{ event_field }}": "{{ some_other_event_field }}"
            },
            "docs::human_name": "Labels"
          },
          "additionalProperties": {
            "$ref": "#/definitions/vector::template::Template"
          },
          "description": "Both keys and values are templateable, which enables you to attach dynamic labels to events.\n\nValid label keys include `*`, and prefixes ending with `*`, to allow for the expansion of\nobjects into multiple labels. See [Label expansion][label_expansion] for more information.\n\nNote: If the set of labels has high cardinality, this can cause drastic performance issues\nwith Loki. To prevent this from happening, reduce the number of unique label keys and\nvalues.\n\n[label_expansion]: https://vector.dev/docs/reference/configuration/sinks/loki/#label-expansion",
          "title": "A set of labels that are attached to each batch of events.",
          "type": "object"
        },
        "out_of_order_action": {
          "_metadata": {
            "docs::enum_tagging": "external",
            "docs::human_name": "Out Of Order Action"
          },
          "default": "drop",
          "description": "Some sources may generate events with timestamps that aren't in chronological order. Even though the\nsink sorts the events before sending them to Loki, there is a chance that another event could come in\nthat is out of order with the latest events sent to Loki. Prior to Loki 2.4.0, this\nwas not supported and would result in an error during the push request.\n\nIf you're using Loki 2.4.0 or newer, `Accept` is the preferred action, which lets Loki handle\nany necessary sorting/reordering. If you're using an earlier version, then you must use `Drop`\nor `RewriteTimestamp` depending on which option makes the most sense for your use case.",
          "oneOf": [
            {
              "_metadata": {
                "docs::human_name": "Drop",
                "logical_name": "Drop"
              },
              "const": "drop",
              "description": "Drop the event."
            },
            {
              "_metadata": {
                "docs::human_name": "Rewrite Timestamp",
                "logical_name": "RewriteTimestamp"
              },
              "const": "rewrite_timestamp",
              "description": "Rewrite the timestamp of the event to the timestamp of the latest event seen by the sink."
            },
            {
              "_metadata": {
                "docs::human_name": "Accept",
                "logical_name": "Accept"
              },
              "const": "accept",
              "description": "The event is not dropped and is sent without modification.\n\nRequires Loki 2.4.0 or newer.",
              "title": "Accept the event."
            }
          ],
          "title": "Out-of-order event behavior.",
          "unevaluatedProperties": false
        },
        "path": {
          "_metadata": {
            "docs::human_name": "Path"
          },
          "default": "/loki/api/v1/push",
          "description": "The path to use in the URL of the Loki instance.",
          "type": "string"
        },
        "remove_label_fields": {
          "_metadata": {
            "docs::human_name": "Remove Label Fields"
          },
          "default": false,
          "description": "Whether or not to delete fields from the event when they are used as labels.",
          "type": "boolean"
        },
        "remove_timestamp": {
          "_metadata": {
            "docs::human_name": "Remove Timestamp"
          },
          "default": true,
          "description": "The timestamp is still sent as event metadata for Loki to use for indexing.",
          "title": "Whether or not to remove the timestamp from the event payload.",
          "type": "boolean"
        },
        "request": {
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          },
          "default": {
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "initial_concurrency": 1,
              "rtt_deviation_scale": 2.5
            },
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775808,
            "retry_attempts": 9223372036854775808,
            "retry_initial_backoff_secs": 1,
            "retry_max_duration_secs": 3600,
            "timeout_secs": 60
          },
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "title": "Middleware settings for outbound requests."
        },
        "tenant_id": {
          "$ref": "#/definitions/core::option::Option<vector::template::Template>",
          "_metadata": {
            "docs::examples": [
              "some_tenant_id",
              "{{ event_field }}"
            ],
            "docs::human_name": "Tenant ID"
          },
          "description": "When running Loki locally, a tenant ID is not required.\n\n[tenant_id]: https://grafana.com/docs/loki/latest/operations/multi-tenancy/",
          "title": "The [tenant ID][tenant_id] to specify in requests to Loki."
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "required": [
        "encoding",
        "endpoint"
      ],
      "type": "object"
    },
    "vector::sinks::mezmo::LogdnaConfig": {
      "$ref": "#/definitions/vector::sinks::mezmo::MezmoConfig",
      "_metadata": {
        "deprecated": "The `logdna` sink has been renamed. Please use `mezmo` instead.",
        "docs::component_name": "logdna",
        "docs::component_type": "sink"
      },
      "description": "Configuration for the `logdna` sink."
    },
    "vector::sinks::mezmo::MezmoConfig": {
      "_metadata": {
        "docs::component_name": "mezmo",
        "docs::component_type": "sink"
      },
      "description": "Configuration for the `mezmo` (formerly `logdna`) sink.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled for this sink."
        },
        "api_key": {
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "docs::examples": [
              "${LOGDNA_API_KEY}",
              "ef8d5de700e7989468166c40fc8a0ccd"
            ],
            "docs::human_name": "API Key"
          },
          "description": "The Ingestion API key."
        },
        "batch": {
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::RealtimeSizeBasedDefaultBatchSettings>",
          "_metadata": {
            "docs::human_name": "Batch"
          },
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "description": "Event batching behavior."
        },
        "default_app": {
          "_metadata": {
            "docs::examples": "my-app",
            "docs::human_name": "Default App"
          },
          "default": "vector",
          "description": "The default app that is set for events that do not contain a `file` or `app` field.",
          "type": "string"
        },
        "default_env": {
          "_metadata": {
            "docs::examples": "staging",
            "docs::human_name": "Default Env"
          },
          "default": "production",
          "description": "The default environment that is set for events that do not contain an `env` field.",
          "type": "string"
        },
        "encoding": {
          "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer",
          "_metadata": {
            "docs::human_name": "Encoding"
          },
          "default": {},
          "description": "Transformations to prepare an event for serialization."
        },
        "endpoint": {
          "$ref": "#/definitions/vector::sinks::util::uri::UriSerde",
          "_metadata": {
            "docs::examples": [
              "http://127.0.0.1",
              "http://example.com"
            ],
            "docs::human_name": "Endpoint"
          },
          "default": "https://logs.mezmo.com/",
          "description": "Both IP address and hostname are accepted formats.",
          "title": "The HTTP endpoint to send logs to."
        },
        "hostname": {
          "$ref": "#/definitions/vector::template::Template",
          "_metadata": {
            "docs::examples": [
              "${HOSTNAME}",
              "my-local-machine"
            ],
            "docs::human_name": "Hostname"
          },
          "description": "The hostname that is attached to each batch of events."
        },
        "ip": {
          "_metadata": {
            "docs::examples": "0.0.0.0",
            "docs::human_name": "IP Address",
            "docs::optional": true
          },
          "description": "The IP address that is attached to each batch of events.",
          "type": [
            "string",
            "null"
          ]
        },
        "mac": {
          "_metadata": {
            "docs::examples": "my-mac-address",
            "docs::human_name": "MAC Address",
            "docs::optional": true
          },
          "description": "The MAC address that is attached to each batch of events.",
          "type": [
            "string",
            "null"
          ]
        },
        "request": {
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          },
          "default": {
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "initial_concurrency": 1,
              "rtt_deviation_scale": 2.5
            },
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775808,
            "retry_attempts": 9223372036854775808,
            "retry_initial_backoff_secs": 1,
            "retry_max_duration_secs": 3600,
            "timeout_secs": 60
          },
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "title": "Middleware settings for outbound requests."
        },
        "tags": {
          "_metadata": {
            "docs::examples": [
              "tag1",
              "tag2"
            ],
            "docs::human_name": "Tags",
            "docs::optional": true,
            "docs::templateable": true
          },
          "description": "The tags that are attached to each batch of events.",
          "items": {
            "$ref": "#/definitions/vector::template::Template"
          },
          "type": [
            "array",
            "null"
          ]
        }
      },
      "required": [
        "api_key",
        "hostname"
      ],
      "type": "object"
    },
    "vector::sinks::nats::config::NatsSinkConfig": {
      "_metadata": {
        "docs::component_name": "nats",
        "docs::component_type": "sink"
      },
      "description": "Configuration for the `nats` sink.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled for this sink."
        },
        "auth": {
          "$ref": "#/definitions/core::option::Option<vector::nats::NatsAuthConfig>",
          "_metadata": {
            "docs::human_name": "Auth"
          }
        },
        "connection_name": {
          "_metadata": {
            "docs::examples": "foo",
            "docs::human_name": "Connection Name"
          },
          "default": "vector",
          "description": "[nats_connection_name]: https://docs.nats.io/using-nats/developer/connecting/name",
          "title": "A NATS [name][nats_connection_name] assigned to the NATS connection.",
          "type": "string"
        },
        "encoding": {
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
          "_metadata": {
            "docs::human_name": "Encoding"
          },
          "description": "Configures how events are encoded into raw bytes."
        },
        "request": {
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          },
          "default": {
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "initial_concurrency": 1,
              "rtt_deviation_scale": 2.5
            },
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775808,
            "retry_attempts": 9223372036854775808,
            "retry_initial_backoff_secs": 1,
            "retry_max_duration_secs": 3600,
            "timeout_secs": 60
          },
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "title": "Middleware settings for outbound requests."
        },
        "subject": {
          "$ref": "#/definitions/vector::template::Template",
          "_metadata": {
            "docs::examples": [
              "{{ host }}",
              "foo",
              "time.us.east",
              "time.*.east",
              "time.>",
              ">"
            ],
            "docs::human_name": "Subject",
            "docs::templateable": true
          },
          "description": "[nats_subject]: https://docs.nats.io/nats-concepts/subjects",
          "title": "The NATS [subject][nats_subject] to publish messages to."
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        },
        "url": {
          "_metadata": {
            "docs::examples": [
              "nats://demo.nats.io",
              "nats://127.0.0.1:4242"
            ],
            "docs::human_name": "URL"
          },
          "description": "The URL must take the form of `nats://server:port`.\nIf the port is not specified it defaults to 4222.\n\n[nats_url]: https://docs.nats.io/using-nats/developer/connecting#nats-url",
          "title": "The NATS [URL][nats_url] to connect to.",
          "type": "string"
        }
      },
      "required": [
        "encoding",
        "subject",
        "url"
      ],
      "type": "object"
    },
    "vector::sinks::new_relic::config::NewRelicConfig": {
      "_metadata": {
        "docs::component_name": "new_relic",
        "docs::component_type": "sink"
      },
      "description": "Configuration for the `new_relic` sink.",
      "properties": {
        "account_id": {
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "docs::examples": [
              "xxxx",
              "${NEW_RELIC_ACCOUNT_KEY}"
            ],
            "docs::human_name": "Account ID"
          },
          "description": "The New Relic account ID."
        },
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled for this sink."
        },
        "api": {
          "_metadata": {
            "docs::enum_tagging": "external",
            "docs::human_name": "API"
          },
          "description": "New Relic API endpoint.",
          "oneOf": [
            {
              "_metadata": {
                "docs::human_name": "Events",
                "logical_name": "Events"
              },
              "const": "events",
              "description": "Events API."
            },
            {
              "_metadata": {
                "docs::human_name": "Metrics",
                "logical_name": "Metrics"
              },
              "const": "metrics",
              "description": "Metrics API."
            },
            {
              "_metadata": {
                "docs::human_name": "Logs",
                "logical_name": "Logs"
              },
              "const": "logs",
              "description": "Logs API."
            }
          ],
          "unevaluatedProperties": false
        },
        "batch": {
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Batch"
          },
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "description": "Event batching behavior.",
          "properties": {
            "max_bytes": {
              "_metadata": {
                "docs::human_name": "Max Bytes",
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "bytes"
              },
              "default": 1000000,
              "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "title": "The maximum size of a batch that is processed by a sink.",
              "type": [
                "integer",
                "null"
              ]
            },
            "max_events": {
              "_metadata": {
                "docs::human_name": "Max Events",
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "events"
              },
              "default": 100,
              "description": "The maximum size of a batch before it is flushed.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "type": [
                "integer",
                "null"
              ]
            },
            "timeout_secs": {
              "_metadata": {
                "docs::human_name": "Timeout",
                "docs::numeric_type": "float",
                "docs::optional": true,
                "docs::type_unit": "seconds"
              },
              "default": 1,
              "description": "The maximum age of a batch before it is flushed.",
              "maximum": 9007199254740991,
              "minimum": -9007199254740991,
              "type": [
                "number",
                "null"
              ]
            }
          },
          "type": "object",
          "unevaluatedProperties": false
        },
        "compression": {
          "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
          "_metadata": {
            "docs::human_name": "Compression"
          },
          "default": "gzip",
          "description": "All compression algorithms use the default compression level unless otherwise specified.",
          "title": "Compression configuration."
        },
        "encoding": {
          "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer",
          "_metadata": {
            "docs::human_name": "Encoding"
          },
          "default": {},
          "description": "Transformations to prepare an event for serialization."
        },
        "license_key": {
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "docs::examples": [
              "xxxx",
              "${NEW_RELIC_LICENSE_KEY}"
            ],
            "docs::human_name": "License Key"
          },
          "description": "A valid New Relic license key."
        },
        "region": {
          "_metadata": {
            "docs::human_name": "Region",
            "docs::optional": true
          },
          "description": "New Relic region.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "_metadata": {
                "docs::enum_tagging": "external"
              },
              "description": "New Relic region.",
              "oneOf": [
                {
                  "_metadata": {
                    "docs::human_name": "US",
                    "logical_name": "Us"
                  },
                  "const": "us",
                  "description": "US region."
                },
                {
                  "_metadata": {
                    "docs::human_name": "EU",
                    "logical_name": "Eu"
                  },
                  "const": "eu",
                  "description": "EU region."
                }
              ]
            }
          ],
          "unevaluatedProperties": false
        },
        "request": {
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          },
          "default": {
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "initial_concurrency": 1,
              "rtt_deviation_scale": 2.5
            },
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775808,
            "retry_attempts": 9223372036854775808,
            "retry_initial_backoff_secs": 1,
            "retry_max_duration_secs": 3600,
            "timeout_secs": 60
          },
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "title": "Middleware settings for outbound requests."
        }
      },
      "required": [
        "account_id",
        "api",
        "license_key"
      ],
      "type": "object"
    },
    "vector::sinks::papertrail::PapertrailConfig": {
      "_metadata": {
        "docs::component_name": "papertrail",
        "docs::component_type": "sink"
      },
      "description": "Configuration for the `papertrail` sink.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled for this sink."
        },
        "encoding": {
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
          "_metadata": {
            "docs::human_name": "Encoding"
          },
          "description": "Configures how events are encoded into raw bytes."
        },
        "endpoint": {
          "$ref": "#/definitions/vector::sinks::util::uri::UriSerde",
          "_metadata": {
            "docs::examples": "logs.papertrailapp.com:12345",
            "docs::human_name": "Endpoint"
          },
          "description": "The TCP endpoint to send logs to."
        },
        "keepalive": {
          "$ref": "#/definitions/core::option::Option<vector_core::tcp::TcpKeepaliveConfig>",
          "_metadata": {
            "docs::human_name": "Keepalive"
          }
        },
        "process": {
          "$ref": "#/definitions/vector::template::Template",
          "_metadata": {
            "docs::examples": [
              "{{ process }}",
              "my-process"
            ],
            "docs::human_name": "Process"
          },
          "default": "vector",
          "description": "The value to use as the `process` in Papertrail."
        },
        "send_buffer_bytes": {
          "_metadata": {
            "docs::human_name": "Send Buffer Bytes",
            "docs::numeric_type": "uint",
            "docs::optional": true
          },
          "description": "Configures the send buffer size using the `SO_SNDBUF` option on the socket.",
          "maximum": 9007199254740991,
          "minimum": 0,
          "type": [
            "integer",
            "null"
          ]
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "required": [
        "encoding",
        "endpoint"
      ],
      "type": "object"
    },
    "vector::sinks::prometheus::exporter::PrometheusExporterConfig": {
      "_metadata": {
        "docs::component_name": "prometheus_exporter",
        "docs::component_type": "sink"
      },
      "description": "Configuration for the `prometheus_exporter` sink.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled for this sink."
        },
        "address": {
          "$ref": "#/definitions/stdlib::SocketAddr",
          "_metadata": {
            "docs::examples": "192.160.0.10:9598",
            "docs::human_name": "Address"
          },
          "default": "0.0.0.0:9598",
          "description": "The metrics are exposed at the typical Prometheus exporter path, `/metrics`.",
          "title": "The address to expose for scraping."
        },
        "auth": {
          "$ref": "#/definitions/core::option::Option<vector::http::Auth>",
          "_metadata": {
            "docs::human_name": "Auth"
          }
        },
        "buckets": {
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Buckets",
            "docs::numeric_type": "float"
          },
          "default": [
            0.005,
            0.01,
            0.025,
            0.05,
            0.1,
            0.25,
            0.5,
            1,
            2.5,
            5,
            10
          ],
          "description": "[dist_metric_docs]: https://vector.dev/docs/about/under-the-hood/architecture/data-model/metric/#distribution",
          "items": {
            "_metadata": {
              "docs::numeric_type": "float"
            },
            "maximum": 9007199254740991,
            "minimum": -9007199254740991,
            "type": "number"
          },
          "title": "Default buckets to use for aggregating [distribution][dist_metric_docs] metrics into histograms.",
          "type": "array"
        },
        "default_namespace": {
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Default Namespace",
            "docs::optional": true
          },
          "description": "This namespace is only used if a metric has no existing namespace. When a namespace is\npresent, it is used as a prefix to the metric name, and separated with an underscore (`_`).\n\nIt should follow the Prometheus [naming conventions][prom_naming_docs].\n\n[prom_naming_docs]: https://prometheus.io/docs/practices/naming/#metric-names",
          "title": "The default namespace for any metrics sent.",
          "type": [
            "string",
            "null"
          ]
        },
        "distributions_as_summaries": {
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Distributions As Summaries"
          },
          "default": false,
          "description": "While distributions as a lossless way to represent a set of samples for a\nmetric is supported, Prometheus clients (the application being scraped, which is this sink) must\naggregate locally into either an aggregated histogram or aggregated summary.\n\n[dist_metric_docs]: https://vector.dev/docs/about/under-the-hood/architecture/data-model/metric/#distribution\n[prom_agg_hist_docs]: https://prometheus.io/docs/concepts/metric_types/#histogram\n[prom_agg_summ_docs]: https://prometheus.io/docs/concepts/metric_types/#summary",
          "title": "Whether or not to render [distributions][dist_metric_docs] as an [aggregated histogram][prom_agg_hist_docs] or  [aggregated summary][prom_agg_summ_docs].",
          "type": "boolean"
        },
        "flush_period_secs": {
          "$ref": "#/definitions/serde_with::DurationSeconds",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Flush Interval"
          },
          "default": 60,
          "description": "On the flush interval, if a metric has not been seen since the last flush interval, it is\nconsidered expired and is removed.\n\nBe sure to configure this value higher than your client’s scrape interval.",
          "title": "The interval, in seconds, on which metrics are flushed."
        },
        "quantiles": {
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Quantiles",
            "docs::numeric_type": "float"
          },
          "default": [
            0.5,
            0.75,
            0.9,
            0.95,
            0.99
          ],
          "description": "[dist_metric_docs]: https://vector.dev/docs/about/under-the-hood/architecture/data-model/metric/#distribution",
          "items": {
            "_metadata": {
              "docs::numeric_type": "float"
            },
            "maximum": 9007199254740991,
            "minimum": -9007199254740991,
            "type": "number"
          },
          "title": "Quantiles to use for aggregating [distribution][dist_metric_docs] metrics into a summary.",
          "type": "array"
        },
        "suppress_timestamp": {
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Suppress Timestamp"
          },
          "default": false,
          "description": "This can sometimes be useful when the source of metrics leads to their timestamps being too\nfar in the past for Prometheus to allow them, such as when aggregating metrics over long\ntime periods, or when replaying old metrics from a disk buffer.",
          "title": "Suppresses timestamps on the Prometheus output.",
          "type": "boolean"
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "type": "object"
    },
    "vector::sinks::prometheus::remote_write::RemoteWriteConfig": {
      "_metadata": {
        "docs::component_name": "prometheus_remote_write",
        "docs::component_type": "sink"
      },
      "description": "Configuration for the `prometheus_remote_write` sink.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled for this sink."
        },
        "auth": {
          "_metadata": {
            "docs::human_name": "Auth",
            "docs::optional": true
          },
          "description": "Authentication strategies.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "_metadata": {
                "docs::enum_tag_description": "The authentication strategy to use.",
                "docs::enum_tag_field": "strategy",
                "docs::enum_tagging": "internal"
              },
              "description": "Authentication strategies.",
              "oneOf": [
                {
                  "_metadata": {
                    "docs::human_name": "Basic",
                    "logical_name": "Basic"
                  },
                  "description": "HTTP Basic Authentication.",
                  "properties": {
                    "password": {
                      "_metadata": {
                        "docs::human_name": "Password"
                      },
                      "description": "Basic authentication password.",
                      "type": "string"
                    },
                    "strategy": {
                      "_metadata": {
                        "docs::human_name": "Strategy"
                      },
                      "const": "basic",
                      "description": "HTTP Basic Authentication."
                    },
                    "user": {
                      "_metadata": {
                        "docs::human_name": "User"
                      },
                      "description": "Basic authentication username.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "password",
                    "strategy",
                    "user"
                  ],
                  "type": "object"
                },
                {
                  "_metadata": {
                    "docs::human_name": "Bearer",
                    "logical_name": "Bearer"
                  },
                  "description": "A bearer token (OAuth2, JWT, etc) is passed as-is.",
                  "properties": {
                    "strategy": {
                      "_metadata": {
                        "docs::human_name": "Strategy"
                      },
                      "const": "bearer",
                      "description": "A bearer token (OAuth2, JWT, etc) is passed as-is.",
                      "title": "Bearer authentication."
                    },
                    "token": {
                      "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
                      "_metadata": {
                        "docs::human_name": "Token"
                      },
                      "description": "The bearer token to send."
                    }
                  },
                  "required": [
                    "strategy",
                    "token"
                  ],
                  "title": "Bearer authentication.",
                  "type": "object"
                },
                {
                  "_metadata": {
                    "docs::human_name": "AWS",
                    "logical_name": "Aws"
                  },
                  "allOf": [
                    {
                      "_metadata": {
                        "docs::enum_tagging": "untagged"
                      },
                      "anyOf": [
                        {
                          "_metadata": {
                            "docs::human_name": "Access Key",
                            "logical_name": "AccessKey"
                          },
                          "description": "Authenticate using a fixed access key and secret pair.",
                          "properties": {
                            "access_key_id": {
                              "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
                              "_metadata": {
                                "docs::examples": "AKIAIOSFODNN7EXAMPLE",
                                "docs::human_name": "Access Key ID"
                              },
                              "description": "The AWS access key ID."
                            },
                            "assume_role": {
                              "_metadata": {
                                "docs::examples": "arn:aws:iam::123456789098:role/my_role",
                                "docs::human_name": "Assume Role",
                                "docs::optional": true
                              },
                              "description": "[iam_role]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html",
                              "title": "The ARN of an [IAM role][iam_role] to assume.",
                              "type": [
                                "string",
                                "null"
                              ]
                            },
                            "external_id": {
                              "_metadata": {
                                "docs::examples": "randomEXAMPLEidString",
                                "docs::human_name": "External ID",
                                "docs::optional": true
                              },
                              "description": "[external_id]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html",
                              "title": "The optional unique external ID in conjunction with role to assume.",
                              "type": [
                                "string",
                                "null"
                              ]
                            },
                            "region": {
                              "_metadata": {
                                "docs::examples": "us-west-2",
                                "docs::human_name": "Region",
                                "docs::optional": true
                              },
                              "description": "If not set, this will default to the configured region\nfor the service itself.\n\n[aws_region]: https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints",
                              "title": "The [AWS region][aws_region] to send STS requests to.",
                              "type": [
                                "string",
                                "null"
                              ]
                            },
                            "secret_access_key": {
                              "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
                              "_metadata": {
                                "docs::examples": "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY",
                                "docs::human_name": "Secret Access Key"
                              },
                              "description": "The AWS secret access key."
                            }
                          },
                          "required": [
                            "access_key_id",
                            "secret_access_key"
                          ],
                          "type": "object"
                        },
                        {
                          "_metadata": {
                            "docs::human_name": "File",
                            "logical_name": "File"
                          },
                          "description": "Additionally, the specific credential profile to use can be set.\nThe file format must match the credentials file format outlined in\n<https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html>.",
                          "properties": {
                            "credentials_file": {
                              "_metadata": {
                                "docs::examples": "/my/aws/credentials",
                                "docs::human_name": "Credentials File"
                              },
                              "description": "Path to the credentials file.",
                              "type": "string"
                            },
                            "profile": {
                              "_metadata": {
                                "docs::examples": "develop",
                                "docs::human_name": "Profile"
                              },
                              "default": "default",
                              "description": "Used to select AWS credentials from a provided credentials file.",
                              "title": "The credentials profile to use.",
                              "type": "string"
                            }
                          },
                          "required": [
                            "credentials_file"
                          ],
                          "title": "Authenticate using credentials stored in a file.",
                          "type": "object"
                        },
                        {
                          "_metadata": {
                            "docs::human_name": "Role",
                            "logical_name": "Role"
                          },
                          "description": "Assume the given role ARN.",
                          "properties": {
                            "assume_role": {
                              "_metadata": {
                                "docs::examples": "arn:aws:iam::123456789098:role/my_role",
                                "docs::human_name": "Assume Role"
                              },
                              "description": "[iam_role]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html",
                              "title": "The ARN of an [IAM role][iam_role] to assume.",
                              "type": "string"
                            },
                            "external_id": {
                              "_metadata": {
                                "docs::examples": "randomEXAMPLEidString",
                                "docs::human_name": "External ID",
                                "docs::optional": true
                              },
                              "description": "[external_id]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html",
                              "title": "The optional unique external ID in conjunction with role to assume.",
                              "type": [
                                "string",
                                "null"
                              ]
                            },
                            "imds": {
                              "_metadata": {
                                "docs::human_name": "IMDS"
                              },
                              "default": {
                                "connect_timeout_seconds": 1,
                                "max_attempts": 4,
                                "read_timeout_seconds": 1
                              },
                              "description": "Configuration for authenticating with AWS through IMDS.",
                              "properties": {
                                "connect_timeout_seconds": {
                                  "$ref": "#/definitions/serde_with::DurationSeconds",
                                  "_metadata": {
                                    "docs::human_name": "Connect Timeout Seconds"
                                  },
                                  "default": 1,
                                  "description": "Connect timeout for IMDS."
                                },
                                "max_attempts": {
                                  "_metadata": {
                                    "docs::human_name": "Max Attempts",
                                    "docs::numeric_type": "uint"
                                  },
                                  "default": 4,
                                  "description": "Number of IMDS retries for fetching tokens and metadata.",
                                  "maximum": 4294967295,
                                  "minimum": 0,
                                  "type": "integer"
                                },
                                "read_timeout_seconds": {
                                  "$ref": "#/definitions/serde_with::DurationSeconds",
                                  "_metadata": {
                                    "docs::human_name": "Read Timeout Seconds"
                                  },
                                  "default": 1,
                                  "description": "Read timeout for IMDS."
                                }
                              },
                              "type": "object",
                              "unevaluatedProperties": false
                            },
                            "load_timeout_secs": {
                              "_metadata": {
                                "docs::examples": 30,
                                "docs::human_name": "Load Timeout",
                                "docs::numeric_type": "uint",
                                "docs::optional": true,
                                "docs::type_unit": "seconds"
                              },
                              "description": "Relevant when the default credentials chain or `assume_role` is used.",
                              "maximum": 9007199254740991,
                              "minimum": 0,
                              "title": "Timeout for assuming the role, in seconds.",
                              "type": [
                                "integer",
                                "null"
                              ]
                            },
                            "region": {
                              "_metadata": {
                                "docs::examples": "us-west-2",
                                "docs::human_name": "Region",
                                "docs::optional": true
                              },
                              "description": "If not set, this defaults to the configured region\nfor the service itself.\n\n[aws_region]: https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints",
                              "title": "The [AWS region][aws_region] to send STS requests to.",
                              "type": [
                                "string",
                                "null"
                              ]
                            }
                          },
                          "required": [
                            "assume_role"
                          ],
                          "type": "object"
                        }
                      ],
                      "description": "Configuration of the authentication strategy for interacting with AWS services."
                    },
                    {
                      "properties": {
                        "strategy": {
                          "_metadata": {
                            "docs::human_name": "Strategy"
                          },
                          "const": "aws",
                          "description": "Amazon Prometheus Service-specific authentication."
                        }
                      },
                      "required": [
                        "strategy"
                      ],
                      "type": "object"
                    }
                  ],
                  "description": "Amazon Prometheus Service-specific authentication."
                }
              ]
            }
          ],
          "unevaluatedProperties": false
        },
        "aws": {
          "$ref": "#/definitions/core::option::Option<vector::aws::region::RegionOrEndpoint>",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "AWS"
          }
        },
        "batch": {
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Batch"
          },
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "description": "Event batching behavior.",
          "properties": {
            "max_bytes": {
              "_metadata": {
                "docs::human_name": "Max Bytes",
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "bytes"
              },
              "default": null,
              "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "title": "The maximum size of a batch that is processed by a sink.",
              "type": [
                "integer",
                "null"
              ]
            },
            "max_events": {
              "_metadata": {
                "docs::human_name": "Max Events",
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "events"
              },
              "default": 1000,
              "description": "The maximum size of a batch before it is flushed.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "type": [
                "integer",
                "null"
              ]
            },
            "timeout_secs": {
              "_metadata": {
                "docs::human_name": "Timeout",
                "docs::numeric_type": "float",
                "docs::optional": true,
                "docs::type_unit": "seconds"
              },
              "default": 1,
              "description": "The maximum age of a batch before it is flushed.",
              "maximum": 9007199254740991,
              "minimum": -9007199254740991,
              "type": [
                "number",
                "null"
              ]
            }
          },
          "type": "object",
          "unevaluatedProperties": false
        },
        "buckets": {
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Buckets",
            "docs::numeric_type": "float"
          },
          "default": [
            0.005,
            0.01,
            0.025,
            0.05,
            0.1,
            0.25,
            0.5,
            1,
            2.5,
            5,
            10
          ],
          "description": "[dist_metric_docs]: https://vector.dev/docs/about/under-the-hood/architecture/data-model/metric/#distribution",
          "items": {
            "_metadata": {
              "docs::numeric_type": "float"
            },
            "maximum": 9007199254740991,
            "minimum": -9007199254740991,
            "type": "number"
          },
          "title": "Default buckets to use for aggregating [distribution][dist_metric_docs] metrics into histograms.",
          "type": "array"
        },
        "compression": {
          "_metadata": {
            "docs::advanced": true,
            "docs::enum_tagging": "external",
            "docs::human_name": "Compression"
          },
          "default": "snappy",
          "description": "Supported compression types for Prometheus Remote Write.",
          "oneOf": [
            {
              "_metadata": {
                "docs::human_name": "Snappy",
                "logical_name": "Snappy"
              },
              "const": "snappy",
              "description": "Snappy."
            },
            {
              "_metadata": {
                "docs::human_name": "Gzip",
                "logical_name": "Gzip"
              },
              "const": "gzip",
              "description": "Gzip."
            },
            {
              "_metadata": {
                "docs::human_name": "Zstd",
                "logical_name": "Zstd"
              },
              "const": "zstd",
              "description": "Zstandard."
            }
          ],
          "unevaluatedProperties": false
        },
        "default_namespace": {
          "_metadata": {
            "docs::advanced": true,
            "docs::examples": "service",
            "docs::human_name": "Default Namespace",
            "docs::optional": true
          },
          "description": "This namespace is only used if a metric has no existing namespace. When a namespace is\npresent, it is used as a prefix to the metric name, and separated with an underscore (`_`).\n\nIt should follow the Prometheus [naming conventions][prom_naming_docs].\n\n[prom_naming_docs]: https://prometheus.io/docs/practices/naming/#metric-names",
          "title": "The default namespace for any metrics sent.",
          "type": [
            "string",
            "null"
          ]
        },
        "endpoint": {
          "_metadata": {
            "docs::examples": "https://localhost:8087/api/v1/write",
            "docs::human_name": "Endpoint"
          },
          "description": "The endpoint should include the scheme and the path to write to.",
          "title": "The endpoint to send data to.",
          "type": "string"
        },
        "quantiles": {
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Quantiles",
            "docs::numeric_type": "float"
          },
          "default": [
            0.5,
            0.75,
            0.9,
            0.95,
            0.99
          ],
          "description": "[dist_metric_docs]: https://vector.dev/docs/about/under-the-hood/architecture/data-model/metric/#distribution",
          "items": {
            "_metadata": {
              "docs::numeric_type": "float"
            },
            "maximum": 9007199254740991,
            "minimum": -9007199254740991,
            "type": "number"
          },
          "title": "Quantiles to use for aggregating [distribution][dist_metric_docs] metrics into a summary.",
          "type": "array"
        },
        "request": {
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          },
          "default": {
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "initial_concurrency": 1,
              "rtt_deviation_scale": 2.5
            },
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775808,
            "retry_attempts": 9223372036854775808,
            "retry_initial_backoff_secs": 1,
            "retry_max_duration_secs": 3600,
            "timeout_secs": 60
          },
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "title": "Middleware settings for outbound requests."
        },
        "tenant_id": {
          "$ref": "#/definitions/core::option::Option<vector::template::Template>",
          "_metadata": {
            "docs::advanced": true,
            "docs::examples": "my-domain",
            "docs::human_name": "Tenant ID"
          },
          "default": null,
          "description": "If set, a header named `X-Scope-OrgID` is added to outgoing requests with the value of this setting.\n\nThis may be used by Cortex or other remote services to identify the tenant making the request.",
          "title": "The tenant ID to send."
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "required": [
        "endpoint"
      ],
      "type": "object"
    },
    "vector::sinks::pulsar::config::PulsarSinkConfig": {
      "_metadata": {
        "docs::component_name": "pulsar",
        "docs::component_type": "sink"
      },
      "description": "Configuration for the `pulsar` sink.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled for this sink."
        },
        "auth": {
          "_metadata": {
            "docs::human_name": "Auth",
            "docs::optional": true
          },
          "description": "Authentication configuration.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "description": "Authentication configuration.",
              "properties": {
                "name": {
                  "_metadata": {
                    "docs::examples": [
                      "${PULSAR_NAME}",
                      "name123"
                    ],
                    "docs::human_name": "Name",
                    "docs::optional": true
                  },
                  "description": "This can be used either for basic authentication (username/password) or JWT authentication.\nWhen used for JWT, the value should be `token`.",
                  "title": "Basic authentication name/username.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "oauth2": {
                  "_metadata": {
                    "docs::human_name": "OAuth2",
                    "docs::optional": true
                  },
                  "description": "OAuth2-specific authentication configuration.",
                  "oneOf": [
                    {
                      "type": "null"
                    },
                    {
                      "description": "OAuth2-specific authentication configuration.",
                      "properties": {
                        "audience": {
                          "_metadata": {
                            "docs::examples": [
                              "${OAUTH2_AUDIENCE}",
                              "pulsar"
                            ],
                            "docs::human_name": "Audience",
                            "docs::optional": true
                          },
                          "description": "The OAuth2 audience.",
                          "type": [
                            "string",
                            "null"
                          ]
                        },
                        "credentials_url": {
                          "_metadata": {
                            "docs::examples": [
                              "{OAUTH2_CREDENTIALS_URL}",
                              "file:///oauth2_credentials",
                              "data:application/json;base64,cHVsc2FyCg=="
                            ],
                            "docs::human_name": "Credentials URL"
                          },
                          "description": "A data URL is also supported.",
                          "title": "The credentials URL.",
                          "type": "string"
                        },
                        "issuer_url": {
                          "_metadata": {
                            "docs::examples": [
                              "${OAUTH2_ISSUER_URL}",
                              "https://oauth2.issuer"
                            ],
                            "docs::human_name": "Issuer URL"
                          },
                          "description": "The issuer URL.",
                          "type": "string"
                        },
                        "scope": {
                          "_metadata": {
                            "docs::examples": [
                              "${OAUTH2_SCOPE}",
                              "admin"
                            ],
                            "docs::human_name": "Scope",
                            "docs::optional": true
                          },
                          "description": "The OAuth2 scope.",
                          "type": [
                            "string",
                            "null"
                          ]
                        }
                      },
                      "required": [
                        "credentials_url",
                        "issuer_url"
                      ],
                      "type": "object"
                    }
                  ],
                  "unevaluatedProperties": false
                },
                "token": {
                  "$ref": "#/definitions/core::option::Option<vector_common::sensitive_string::SensitiveString>",
                  "_metadata": {
                    "docs::examples": [
                      "${PULSAR_TOKEN}",
                      "123456789"
                    ],
                    "docs::human_name": "Token"
                  },
                  "description": "This can be used either for basic authentication (username/password) or JWT authentication.\nWhen used for JWT, the value should be the signed JWT, in the compact representation.",
                  "title": "Basic authentication password/token."
                }
              },
              "type": "object"
            }
          ],
          "unevaluatedProperties": false
        },
        "batch": {
          "_metadata": {
            "docs::human_name": "Batch"
          },
          "default": {
            "max_bytes": null,
            "max_events": null
          },
          "description": "Event batching behavior.",
          "properties": {
            "max_bytes": {
              "_metadata": {
                "docs::human_name": "Max Bytes",
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "bytes"
              },
              "description": "The maximum size of a batch before it is flushed.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "type": [
                "integer",
                "null"
              ]
            },
            "max_events": {
              "_metadata": {
                "docs::examples": 1000,
                "docs::human_name": "Max Events",
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "events"
              },
              "description": "Note this is an unsigned 32 bit integer which is a smaller capacity than\nmany of the other sink batch settings.",
              "maximum": 4294967295,
              "minimum": 0,
              "title": "The maximum amount of events in a batch before it is flushed.",
              "type": [
                "integer",
                "null"
              ]
            }
          },
          "type": "object",
          "unevaluatedProperties": false
        },
        "compression": {
          "_metadata": {
            "docs::enum_tagging": "external",
            "docs::human_name": "Compression"
          },
          "default": "none",
          "description": "Supported compression types for Pulsar.",
          "oneOf": [
            {
              "_metadata": {
                "docs::human_name": "None",
                "logical_name": "None"
              },
              "const": "none",
              "description": "No compression."
            },
            {
              "_metadata": {
                "docs::human_name": "LZ4",
                "logical_name": "Lz4"
              },
              "const": "lz4",
              "description": "LZ4."
            },
            {
              "_metadata": {
                "docs::human_name": "Zlib",
                "logical_name": "Zlib"
              },
              "const": "zlib",
              "description": "Zlib."
            },
            {
              "_metadata": {
                "docs::human_name": "Zstd",
                "logical_name": "Zstd"
              },
              "const": "zstd",
              "description": "Zstandard."
            },
            {
              "_metadata": {
                "docs::human_name": "Snappy",
                "logical_name": "Snappy"
              },
              "const": "snappy",
              "description": "Snappy."
            }
          ],
          "unevaluatedProperties": false
        },
        "encoding": {
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
          "_metadata": {
            "docs::human_name": "Encoding"
          },
          "description": "Configures how events are encoded into raw bytes."
        },
        "endpoint": {
          "_metadata": {
            "docs::examples": "pulsar://127.0.0.1:6650",
            "docs::human_name": "Endpoint"
          },
          "description": "The endpoint should specify the pulsar protocol and port.",
          "title": "The endpoint to which the Pulsar client should connect to.",
          "type": "string"
        },
        "partition_key_field": {
          "$ref": "#/definitions/core::option::Option<vector_lookup::lookup_v2::optional_path::OptionalTargetPath>",
          "_metadata": {
            "docs::examples": [
              "message",
              "my_field"
            ],
            "docs::human_name": "Partition Key Field"
          },
          "description": "If the field does not exist in the log event or metric tags, a blank value will be used.\n\nIf omitted, the key is not sent.\n\nPulsar uses a hash of the key to choose the topic-partition or uses round-robin if the record has no key.",
          "title": "The log field name or tags key to use for the partition key."
        },
        "producer_name": {
          "_metadata": {
            "docs::examples": "producer-name",
            "docs::human_name": "Producer Name",
            "docs::optional": true
          },
          "description": "The name of the producer. If not specified, the default name assigned by Pulsar is used.",
          "type": [
            "string",
            "null"
          ]
        },
        "properties_key": {
          "$ref": "#/definitions/core::option::Option<vector_lookup::lookup_v2::optional_path::OptionalTargetPath>",
          "_metadata": {
            "docs::human_name": "Properties Key"
          },
          "description": "If omitted, no properties will be written.",
          "title": "The log field name to use for the Pulsar properties key."
        },
        "topic": {
          "$ref": "#/definitions/vector::template::Template",
          "_metadata": {
            "docs::examples": "topic-1234",
            "docs::human_name": "Topic"
          },
          "description": "The Pulsar topic name to write events to."
        }
      },
      "required": [
        "encoding",
        "endpoint",
        "topic"
      ],
      "type": "object"
    },
    "vector::sinks::redis::config::RedisSinkConfig": {
      "_metadata": {
        "docs::component_name": "redis",
        "docs::component_type": "sink"
      },
      "description": "Configuration for the `redis` sink.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled for this sink."
        },
        "batch": {
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Batch"
          },
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "description": "Event batching behavior.",
          "properties": {
            "max_bytes": {
              "_metadata": {
                "docs::human_name": "Max Bytes",
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "bytes"
              },
              "default": null,
              "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "title": "The maximum size of a batch that is processed by a sink.",
              "type": [
                "integer",
                "null"
              ]
            },
            "max_events": {
              "_metadata": {
                "docs::human_name": "Max Events",
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "events"
              },
              "default": 1,
              "description": "The maximum size of a batch before it is flushed.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "type": [
                "integer",
                "null"
              ]
            },
            "timeout_secs": {
              "_metadata": {
                "docs::human_name": "Timeout",
                "docs::numeric_type": "float",
                "docs::optional": true,
                "docs::type_unit": "seconds"
              },
              "default": 1,
              "description": "The maximum age of a batch before it is flushed.",
              "maximum": 9007199254740991,
              "minimum": -9007199254740991,
              "type": [
                "number",
                "null"
              ]
            }
          },
          "type": "object",
          "unevaluatedProperties": false
        },
        "data_type": {
          "_metadata": {
            "docs::enum_tagging": "external",
            "docs::human_name": "Data Type"
          },
          "default": "list",
          "description": "Redis data type to store messages in.",
          "oneOf": [
            {
              "_metadata": {
                "docs::human_name": "List",
                "logical_name": "List"
              },
              "const": "list",
              "description": "This resembles a deque, where messages can be popped and pushed from either end.\n\nThis is the default.",
              "title": "The Redis `list` type."
            },
            {
              "_metadata": {
                "docs::human_name": "Channel",
                "logical_name": "Channel"
              },
              "const": "channel",
              "description": "Redis channels function in a pub/sub fashion, allowing many-to-many broadcasting and receiving.",
              "title": "The Redis `channel` type."
            }
          ],
          "unevaluatedProperties": false
        },
        "encoding": {
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
          "_metadata": {
            "docs::human_name": "Encoding"
          },
          "description": "Configures how events are encoded into raw bytes."
        },
        "endpoint": {
          "_metadata": {
            "docs::examples": "redis://127.0.0.1:6379/0",
            "docs::human_name": "Endpoint"
          },
          "description": "The URL _must_ take the form of `protocol://server:port/db` where the protocol can either be\n`redis` or `rediss` for connections secured via TLS.",
          "title": "The URL of the Redis endpoint to connect to.",
          "type": "string"
        },
        "key": {
          "$ref": "#/definitions/vector::template::Template",
          "_metadata": {
            "docs::examples": [
              "syslog:{{ app }}",
              "vector"
            ],
            "docs::human_name": "Key"
          },
          "description": "The Redis key to publish messages to."
        },
        "list_option": {
          "_metadata": {
            "docs::human_name": "List Option",
            "docs::optional": true
          },
          "description": "List-specific options.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "description": "List-specific options.",
              "properties": {
                "method": {
                  "_metadata": {
                    "docs::enum_tagging": "external",
                    "docs::human_name": "Method"
                  },
                  "description": "The method to use for pushing messages into a `list`.",
                  "oneOf": [
                    {
                      "_metadata": {
                        "docs::human_name": "R Push",
                        "logical_name": "RPush"
                      },
                      "const": "rpush",
                      "description": "This pushes messages onto the tail of the list.\n\nThis is the default.",
                      "title": "Use the `rpush` method."
                    },
                    {
                      "_metadata": {
                        "docs::human_name": "L Push",
                        "logical_name": "LPush"
                      },
                      "const": "lpush",
                      "description": "This pushes messages onto the head of the list.",
                      "title": "Use the `lpush` method."
                    }
                  ],
                  "unevaluatedProperties": false
                }
              },
              "required": [
                "method"
              ],
              "type": "object"
            }
          ],
          "unevaluatedProperties": false
        },
        "request": {
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          },
          "default": {
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "initial_concurrency": 1,
              "rtt_deviation_scale": 2.5
            },
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775808,
            "retry_attempts": 9223372036854775808,
            "retry_initial_backoff_secs": 1,
            "retry_max_duration_secs": 3600,
            "timeout_secs": 60
          },
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "title": "Middleware settings for outbound requests."
        }
      },
      "required": [
        "encoding",
        "endpoint",
        "key"
      ],
      "type": "object"
    },
    "vector::sinks::s3_common::config::S3StorageClass": {
      "_metadata": {
        "docs::enum_tagging": "external"
      },
      "description": "More information on each storage class can be found in the [AWS documentation][aws_docs].\n\n[aws_docs]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage-class-intro.html",
      "oneOf": [
        {
          "_metadata": {
            "docs::human_name": "Standard",
            "logical_name": "Standard"
          },
          "const": "STANDARD",
          "description": "Standard Redundancy."
        },
        {
          "_metadata": {
            "docs::human_name": "Reduced Redundancy",
            "logical_name": "ReducedRedundancy"
          },
          "const": "REDUCED_REDUNDANCY",
          "description": "Reduced Redundancy."
        },
        {
          "_metadata": {
            "docs::human_name": "Intelligent Tiering",
            "logical_name": "IntelligentTiering"
          },
          "const": "INTELLIGENT_TIERING",
          "description": "Intelligent Tiering."
        },
        {
          "_metadata": {
            "docs::human_name": "Standard Ia",
            "logical_name": "StandardIa"
          },
          "const": "STANDARD_IA",
          "description": "Infrequently Accessed."
        },
        {
          "_metadata": {
            "docs::human_name": "Onezone Ia",
            "logical_name": "OnezoneIa"
          },
          "const": "ONEZONE_IA",
          "description": "Infrequently Accessed (single Availability zone)."
        },
        {
          "_metadata": {
            "docs::human_name": "Glacier",
            "logical_name": "Glacier"
          },
          "const": "GLACIER",
          "description": "Glacier Flexible Retrieval."
        },
        {
          "_metadata": {
            "docs::human_name": "Deep Archive",
            "logical_name": "DeepArchive"
          },
          "const": "DEEP_ARCHIVE",
          "description": "Glacier Deep Archive."
        }
      ],
      "title": "S3 storage classes.",
      "unevaluatedProperties": false
    },
    "vector::sinks::sematext::Region": {
      "_metadata": {
        "docs::enum_tagging": "external"
      },
      "description": "The Sematext region to send data to.",
      "oneOf": [
        {
          "_metadata": {
            "docs::human_name": "US",
            "logical_name": "Us"
          },
          "const": "us",
          "description": "United States"
        },
        {
          "_metadata": {
            "docs::human_name": "EU",
            "logical_name": "Eu"
          },
          "const": "eu",
          "description": "Europe"
        }
      ],
      "unevaluatedProperties": false
    },
    "vector::sinks::sematext::logs::SematextLogsConfig": {
      "_metadata": {
        "docs::component_name": "sematext_logs",
        "docs::component_type": "sink"
      },
      "description": "Configuration for the `sematext_logs` sink.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled for this sink."
        },
        "batch": {
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::RealtimeSizeBasedDefaultBatchSettings>",
          "_metadata": {
            "docs::human_name": "Batch"
          },
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "description": "Event batching behavior."
        },
        "encoding": {
          "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer",
          "_metadata": {
            "docs::human_name": "Encoding"
          },
          "default": {},
          "description": "Transformations to prepare an event for serialization."
        },
        "endpoint": {
          "_metadata": {
            "docs::examples": [
              "http://127.0.0.1",
              "https://example.com"
            ],
            "docs::human_name": "Endpoint",
            "docs::optional": true
          },
          "description": "Setting this option overrides the `region` option.",
          "title": "The endpoint to send data to.",
          "type": [
            "string",
            "null"
          ]
        },
        "region": {
          "$ref": "#/definitions/vector::sinks::sematext::Region",
          "_metadata": {
            "docs::human_name": "Region"
          },
          "default": "us",
          "description": "The Sematext region to send data to."
        },
        "request": {
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          },
          "default": {
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "initial_concurrency": 1,
              "rtt_deviation_scale": 2.5
            },
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775808,
            "retry_attempts": 9223372036854775808,
            "retry_initial_backoff_secs": 1,
            "retry_max_duration_secs": 3600,
            "timeout_secs": 60
          },
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "title": "Middleware settings for outbound requests."
        },
        "token": {
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "docs::examples": [
              "${SEMATEXT_TOKEN}",
              "some-sematext-token"
            ],
            "docs::human_name": "Token"
          },
          "description": "The token that is used to write to Sematext."
        }
      },
      "required": [
        "token"
      ],
      "type": "object"
    },
    "vector::sinks::sematext::metrics::SematextMetricsConfig": {
      "_metadata": {
        "docs::component_name": "sematext_metrics",
        "docs::component_type": "sink"
      },
      "description": "Configuration for the `sematext_metrics` sink.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled for this sink."
        },
        "batch": {
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Batch"
          },
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "description": "Event batching behavior.",
          "properties": {
            "max_bytes": {
              "_metadata": {
                "docs::human_name": "Max Bytes",
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "bytes"
              },
              "default": null,
              "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "title": "The maximum size of a batch that is processed by a sink.",
              "type": [
                "integer",
                "null"
              ]
            },
            "max_events": {
              "_metadata": {
                "docs::human_name": "Max Events",
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "events"
              },
              "default": 20,
              "description": "The maximum size of a batch before it is flushed.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "type": [
                "integer",
                "null"
              ]
            },
            "timeout_secs": {
              "_metadata": {
                "docs::human_name": "Timeout",
                "docs::numeric_type": "float",
                "docs::optional": true,
                "docs::type_unit": "seconds"
              },
              "default": 1,
              "description": "The maximum age of a batch before it is flushed.",
              "maximum": 9007199254740991,
              "minimum": -9007199254740991,
              "type": [
                "number",
                "null"
              ]
            }
          },
          "type": "object",
          "unevaluatedProperties": false
        },
        "default_namespace": {
          "_metadata": {
            "docs::examples": "service",
            "docs::human_name": "Default Namespace"
          },
          "description": "This namespace is only used if a metric has no existing namespace. When a namespace is\npresent, it is used as a prefix to the metric name, and separated with a period (`.`).",
          "title": "Sets the default namespace for any metrics sent.",
          "type": "string"
        },
        "endpoint": {
          "_metadata": {
            "docs::examples": [
              "http://127.0.0.1",
              "https://example.com"
            ],
            "docs::human_name": "Endpoint",
            "docs::optional": true
          },
          "description": "Setting this option overrides the `region` option.",
          "title": "The endpoint to send data to.",
          "type": [
            "string",
            "null"
          ]
        },
        "region": {
          "$ref": "#/definitions/vector::sinks::sematext::Region",
          "_metadata": {
            "docs::human_name": "Region"
          },
          "default": "us",
          "description": "The Sematext region to send data to."
        },
        "request": {
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          },
          "default": {
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "initial_concurrency": 1,
              "rtt_deviation_scale": 2.5
            },
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775808,
            "retry_attempts": 9223372036854775808,
            "retry_initial_backoff_secs": 1,
            "retry_max_duration_secs": 3600,
            "timeout_secs": 60
          },
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "title": "Middleware settings for outbound requests."
        },
        "token": {
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "docs::examples": [
              "${SEMATEXT_TOKEN}",
              "some-sematext-token"
            ],
            "docs::human_name": "Token"
          },
          "description": "The token that is used to write to Sematext."
        }
      },
      "required": [
        "default_namespace",
        "token"
      ],
      "type": "object"
    },
    "vector::sinks::socket::SocketSinkConfig": {
      "_metadata": {
        "docs::component_name": "socket",
        "docs::component_type": "sink"
      },
      "allOf": [
        {
          "properties": {
            "acknowledgements": {
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              },
              "default": {
                "enabled": null
              },
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "title": "Controls how acknowledgements are handled for this sink."
            }
          },
          "type": "object"
        },
        {
          "_metadata": {
            "docs::enum_tag_description": "The type of socket to use.",
            "docs::enum_tag_field": "mode",
            "docs::enum_tagging": "internal"
          },
          "description": "Socket mode.",
          "oneOf": [
            {
              "_metadata": {
                "docs::human_name": "TCP",
                "logical_name": "Tcp"
              },
              "allOf": [
                {
                  "allOf": [
                    {
                      "description": "A TCP sink.",
                      "properties": {
                        "address": {
                          "_metadata": {
                            "docs::examples": [
                              "92.12.333.224:5000",
                              "https://somehost:5000"
                            ],
                            "docs::human_name": "Address"
                          },
                          "description": "Both IP address and hostname are accepted formats.\n\nThe address _must_ include a port.",
                          "title": "The address to connect to.",
                          "type": "string"
                        },
                        "keepalive": {
                          "$ref": "#/definitions/core::option::Option<vector_core::tcp::TcpKeepaliveConfig>",
                          "_metadata": {
                            "docs::human_name": "Keepalive"
                          }
                        },
                        "send_buffer_bytes": {
                          "_metadata": {
                            "docs::examples": 65536,
                            "docs::human_name": "Send Buffer Bytes",
                            "docs::numeric_type": "uint",
                            "docs::optional": true,
                            "docs::type_unit": "bytes"
                          },
                          "description": "If set, the value of the setting is passed via the `SO_SNDBUF` option.",
                          "maximum": 9007199254740991,
                          "minimum": 0,
                          "title": "The size of the socket's send buffer.",
                          "type": [
                            "integer",
                            "null"
                          ]
                        },
                        "tls": {
                          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
                          "_metadata": {
                            "docs::human_name": "TLS"
                          }
                        }
                      },
                      "required": [
                        "address"
                      ],
                      "type": "object"
                    },
                    {
                      "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfigWithFraming",
                      "description": "Encoding configuration."
                    }
                  ],
                  "description": "TCP configuration."
                },
                {
                  "properties": {
                    "mode": {
                      "_metadata": {
                        "docs::human_name": "Mode"
                      },
                      "const": "tcp",
                      "description": "Send over TCP."
                    }
                  },
                  "required": [
                    "mode"
                  ],
                  "type": "object"
                }
              ],
              "description": "Send over TCP."
            },
            {
              "_metadata": {
                "docs::human_name": "UDP",
                "logical_name": "Udp"
              },
              "allOf": [
                {
                  "allOf": [
                    {
                      "properties": {
                        "encoding": {
                          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
                          "_metadata": {
                            "docs::human_name": "Encoding"
                          },
                          "description": "Configures how events are encoded into raw bytes."
                        }
                      },
                      "required": [
                        "encoding"
                      ],
                      "type": "object"
                    },
                    {
                      "description": "A UDP sink.",
                      "properties": {
                        "address": {
                          "_metadata": {
                            "docs::examples": [
                              "92.12.333.224:5000",
                              "https://somehost:5000"
                            ],
                            "docs::human_name": "Address"
                          },
                          "description": "Both IP address and hostname are accepted formats.\n\nThe address _must_ include a port.",
                          "title": "The address to connect to.",
                          "type": "string"
                        },
                        "send_buffer_bytes": {
                          "_metadata": {
                            "docs::examples": 65536,
                            "docs::human_name": "Send Buffer Bytes",
                            "docs::numeric_type": "uint",
                            "docs::optional": true,
                            "docs::type_unit": "bytes"
                          },
                          "description": "If set, the value of the setting is passed via the `SO_SNDBUF` option.",
                          "maximum": 9007199254740991,
                          "minimum": 0,
                          "title": "The size of the socket's send buffer.",
                          "type": [
                            "integer",
                            "null"
                          ]
                        }
                      },
                      "required": [
                        "address"
                      ],
                      "type": "object"
                    }
                  ],
                  "description": "UDP configuration."
                },
                {
                  "properties": {
                    "mode": {
                      "_metadata": {
                        "docs::human_name": "Mode"
                      },
                      "const": "udp",
                      "description": "Send over UDP."
                    }
                  },
                  "required": [
                    "mode"
                  ],
                  "type": "object"
                }
              ],
              "description": "Send over UDP."
            },
            {
              "_metadata": {
                "docs::human_name": "Unix",
                "logical_name": "Unix"
              },
              "allOf": [
                {
                  "allOf": [
                    {
                      "description": "A Unix Domain Socket sink.",
                      "properties": {
                        "path": {
                          "$ref": "#/definitions/stdlib::PathBuf",
                          "_metadata": {
                            "docs::examples": "/path/to/socket",
                            "docs::human_name": "Path"
                          },
                          "description": "This should be an absolute path.",
                          "title": "The Unix socket path."
                        }
                      },
                      "required": [
                        "path"
                      ],
                      "type": "object"
                    },
                    {
                      "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfigWithFraming",
                      "description": "Encoding configuration."
                    }
                  ],
                  "description": "Unix Domain Socket configuration."
                },
                {
                  "properties": {
                    "mode": {
                      "_metadata": {
                        "docs::human_name": "Mode"
                      },
                      "const": "unix",
                      "description": "Send over a Unix domain socket (UDS)."
                    }
                  },
                  "required": [
                    "mode"
                  ],
                  "type": "object"
                }
              ],
              "description": "Send over a Unix domain socket (UDS)."
            }
          ]
        }
      ],
      "description": "Configuration for the `socket` sink."
    },
    "vector::sinks::splunk_hec::common::acknowledgements::HecClientAcknowledgementsConfig": {
      "_metadata": {
        "docs::advanced": true
      },
      "allOf": [
        {
          "properties": {
            "indexer_acknowledgements_enabled": {
              "_metadata": {
                "docs::human_name": "Indexer Acknowledgements Enabled"
              },
              "description": "[splunk_indexer_ack_docs]: https://docs.splunk.com/Documentation/Splunk/8.2.3/Data/AboutHECIDXAck",
              "title": "Controls if the sink integrates with [Splunk HEC indexer acknowledgements][splunk_indexer_ack_docs] for end-to-end acknowledgements.",
              "type": "boolean"
            },
            "max_pending_acks": {
              "_metadata": {
                "docs::human_name": "Max Pending Acks",
                "docs::numeric_type": "uint"
              },
              "description": "Once reached, the sink begins applying backpressure.",
              "maximum": 9007199254740991,
              "minimum": 1,
              "title": "The maximum number of pending acknowledgements from events sent to the Splunk HEC collector.",
              "type": "integer"
            },
            "query_interval": {
              "_metadata": {
                "docs::human_name": "Query Interval",
                "docs::numeric_type": "uint",
                "docs::type_unit": "seconds"
              },
              "description": "The amount of time to wait between queries to the Splunk HEC indexer acknowledgement endpoint.",
              "maximum": 255,
              "minimum": 1,
              "type": "integer"
            },
            "retry_limit": {
              "_metadata": {
                "docs::human_name": "Retry Limit",
                "docs::numeric_type": "uint"
              },
              "description": "The maximum number of times an acknowledgement ID is queried for its status.",
              "maximum": 255,
              "minimum": 1,
              "type": "integer"
            }
          },
          "type": "object"
        },
        {
          "default": {
            "enabled": null
          },
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "properties": {
            "enabled": {
              "_metadata": {
                "docs::human_name": "Enabled",
                "docs::optional": true
              },
              "description": "When enabled for a sink, any source connected to that sink, where the source supports\nend-to-end acknowledgements as well, waits for events to be acknowledged by the sink\nbefore acknowledging them at the source.\n\nEnabling or disabling acknowledgements at the sink level takes precedence over any global\n[`acknowledgements`][global_acks] configuration.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements",
              "title": "Whether or not end-to-end acknowledgements are enabled.",
              "type": [
                "boolean",
                "null"
              ]
            }
          },
          "title": "Controls how acknowledgements are handled for this sink.",
          "type": "object"
        }
      ],
      "default": {
        "indexer_acknowledgements_enabled": true,
        "max_pending_acks": 1000000,
        "query_interval": 10,
        "retry_limit": 30
      },
      "description": "Splunk HEC acknowledgement configuration.",
      "unevaluatedProperties": false
    },
    "vector::sinks::splunk_hec::logs::config::HecLogsSinkConfig": {
      "_metadata": {
        "docs::component_name": "splunk_hec_logs",
        "docs::component_type": "sink"
      },
      "description": "Configuration for the `splunk_hec_logs` sink.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector::sinks::splunk_hec::common::acknowledgements::HecClientAcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "indexer_acknowledgements_enabled": true,
            "max_pending_acks": 1000000,
            "query_interval": 10,
            "retry_limit": 30
          },
          "description": "Splunk HEC acknowledgement configuration."
        },
        "auto_extract_timestamp": {
          "_metadata": {
            "docs::human_name": "Auto Extract Timestamp",
            "docs::optional": true
          },
          "default": null,
          "description": "This option is only relevant to Splunk v8.x and above, and is only applied when\n`endpoint_target` is set to `event`.\n\nSetting this to `true` causes Splunk to extract the timestamp from the message text\nrather than use the timestamp embedded in the event. The timestamp must be in the format\n`yyyy-mm-dd hh:mm:ss`.",
          "title": "Passes the `auto_extract_timestamp` option to Splunk.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "batch": {
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::splunk_hec::common::util::SplunkHecDefaultBatchSettings>",
          "_metadata": {
            "docs::human_name": "Batch"
          },
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "description": "Event batching behavior."
        },
        "compression": {
          "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
          "_metadata": {
            "docs::human_name": "Compression"
          },
          "default": "none",
          "description": "All compression algorithms use the default compression level unless otherwise specified.",
          "title": "Compression configuration."
        },
        "default_token": {
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "docs::human_name": "Default Token"
          },
          "description": "If an event has a token set in its secrets (`splunk_hec_token`), it prevails over the one set here.",
          "title": "Default Splunk HEC token."
        },
        "encoding": {
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
          "_metadata": {
            "docs::human_name": "Encoding"
          },
          "description": "Configures how events are encoded into raw bytes."
        },
        "endpoint": {
          "_metadata": {
            "docs::examples": [
              "https://http-inputs-hec.splunkcloud.com",
              "https://hec.splunk.com:8088",
              "http://example.com"
            ],
            "docs::human_name": "Endpoint"
          },
          "description": "The scheme (`http` or `https`) must be specified. No path should be included since the paths defined\nby the [`Splunk`][splunk] API are used.\n\n[splunk]: https://docs.splunk.com/Documentation/Splunk/8.0.0/Data/HECRESTendpoints",
          "format": "uri",
          "title": "The base URL of the Splunk instance.",
          "type": "string"
        },
        "endpoint_target": {
          "_metadata": {
            "docs::advanced": true,
            "docs::enum_tagging": "external",
            "docs::human_name": "Endpoint Target"
          },
          "default": "event",
          "description": "Splunk HEC endpoint configuration.",
          "oneOf": [
            {
              "_metadata": {
                "docs::human_name": "Raw",
                "logical_name": "Raw"
              },
              "const": "raw",
              "description": "When the raw endpoint is used, configured [event metadata][event_metadata_docs] is sent as\nquery parameters on the request, except for the `timestamp` field.\n\n[raw_endpoint_docs]: https://docs.splunk.com/Documentation/Splunk/8.0.0/RESTREF/RESTinput#services.2Fcollector.2Fraw\n[event_metadata_docs]: https://docs.splunk.com/Documentation/Splunk/latest/Data/FormateventsforHTTPEventCollector#Event_metadata",
              "title": "Events are sent to the [raw endpoint][raw_endpoint_docs]."
            },
            {
              "_metadata": {
                "docs::human_name": "Event",
                "logical_name": "Event"
              },
              "const": "event",
              "description": "When the event endpoint is used, configured [event metadata][event_metadata_docs] is sent\ndirectly with each event.\n\n[event_endpoint_docs]: https://docs.splunk.com/Documentation/Splunk/8.0.0/RESTREF/RESTinput#services.2Fcollector.2Fevent\n[event_metadata_docs]: https://docs.splunk.com/Documentation/Splunk/latest/Data/FormateventsforHTTPEventCollector#Event_metadata",
              "title": "Events are sent to the [event endpoint][event_endpoint_docs]."
            }
          ],
          "unevaluatedProperties": false
        },
        "host_key": {
          "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Host Key"
          },
          "default": "host",
          "description": "By default, the [global `log_schema.host_key` option][global_host_key] is used.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
          "title": "Overrides the name of the log field used to retrieve the hostname to send to Splunk HEC."
        },
        "index": {
          "$ref": "#/definitions/core::option::Option<vector::template::Template>",
          "_metadata": {
            "docs::examples": [
              "{{ host }}",
              "custom_index"
            ],
            "docs::human_name": "Index"
          },
          "description": "If not specified, the default index defined within Splunk is used.",
          "title": "The name of the index to send events to."
        },
        "indexed_fields": {
          "_metadata": {
            "docs::advanced": true,
            "docs::examples": [
              "field1",
              "field2"
            ],
            "docs::human_name": "Indexed Fields"
          },
          "default": [],
          "description": "[splunk_field_index_docs]: https://docs.splunk.com/Documentation/Splunk/8.0.0/Data/IFXandHEC",
          "items": {
            "$ref": "#/definitions/vector_lookup::lookup_v2::ConfigValuePath"
          },
          "title": "Fields to be [added to Splunk index][splunk_field_index_docs].",
          "type": "array"
        },
        "request": {
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          },
          "default": {
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "initial_concurrency": 1,
              "rtt_deviation_scale": 2.5
            },
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775808,
            "retry_attempts": 9223372036854775808,
            "retry_initial_backoff_secs": 1,
            "retry_max_duration_secs": 3600,
            "timeout_secs": 60
          },
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "title": "Middleware settings for outbound requests."
        },
        "source": {
          "$ref": "#/definitions/core::option::Option<vector::template::Template>",
          "_metadata": {
            "docs::advanced": true,
            "docs::examples": [
              "{{ file }}",
              "/var/log/syslog",
              "UDP:514"
            ],
            "docs::human_name": "Source"
          },
          "description": "This is typically the filename the logs originated from.\n\nIf unset, the Splunk collector sets it.",
          "title": "The source of events sent to this sink."
        },
        "sourcetype": {
          "$ref": "#/definitions/core::option::Option<vector::template::Template>",
          "_metadata": {
            "docs::advanced": true,
            "docs::examples": [
              "{{ sourcetype }}",
              "_json"
            ],
            "docs::human_name": "Sourcetype"
          },
          "description": "If unset, Splunk defaults to `httpevent`.",
          "title": "The sourcetype of events sent to this sink."
        },
        "timestamp_key": {
          "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
          "_metadata": {
            "docs::advanced": true,
            "docs::examples": [
              "timestamp",
              ""
            ],
            "docs::human_name": "Timestamp Key"
          },
          "default": "timestamp",
          "description": "By default, the [global `log_schema.timestamp_key` option][global_timestamp_key] is used.\n\n[global_timestamp_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.timestamp_key",
          "title": "Overrides the name of the log field used to retrieve the timestamp to send to Splunk HEC.\nWhen set to `“”`, a timestamp is not set in the events sent to Splunk HEC."
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "required": [
        "default_token",
        "encoding",
        "endpoint"
      ],
      "type": "object"
    },
    "vector::sinks::splunk_hec::metrics::config::HecMetricsSinkConfig": {
      "_metadata": {
        "docs::component_name": "splunk_hec_metrics",
        "docs::component_type": "sink"
      },
      "description": "Configuration of the `splunk_hec_metrics` sink.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector::sinks::splunk_hec::common::acknowledgements::HecClientAcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "indexer_acknowledgements_enabled": true,
            "max_pending_acks": 1000000,
            "query_interval": 10,
            "retry_limit": 30
          },
          "description": "Splunk HEC acknowledgement configuration."
        },
        "batch": {
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::splunk_hec::common::util::SplunkHecDefaultBatchSettings>",
          "_metadata": {
            "docs::human_name": "Batch"
          },
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "description": "Event batching behavior."
        },
        "compression": {
          "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
          "_metadata": {
            "docs::human_name": "Compression"
          },
          "default": "none",
          "description": "All compression algorithms use the default compression level unless otherwise specified.",
          "title": "Compression configuration."
        },
        "default_namespace": {
          "_metadata": {
            "docs::examples": "service",
            "docs::human_name": "Default Namespace",
            "docs::optional": true
          },
          "description": "This namespace is only used if a metric has no existing namespace. When a namespace is\npresent, it is used as a prefix to the metric name, and separated with a period (`.`).",
          "title": "Sets the default namespace for any metrics sent.",
          "type": [
            "string",
            "null"
          ]
        },
        "default_token": {
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "docs::examples": [
              "${SPLUNK_HEC_TOKEN}",
              "A94A8FE5CCB19BA61C4C08"
            ],
            "docs::human_name": "Default Token"
          },
          "description": "If an event has a token set in its metadata, it prevails over the one set here.",
          "title": "Default Splunk HEC token."
        },
        "endpoint": {
          "_metadata": {
            "docs::examples": [
              "https://http-inputs-hec.splunkcloud.com",
              "https://hec.splunk.com:8088",
              "http://example.com"
            ],
            "docs::human_name": "Endpoint"
          },
          "description": "The scheme (`http` or `https`) must be specified. No path should be included since the paths defined\nby the [`Splunk`][splunk] API are used.\n\n[splunk]: https://docs.splunk.com/Documentation/Splunk/8.0.0/Data/HECRESTendpoints",
          "format": "uri",
          "title": "The base URL of the Splunk instance.",
          "type": "string"
        },
        "host_key": {
          "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Host Key"
          },
          "default": "host",
          "description": "By default, the [global `log_schema.host_key` option][global_host_key] is used.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
          "title": "Overrides the name of the log field used to retrieve the hostname to send to Splunk HEC."
        },
        "index": {
          "$ref": "#/definitions/core::option::Option<vector::template::Template>",
          "_metadata": {
            "docs::examples": [
              "{{ host }}",
              "custom_index"
            ],
            "docs::human_name": "Index"
          },
          "description": "If not specified, the default index defined within Splunk is used.",
          "title": "The name of the index where to send the events to."
        },
        "request": {
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          },
          "default": {
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "initial_concurrency": 1,
              "rtt_deviation_scale": 2.5
            },
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775808,
            "retry_attempts": 9223372036854775808,
            "retry_initial_backoff_secs": 1,
            "retry_max_duration_secs": 3600,
            "timeout_secs": 60
          },
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "title": "Middleware settings for outbound requests."
        },
        "source": {
          "$ref": "#/definitions/core::option::Option<vector::template::Template>",
          "_metadata": {
            "docs::advanced": true,
            "docs::examples": [
              "{{ file }}",
              "/var/log/syslog",
              "UDP:514"
            ],
            "docs::human_name": "Source"
          },
          "description": "This is typically the filename the logs originated from.\n\nIf unset, the Splunk collector sets it.",
          "title": "The source of events sent to this sink."
        },
        "sourcetype": {
          "$ref": "#/definitions/core::option::Option<vector::template::Template>",
          "_metadata": {
            "docs::advanced": true,
            "docs::examples": [
              "{{ sourcetype }}",
              "_json"
            ],
            "docs::human_name": "Sourcetype"
          },
          "description": "If unset, Splunk defaults to `httpevent`.",
          "title": "The sourcetype of events sent to this sink."
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "required": [
        "default_token",
        "endpoint"
      ],
      "type": "object"
    },
    "vector::sinks::statsd::config::StatsdSinkConfig": {
      "_metadata": {
        "docs::component_name": "statsd",
        "docs::component_type": "sink"
      },
      "allOf": [
        {
          "properties": {
            "acknowledgements": {
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              },
              "default": {
                "enabled": null
              },
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "title": "Controls how acknowledgements are handled for this sink."
            },
            "batch": {
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Batch"
              },
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "description": "Event batching behavior.",
              "properties": {
                "max_bytes": {
                  "_metadata": {
                    "docs::human_name": "Max Bytes",
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes"
                  },
                  "default": 1300,
                  "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "title": "The maximum size of a batch that is processed by a sink.",
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "max_events": {
                  "_metadata": {
                    "docs::human_name": "Max Events",
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "events"
                  },
                  "default": 1000,
                  "description": "The maximum size of a batch before it is flushed.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "timeout_secs": {
                  "_metadata": {
                    "docs::human_name": "Timeout",
                    "docs::numeric_type": "float",
                    "docs::optional": true,
                    "docs::type_unit": "seconds"
                  },
                  "default": 1,
                  "description": "The maximum age of a batch before it is flushed.",
                  "maximum": 9007199254740991,
                  "minimum": -9007199254740991,
                  "type": [
                    "number",
                    "null"
                  ]
                }
              },
              "type": "object",
              "unevaluatedProperties": false
            },
            "default_namespace": {
              "_metadata": {
                "docs::examples": "service",
                "docs::human_name": "Default Namespace",
                "docs::optional": true
              },
              "description": "This namespace is only used if a metric has no existing namespace. When a namespace is\npresent, it is used as a prefix to the metric name, and separated with a period (`.`).",
              "title": "Sets the default namespace for any metrics sent.",
              "type": [
                "string",
                "null"
              ]
            }
          },
          "type": "object"
        },
        {
          "_metadata": {
            "docs::enum_tag_description": "The type of socket to use.",
            "docs::enum_tag_field": "mode",
            "docs::enum_tagging": "internal"
          },
          "description": "Socket mode.",
          "oneOf": [
            {
              "_metadata": {
                "docs::human_name": "TCP",
                "logical_name": "Tcp"
              },
              "allOf": [
                {
                  "description": "TCP configuration.",
                  "properties": {
                    "address": {
                      "$ref": "#/definitions/vector::sinks::util::service::net::HostAndPort",
                      "_metadata": {
                        "docs::human_name": "Address"
                      },
                      "description": "Both IP addresses and hostnames/fully qualified domain names (FQDNs) are accepted formats.\n\nThe address _must_ include a port.",
                      "title": "The address to connect to."
                    },
                    "keepalive": {
                      "$ref": "#/definitions/core::option::Option<vector_core::tcp::TcpKeepaliveConfig>",
                      "_metadata": {
                        "docs::human_name": "Keepalive"
                      }
                    },
                    "send_buffer_size": {
                      "_metadata": {
                        "docs::examples": 65536,
                        "docs::human_name": "Send Buffer Size",
                        "docs::numeric_type": "uint",
                        "docs::optional": true,
                        "docs::type_unit": "bytes"
                      },
                      "description": "If set, the value of the setting is passed via the `SO_SNDBUF` option.",
                      "maximum": 9007199254740991,
                      "minimum": 0,
                      "title": "The size of the socket's send buffer.",
                      "type": [
                        "integer",
                        "null"
                      ]
                    },
                    "tls": {
                      "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
                      "_metadata": {
                        "docs::human_name": "TLS"
                      }
                    }
                  },
                  "required": [
                    "address"
                  ],
                  "type": "object"
                },
                {
                  "properties": {
                    "mode": {
                      "_metadata": {
                        "docs::human_name": "Mode"
                      },
                      "const": "tcp",
                      "description": "Send over TCP."
                    }
                  },
                  "required": [
                    "mode"
                  ],
                  "type": "object"
                }
              ],
              "description": "Send over TCP."
            },
            {
              "_metadata": {
                "docs::human_name": "UDP",
                "logical_name": "Udp"
              },
              "allOf": [
                {
                  "description": "UDP configuration.",
                  "properties": {
                    "address": {
                      "$ref": "#/definitions/vector::sinks::util::service::net::HostAndPort",
                      "_metadata": {
                        "docs::human_name": "Address"
                      },
                      "description": "Both IP addresses and hostnames/fully qualified domain names (FQDNs) are accepted formats.\n\nThe address _must_ include a port.",
                      "title": "The address to connect to."
                    },
                    "send_buffer_size": {
                      "_metadata": {
                        "docs::examples": 65536,
                        "docs::human_name": "Send Buffer Size",
                        "docs::numeric_type": "uint",
                        "docs::optional": true,
                        "docs::type_unit": "bytes"
                      },
                      "description": "If set, the value of the setting is passed via the `SO_SNDBUF` option.",
                      "maximum": 9007199254740991,
                      "minimum": 0,
                      "title": "The size of the socket's send buffer.",
                      "type": [
                        "integer",
                        "null"
                      ]
                    }
                  },
                  "required": [
                    "address"
                  ],
                  "type": "object"
                },
                {
                  "properties": {
                    "mode": {
                      "_metadata": {
                        "docs::human_name": "Mode"
                      },
                      "const": "udp",
                      "description": "Send over UDP."
                    }
                  },
                  "required": [
                    "mode"
                  ],
                  "type": "object"
                }
              ],
              "description": "Send over UDP."
            },
            {
              "_metadata": {
                "docs::human_name": "Unix",
                "logical_name": "Unix"
              },
              "allOf": [
                {
                  "description": "Unix Domain Socket configuration.",
                  "properties": {
                    "path": {
                      "$ref": "#/definitions/stdlib::PathBuf",
                      "_metadata": {
                        "docs::examples": "/path/to/socket",
                        "docs::human_name": "Path"
                      },
                      "description": "This should be an absolute path.",
                      "title": "The Unix socket path."
                    },
                    "send_buffer_size": {
                      "_metadata": {
                        "docs::examples": 65536,
                        "docs::human_name": "Send Buffer Size",
                        "docs::numeric_type": "uint",
                        "docs::optional": true,
                        "docs::type_unit": "bytes"
                      },
                      "description": "If set, the value of the setting is passed via the `SO_SNDBUF` option.",
                      "maximum": 9007199254740991,
                      "minimum": 0,
                      "title": "The size of the socket's send buffer.",
                      "type": [
                        "integer",
                        "null"
                      ]
                    },
                    "unix_mode": {
                      "_metadata": {
                        "docs::enum_tagging": "external",
                        "docs::human_name": "Unix Mode"
                      },
                      "default": "Stream",
                      "description": "The Unix socket mode to use.",
                      "oneOf": [
                        {
                          "_metadata": {
                            "docs::human_name": "Datagram",
                            "logical_name": "Datagram"
                          },
                          "const": "Datagram",
                          "description": "Datagram-oriented (`SOCK_DGRAM`)."
                        },
                        {
                          "_metadata": {
                            "docs::human_name": "Stream",
                            "logical_name": "Stream"
                          },
                          "const": "Stream",
                          "description": "Stream-oriented (`SOCK_STREAM`)."
                        }
                      ],
                      "unevaluatedProperties": false
                    }
                  },
                  "required": [
                    "path"
                  ],
                  "type": "object"
                },
                {
                  "properties": {
                    "mode": {
                      "_metadata": {
                        "docs::human_name": "Mode"
                      },
                      "const": "unix",
                      "description": "Send over a Unix domain socket (UDS)."
                    }
                  },
                  "required": [
                    "mode"
                  ],
                  "type": "object"
                }
              ],
              "description": "Send over a Unix domain socket (UDS)."
            }
          ]
        }
      ],
      "description": "Configuration for the `statsd` sink."
    },
    "vector::sinks::util::batch::BatchConfig<vector::sinks::splunk_hec::common::util::SplunkHecDefaultBatchSettings>": {
      "_metadata": {
        "docs::advanced": true
      },
      "description": "Event batching behavior.",
      "properties": {
        "max_bytes": {
          "_metadata": {
            "docs::human_name": "Max Bytes",
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "bytes"
          },
          "default": 1000000,
          "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
          "maximum": 9007199254740991,
          "minimum": 0,
          "title": "The maximum size of a batch that is processed by a sink.",
          "type": [
            "integer",
            "null"
          ]
        },
        "max_events": {
          "_metadata": {
            "docs::human_name": "Max Events",
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "events"
          },
          "default": null,
          "description": "The maximum size of a batch before it is flushed.",
          "maximum": 9007199254740991,
          "minimum": 0,
          "type": [
            "integer",
            "null"
          ]
        },
        "timeout_secs": {
          "_metadata": {
            "docs::human_name": "Timeout",
            "docs::numeric_type": "float",
            "docs::optional": true,
            "docs::type_unit": "seconds"
          },
          "default": 1,
          "description": "The maximum age of a batch before it is flushed.",
          "maximum": 9007199254740991,
          "minimum": -9007199254740991,
          "type": [
            "number",
            "null"
          ]
        }
      },
      "type": "object",
      "unevaluatedProperties": false
    },
    "vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::BulkSizeBasedDefaultBatchSettings>": {
      "_metadata": {
        "docs::advanced": true
      },
      "description": "Event batching behavior.",
      "properties": {
        "max_bytes": {
          "_metadata": {
            "docs::human_name": "Max Bytes",
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "bytes"
          },
          "default": 10000000,
          "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
          "maximum": 9007199254740991,
          "minimum": 0,
          "title": "The maximum size of a batch that is processed by a sink.",
          "type": [
            "integer",
            "null"
          ]
        },
        "max_events": {
          "_metadata": {
            "docs::human_name": "Max Events",
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "events"
          },
          "default": null,
          "description": "The maximum size of a batch before it is flushed.",
          "maximum": 9007199254740991,
          "minimum": 0,
          "type": [
            "integer",
            "null"
          ]
        },
        "timeout_secs": {
          "_metadata": {
            "docs::human_name": "Timeout",
            "docs::numeric_type": "float",
            "docs::optional": true,
            "docs::type_unit": "seconds"
          },
          "default": 300,
          "description": "The maximum age of a batch before it is flushed.",
          "maximum": 9007199254740991,
          "minimum": -9007199254740991,
          "type": [
            "number",
            "null"
          ]
        }
      },
      "type": "object",
      "unevaluatedProperties": false
    },
    "vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::RealtimeSizeBasedDefaultBatchSettings>": {
      "_metadata": {
        "docs::advanced": true
      },
      "description": "Event batching behavior.",
      "properties": {
        "max_bytes": {
          "_metadata": {
            "docs::human_name": "Max Bytes",
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "bytes"
          },
          "default": 10000000,
          "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
          "maximum": 9007199254740991,
          "minimum": 0,
          "title": "The maximum size of a batch that is processed by a sink.",
          "type": [
            "integer",
            "null"
          ]
        },
        "max_events": {
          "_metadata": {
            "docs::human_name": "Max Events",
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "events"
          },
          "default": null,
          "description": "The maximum size of a batch before it is flushed.",
          "maximum": 9007199254740991,
          "minimum": 0,
          "type": [
            "integer",
            "null"
          ]
        },
        "timeout_secs": {
          "_metadata": {
            "docs::human_name": "Timeout",
            "docs::numeric_type": "float",
            "docs::optional": true,
            "docs::type_unit": "seconds"
          },
          "default": 1,
          "description": "The maximum age of a batch before it is flushed.",
          "maximum": 9007199254740991,
          "minimum": -9007199254740991,
          "type": [
            "number",
            "null"
          ]
        }
      },
      "type": "object",
      "unevaluatedProperties": false
    },
    "vector::sinks::util::buffer::compression::Compression": {
      "_metadata": {
        "docs::advanced": true,
        "docs::enum_tagging": "external"
      },
      "description": "All compression algorithms use the default compression level unless otherwise specified.",
      "oneOf": [
        {
          "_metadata": {
            "docs::enum_tagging": "external"
          },
          "description": "Compression algorithm.",
          "oneOf": [
            {
              "_metadata": {
                "docs::human_name": "None",
                "logical_name": "None"
              },
              "const": "none",
              "description": "No compression."
            },
            {
              "_metadata": {
                "docs::human_name": "Gzip",
                "logical_name": "Gzip"
              },
              "const": "gzip",
              "description": "[gzip]: https://www.gzip.org/",
              "title": "[Gzip][gzip] compression."
            },
            {
              "_metadata": {
                "docs::human_name": "Zlib",
                "logical_name": "Zlib"
              },
              "const": "zlib",
              "description": "[zlib]: https://zlib.net/",
              "title": "[Zlib][zlib] compression."
            },
            {
              "_metadata": {
                "docs::human_name": "Zstd",
                "logical_name": "Zstd"
              },
              "const": "zstd",
              "description": "[zstd]: https://facebook.github.io/zstd/",
              "title": "[Zstandard][zstd] compression."
            }
          ]
        },
        {
          "_metadata": {
            "docs::hidden": true
          },
          "description": "Compression algorithm and compression level.",
          "properties": {
            "algorithm": {
              "_metadata": {
                "docs::enum_tagging": "external",
                "docs::human_name": "Algorithm"
              },
              "description": "Compression algorithm.",
              "oneOf": [
                {
                  "_metadata": {
                    "docs::human_name": "None",
                    "logical_name": "None"
                  },
                  "const": "none",
                  "description": "No compression."
                },
                {
                  "_metadata": {
                    "docs::human_name": "Gzip",
                    "logical_name": "Gzip"
                  },
                  "const": "gzip",
                  "description": "[gzip]: https://www.gzip.org/",
                  "title": "[Gzip][gzip] compression."
                },
                {
                  "_metadata": {
                    "docs::human_name": "Zlib",
                    "logical_name": "Zlib"
                  },
                  "const": "zlib",
                  "description": "[zlib]: https://zlib.net/",
                  "title": "[Zlib][zlib] compression."
                },
                {
                  "_metadata": {
                    "docs::human_name": "Zstd",
                    "logical_name": "Zstd"
                  },
                  "const": "zstd",
                  "description": "[zstd]: https://facebook.github.io/zstd/",
                  "title": "[Zstandard][zstd] compression."
                }
              ],
              "unevaluatedProperties": false
            },
            "level": {
              "_metadata": {
                "docs::human_name": "Level"
              },
              "description": "Compression level.",
              "enum": [
                "none",
                "fast",
                "best",
                "default",
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21
              ]
            }
          },
          "required": [
            "algorithm"
          ],
          "type": "object"
        }
      ],
      "title": "Compression configuration.",
      "unevaluatedProperties": false
    },
    "vector::sinks::util::http::RequestConfig": {
      "allOf": [
        {
          "properties": {
            "headers": {
              "_metadata": {
                "docs::additional_props_description": "An HTTP request header and it's value.",
                "docs::examples": {
                  "Accept": "text/plain",
                  "X-My-Custom-Header": "A-Value"
                },
                "docs::human_name": "Headers"
              },
              "additionalProperties": {
                "type": "string"
              },
              "default": {},
              "description": "Additional HTTP headers to add to every HTTP request.",
              "type": "object"
            }
          },
          "type": "object"
        },
        {
          "_metadata": {
            "docs::advanced": true
          },
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "properties": {
            "adaptive_concurrency": {
              "_metadata": {
                "docs::human_name": "Adaptive Concurrency"
              },
              "default": {
                "decrease_ratio": 0.9,
                "ewma_alpha": 0.4,
                "initial_concurrency": 1,
                "rtt_deviation_scale": 2.5
              },
              "description": "These parameters typically do not require changes from the default, and incorrect values can lead to meta-stable or\nunstable performance and sink behavior. Proceed with caution.",
              "properties": {
                "decrease_ratio": {
                  "_metadata": {
                    "docs::human_name": "Decrease Ratio",
                    "docs::numeric_type": "float"
                  },
                  "default": 0.9,
                  "description": "Valid values are greater than `0` and less than `1`. Smaller values cause the algorithm to scale back rapidly\nwhen latency increases.\n\nNote that the new limit is rounded down after applying this ratio.",
                  "maximum": 1,
                  "minimum": 0,
                  "title": "The fraction of the current value to set the new concurrency limit when decreasing the limit.",
                  "type": "number"
                },
                "ewma_alpha": {
                  "_metadata": {
                    "docs::human_name": "EWMA Alpha",
                    "docs::numeric_type": "float"
                  },
                  "default": 0.4,
                  "description": "Valid values are greater than `0` and less than `1`.\n\nARC uses an exponentially weighted moving average (EWMA) of past RTT measurements as a reference to compare with\nthe current RTT. Smaller values cause this reference to adjust more slowly, which may be useful if a service has\nunusually high response variability.",
                  "maximum": 1,
                  "minimum": 0,
                  "title": "The weighting of new measurements compared to older measurements.",
                  "type": "number"
                },
                "initial_concurrency": {
                  "_metadata": {
                    "docs::human_name": "Initial Concurrency",
                    "docs::numeric_type": "uint"
                  },
                  "default": 1,
                  "description": "It is recommended to set this value to your service's average limit if you're seeing that it takes a\nlong time to ramp up adaptive concurrency after a restart. You can find this value by looking at the\n`adaptive_concurrency_limit` metric.",
                  "maximum": 200,
                  "minimum": 1,
                  "title": "The initial concurrency limit to use. If not specified, the initial limit will be 1 (no concurrency).",
                  "type": "integer"
                },
                "rtt_deviation_scale": {
                  "_metadata": {
                    "docs::human_name": "RTT Deviation Scale",
                    "docs::numeric_type": "float"
                  },
                  "default": 2.5,
                  "description": "Valid values are greater than or equal to `0`, and we expect reasonable values to range from `1.0` to `3.0`.\n\nWhen calculating the past RTT average, we also compute a secondary “deviation” value that indicates how variable\nthose values are. We use that deviation when comparing the past RTT average to the current measurements, so we\ncan ignore increases in RTT that are within an expected range. This factor is used to scale up the deviation to\nan appropriate range.  Larger values cause the algorithm to ignore larger increases in the RTT.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "title": "Scale of RTT deviations which are not considered anomalous.",
                  "type": "number"
                }
              },
              "title": "Configuration of adaptive concurrency parameters.",
              "type": "object",
              "unevaluatedProperties": false
            },
            "concurrency": {
              "_metadata": {
                "docs::enum_tagging": "external",
                "docs::human_name": "Concurrency"
              },
              "default": "none",
              "description": "Configuration for outbound request concurrency.",
              "oneOf": [
                {
                  "_metadata": {
                    "docs::human_name": "None",
                    "logical_name": "None"
                  },
                  "const": "none",
                  "description": "Only one request can be outstanding at any given time.",
                  "title": "A fixed concurrency of 1."
                },
                {
                  "_metadata": {
                    "docs::human_name": "Adaptive",
                    "logical_name": "Adaptive"
                  },
                  "const": "adaptive",
                  "description": "[arc]: https://vector.dev/docs/about/under-the-hood/networking/arc/",
                  "title": "Concurrency will be managed by Vector's [Adaptive Request Concurrency][arc] feature."
                },
                {
                  "_metadata": {
                    "docs::human_name": "Fixed",
                    "docs::numeric_type": "uint",
                    "logical_name": "Fixed"
                  },
                  "description": "A fixed amount of concurrency will be allowed.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "type": "integer"
                }
              ],
              "unevaluatedProperties": false
            },
            "rate_limit_duration_secs": {
              "_metadata": {
                "docs::human_name": "Rate Limit Duration",
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "seconds"
              },
              "default": 1,
              "description": "The time window used for the `rate_limit_num` option.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "type": [
                "integer",
                "null"
              ]
            },
            "rate_limit_num": {
              "_metadata": {
                "docs::human_name": "Rate Limit Number",
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "requests"
              },
              "default": 9223372036854775808,
              "description": "The maximum number of requests allowed within the `rate_limit_duration_secs` time window.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "type": [
                "integer",
                "null"
              ]
            },
            "retry_attempts": {
              "_metadata": {
                "docs::human_name": "Retry Attempts",
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "retries"
              },
              "default": 9223372036854775808,
              "description": "The default, for all intents and purposes, represents an infinite number of retries.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "title": "The maximum number of retries to make for failed requests.",
              "type": [
                "integer",
                "null"
              ]
            },
            "retry_initial_backoff_secs": {
              "_metadata": {
                "docs::human_name": "Retry Initial Backoff",
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "seconds"
              },
              "default": 1,
              "description": "After the first retry has failed, the fibonacci sequence is used to select future backoffs.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "title": "The amount of time to wait before attempting the first retry for a failed request.",
              "type": [
                "integer",
                "null"
              ]
            },
            "retry_max_duration_secs": {
              "_metadata": {
                "docs::human_name": "Max Retry Duration",
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "seconds"
              },
              "default": 3600,
              "description": "The maximum amount of time to wait between retries.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "type": [
                "integer",
                "null"
              ]
            },
            "timeout_secs": {
              "_metadata": {
                "docs::human_name": "Timeout",
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "seconds"
              },
              "default": 60,
              "description": "Datadog highly recommends that you do not lower this value below the service's internal timeout, as this could\ncreate orphaned requests, pile on retries, and result in duplicate data downstream.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "title": "The time a request can take before being aborted.",
              "type": [
                "integer",
                "null"
              ]
            }
          },
          "title": "Middleware settings for outbound requests.",
          "type": "object"
        }
      ],
      "description": "Outbound HTTP request settings.",
      "unevaluatedProperties": false
    },
    "vector::sinks::util::service::TowerRequestConfig": {
      "_metadata": {
        "docs::advanced": true
      },
      "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
      "properties": {
        "adaptive_concurrency": {
          "_metadata": {
            "docs::human_name": "Adaptive Concurrency"
          },
          "default": {
            "decrease_ratio": 0.9,
            "ewma_alpha": 0.4,
            "initial_concurrency": 1,
            "rtt_deviation_scale": 2.5
          },
          "description": "These parameters typically do not require changes from the default, and incorrect values can lead to meta-stable or\nunstable performance and sink behavior. Proceed with caution.",
          "properties": {
            "decrease_ratio": {
              "_metadata": {
                "docs::human_name": "Decrease Ratio",
                "docs::numeric_type": "float"
              },
              "default": 0.9,
              "description": "Valid values are greater than `0` and less than `1`. Smaller values cause the algorithm to scale back rapidly\nwhen latency increases.\n\nNote that the new limit is rounded down after applying this ratio.",
              "maximum": 1,
              "minimum": 0,
              "title": "The fraction of the current value to set the new concurrency limit when decreasing the limit.",
              "type": "number"
            },
            "ewma_alpha": {
              "_metadata": {
                "docs::human_name": "EWMA Alpha",
                "docs::numeric_type": "float"
              },
              "default": 0.4,
              "description": "Valid values are greater than `0` and less than `1`.\n\nARC uses an exponentially weighted moving average (EWMA) of past RTT measurements as a reference to compare with\nthe current RTT. Smaller values cause this reference to adjust more slowly, which may be useful if a service has\nunusually high response variability.",
              "maximum": 1,
              "minimum": 0,
              "title": "The weighting of new measurements compared to older measurements.",
              "type": "number"
            },
            "initial_concurrency": {
              "_metadata": {
                "docs::human_name": "Initial Concurrency",
                "docs::numeric_type": "uint"
              },
              "default": 1,
              "description": "It is recommended to set this value to your service's average limit if you're seeing that it takes a\nlong time to ramp up adaptive concurrency after a restart. You can find this value by looking at the\n`adaptive_concurrency_limit` metric.",
              "maximum": 200,
              "minimum": 1,
              "title": "The initial concurrency limit to use. If not specified, the initial limit will be 1 (no concurrency).",
              "type": "integer"
            },
            "rtt_deviation_scale": {
              "_metadata": {
                "docs::human_name": "RTT Deviation Scale",
                "docs::numeric_type": "float"
              },
              "default": 2.5,
              "description": "Valid values are greater than or equal to `0`, and we expect reasonable values to range from `1.0` to `3.0`.\n\nWhen calculating the past RTT average, we also compute a secondary “deviation” value that indicates how variable\nthose values are. We use that deviation when comparing the past RTT average to the current measurements, so we\ncan ignore increases in RTT that are within an expected range. This factor is used to scale up the deviation to\nan appropriate range.  Larger values cause the algorithm to ignore larger increases in the RTT.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "title": "Scale of RTT deviations which are not considered anomalous.",
              "type": "number"
            }
          },
          "title": "Configuration of adaptive concurrency parameters.",
          "type": "object",
          "unevaluatedProperties": false
        },
        "concurrency": {
          "_metadata": {
            "docs::enum_tagging": "external",
            "docs::human_name": "Concurrency"
          },
          "default": "none",
          "description": "Configuration for outbound request concurrency.",
          "oneOf": [
            {
              "_metadata": {
                "docs::human_name": "None",
                "logical_name": "None"
              },
              "const": "none",
              "description": "Only one request can be outstanding at any given time.",
              "title": "A fixed concurrency of 1."
            },
            {
              "_metadata": {
                "docs::human_name": "Adaptive",
                "logical_name": "Adaptive"
              },
              "const": "adaptive",
              "description": "[arc]: https://vector.dev/docs/about/under-the-hood/networking/arc/",
              "title": "Concurrency will be managed by Vector's [Adaptive Request Concurrency][arc] feature."
            },
            {
              "_metadata": {
                "docs::human_name": "Fixed",
                "docs::numeric_type": "uint",
                "logical_name": "Fixed"
              },
              "description": "A fixed amount of concurrency will be allowed.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "type": "integer"
            }
          ],
          "unevaluatedProperties": false
        },
        "rate_limit_duration_secs": {
          "_metadata": {
            "docs::human_name": "Rate Limit Duration",
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "seconds"
          },
          "default": 1,
          "description": "The time window used for the `rate_limit_num` option.",
          "maximum": 9007199254740991,
          "minimum": 0,
          "type": [
            "integer",
            "null"
          ]
        },
        "rate_limit_num": {
          "_metadata": {
            "docs::human_name": "Rate Limit Number",
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "requests"
          },
          "default": 9223372036854775808,
          "description": "The maximum number of requests allowed within the `rate_limit_duration_secs` time window.",
          "maximum": 9007199254740991,
          "minimum": 0,
          "type": [
            "integer",
            "null"
          ]
        },
        "retry_attempts": {
          "_metadata": {
            "docs::human_name": "Retry Attempts",
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "retries"
          },
          "default": 9223372036854775808,
          "description": "The default, for all intents and purposes, represents an infinite number of retries.",
          "maximum": 9007199254740991,
          "minimum": 0,
          "title": "The maximum number of retries to make for failed requests.",
          "type": [
            "integer",
            "null"
          ]
        },
        "retry_initial_backoff_secs": {
          "_metadata": {
            "docs::human_name": "Retry Initial Backoff",
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "seconds"
          },
          "default": 1,
          "description": "After the first retry has failed, the fibonacci sequence is used to select future backoffs.",
          "maximum": 9007199254740991,
          "minimum": 0,
          "title": "The amount of time to wait before attempting the first retry for a failed request.",
          "type": [
            "integer",
            "null"
          ]
        },
        "retry_max_duration_secs": {
          "_metadata": {
            "docs::human_name": "Max Retry Duration",
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "seconds"
          },
          "default": 3600,
          "description": "The maximum amount of time to wait between retries.",
          "maximum": 9007199254740991,
          "minimum": 0,
          "type": [
            "integer",
            "null"
          ]
        },
        "timeout_secs": {
          "_metadata": {
            "docs::human_name": "Timeout",
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "seconds"
          },
          "default": 60,
          "description": "Datadog highly recommends that you do not lower this value below the service's internal timeout, as this could\ncreate orphaned requests, pile on retries, and result in duplicate data downstream.",
          "maximum": 9007199254740991,
          "minimum": 0,
          "title": "The time a request can take before being aborted.",
          "type": [
            "integer",
            "null"
          ]
        }
      },
      "title": "Middleware settings for outbound requests.",
      "type": "object",
      "unevaluatedProperties": false
    },
    "vector::sinks::util::service::net::HostAndPort": {
      "_metadata": {
        "docs::examples": [
          "92.12.333.224:5000",
          "somehost:5000"
        ]
      },
      "description": "Both IP addresses and hostnames/fully qualified domain names (FQDNs) are accepted formats.\n\nThe address _must_ include a port.",
      "title": "The address to connect to.",
      "type": "string"
    },
    "vector::sinks::util::uri::UriSerde": {
      "description": "",
      "title": "The URI component of a request.",
      "type": "string"
    },
    "vector::sinks::vector::config::VectorConfig": {
      "_metadata": {
        "docs::component_name": "vector",
        "docs::component_type": "sink"
      },
      "description": "Configuration for the `vector` sink.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled for this sink."
        },
        "address": {
          "_metadata": {
            "docs::examples": [
              "92.12.333.224:6000",
              "https://somehost:6000"
            ],
            "docs::human_name": "Address"
          },
          "description": "Both IP address and hostname are accepted formats.\n\nThe address _must_ include a port.",
          "format": "uri",
          "title": "The downstream Vector address to which to connect.",
          "type": "string"
        },
        "batch": {
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Batch"
          },
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "description": "Event batching behavior.",
          "properties": {
            "max_bytes": {
              "_metadata": {
                "docs::human_name": "Max Bytes",
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "bytes"
              },
              "default": null,
              "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "title": "The maximum size of a batch that is processed by a sink.",
              "type": [
                "integer",
                "null"
              ]
            },
            "max_events": {
              "_metadata": {
                "docs::human_name": "Max Events",
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "events"
              },
              "default": 1000,
              "description": "The maximum size of a batch before it is flushed.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "type": [
                "integer",
                "null"
              ]
            },
            "timeout_secs": {
              "_metadata": {
                "docs::human_name": "Timeout",
                "docs::numeric_type": "float",
                "docs::optional": true,
                "docs::type_unit": "seconds"
              },
              "default": 1,
              "description": "The maximum age of a batch before it is flushed.",
              "maximum": 9007199254740991,
              "minimum": -9007199254740991,
              "type": [
                "number",
                "null"
              ]
            }
          },
          "type": "object",
          "unevaluatedProperties": false
        },
        "compression": {
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Compression"
          },
          "default": false,
          "description": "If set to `true`, requests are compressed with [`gzip`][gzip_docs].\n\n[gzip_docs]: https://www.gzip.org/",
          "title": "Whether or not to compress requests.",
          "type": "boolean"
        },
        "request": {
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          },
          "default": {
            "adaptive_concurrency": {
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "initial_concurrency": 1,
              "rtt_deviation_scale": 2.5
            },
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775808,
            "retry_attempts": 9223372036854775808,
            "retry_initial_backoff_secs": 1,
            "retry_max_duration_secs": 3600,
            "timeout_secs": 60
          },
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "title": "Middleware settings for outbound requests."
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          },
          "default": null
        },
        "version": {
          "_metadata": {
            "docs::hidden": true,
            "docs::human_name": "Version",
            "docs::optional": true
          },
          "description": "Version of the configuration.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "_metadata": {
                "docs::enum_tagging": "external"
              },
              "description": "Marker type for the version two of the configuration for the `vector` sink.",
              "oneOf": [
                {
                  "_metadata": {
                    "docs::human_name": "V2",
                    "logical_name": "V2"
                  },
                  "const": "2",
                  "description": "Marker value for version two."
                }
              ]
            }
          ],
          "unevaluatedProperties": false
        }
      },
      "required": [
        "address"
      ],
      "type": "object"
    },
    "vector::sinks::webhdfs::config::WebHdfsConfig": {
      "_metadata": {
        "docs::component_name": "webhdfs",
        "docs::component_type": "sink"
      },
      "allOf": [
        {
          "properties": {
            "acknowledgements": {
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              },
              "default": {
                "enabled": null
              },
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "title": "Controls how acknowledgements are handled for this sink."
            },
            "batch": {
              "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::BulkSizeBasedDefaultBatchSettings>",
              "_metadata": {
                "docs::human_name": "Batch"
              },
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "description": "Event batching behavior."
            },
            "compression": {
              "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
              "_metadata": {
                "docs::human_name": "Compression"
              },
              "default": "gzip",
              "description": "All compression algorithms use the default compression level unless otherwise specified.",
              "title": "Compression configuration."
            },
            "endpoint": {
              "_metadata": {
                "docs::examples": "http://127.0.0.1:9870",
                "docs::human_name": "Endpoint"
              },
              "default": "",
              "description": "The endpoint is the HDFS's web restful HTTP API endpoint.\n\nFor more information, see the [HDFS Architecture][hdfs_arch] documentation.\n\n[hdfs_arch]: https://hadoop.apache.org/docs/r3.3.4/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html#NameNode_and_DataNodes",
              "title": "An HDFS cluster consists of a single NameNode, a master server that manages the file system namespace and regulates access to files by clients.",
              "type": "string"
            },
            "prefix": {
              "_metadata": {
                "docs::human_name": "Prefix",
                "docs::templateable": true
              },
              "default": "",
              "description": "Prefixes are useful for partitioning objects, such as by creating a blob key that\nstores blobs under a particular directory. If using a prefix for this purpose, it must end\nin `/` to act as a directory path. A trailing `/` is **not** automatically added.\n\nThe final file path is in the format of `{root}/{prefix}{suffix}`.",
              "title": "A prefix to apply to all keys.",
              "type": "string"
            },
            "root": {
              "_metadata": {
                "docs::human_name": "Root"
              },
              "default": "",
              "description": "Must be a valid directory.\n\nThe final file path is in the format of `{root}/{prefix}{suffix}`.",
              "title": "The root path for WebHDFS.",
              "type": "string"
            }
          },
          "type": "object"
        },
        {
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfigWithFraming",
          "description": "Encoding configuration."
        }
      ],
      "description": "Configuration for the `webhdfs` sink."
    },
    "vector::sources::Sources": {
      "_metadata": {
        "docs::enum_tag_field": "type",
        "docs::enum_tagging": "internal"
      },
      "description": "Configurable sources in Vector.",
      "oneOf": [
        {
          "_metadata": {
            "docs::human_name": "AMQP",
            "logical_name": "AmqpSource"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sources::amqp::AmqpSourceConfig",
              "description": "Supports AMQP version 0.9.1",
              "title": "Configuration for the `amqp` source."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "amqp",
                  "description": "Collect events from AMQP 0.9.1 compatible brokers like RabbitMQ."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Collect events from AMQP 0.9.1 compatible brokers like RabbitMQ."
        },
        {
          "_metadata": {
            "docs::human_name": "AWS Kinesis Firehose",
            "logical_name": "AwsKinesisFirehose"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sources::aws_kinesis_firehose::AwsKinesisFirehoseConfig",
              "description": "Configuration for the `aws_kinesis_firehose` source."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "aws_kinesis_firehose",
                  "description": "Collect logs from AWS Kinesis Firehose."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Collect logs from AWS Kinesis Firehose."
        },
        {
          "_metadata": {
            "docs::human_name": "AWS S3",
            "logical_name": "AwsS3"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sources::aws_s3::AwsS3Config",
              "description": "Configuration for the `aws_s3` source."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "aws_s3",
                  "description": "Collect logs from AWS S3."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Collect logs from AWS S3."
        },
        {
          "_metadata": {
            "docs::human_name": "AWS SQS",
            "logical_name": "AwsSqs"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sources::aws_sqs::config::AwsSqsConfig",
              "description": "Configuration for the `aws_sqs` source."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "aws_sqs",
                  "description": "Collect logs from AWS SQS."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Collect logs from AWS SQS."
        },
        {
          "_metadata": {
            "docs::human_name": "Datadog Agent",
            "logical_name": "DatadogAgent"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sources::datadog_agent::DatadogAgentConfig",
              "description": "Configuration for the `datadog_agent` source."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "datadog_agent",
                  "description": "Receive logs, metrics, and traces collected by a Datadog Agent."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Receive logs, metrics, and traces collected by a Datadog Agent."
        },
        {
          "_metadata": {
            "docs::human_name": "Demo Logs",
            "logical_name": "DemoLogs"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sources::demo_logs::DemoLogsConfig",
              "description": "Configuration for the `demo_logs` source."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "demo_logs",
                  "description": "Generate fake log events, which can be useful for testing and demos."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Generate fake log events, which can be useful for testing and demos."
        },
        {
          "_metadata": {
            "docs::human_name": "Fluent",
            "logical_name": "Fluent"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sources::fluent::FluentConfig",
              "description": "Configuration for the `fluent` source."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "fluent",
                  "description": "Collect logs from a Fluentd or Fluent Bit agent."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Collect logs from a Fluentd or Fluent Bit agent."
        },
        {
          "_metadata": {
            "docs::human_name": "GCP Pub/Sub",
            "logical_name": "Pubsub"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sources::gcp_pubsub::PubsubConfig",
              "description": "Configuration for the `gcp_pubsub` source."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "gcp_pubsub",
                  "description": "Fetch observability events from GCP's Pub/Sub messaging system."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Fetch observability events from GCP's Pub/Sub messaging system."
        },
        {
          "_metadata": {
            "docs::human_name": "Heroku Logs",
            "logical_name": "Logplex"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sources::heroku_logs::LogplexConfig",
              "description": "Configuration for `heroku_logs` source."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "heroku_logs",
                  "description": "Collect logs from Heroku's Logplex, the router responsible for receiving logs from your Heroku apps."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Collect logs from Heroku's Logplex, the router responsible for receiving logs from your Heroku apps."
        },
        {
          "_metadata": {
            "docs::human_name": "Host Metrics",
            "logical_name": "HostMetrics"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sources::host_metrics::HostMetricsConfig",
              "description": "Configuration for the `host_metrics` source."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "host_metrics",
                  "description": "Collect metric data from the local system."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Collect metric data from the local system."
        },
        {
          "_metadata": {
            "docs::human_name": "HTTP",
            "logical_name": "Http"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sources::http_server::HttpConfig",
              "description": "Configuration for the `http` source."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "http",
                  "description": "Host an HTTP endpoint to receive logs."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Host an HTTP endpoint to receive logs."
        },
        {
          "_metadata": {
            "docs::human_name": "HTTP Client",
            "logical_name": "HttpClient"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sources::http_client::client::HttpClientConfig",
              "description": "Configuration for the `http_client` source."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "http_client",
                  "description": "Pull observability data from an HTTP server at a configured interval."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Pull observability data from an HTTP server at a configured interval."
        },
        {
          "_metadata": {
            "docs::human_name": "HTTP Server",
            "logical_name": "SimpleHttp"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sources::http_server::SimpleHttpConfig",
              "description": "Configuration for the `http_server` source."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "http_server",
                  "description": "Host an HTTP endpoint to receive logs."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Host an HTTP endpoint to receive logs."
        },
        {
          "_metadata": {
            "docs::human_name": "Internal Logs",
            "logical_name": "InternalLogs"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sources::internal_logs::InternalLogsConfig",
              "description": "Configuration for the `internal_logs` source."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "internal_logs",
                  "description": "Expose internal log messages emitted by the running Vector instance."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Expose internal log messages emitted by the running Vector instance."
        },
        {
          "_metadata": {
            "docs::human_name": "Internal Metrics",
            "logical_name": "InternalMetrics"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sources::internal_metrics::InternalMetricsConfig",
              "description": "Configuration for the `internal_metrics` source."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "internal_metrics",
                  "description": "Expose internal metrics emitted by the running Vector instance."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Expose internal metrics emitted by the running Vector instance."
        },
        {
          "_metadata": {
            "docs::human_name": "Kafka",
            "logical_name": "KafkaSource"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sources::kafka::KafkaSourceConfig",
              "description": "Configuration for the `kafka` source."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "kafka",
                  "description": "Collect logs from Apache Kafka."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Collect logs from Apache Kafka."
        },
        {
          "_metadata": {
            "docs::human_name": "Logstash",
            "logical_name": "Logstash"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sources::logstash::LogstashConfig",
              "description": "Configuration for the `logstash` source."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "logstash",
                  "description": "Collect logs from a Logstash agent."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Collect logs from a Logstash agent."
        },
        {
          "_metadata": {
            "docs::human_name": "NATS",
            "logical_name": "NatsSource"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sources::nats::NatsSourceConfig",
              "description": "Configuration for the `nats` source."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "nats",
                  "description": "Read observability data from subjects on the NATS messaging system."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Read observability data from subjects on the NATS messaging system."
        },
        {
          "_metadata": {
            "docs::human_name": "OpenTelemetry",
            "logical_name": "Opentelemetry"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sources::opentelemetry::OpentelemetryConfig",
              "description": "Configuration for the `opentelemetry` source."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "opentelemetry",
                  "description": "Receive OTLP data through gRPC or HTTP."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Receive OTLP data through gRPC or HTTP."
        },
        {
          "_metadata": {
            "docs::human_name": "Prometheus Remote Write",
            "logical_name": "PrometheusRemoteWrite"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sources::prometheus::remote_write::PrometheusRemoteWriteConfig",
              "description": "Configuration for the `prometheus_remote_write` source."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "prometheus_remote_write",
                  "description": "Receive metric via the Prometheus Remote Write protocol."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Receive metric via the Prometheus Remote Write protocol."
        },
        {
          "_metadata": {
            "docs::human_name": "Redis",
            "logical_name": "RedisSource"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sources::redis::RedisSourceConfig",
              "description": "Configuration for the `redis` source."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "redis",
                  "description": "Collect observability data from Redis."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Collect observability data from Redis."
        },
        {
          "_metadata": {
            "docs::human_name": "Splunk HEC",
            "logical_name": "Splunk"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sources::splunk_hec::SplunkConfig",
              "description": "Configuration for the `splunk_hec` source."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "splunk_hec",
                  "description": "Receive logs from Splunk."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Receive logs from Splunk."
        },
        {
          "_metadata": {
            "docs::human_name": "StatsD",
            "logical_name": "Statsd"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sources::statsd::StatsdConfig",
              "description": "Configuration for the `statsd` source."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "statsd",
                  "description": "Collect metrics emitted by the StatsD aggregator."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Collect metrics emitted by the StatsD aggregator."
        },
        {
          "_metadata": {
            "docs::human_name": "Stdin",
            "logical_name": "Stdin"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sources::file_descriptors::stdin::StdinConfig",
              "description": "Configuration for the `stdin` source."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "stdin",
                  "description": "Collect logs sent via stdin."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Collect logs sent via stdin."
        },
        {
          "_metadata": {
            "docs::human_name": "Syslog",
            "logical_name": "Syslog"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sources::syslog::SyslogConfig",
              "description": "Configuration for the `syslog` source."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "syslog",
                  "description": "Collect logs sent via Syslog."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Collect logs sent via Syslog."
        },
        {
          "_metadata": {
            "docs::human_name": "Unit Test",
            "logical_name": "UnitTestSource"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::config::unit_test::unit_test_components::UnitTestSourceConfig",
              "description": "Configuration for the `unit_test` source."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "unit_test",
                  "description": "Unit test."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Unit test."
        },
        {
          "_metadata": {
            "docs::human_name": "Unit Test Stream",
            "logical_name": "UnitTestStreamSource"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::config::unit_test::unit_test_components::UnitTestStreamSourceConfig",
              "description": "Configuration for the `unit_test_stream` source."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "unit_test_stream",
                  "description": "Unit test stream."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Unit test stream."
        },
        {
          "_metadata": {
            "docs::human_name": "Vector",
            "logical_name": "Vector"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::sources::vector::VectorConfig",
              "description": "Configuration for the `vector` source."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "vector",
                  "description": "Collect observability data from a Vector instance."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Collect observability data from a Vector instance."
        }
      ]
    },
    "vector::sources::amqp::AmqpSourceConfig": {
      "_metadata": {
        "docs::component_name": "amqp",
        "docs::component_type": "source"
      },
      "allOf": [
        {
          "properties": {
            "acknowledgements": {
              "$ref": "#/definitions/vector_core::config::SourceAcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              },
              "default": {
                "enabled": null
              },
              "description": "This setting is **deprecated** in favor of enabling `acknowledgements` at the [global][global_acks] or sink level.\n\nEnabling or disabling acknowledgements at the source level has **no effect** on acknowledgement behavior.\n\nSee [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "title": "Controls how acknowledgements are handled by this source."
            },
            "consumer": {
              "_metadata": {
                "docs::examples": "consumer-group-name",
                "docs::human_name": "Consumer"
              },
              "default": "vector",
              "description": "The identifier for the consumer.",
              "type": "string"
            },
            "decoding": {
              "$ref": "#/definitions/codecs::decoding::DeserializerConfig",
              "_metadata": {
                "docs::human_name": "Decoding"
              },
              "default": {
                "codec": "bytes"
              },
              "description": "Configures how events are decoded from raw bytes."
            },
            "exchange_key": {
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
              "_metadata": {
                "docs::human_name": "Exchange Key"
              },
              "default": "exchange",
              "description": "The `AMQP` exchange key."
            },
            "framing": {
              "$ref": "#/definitions/codecs::decoding::FramingConfig",
              "_metadata": {
                "docs::human_name": "Framing"
              },
              "default": {
                "method": "bytes"
              },
              "description": "Framing handles how events are separated when encoded in a raw byte form, where each event is\na frame that must be prefixed, or delimited, in a way that marks where an event begins and\nends within the byte stream.",
              "title": "Framing configuration."
            },
            "log_namespace": {
              "_metadata": {
                "docs::hidden": true,
                "docs::human_name": "Log Namespace",
                "docs::optional": true
              },
              "default": null,
              "description": "The namespace to use for logs. This overrides the global setting.",
              "type": [
                "boolean",
                "null"
              ]
            },
            "offset_key": {
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
              "_metadata": {
                "docs::human_name": "Offset Key"
              },
              "default": "offset",
              "description": "The `AMQP` offset key."
            },
            "queue": {
              "_metadata": {
                "docs::human_name": "Queue"
              },
              "default": "vector",
              "description": "The name of the queue to consume.",
              "type": "string"
            },
            "routing_key_field": {
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
              "_metadata": {
                "docs::human_name": "Routing Key Field"
              },
              "default": "routing",
              "description": "The `AMQP` routing key."
            }
          },
          "type": "object"
        },
        {
          "$ref": "#/definitions/vector::amqp::AmqpConfig",
          "description": "AMQP connection options."
        }
      ],
      "description": "Supports AMQP version 0.9.1",
      "title": "Configuration for the `amqp` source."
    },
    "vector::sources::aws_kinesis_firehose::AwsKinesisFirehoseConfig": {
      "_metadata": {
        "docs::component_name": "aws_kinesis_firehose",
        "docs::component_type": "source"
      },
      "description": "Configuration for the `aws_kinesis_firehose` source.",
      "properties": {
        "access_key": {
          "$ref": "#/definitions/core::option::Option<vector_common::sensitive_string::SensitiveString>",
          "_metadata": {
            "deprecated_message": "This option has been deprecated, use `access_keys` instead.",
            "docs::examples": "A94A8FE5CCB19BA61C4C08",
            "docs::human_name": "Access Key"
          },
          "deprecated": true,
          "description": "AWS Kinesis Firehose can be configured to pass along a user-configurable access key with each request. If\nconfigured, `access_key` should be set to the same value. Otherwise, all requests are allowed.",
          "title": "An access key to authenticate requests against."
        },
        "access_keys": {
          "_metadata": {
            "docs::examples": [
              "A94A8FE5CCB19BA61C4C08",
              "B94B8FE5CCB19BA61C4C12"
            ],
            "docs::human_name": "Access Keys",
            "docs::optional": true,
            "sensitive": true
          },
          "description": "AWS Kinesis Firehose can be configured to pass along a user-configurable access key with each request. If\nconfigured, `access_keys` should be set to the same value. Otherwise, all requests are allowed.",
          "items": {
            "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString"
          },
          "title": "A list of access keys to authenticate requests against.",
          "type": [
            "array",
            "null"
          ]
        },
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::SourceAcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "This setting is **deprecated** in favor of enabling `acknowledgements` at the [global][global_acks] or sink level.\n\nEnabling or disabling acknowledgements at the source level has **no effect** on acknowledgement behavior.\n\nSee [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled by this source."
        },
        "address": {
          "$ref": "#/definitions/stdlib::SocketAddr",
          "_metadata": {
            "docs::examples": [
              "0.0.0.0:443",
              "localhost:443"
            ],
            "docs::human_name": "Address"
          },
          "description": "The socket address to listen for connections on."
        },
        "decoding": {
          "$ref": "#/definitions/codecs::decoding::DeserializerConfig",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Decoding"
          },
          "default": {
            "codec": "bytes"
          },
          "description": "Configures how events are decoded from raw bytes."
        },
        "framing": {
          "$ref": "#/definitions/codecs::decoding::FramingConfig",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Framing"
          },
          "default": {
            "method": "bytes"
          },
          "description": "Framing handles how events are separated when encoded in a raw byte form, where each event is\na frame that must be prefixed, or delimited, in a way that marks where an event begins and\nends within the byte stream.",
          "title": "Framing configuration."
        },
        "log_namespace": {
          "_metadata": {
            "docs::hidden": true,
            "docs::human_name": "Log Namespace",
            "docs::optional": true
          },
          "default": null,
          "description": "The namespace to use for logs. This overrides the global setting.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "record_compression": {
          "_metadata": {
            "docs::advanced": true,
            "docs::enum_tagging": "external",
            "docs::human_name": "Record Compression"
          },
          "default": "auto",
          "description": "Some services, like AWS CloudWatch Logs, [compresses the events with gzip][events_with_gzip],\nbefore sending them AWS Kinesis Firehose. This option can be used to automatically decompress\nthem before forwarding them to the next component.\n\nNote that this is different from [Content encoding option][encoding_option] of the\nFirehose HTTP endpoint destination. That option controls the content encoding of the entire HTTP request.\n\n[events_with_gzip]: https://docs.aws.amazon.com/firehose/latest/dev/writing-with-cloudwatch-logs.html\n[encoding_option]: https://docs.aws.amazon.com/firehose/latest/dev/create-destination.html#create-destination-http",
          "oneOf": [
            {
              "_metadata": {
                "docs::human_name": "Auto",
                "logical_name": "Auto"
              },
              "const": "auto",
              "description": "The compression scheme of the object is determined by looking at its file signature, also known\nas [magic bytes][magic_bytes].\n\nIf the record fails to decompress with the discovered format, the record is forwarded as is.\nThus, if you know the records are always gzip encoded (for example, if they are coming from AWS CloudWatch Logs),\nset `gzip` in this field so that any records that are not-gzipped are rejected.\n\n[magic_bytes]: https://en.wikipedia.org/wiki/List_of_file_signatures",
              "title": "Automatically attempt to determine the compression scheme."
            },
            {
              "_metadata": {
                "docs::human_name": "None",
                "logical_name": "None"
              },
              "const": "none",
              "description": "Uncompressed."
            },
            {
              "_metadata": {
                "docs::human_name": "Gzip",
                "logical_name": "Gzip"
              },
              "const": "gzip",
              "description": "GZIP."
            }
          ],
          "title": "The compression scheme to use for decompressing records within the Firehose message.",
          "unevaluatedProperties": false
        },
        "store_access_key": {
          "_metadata": {
            "docs::human_name": "Store Access Key"
          },
          "description": "If set to `true`, when incoming requests contains an access key sent by AWS Firehose, it is kept in the\nevent secrets as \"aws_kinesis_firehose_access_key\".",
          "title": "Whether or not to store the AWS Firehose Access Key in event secrets.",
          "type": "boolean"
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "required": [
        "address",
        "store_access_key"
      ],
      "type": "object"
    },
    "vector::sources::aws_s3::AwsS3Config": {
      "_metadata": {
        "docs::component_name": "aws_s3",
        "docs::component_type": "source"
      },
      "allOf": [
        {
          "properties": {
            "acknowledgements": {
              "$ref": "#/definitions/vector_core::config::SourceAcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              },
              "default": {
                "enabled": null
              },
              "description": "This setting is **deprecated** in favor of enabling `acknowledgements` at the [global][global_acks] or sink level.\n\nEnabling or disabling acknowledgements at the source level has **no effect** on acknowledgement behavior.\n\nSee [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "title": "Controls how acknowledgements are handled by this source."
            },
            "assume_role": {
              "_metadata": {
                "docs::hidden": true,
                "docs::human_name": "Assume Role",
                "docs::optional": true
              },
              "deprecated": true,
              "description": "[iam_role]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html",
              "title": "The ARN of an [IAM role][iam_role] to assume at startup.",
              "type": [
                "string",
                "null"
              ]
            },
            "auth": {
              "$ref": "#/definitions/vector::aws::auth::AwsAuthentication",
              "_metadata": {
                "docs::human_name": "Auth"
              },
              "default": {
                "imds": {
                  "connect_timeout_seconds": 1,
                  "max_attempts": 4,
                  "read_timeout_seconds": 1
                },
                "load_timeout_secs": null,
                "region": null
              },
              "description": "Configuration of the authentication strategy for interacting with AWS services."
            },
            "compression": {
              "_metadata": {
                "docs::advanced": true,
                "docs::enum_tagging": "external",
                "docs::human_name": "Compression"
              },
              "description": "The compression scheme used for decompressing objects retrieved from S3.",
              "oneOf": [
                {
                  "_metadata": {
                    "docs::human_name": "Auto",
                    "logical_name": "Auto"
                  },
                  "const": "auto",
                  "description": "The compression scheme of the object is determined from its `Content-Encoding` and\n`Content-Type` metadata, as well as the key suffix (for example, `.gz`).\n\nIt is set to `none` if the compression scheme cannot be determined.",
                  "title": "Automatically attempt to determine the compression scheme."
                },
                {
                  "_metadata": {
                    "docs::human_name": "None",
                    "logical_name": "None"
                  },
                  "const": "none",
                  "description": "Uncompressed."
                },
                {
                  "_metadata": {
                    "docs::human_name": "Gzip",
                    "logical_name": "Gzip"
                  },
                  "const": "gzip",
                  "description": "GZIP."
                },
                {
                  "_metadata": {
                    "docs::human_name": "Zstd",
                    "logical_name": "Zstd"
                  },
                  "const": "zstd",
                  "description": "ZSTD."
                }
              ],
              "unevaluatedProperties": false
            },
            "decoding": {
              "$ref": "#/definitions/codecs::decoding::DeserializerConfig",
              "_metadata": {
                "docs::human_name": "Decoding"
              },
              "default": {
                "codec": "bytes"
              },
              "description": "Configures how events are decoded from raw bytes."
            },
            "framing": {
              "$ref": "#/definitions/codecs::decoding::FramingConfig",
              "_metadata": {
                "docs::human_name": "Framing"
              },
              "default": {
                "method": "newline_delimited"
              },
              "description": "Framing handles how events are separated when encoded in a raw byte form, where each event is\na frame that must be prefixed, or delimited, in a way that marks where an event begins and\nends within the byte stream.",
              "title": "Framing configuration."
            },
            "log_namespace": {
              "_metadata": {
                "docs::hidden": true,
                "docs::human_name": "Log Namespace",
                "docs::optional": true
              },
              "default": null,
              "description": "The namespace to use for logs. This overrides the global setting.",
              "type": [
                "boolean",
                "null"
              ]
            },
            "multiline": {
              "_metadata": {
                "docs::human_name": "Multiline",
                "docs::optional": true
              },
              "description": "If not specified, multiline aggregation is disabled.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "description": "Configuration of multi-line aggregation.",
                  "properties": {
                    "condition_pattern": {
                      "_metadata": {
                        "docs::examples": [
                          "^[\\s]+",
                          "\\\\$",
                          "^(INFO|ERROR) ",
                          ";$"
                        ],
                        "docs::human_name": "Condition Pattern"
                      },
                      "description": "This setting must be configured in conjunction with `mode`.",
                      "title": "Regular expression pattern that is used to determine whether or not more lines should be read.",
                      "type": "string"
                    },
                    "mode": {
                      "_metadata": {
                        "docs::enum_tagging": "external",
                        "docs::human_name": "Mode"
                      },
                      "description": "This setting must be configured in conjunction with `condition_pattern`.",
                      "oneOf": [
                        {
                          "_metadata": {
                            "docs::human_name": "Continue Through",
                            "logical_name": "ContinueThrough"
                          },
                          "const": "continue_through",
                          "description": "The first line (the line that matched the start pattern) does not need to match the `ContinueThrough` pattern.\n\nThis is useful in cases such as a Java stack trace, where some indicator in the line (such as a leading\nwhitespace) indicates that it is an extension of the proceeding line.",
                          "title": "All consecutive lines matching this pattern are included in the group."
                        },
                        {
                          "_metadata": {
                            "docs::human_name": "Continue Past",
                            "logical_name": "ContinuePast"
                          },
                          "const": "continue_past",
                          "description": "This is useful in cases where a log message ends with a continuation marker, such as a backslash, indicating\nthat the following line is part of the same message.",
                          "title": "All consecutive lines matching this pattern, plus one additional line, are included in the group."
                        },
                        {
                          "_metadata": {
                            "docs::human_name": "Halt Before",
                            "logical_name": "HaltBefore"
                          },
                          "const": "halt_before",
                          "description": "This is useful where a log line contains a marker indicating that it begins a new message.",
                          "title": "All consecutive lines not matching this pattern are included in the group."
                        },
                        {
                          "_metadata": {
                            "docs::human_name": "Halt With",
                            "logical_name": "HaltWith"
                          },
                          "const": "halt_with",
                          "description": "This is useful where a log line ends with a termination marker, such as a semicolon.",
                          "title": "All consecutive lines, up to and including the first line matching this pattern, are included in the group."
                        }
                      ],
                      "title": "Aggregation mode.",
                      "unevaluatedProperties": false
                    },
                    "start_pattern": {
                      "_metadata": {
                        "docs::examples": [
                          "^[\\s]+",
                          "\\\\$",
                          "^(INFO|ERROR) ",
                          ";$"
                        ],
                        "docs::human_name": "Start Pattern"
                      },
                      "description": "Regular expression pattern that is used to match the start of a new message.",
                      "type": "string"
                    },
                    "timeout_ms": {
                      "$ref": "#/definitions/serde_with::DurationMilliSeconds",
                      "_metadata": {
                        "docs::examples": [
                          1000,
                          600000
                        ],
                        "docs::human_name": "Timeout"
                      },
                      "description": "Once this timeout is reached, the buffered message is guaranteed to be flushed, even if incomplete.",
                      "title": "The maximum amount of time to wait for the next additional line, in milliseconds."
                    }
                  },
                  "required": [
                    "condition_pattern",
                    "mode",
                    "start_pattern",
                    "timeout_ms"
                  ],
                  "type": "object"
                }
              ],
              "title": "Multiline aggregation configuration.",
              "unevaluatedProperties": false
            },
            "sqs": {
              "_metadata": {
                "docs::human_name": "SQS",
                "docs::optional": true
              },
              "description": "Configuration options for SQS.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "description": "SQS configuration options.",
                  "properties": {
                    "client_concurrency": {
                      "_metadata": {
                        "docs::examples": 5,
                        "docs::human_name": "Client Concurrency",
                        "docs::numeric_type": "uint",
                        "docs::optional": true,
                        "docs::type_unit": "tasks"
                      },
                      "description": "Defaults to the number of available CPUs on the system.\n\nShould not typically need to be changed, but it can sometimes be beneficial to raise this\nvalue when there is a high rate of messages being pushed into the queue and the objects\nbeing fetched are small. In these cases, system resources may not be fully utilized without\nfetching more messages per second, as the SQS message consumption rate affects the S3 object\nretrieval rate.",
                      "maximum": 9007199254740991,
                      "minimum": 1,
                      "title": "Number of concurrent tasks to create for polling the queue for messages.",
                      "type": [
                        "integer",
                        "null"
                      ]
                    },
                    "delete_message": {
                      "_metadata": {
                        "docs::human_name": "Delete Message"
                      },
                      "default": true,
                      "description": "It can be useful to set this to `false` for debugging or during the initial setup.",
                      "title": "Whether to delete the message once it is processed.",
                      "type": "boolean"
                    },
                    "poll_secs": {
                      "_metadata": {
                        "docs::human_name": "Poll Secs",
                        "docs::numeric_type": "uint",
                        "docs::type_unit": "seconds"
                      },
                      "default": 15,
                      "description": "Generally, this should not be changed unless instructed to do so, as if messages are available,\nthey are always consumed, regardless of the value of `poll_secs`.",
                      "maximum": 4294967295,
                      "minimum": 0,
                      "title": "How long to wait while polling the queue for new messages, in seconds.",
                      "type": "integer"
                    },
                    "queue_url": {
                      "_metadata": {
                        "docs::examples": "https://sqs.us-east-2.amazonaws.com/123456789012/MyQueue",
                        "docs::human_name": "Queue URL"
                      },
                      "description": "The URL of the SQS queue to poll for bucket notifications.",
                      "format": "uri",
                      "type": "string"
                    },
                    "tls_options": {
                      "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
                      "_metadata": {
                        "docs::human_name": "TLS Options"
                      },
                      "default": null
                    },
                    "visibility_timeout_secs": {
                      "_metadata": {
                        "docs::human_name": "Visibility Timeout",
                        "docs::numeric_type": "uint",
                        "docs::type_unit": "seconds"
                      },
                      "default": 300,
                      "description": "This controls how long a message is left unavailable after it is received. If a message is received, and\ntakes longer than `visibility_timeout_secs` to process and delete the message from the queue, it is made available again for another consumer.\n\nThis can happen if there is an issue between consuming a message and deleting it.",
                      "maximum": 4294967295,
                      "minimum": 0,
                      "title": "The visibility timeout to use for messages, in seconds.",
                      "type": "integer"
                    }
                  },
                  "required": [
                    "queue_url"
                  ],
                  "type": "object"
                }
              ],
              "unevaluatedProperties": false
            },
            "strategy": {
              "_metadata": {
                "docs::enum_tagging": "external",
                "docs::hidden": true,
                "docs::human_name": "Strategy"
              },
              "description": "The strategy to use to consume objects from S3.",
              "oneOf": [
                {
                  "_metadata": {
                    "docs::human_name": "SQS",
                    "logical_name": "Sqs"
                  },
                  "const": "sqs",
                  "description": "[aws_sqs]: https://aws.amazon.com/sqs/",
                  "title": "Consumes objects by processing bucket notification events sent to an [AWS SQS queue][aws_sqs]."
                }
              ],
              "unevaluatedProperties": false
            },
            "tls_options": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS Options"
              }
            }
          },
          "type": "object"
        },
        {
          "$ref": "#/definitions/vector::aws::region::RegionOrEndpoint",
          "description": "Configuration of the region/endpoint to use when interacting with an AWS service."
        }
      ],
      "default": {
        "acknowledgements": {
          "enabled": null
        },
        "assume_role": null,
        "auth": {
          "imds": {
            "connect_timeout_seconds": 1,
            "max_attempts": 4,
            "read_timeout_seconds": 1
          },
          "load_timeout_secs": null,
          "region": null
        },
        "compression": "auto",
        "decoding": {
          "codec": "bytes"
        },
        "endpoint": null,
        "framing": {
          "method": "newline_delimited"
        },
        "log_namespace": null,
        "multiline": null,
        "region": null,
        "sqs": null,
        "strategy": "sqs",
        "tls_options": null
      },
      "description": "Configuration for the `aws_s3` source."
    },
    "vector::sources::aws_sqs::config::AwsSqsConfig": {
      "_metadata": {
        "docs::component_name": "aws_sqs",
        "docs::component_type": "source"
      },
      "allOf": [
        {
          "properties": {
            "acknowledgements": {
              "$ref": "#/definitions/vector_core::config::SourceAcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              },
              "default": {
                "enabled": null
              },
              "description": "This setting is **deprecated** in favor of enabling `acknowledgements` at the [global][global_acks] or sink level.\n\nEnabling or disabling acknowledgements at the source level has **no effect** on acknowledgement behavior.\n\nSee [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "title": "Controls how acknowledgements are handled by this source."
            },
            "auth": {
              "$ref": "#/definitions/vector::aws::auth::AwsAuthentication",
              "_metadata": {
                "docs::human_name": "Auth"
              },
              "default": {
                "imds": {
                  "connect_timeout_seconds": 1,
                  "max_attempts": 4,
                  "read_timeout_seconds": 1
                },
                "load_timeout_secs": null,
                "region": null
              },
              "description": "Configuration of the authentication strategy for interacting with AWS services."
            },
            "client_concurrency": {
              "_metadata": {
                "docs::human_name": "Client Concurrency",
                "docs::numeric_type": "uint",
                "docs::optional": true
              },
              "description": "Defaults to the number of available CPUs on the system.\n\nShould not typically need to be changed, but it can sometimes be beneficial to raise this\nvalue when there is a high rate of messages being pushed into the queue and the messages\nbeing fetched are small. In these cases, system resources may not be fully utilized without\nfetching more messages per second, as it spends more time fetching the messages than\nprocessing them.",
              "maximum": 9007199254740991,
              "minimum": 1,
              "title": "Number of concurrent tasks to create for polling the queue for messages.",
              "type": [
                "integer",
                "null"
              ]
            },
            "decoding": {
              "$ref": "#/definitions/codecs::decoding::DeserializerConfig",
              "_metadata": {
                "docs::human_name": "Decoding"
              },
              "default": {
                "codec": "bytes"
              },
              "description": "Configures how events are decoded from raw bytes."
            },
            "delete_message": {
              "_metadata": {
                "docs::human_name": "Delete Message"
              },
              "default": true,
              "description": "It can be useful to set this to `false` for debugging or during the initial setup.",
              "title": "Whether to delete the message once it is processed.",
              "type": "boolean"
            },
            "framing": {
              "$ref": "#/definitions/codecs::decoding::FramingConfig",
              "_metadata": {
                "docs::human_name": "Framing"
              },
              "default": {
                "method": "bytes"
              },
              "description": "Framing handles how events are separated when encoded in a raw byte form, where each event is\na frame that must be prefixed, or delimited, in a way that marks where an event begins and\nends within the byte stream.",
              "title": "Framing configuration."
            },
            "log_namespace": {
              "_metadata": {
                "docs::hidden": true,
                "docs::human_name": "Log Namespace",
                "docs::optional": true
              },
              "default": null,
              "description": "The namespace to use for logs. This overrides the global setting.",
              "type": [
                "boolean",
                "null"
              ]
            },
            "poll_secs": {
              "_metadata": {
                "docs::human_name": "Poll Wait Time",
                "docs::numeric_type": "uint",
                "docs::type_unit": "seconds"
              },
              "default": 15,
              "description": "Generally, this should not be changed unless instructed to do so, as if messages are available,\nthey are always consumed, regardless of the value of `poll_secs`.",
              "maximum": 4294967295,
              "minimum": 0,
              "title": "How long to wait while polling the queue for new messages, in seconds.",
              "type": "integer"
            },
            "queue_url": {
              "_metadata": {
                "docs::examples": "https://sqs.us-east-2.amazonaws.com/123456789012/MyQueue",
                "docs::human_name": "Queue URL"
              },
              "description": "The URL of the SQS queue to poll for messages.",
              "type": "string"
            },
            "tls": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              }
            },
            "visibility_timeout_secs": {
              "_metadata": {
                "docs::human_name": "Visibility Timeout",
                "docs::numeric_type": "uint",
                "docs::type_unit": "seconds"
              },
              "default": 300,
              "description": "This controls how long a message is left unavailable after it is received. If a message is received, and\ntakes longer than `visibility_timeout_secs` to process and delete the message from the queue, it is made available again for another consumer.\n\nThis can happen if there is an issue between consuming a message and deleting it.",
              "maximum": 4294967295,
              "minimum": 0,
              "title": "The visibility timeout to use for messages, in seconds.",
              "type": "integer"
            }
          },
          "required": [
            "queue_url"
          ],
          "type": "object"
        },
        {
          "$ref": "#/definitions/vector::aws::region::RegionOrEndpoint",
          "description": "Configuration of the region/endpoint to use when interacting with an AWS service."
        }
      ],
      "description": "Configuration for the `aws_sqs` source."
    },
    "vector::sources::datadog_agent::DatadogAgentConfig": {
      "_metadata": {
        "docs::component_name": "datadog_agent",
        "docs::component_type": "source"
      },
      "description": "Configuration for the `datadog_agent` source.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::SourceAcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "This setting is **deprecated** in favor of enabling `acknowledgements` at the [global][global_acks] or sink level.\n\nEnabling or disabling acknowledgements at the source level has **no effect** on acknowledgement behavior.\n\nSee [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled by this source."
        },
        "address": {
          "$ref": "#/definitions/stdlib::SocketAddr",
          "_metadata": {
            "docs::examples": [
              "0.0.0.0:80",
              "localhost:80"
            ],
            "docs::human_name": "Address"
          },
          "description": "It _must_ include a port.",
          "title": "The socket address to accept connections on."
        },
        "decoding": {
          "$ref": "#/definitions/codecs::decoding::DeserializerConfig",
          "_metadata": {
            "docs::human_name": "Decoding"
          },
          "default": {
            "codec": "bytes"
          },
          "description": "Configures how events are decoded from raw bytes."
        },
        "disable_logs": {
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Disable Logs"
          },
          "default": false,
          "description": "If this is set to `true`, logs are not accepted by the component.",
          "type": "boolean"
        },
        "disable_metrics": {
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Disable Metrics"
          },
          "default": false,
          "description": "If this is set to `true`, metrics are not accepted by the component.",
          "type": "boolean"
        },
        "disable_traces": {
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Disable Traces"
          },
          "default": false,
          "description": "If this is set to `true`, traces are not accepted by the component.",
          "type": "boolean"
        },
        "framing": {
          "$ref": "#/definitions/codecs::decoding::FramingConfig",
          "_metadata": {
            "docs::human_name": "Framing"
          },
          "default": {
            "method": "bytes"
          },
          "description": "Framing handles how events are separated when encoded in a raw byte form, where each event is\na frame that must be prefixed, or delimited, in a way that marks where an event begins and\nends within the byte stream.",
          "title": "Framing configuration."
        },
        "log_namespace": {
          "_metadata": {
            "docs::hidden": true,
            "docs::human_name": "Log Namespace",
            "docs::optional": true
          },
          "default": null,
          "description": "The namespace to use for logs. This overrides the global setting.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "multiple_outputs": {
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Multiple Outputs"
          },
          "default": false,
          "description": "For a source component named `agent`, the received logs, metrics, and traces can then be\nconfigured as input to other components by specifying `agent.logs`, `agent.metrics`, and\n`agent.traces`, respectively.",
          "title": "If this is set to `true` logs, metrics, and traces are sent to different outputs.",
          "type": "boolean"
        },
        "store_api_key": {
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Store API Key"
          },
          "default": true,
          "description": "If this is set to `true`, when incoming events contain a Datadog API key, it is\nstored in the event metadata and used if the event is sent to a Datadog sink.",
          "type": "boolean"
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "required": [
        "address"
      ],
      "type": "object"
    },
    "vector::sources::demo_logs::DemoLogsConfig": {
      "_metadata": {
        "docs::component_name": "demo_logs",
        "docs::component_type": "source"
      },
      "allOf": [
        {
          "properties": {
            "count": {
              "_metadata": {
                "docs::human_name": "Count",
                "docs::numeric_type": "uint"
              },
              "default": 9223372036854775808,
              "description": "By default, the source continuously prints logs (infinitely).",
              "maximum": 9007199254740991,
              "minimum": 0,
              "title": "The total number of lines to output.",
              "type": "integer"
            },
            "decoding": {
              "$ref": "#/definitions/codecs::decoding::DeserializerConfig",
              "_metadata": {
                "docs::human_name": "Decoding"
              },
              "default": {
                "codec": "bytes"
              },
              "description": "Configures how events are decoded from raw bytes."
            },
            "framing": {
              "$ref": "#/definitions/codecs::decoding::FramingConfig",
              "_metadata": {
                "docs::human_name": "Framing"
              },
              "default": {
                "method": "bytes"
              },
              "description": "Framing handles how events are separated when encoded in a raw byte form, where each event is\na frame that must be prefixed, or delimited, in a way that marks where an event begins and\nends within the byte stream.",
              "title": "Framing configuration."
            },
            "interval": {
              "$ref": "#/definitions/serde_with::DurationFractionalSeconds",
              "_metadata": {
                "docs::examples": [
                  1,
                  0.1,
                  0.01
                ],
                "docs::human_name": "Interval"
              },
              "default": 1,
              "description": "The default is one batch per second. To remove the delay and output batches as quickly as possible, set\n`interval` to `0.0`.",
              "title": "The amount of time, in seconds, to pause between each batch of output lines."
            },
            "log_namespace": {
              "_metadata": {
                "docs::hidden": true,
                "docs::human_name": "Log Namespace",
                "docs::optional": true
              },
              "default": null,
              "description": "The namespace to use for logs. This overrides the global setting.",
              "type": [
                "boolean",
                "null"
              ]
            }
          },
          "type": "object"
        },
        {
          "_metadata": {
            "docs::enum_tag_description": "The format of the randomly generated output.",
            "docs::enum_tag_field": "format",
            "docs::enum_tagging": "internal"
          },
          "description": "Output format configuration.",
          "oneOf": [
            {
              "_metadata": {
                "docs::human_name": "Shuffle",
                "logical_name": "Shuffle"
              },
              "description": "Lines are chosen at random from the list specified using `lines`.",
              "properties": {
                "format": {
                  "_metadata": {
                    "docs::human_name": "Format"
                  },
                  "const": "shuffle",
                  "description": "Lines are chosen at random from the list specified using `lines`."
                },
                "lines": {
                  "_metadata": {
                    "docs::examples": [
                      "line1",
                      "line2"
                    ],
                    "docs::human_name": "Lines"
                  },
                  "description": "The list of lines to output.",
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                "sequence": {
                  "_metadata": {
                    "docs::human_name": "Sequence"
                  },
                  "default": false,
                  "description": "If `true`, each output line starts with an increasing sequence number, beginning with 0.",
                  "type": "boolean"
                }
              },
              "required": [
                "format",
                "lines"
              ],
              "type": "object"
            },
            {
              "_metadata": {
                "docs::human_name": "Apache Common",
                "logical_name": "ApacheCommon"
              },
              "description": "[apache_common]: https://httpd.apache.org/docs/current/logs.html#common",
              "properties": {
                "format": {
                  "_metadata": {
                    "docs::human_name": "Format"
                  },
                  "const": "apache_common",
                  "description": "[apache_common]: https://httpd.apache.org/docs/current/logs.html#common",
                  "title": "Randomly generated logs in [Apache common][apache_common] format."
                }
              },
              "required": [
                "format"
              ],
              "title": "Randomly generated logs in [Apache common][apache_common] format.",
              "type": "object"
            },
            {
              "_metadata": {
                "docs::human_name": "Apache Error",
                "logical_name": "ApacheError"
              },
              "description": "[apache_error]: https://httpd.apache.org/docs/current/logs.html#errorlog",
              "properties": {
                "format": {
                  "_metadata": {
                    "docs::human_name": "Format"
                  },
                  "const": "apache_error",
                  "description": "[apache_error]: https://httpd.apache.org/docs/current/logs.html#errorlog",
                  "title": "Randomly generated logs in [Apache error][apache_error] format."
                }
              },
              "required": [
                "format"
              ],
              "title": "Randomly generated logs in [Apache error][apache_error] format.",
              "type": "object"
            },
            {
              "_metadata": {
                "docs::human_name": "Syslog",
                "logical_name": "Syslog"
              },
              "description": "[syslog_5424]: https://tools.ietf.org/html/rfc5424",
              "properties": {
                "format": {
                  "_metadata": {
                    "docs::human_name": "Format"
                  },
                  "const": "syslog",
                  "description": "[syslog_5424]: https://tools.ietf.org/html/rfc5424",
                  "title": "Randomly generated logs in Syslog format ([RFC 5424][syslog_5424])."
                }
              },
              "required": [
                "format"
              ],
              "title": "Randomly generated logs in Syslog format ([RFC 5424][syslog_5424]).",
              "type": "object"
            },
            {
              "_metadata": {
                "docs::human_name": "BSD Syslog",
                "logical_name": "BsdSyslog"
              },
              "description": "[syslog_3164]: https://tools.ietf.org/html/rfc3164",
              "properties": {
                "format": {
                  "_metadata": {
                    "docs::human_name": "Format"
                  },
                  "const": "bsd_syslog",
                  "description": "[syslog_3164]: https://tools.ietf.org/html/rfc3164",
                  "title": "Randomly generated logs in Syslog format ([RFC 3164][syslog_3164])."
                }
              },
              "required": [
                "format"
              ],
              "title": "Randomly generated logs in Syslog format ([RFC 3164][syslog_3164]).",
              "type": "object"
            },
            {
              "_metadata": {
                "docs::human_name": "JSON",
                "logical_name": "Json"
              },
              "description": "[json]: https://en.wikipedia.org/wiki/JSON",
              "properties": {
                "format": {
                  "_metadata": {
                    "docs::human_name": "Format"
                  },
                  "const": "json",
                  "description": "[json]: https://en.wikipedia.org/wiki/JSON",
                  "title": "Randomly generated HTTP server logs in [JSON][json] format."
                }
              },
              "required": [
                "format"
              ],
              "title": "Randomly generated HTTP server logs in [JSON][json] format.",
              "type": "object"
            }
          ]
        }
      ],
      "description": "Configuration for the `demo_logs` source."
    },
    "vector::sources::file_descriptors::stdin::StdinConfig": {
      "_metadata": {
        "docs::component_name": "stdin",
        "docs::component_type": "source"
      },
      "default": {
        "decoding": {
          "codec": "bytes"
        },
        "framing": null,
        "host_key": null,
        "log_namespace": null,
        "max_length": 102400
      },
      "description": "Configuration for the `stdin` source.",
      "properties": {
        "decoding": {
          "$ref": "#/definitions/codecs::decoding::DeserializerConfig",
          "_metadata": {
            "docs::human_name": "Decoding"
          },
          "default": {
            "codec": "bytes"
          },
          "description": "Configures how events are decoded from raw bytes."
        },
        "framing": {
          "$ref": "#/definitions/core::option::Option<codecs::decoding::FramingConfig>",
          "_metadata": {
            "docs::human_name": "Framing"
          }
        },
        "host_key": {
          "$ref": "#/definitions/core::option::Option<vector_lookup::lookup_v2::optional_path::OptionalValuePath>",
          "_metadata": {
            "docs::human_name": "Host Key"
          },
          "description": "By default, the [global `log_schema.host_key` option][global_host_key] is used.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
          "title": "Overrides the name of the log field used to add the current hostname to each event."
        },
        "log_namespace": {
          "_metadata": {
            "docs::hidden": true,
            "docs::human_name": "Log Namespace",
            "docs::optional": true
          },
          "default": null,
          "description": "The namespace to use for logs. This overrides the global setting.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "max_length": {
          "_metadata": {
            "docs::human_name": "Max Length",
            "docs::numeric_type": "uint",
            "docs::type_unit": "bytes"
          },
          "default": 102400,
          "description": "Messages larger than this are truncated.",
          "maximum": 9007199254740991,
          "minimum": 0,
          "title": "The maximum buffer size, in bytes, of incoming messages.",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "vector::sources::fluent::FluentConfig": {
      "_metadata": {
        "docs::component_name": "fluent",
        "docs::component_type": "source"
      },
      "description": "Configuration for the `fluent` source.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::SourceAcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "This setting is **deprecated** in favor of enabling `acknowledgements` at the [global][global_acks] or sink level.\n\nEnabling or disabling acknowledgements at the source level has **no effect** on acknowledgement behavior.\n\nSee [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled by this source."
        },
        "address": {
          "$ref": "#/definitions/vector::sources::util::net::SocketListenAddr",
          "_metadata": {
            "docs::human_name": "Address"
          },
          "description": "If a socket address is used, it _must_ include a port.",
          "title": "The socket address to listen for connections on, or `systemd{#N}` to use the Nth socket passed by\nsystemd socket activation."
        },
        "connection_limit": {
          "_metadata": {
            "docs::human_name": "Connection Limit",
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "connections"
          },
          "description": "The maximum number of TCP connections that are allowed at any given time.",
          "maximum": 4294967295,
          "minimum": 0,
          "type": [
            "integer",
            "null"
          ]
        },
        "keepalive": {
          "$ref": "#/definitions/core::option::Option<vector_core::tcp::TcpKeepaliveConfig>",
          "_metadata": {
            "docs::human_name": "Keepalive"
          }
        },
        "log_namespace": {
          "_metadata": {
            "docs::hidden": true,
            "docs::human_name": "Log Namespace",
            "docs::optional": true
          },
          "default": null,
          "description": "The namespace to use for logs. This overrides the global setting.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "receive_buffer_bytes": {
          "_metadata": {
            "docs::examples": 65536,
            "docs::human_name": "Receive Buffer Bytes",
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "bytes"
          },
          "description": "This generally should not need to be changed.",
          "maximum": 9007199254740991,
          "minimum": 0,
          "title": "The size of the receive buffer used for each connection.",
          "type": [
            "integer",
            "null"
          ]
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsSourceConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "required": [
        "address"
      ],
      "type": "object"
    },
    "vector::sources::gcp_pubsub::PubsubConfig": {
      "_metadata": {
        "docs::component_name": "gcp_pubsub",
        "docs::component_type": "source"
      },
      "allOf": [
        {
          "properties": {
            "ack_deadline_seconds": {
              "_metadata": {
                "deprecated_message": "This option has been deprecated, use `ack_deadline_secs` instead.",
                "docs::human_name": "Ack Deadline Seconds",
                "docs::numeric_type": "uint",
                "docs::optional": true
              },
              "deprecated": true,
              "description": "Messages that are not acknowledged when this deadline expires may be retransmitted.",
              "maximum": 65535,
              "minimum": 0,
              "title": "The acknowledgement deadline, in seconds, to use for this stream.",
              "type": [
                "integer",
                "null"
              ]
            },
            "ack_deadline_secs": {
              "$ref": "#/definitions/serde_with::DurationSeconds",
              "_metadata": {
                "docs::human_name": "Acknowledgement Deadline"
              },
              "default": 600,
              "description": "Messages that are not acknowledged when this deadline expires may be retransmitted.",
              "title": "The acknowledgement deadline, in seconds, to use for this stream."
            },
            "acknowledgements": {
              "$ref": "#/definitions/vector_core::config::SourceAcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              },
              "default": {
                "enabled": null
              },
              "description": "This setting is **deprecated** in favor of enabling `acknowledgements` at the [global][global_acks] or sink level.\n\nEnabling or disabling acknowledgements at the source level has **no effect** on acknowledgement behavior.\n\nSee [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "title": "Controls how acknowledgements are handled by this source."
            },
            "decoding": {
              "$ref": "#/definitions/codecs::decoding::DeserializerConfig",
              "_metadata": {
                "docs::human_name": "Decoding"
              },
              "default": {
                "codec": "bytes"
              },
              "description": "Configures how events are decoded from raw bytes."
            },
            "endpoint": {
              "_metadata": {
                "docs::examples": "https://us-central1-pubsub.googleapis.com",
                "docs::human_name": "Endpoint"
              },
              "default": "https://pubsub.googleapis.com",
              "description": "The endpoint from which to pull data.",
              "type": "string"
            },
            "framing": {
              "$ref": "#/definitions/codecs::decoding::FramingConfig",
              "_metadata": {
                "docs::human_name": "Framing"
              },
              "default": {
                "method": "bytes"
              },
              "description": "Framing handles how events are separated when encoded in a raw byte form, where each event is\na frame that must be prefixed, or delimited, in a way that marks where an event begins and\nends within the byte stream.",
              "title": "Framing configuration."
            },
            "full_response_size": {
              "_metadata": {
                "docs::human_name": "Full Response Size",
                "docs::numeric_type": "uint"
              },
              "default": 100,
              "description": "The GCP Pub/Sub servers send responses with 100 or more messages when\nthe subscription is busy.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "title": "The number of messages in a response to mark a stream as\n\"busy\". This is used to determine if more streams should be\nstarted.",
              "type": "integer"
            },
            "keepalive_secs": {
              "$ref": "#/definitions/serde_with::DurationFractionalSeconds",
              "_metadata": {
                "docs::human_name": "Keepalive"
              },
              "default": 60,
              "description": "The amount of time, in seconds, with no received activity\nbefore sending a keepalive request. If this is set larger than\n`60`, you may see periodic errors sent from the server."
            },
            "log_namespace": {
              "_metadata": {
                "docs::hidden": true,
                "docs::human_name": "Log Namespace",
                "docs::optional": true
              },
              "default": null,
              "description": "The namespace to use for logs. This overrides the global setting.",
              "type": [
                "boolean",
                "null"
              ]
            },
            "max_concurrency": {
              "_metadata": {
                "docs::human_name": "Max Concurrency",
                "docs::numeric_type": "uint"
              },
              "default": 10,
              "description": "The maximum number of concurrent stream connections to open at once.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "type": "integer"
            },
            "poll_time_seconds": {
              "$ref": "#/definitions/serde_with::DurationFractionalSeconds",
              "_metadata": {
                "docs::human_name": "Poll Time"
              },
              "default": 2,
              "description": "How often to poll the currently active streams to see if they\nare all busy and so open a new stream."
            },
            "project": {
              "_metadata": {
                "docs::human_name": "Project"
              },
              "description": "The project name from which to pull logs.",
              "type": "string"
            },
            "retry_delay_seconds": {
              "_metadata": {
                "deprecated_message": "This option has been deprecated, use `retry_delay_secs` instead.",
                "docs::human_name": "Retry Delay Seconds",
                "docs::numeric_type": "float",
                "docs::optional": true
              },
              "deprecated": true,
              "description": "The amount of time, in seconds, to wait between retry attempts after an error.",
              "maximum": 9007199254740991,
              "minimum": -9007199254740991,
              "type": [
                "number",
                "null"
              ]
            },
            "retry_delay_secs": {
              "$ref": "#/definitions/serde_with::DurationFractionalSeconds",
              "_metadata": {
                "docs::human_name": "Retry Delay"
              },
              "default": 1,
              "description": "The amount of time, in seconds, to wait between retry attempts after an error."
            },
            "subscription": {
              "_metadata": {
                "docs::human_name": "Subscription"
              },
              "description": "The subscription within the project which is configured to receive logs.",
              "type": "string"
            },
            "tls": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              }
            }
          },
          "required": [
            "project",
            "subscription"
          ],
          "type": "object"
        },
        {
          "$ref": "#/definitions/vector::gcp::GcpAuthConfig",
          "description": "Configuration of the authentication strategy for interacting with GCP services."
        }
      ],
      "description": "Configuration for the `gcp_pubsub` source."
    },
    "vector::sources::heroku_logs::LogplexConfig": {
      "_metadata": {
        "docs::component_name": "heroku_logs",
        "docs::component_type": "source"
      },
      "description": "Configuration for `heroku_logs` source.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::SourceAcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "This setting is **deprecated** in favor of enabling `acknowledgements` at the [global][global_acks] or sink level.\n\nEnabling or disabling acknowledgements at the source level has **no effect** on acknowledgement behavior.\n\nSee [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled by this source."
        },
        "address": {
          "$ref": "#/definitions/stdlib::SocketAddr",
          "_metadata": {
            "docs::examples": [
              "0.0.0.0:80",
              "localhost:80"
            ],
            "docs::human_name": "Address"
          },
          "description": "The socket address to listen for connections on."
        },
        "auth": {
          "$ref": "#/definitions/core::option::Option<vector::sources::util::http::auth::HttpSourceAuthConfig>",
          "_metadata": {
            "docs::human_name": "Auth"
          }
        },
        "decoding": {
          "$ref": "#/definitions/codecs::decoding::DeserializerConfig",
          "_metadata": {
            "docs::human_name": "Decoding"
          },
          "default": {
            "codec": "bytes"
          },
          "description": "Configures how events are decoded from raw bytes."
        },
        "framing": {
          "$ref": "#/definitions/codecs::decoding::FramingConfig",
          "_metadata": {
            "docs::human_name": "Framing"
          },
          "default": {
            "method": "bytes"
          },
          "description": "Framing handles how events are separated when encoded in a raw byte form, where each event is\na frame that must be prefixed, or delimited, in a way that marks where an event begins and\nends within the byte stream.",
          "title": "Framing configuration."
        },
        "log_namespace": {
          "_metadata": {
            "docs::hidden": true,
            "docs::human_name": "Log Namespace",
            "docs::optional": true
          },
          "default": null,
          "description": "The namespace to use for logs. This overrides the global setting.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "query_parameters": {
          "_metadata": {
            "docs::examples": [
              "application",
              "source"
            ],
            "docs::human_name": "Query Parameters"
          },
          "default": [],
          "description": "These override any values included in the body with conflicting names.",
          "items": {
            "type": "string"
          },
          "title": "A list of URL query parameters to include in the log event.",
          "type": "array"
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "required": [
        "address"
      ],
      "type": "object"
    },
    "vector::sources::host_metrics::FilterList": {
      "description": "Filtering configuration.",
      "properties": {
        "excludes": {
          "_metadata": {
            "docs::human_name": "Excludes",
            "docs::optional": true
          },
          "description": "The patterns are matched using globbing.",
          "items": {
            "description": "- `?` matches any single character.\n- `*` matches any (possibly empty) sequence of characters.\n- `**` matches the current directory and arbitrary subdirectories. This sequence must form a single path component,\n  so both `**a` and `b**` are invalid and will result in an error. A sequence of more than two consecutive `*`\n  characters is also invalid.\n- `[...]` matches any character inside the brackets. Character sequences can also specify ranges of characters, as\n  ordered by Unicode, so e.g. `[0-9]` specifies any character between 0 and 9 inclusive. An unclosed bracket is\n  invalid.\n- `[!...]` is the negation of `[...]`, i.e. it matches any characters not in the brackets.\n\nThe metacharacters `?`, `*`, `[`, `]` can be matched by using brackets (e.g. `[?]`). When a `]` occurs immediately\nfollowing `[` or `[!` then it is interpreted as being part of, rather then ending, the character set, so `]` and NOT\n`]` can be matched by `[]]` and `[!]]` respectively. The `-` character can be specified inside a character sequence\npattern by placing it at the start or the end, e.g. `[abc-]`.",
            "title": "A compiled Unix shell-style pattern.",
            "type": "string"
          },
          "title": "Any patterns which should be excluded.",
          "type": [
            "array",
            "null"
          ]
        },
        "includes": {
          "_metadata": {
            "docs::human_name": "Includes",
            "docs::optional": true
          },
          "description": "The patterns are matched using globbing.",
          "items": {
            "description": "- `?` matches any single character.\n- `*` matches any (possibly empty) sequence of characters.\n- `**` matches the current directory and arbitrary subdirectories. This sequence must form a single path component,\n  so both `**a` and `b**` are invalid and will result in an error. A sequence of more than two consecutive `*`\n  characters is also invalid.\n- `[...]` matches any character inside the brackets. Character sequences can also specify ranges of characters, as\n  ordered by Unicode, so e.g. `[0-9]` specifies any character between 0 and 9 inclusive. An unclosed bracket is\n  invalid.\n- `[!...]` is the negation of `[...]`, i.e. it matches any characters not in the brackets.\n\nThe metacharacters `?`, `*`, `[`, `]` can be matched by using brackets (e.g. `[?]`). When a `]` occurs immediately\nfollowing `[` or `[!` then it is interpreted as being part of, rather then ending, the character set, so `]` and NOT\n`]` can be matched by `[]]` and `[!]]` respectively. The `-` character can be specified inside a character sequence\npattern by placing it at the start or the end, e.g. `[abc-]`.",
            "title": "A compiled Unix shell-style pattern.",
            "type": "string"
          },
          "title": "Any patterns which should be included.",
          "type": [
            "array",
            "null"
          ]
        }
      },
      "type": "object",
      "unevaluatedProperties": false
    },
    "vector::sources::host_metrics::HostMetricsConfig": {
      "_metadata": {
        "docs::component_name": "host_metrics",
        "docs::component_type": "source"
      },
      "description": "Configuration for the `host_metrics` source.",
      "properties": {
        "cgroups": {
          "_metadata": {
            "docs::human_name": "Cgroups",
            "docs::optional": true
          },
          "default": {
            "base": null,
            "groups": {
              "excludes": null,
              "includes": null
            },
            "levels": 100
          },
          "description": "This collector is only available on Linux systems, and only supports either version 2 or hybrid cgroups.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "default": {
                "base": null,
                "groups": {
                  "excludes": null,
                  "includes": null
                },
                "levels": 100
              },
              "description": "This collector is only available on Linux systems, and only supports either version 2 or hybrid cgroups.",
              "properties": {
                "base": {
                  "$ref": "#/definitions/core::option::Option<std::path::PathBuf>",
                  "_metadata": {
                    "docs::examples": [
                      "/",
                      "system.slice/snapd.service"
                    ],
                    "docs::human_name": "Base"
                  },
                  "description": "The base cgroup name to provide metrics for."
                },
                "base_dir": {
                  "$ref": "#/definitions/core::option::Option<std::path::PathBuf>",
                  "_metadata": {
                    "docs::hidden": true,
                    "docs::human_name": "Base Directory"
                  },
                  "description": "Base cgroup directory, for testing use only"
                },
                "groups": {
                  "$ref": "#/definitions/vector::sources::host_metrics::FilterList",
                  "_metadata": {
                    "docs::examples": {
                      "excludes": [
                        "*.service"
                      ],
                      "includes": [
                        "user.slice/*"
                      ]
                    },
                    "docs::human_name": "Groups"
                  },
                  "default": {
                    "excludes": null,
                    "includes": [
                      "*"
                    ]
                  },
                  "description": "Lists of cgroup name patterns to include or exclude in gathering\nusage metrics."
                },
                "levels": {
                  "_metadata": {
                    "docs::examples": [
                      1,
                      3
                    ],
                    "docs::human_name": "Levels",
                    "docs::numeric_type": "uint"
                  },
                  "default": 100,
                  "description": "A value of `1` means the root or named cgroup.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "title": "The number of levels of the cgroups hierarchy for which to report metrics.",
                  "type": "integer"
                }
              },
              "title": "Options for the cgroups (controller groups) metrics collector.",
              "type": "object"
            }
          ],
          "title": "Options for the cgroups (controller groups) metrics collector.",
          "unevaluatedProperties": false
        },
        "collectors": {
          "_metadata": {
            "docs::enum_tagging": "external",
            "docs::examples": [
              "cgroups",
              "cpu",
              "disk",
              "filesystem",
              "load",
              "host",
              "memory",
              "network"
            ],
            "docs::human_name": "Collectors",
            "docs::optional": true
          },
          "default": [
            "cpu",
            "disk",
            "filesystem",
            "load",
            "host",
            "memory",
            "network",
            "cgroups"
          ],
          "description": "Defaults to all collectors.",
          "items": {
            "_metadata": {
              "docs::enum_tagging": "external"
            },
            "description": "Collector types.",
            "oneOf": [
              {
                "_metadata": {
                  "docs::human_name": "C Groups",
                  "logical_name": "CGroups"
                },
                "const": "cgroups",
                "description": "Only available on Linux.",
                "title": "Metrics related to Linux control groups."
              },
              {
                "_metadata": {
                  "docs::human_name": "CPU",
                  "logical_name": "Cpu"
                },
                "const": "cpu",
                "description": "Metrics related to CPU utilization."
              },
              {
                "_metadata": {
                  "docs::human_name": "Disk",
                  "logical_name": "Disk"
                },
                "const": "disk",
                "description": "Metrics related to disk I/O utilization."
              },
              {
                "_metadata": {
                  "docs::human_name": "Filesystem",
                  "logical_name": "Filesystem"
                },
                "const": "filesystem",
                "description": "Metrics related to filesystem space utilization."
              },
              {
                "_metadata": {
                  "docs::human_name": "Load",
                  "logical_name": "Load"
                },
                "const": "load",
                "description": "Metrics related to the system load average."
              },
              {
                "_metadata": {
                  "docs::human_name": "Host",
                  "logical_name": "Host"
                },
                "const": "host",
                "description": "Metrics related to the host."
              },
              {
                "_metadata": {
                  "docs::human_name": "Memory",
                  "logical_name": "Memory"
                },
                "const": "memory",
                "description": "Metrics related to memory utilization."
              },
              {
                "_metadata": {
                  "docs::human_name": "Network",
                  "logical_name": "Network"
                },
                "const": "network",
                "description": "Metrics related to network utilization."
              }
            ],
            "unevaluatedProperties": false
          },
          "title": "The list of host metric collector services to use.",
          "type": [
            "array",
            "null"
          ]
        },
        "disk": {
          "_metadata": {
            "docs::human_name": "Disk"
          },
          "default": {
            "devices": {
              "excludes": null,
              "includes": null
            }
          },
          "description": "Options for the disk metrics collector.",
          "properties": {
            "devices": {
              "$ref": "#/definitions/vector::sources::host_metrics::FilterList",
              "_metadata": {
                "docs::examples": {
                  "excludes": [
                    "dm-*"
                  ],
                  "includes": [
                    "sda"
                  ]
                },
                "docs::human_name": "Devices"
              },
              "default": {
                "excludes": null,
                "includes": [
                  "*"
                ]
              },
              "description": "Lists of device name patterns to include or exclude in gathering\nI/O utilization metrics."
            }
          },
          "type": "object",
          "unevaluatedProperties": false
        },
        "filesystem": {
          "_metadata": {
            "docs::human_name": "Filesystem"
          },
          "default": {
            "devices": {
              "excludes": null,
              "includes": null
            },
            "filesystems": {
              "excludes": null,
              "includes": null
            },
            "mountpoints": {
              "excludes": null,
              "includes": null
            }
          },
          "description": "Options for the filesystem metrics collector.",
          "properties": {
            "devices": {
              "$ref": "#/definitions/vector::sources::host_metrics::FilterList",
              "_metadata": {
                "docs::examples": {
                  "excludes": [
                    "dm-*"
                  ],
                  "includes": [
                    "sda"
                  ]
                },
                "docs::human_name": "Devices"
              },
              "default": {
                "excludes": null,
                "includes": [
                  "*"
                ]
              },
              "description": "Lists of device name patterns to include or exclude in gathering\nusage metrics."
            },
            "filesystems": {
              "$ref": "#/definitions/vector::sources::host_metrics::FilterList",
              "_metadata": {
                "docs::examples": {
                  "excludes": [
                    "ext*"
                  ],
                  "includes": [
                    "ntfs"
                  ]
                },
                "docs::human_name": "Filesystems"
              },
              "default": {
                "excludes": null,
                "includes": [
                  "*"
                ]
              },
              "description": "Lists of filesystem name patterns to include or exclude in gathering\nusage metrics."
            },
            "mountpoints": {
              "$ref": "#/definitions/vector::sources::host_metrics::FilterList",
              "_metadata": {
                "docs::examples": {
                  "excludes": [
                    "/raid*"
                  ],
                  "includes": [
                    "/home"
                  ]
                },
                "docs::human_name": "Mountpoints"
              },
              "default": {
                "excludes": null,
                "includes": [
                  "*"
                ]
              },
              "description": "Lists of mount point path patterns to include or exclude in gathering\nusage metrics."
            }
          },
          "type": "object",
          "unevaluatedProperties": false
        },
        "namespace": {
          "_metadata": {
            "docs::human_name": "Namespace",
            "docs::optional": true
          },
          "default": "host",
          "description": "Overrides the default namespace for the metrics emitted by the source.",
          "type": [
            "string",
            "null"
          ]
        },
        "network": {
          "_metadata": {
            "docs::human_name": "Network"
          },
          "default": {
            "devices": {
              "excludes": null,
              "includes": null
            }
          },
          "description": "Options for the network metrics collector.",
          "properties": {
            "devices": {
              "$ref": "#/definitions/vector::sources::host_metrics::FilterList",
              "_metadata": {
                "docs::examples": {
                  "excludes": [
                    "dm-*"
                  ],
                  "includes": [
                    "sda"
                  ]
                },
                "docs::human_name": "Devices"
              },
              "default": {
                "excludes": null,
                "includes": [
                  "*"
                ]
              },
              "description": "Lists of device name patterns to include or exclude in gathering\nnetwork utilization metrics."
            }
          },
          "type": "object",
          "unevaluatedProperties": false
        },
        "scrape_interval_secs": {
          "$ref": "#/definitions/serde_with::DurationSeconds",
          "_metadata": {
            "docs::human_name": "Scrape Interval"
          },
          "default": 15,
          "description": "The interval between metric gathering, in seconds."
        }
      },
      "type": "object"
    },
    "vector::sources::http_client::client::HttpClientConfig": {
      "_metadata": {
        "docs::component_name": "http_client",
        "docs::component_type": "source"
      },
      "description": "Configuration for the `http_client` source.",
      "properties": {
        "auth": {
          "$ref": "#/definitions/core::option::Option<vector::http::Auth>",
          "_metadata": {
            "docs::human_name": "Auth"
          },
          "description": "HTTP Authentication."
        },
        "decoding": {
          "$ref": "#/definitions/codecs::decoding::DeserializerConfig",
          "_metadata": {
            "docs::human_name": "Decoding"
          },
          "default": {
            "codec": "bytes"
          },
          "description": "Decoder to use on the HTTP responses."
        },
        "endpoint": {
          "_metadata": {
            "docs::examples": "http://127.0.0.1:9898/logs",
            "docs::human_name": "Endpoint"
          },
          "description": "The full path must be specified.",
          "title": "The HTTP endpoint to collect events from.",
          "type": "string"
        },
        "framing": {
          "$ref": "#/definitions/codecs::decoding::FramingConfig",
          "_metadata": {
            "docs::human_name": "Framing"
          },
          "default": {
            "method": "bytes"
          },
          "description": "Framing to use in the decoding."
        },
        "headers": {
          "_metadata": {
            "docs::additional_props_description": "An HTTP request header and it's value(s).",
            "docs::examples": {
              "Accept": [
                "text/plain",
                "text/html"
              ],
              "X-My-Custom-Header": [
                "a",
                "vector",
                "of",
                "values"
              ]
            },
            "docs::human_name": "Headers"
          },
          "additionalProperties": {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "default": {},
          "description": "One or more values for the same header can be provided.",
          "title": "Headers to apply to the HTTP requests.",
          "type": "object"
        },
        "log_namespace": {
          "_metadata": {
            "docs::hidden": true,
            "docs::human_name": "Log Namespace",
            "docs::optional": true
          },
          "default": null,
          "description": "The namespace to use for logs. This overrides the global setting.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "method": {
          "$ref": "#/definitions/vector::sources::util::http::method::HttpMethod",
          "_metadata": {
            "docs::human_name": "Method"
          },
          "default": "GET",
          "description": "Specifies the method of the HTTP request."
        },
        "query": {
          "_metadata": {
            "docs::additional_props_description": "A query string parameter and it's value(s).",
            "docs::examples": {
              "field": [
                "value"
              ],
              "fruit": [
                "mango",
                "papaya",
                "kiwi"
              ]
            },
            "docs::human_name": "Query"
          },
          "additionalProperties": {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "default": {},
          "description": "One or more values for the same parameter key can be provided.\n\nThe parameters provided in this option are appended to any parameters\nmanually provided in the `endpoint` option.",
          "title": "Custom parameters for the HTTP request query string.",
          "type": "object"
        },
        "scrape_interval_secs": {
          "$ref": "#/definitions/serde_with::DurationSeconds",
          "_metadata": {
            "docs::human_name": "Scrape Interval"
          },
          "default": 15,
          "description": "The interval between scrapes. Requests are run concurrently so if a scrape takes longer\nthan the interval a new scrape will be started. This can take extra resources, set the timeout\nto a value lower than the scrape interval to prevent this from happening."
        },
        "scrape_timeout_secs": {
          "$ref": "#/definitions/serde_with::DurationFractionalSeconds",
          "_metadata": {
            "docs::human_name": "Scrape Timeout"
          },
          "default": 5,
          "description": "The timeout for each scrape request."
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          },
          "description": "TLS configuration."
        }
      },
      "required": [
        "endpoint"
      ],
      "type": "object"
    },
    "vector::sources::http_server::HttpConfig": {
      "$ref": "#/definitions/vector::sources::http_server::SimpleHttpConfig",
      "_metadata": {
        "deprecated": true,
        "docs::component_name": "http",
        "docs::component_type": "source"
      },
      "description": "Configuration for the `http` source."
    },
    "vector::sources::http_server::SimpleHttpConfig": {
      "_metadata": {
        "docs::component_name": "http_server",
        "docs::component_type": "source"
      },
      "description": "Configuration for the `http_server` source.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::SourceAcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "This setting is **deprecated** in favor of enabling `acknowledgements` at the [global][global_acks] or sink level.\n\nEnabling or disabling acknowledgements at the source level has **no effect** on acknowledgement behavior.\n\nSee [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled by this source."
        },
        "address": {
          "$ref": "#/definitions/stdlib::SocketAddr",
          "_metadata": {
            "docs::examples": [
              "0.0.0.0:80",
              "localhost:80"
            ],
            "docs::human_name": "Address"
          },
          "description": "It _must_ include a port.",
          "title": "The socket address to listen for connections on."
        },
        "auth": {
          "$ref": "#/definitions/core::option::Option<vector::sources::util::http::auth::HttpSourceAuthConfig>",
          "_metadata": {
            "docs::human_name": "Auth"
          }
        },
        "decoding": {
          "_metadata": {
            "docs::human_name": "Decoding",
            "docs::optional": true
          },
          "description": "Configures how events are decoded from raw bytes.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "_metadata": {
                "docs::enum_tag_description": "The codec to use for decoding events.",
                "docs::enum_tag_field": "codec",
                "docs::enum_tagging": "internal"
              },
              "description": "Configures how events are decoded from raw bytes.",
              "oneOf": [
                {
                  "_metadata": {
                    "docs::human_name": "Bytes",
                    "logical_name": "Bytes"
                  },
                  "description": "Uses the raw bytes as-is.",
                  "properties": {
                    "codec": {
                      "_metadata": {
                        "docs::human_name": "Codec"
                      },
                      "const": "bytes",
                      "description": "Uses the raw bytes as-is."
                    }
                  },
                  "required": [
                    "codec"
                  ],
                  "type": "object"
                },
                {
                  "_metadata": {
                    "docs::human_name": "JSON",
                    "logical_name": "Json"
                  },
                  "allOf": [
                    {
                      "description": "Config used to build a `JsonDeserializer`.",
                      "properties": {
                        "json": {
                          "_metadata": {
                            "docs::human_name": "JSON"
                          },
                          "default": {
                            "lossy": true
                          },
                          "description": "JSON-specific decoding options.",
                          "properties": {
                            "lossy": {
                              "_metadata": {
                                "docs::human_name": "Lossy"
                              },
                              "default": true,
                              "description": "When true, invalid UTF-8 sequences are replaced with the [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD].\n\n[U+FFFD]: https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character",
                              "title": "Determines whether or not to replace invalid UTF-8 sequences instead of failing.",
                              "type": "boolean"
                            }
                          },
                          "type": "object",
                          "unevaluatedProperties": false
                        }
                      },
                      "type": "object"
                    },
                    {
                      "properties": {
                        "codec": {
                          "_metadata": {
                            "docs::human_name": "Codec"
                          },
                          "const": "json",
                          "description": "[json]: https://www.json.org/",
                          "title": "Decodes the raw bytes as [JSON][json]."
                        }
                      },
                      "required": [
                        "codec"
                      ],
                      "type": "object"
                    }
                  ],
                  "description": "[json]: https://www.json.org/",
                  "title": "Decodes the raw bytes as [JSON][json]."
                },
                {
                  "_metadata": {
                    "docs::human_name": "Protobuf",
                    "logical_name": "Protobuf"
                  },
                  "allOf": [
                    {
                      "description": "Config used to build a `ProtobufDeserializer`.",
                      "properties": {
                        "protobuf": {
                          "_metadata": {
                            "docs::human_name": "Protobuf"
                          },
                          "default": {
                            "desc_file": "",
                            "message_type": ""
                          },
                          "description": "Protobuf-specific decoding options.",
                          "properties": {
                            "desc_file": {
                              "$ref": "#/definitions/stdlib::PathBuf",
                              "_metadata": {
                                "docs::human_name": "Desc File"
                              },
                              "description": "Path to desc file"
                            },
                            "message_type": {
                              "_metadata": {
                                "docs::human_name": "Message Type"
                              },
                              "description": "message type. e.g package.message",
                              "type": "string"
                            }
                          },
                          "required": [
                            "desc_file",
                            "message_type"
                          ],
                          "type": "object",
                          "unevaluatedProperties": false
                        }
                      },
                      "type": "object"
                    },
                    {
                      "properties": {
                        "codec": {
                          "_metadata": {
                            "docs::human_name": "Codec"
                          },
                          "const": "protobuf",
                          "description": "[protobuf]: https://protobuf.dev/",
                          "title": "Decodes the raw bytes as [protobuf][protobuf]."
                        }
                      },
                      "required": [
                        "codec"
                      ],
                      "type": "object"
                    }
                  ],
                  "description": "[protobuf]: https://protobuf.dev/",
                  "title": "Decodes the raw bytes as [protobuf][protobuf]."
                },
                {
                  "_metadata": {
                    "docs::human_name": "Syslog",
                    "logical_name": "Syslog"
                  },
                  "allOf": [
                    {
                      "description": "Config used to build a `SyslogDeserializer`.",
                      "properties": {
                        "syslog": {
                          "_metadata": {
                            "docs::human_name": "Syslog"
                          },
                          "default": {
                            "lossy": true
                          },
                          "description": "Syslog-specific decoding options.",
                          "properties": {
                            "lossy": {
                              "_metadata": {
                                "docs::human_name": "Lossy"
                              },
                              "default": true,
                              "description": "When true, invalid UTF-8 sequences are replaced with the [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD].\n\n[U+FFFD]: https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character",
                              "title": "Determines whether or not to replace invalid UTF-8 sequences instead of failing.",
                              "type": "boolean"
                            }
                          },
                          "type": "object",
                          "unevaluatedProperties": false
                        }
                      },
                      "type": "object"
                    },
                    {
                      "properties": {
                        "codec": {
                          "_metadata": {
                            "docs::human_name": "Codec"
                          },
                          "const": "syslog",
                          "description": "Decodes either as the [RFC 3164][rfc3164]-style format (\"old\" style) or the\n[RFC 5424][rfc5424]-style format (\"new\" style, includes structured data).\n\n[rfc3164]: https://www.ietf.org/rfc/rfc3164.txt\n[rfc5424]: https://www.ietf.org/rfc/rfc5424.txt",
                          "title": "Decodes the raw bytes as a Syslog message."
                        }
                      },
                      "required": [
                        "codec"
                      ],
                      "type": "object"
                    }
                  ],
                  "description": "Decodes either as the [RFC 3164][rfc3164]-style format (\"old\" style) or the\n[RFC 5424][rfc5424]-style format (\"new\" style, includes structured data).\n\n[rfc3164]: https://www.ietf.org/rfc/rfc3164.txt\n[rfc5424]: https://www.ietf.org/rfc/rfc5424.txt",
                  "title": "Decodes the raw bytes as a Syslog message."
                },
                {
                  "_metadata": {
                    "docs::human_name": "Native",
                    "logical_name": "Native"
                  },
                  "description": "This codec is **[experimental][experimental]**.\n\n[vector_native_protobuf]: https://github.com/vectordotdev/vector/blob/master/lib/vector-core/proto/event.proto\n[experimental]: https://vector.dev/highlights/2022-03-31-native-event-codecs",
                  "properties": {
                    "codec": {
                      "_metadata": {
                        "docs::human_name": "Codec"
                      },
                      "const": "native",
                      "description": "This codec is **[experimental][experimental]**.\n\n[vector_native_protobuf]: https://github.com/vectordotdev/vector/blob/master/lib/vector-core/proto/event.proto\n[experimental]: https://vector.dev/highlights/2022-03-31-native-event-codecs",
                      "title": "Decodes the raw bytes as Vector’s [native Protocol Buffers format][vector_native_protobuf]."
                    }
                  },
                  "required": [
                    "codec"
                  ],
                  "title": "Decodes the raw bytes as Vector’s [native Protocol Buffers format][vector_native_protobuf].",
                  "type": "object"
                },
                {
                  "_metadata": {
                    "docs::human_name": "Native JSON",
                    "logical_name": "NativeJson"
                  },
                  "allOf": [
                    {
                      "description": "Config used to build a `NativeJsonDeserializer`.",
                      "properties": {
                        "native_json": {
                          "_metadata": {
                            "docs::human_name": "Native JSON"
                          },
                          "default": {
                            "lossy": true
                          },
                          "description": "Vector's native JSON-specific decoding options.",
                          "properties": {
                            "lossy": {
                              "_metadata": {
                                "docs::human_name": "Lossy"
                              },
                              "default": true,
                              "description": "When true, invalid UTF-8 sequences are replaced with the [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD].\n\n[U+FFFD]: https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character",
                              "title": "Determines whether or not to replace invalid UTF-8 sequences instead of failing.",
                              "type": "boolean"
                            }
                          },
                          "type": "object",
                          "unevaluatedProperties": false
                        }
                      },
                      "type": "object"
                    },
                    {
                      "properties": {
                        "codec": {
                          "_metadata": {
                            "docs::human_name": "Codec"
                          },
                          "const": "native_json",
                          "description": "This codec is **[experimental][experimental]**.\n\n[vector_native_json]: https://github.com/vectordotdev/vector/blob/master/lib/codecs/tests/data/native_encoding/schema.cue\n[experimental]: https://vector.dev/highlights/2022-03-31-native-event-codecs",
                          "title": "Decodes the raw bytes as Vector’s [native JSON format][vector_native_json]."
                        }
                      },
                      "required": [
                        "codec"
                      ],
                      "type": "object"
                    }
                  ],
                  "description": "This codec is **[experimental][experimental]**.\n\n[vector_native_json]: https://github.com/vectordotdev/vector/blob/master/lib/codecs/tests/data/native_encoding/schema.cue\n[experimental]: https://vector.dev/highlights/2022-03-31-native-event-codecs",
                  "title": "Decodes the raw bytes as Vector’s [native JSON format][vector_native_json]."
                },
                {
                  "_metadata": {
                    "docs::human_name": "GELF",
                    "logical_name": "Gelf"
                  },
                  "allOf": [
                    {
                      "description": "On GELF decoding behavior:\n  Graylog has a relaxed decoding. They are much more lenient than the spec would\n  suggest. We've elected to take a more strict approach to maintain backwards compatibility\n  in the event that we need to change the behavior to be more relaxed, so that prior versions\n  of vector will still work with the new relaxed decoding.\nConfig used to build a `GelfDeserializer`.",
                      "properties": {
                        "gelf": {
                          "_metadata": {
                            "docs::human_name": "GELF"
                          },
                          "default": {
                            "lossy": true
                          },
                          "description": "GELF-specific decoding options.",
                          "properties": {
                            "lossy": {
                              "_metadata": {
                                "docs::human_name": "Lossy"
                              },
                              "default": true,
                              "description": "When true, invalid UTF-8 sequences are replaced with the [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD].\n\n[U+FFFD]: https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character",
                              "title": "Determines whether or not to replace invalid UTF-8 sequences instead of failing.",
                              "type": "boolean"
                            }
                          },
                          "type": "object",
                          "unevaluatedProperties": false
                        }
                      },
                      "type": "object"
                    },
                    {
                      "properties": {
                        "codec": {
                          "_metadata": {
                            "docs::human_name": "Codec"
                          },
                          "const": "gelf",
                          "description": "[gelf]: https://docs.graylog.org/docs/gelf",
                          "title": "Decodes the raw bytes as a [GELF][gelf] message."
                        }
                      },
                      "required": [
                        "codec"
                      ],
                      "type": "object"
                    }
                  ],
                  "description": "[gelf]: https://docs.graylog.org/docs/gelf",
                  "title": "Decodes the raw bytes as a [GELF][gelf] message."
                }
              ]
            }
          ],
          "unevaluatedProperties": false
        },
        "encoding": {
          "_metadata": {
            "docs::human_name": "Encoding",
            "docs::optional": true
          },
          "default": null,
          "description": "For `json` and `ndjson` encodings, the fields of the JSON objects are output as separate fields.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "_metadata": {
                "docs::enum_tagging": "external"
              },
              "description": "Content encoding.",
              "oneOf": [
                {
                  "_metadata": {
                    "docs::human_name": "Text",
                    "logical_name": "Text"
                  },
                  "const": "text",
                  "description": "Plaintext."
                },
                {
                  "_metadata": {
                    "docs::human_name": "NDJSON",
                    "logical_name": "Ndjson"
                  },
                  "const": "ndjson",
                  "description": "Newline-delimited JSON."
                },
                {
                  "_metadata": {
                    "docs::human_name": "JSON",
                    "logical_name": "Json"
                  },
                  "const": "json",
                  "description": "JSON."
                },
                {
                  "_metadata": {
                    "docs::human_name": "Binary",
                    "logical_name": "Binary"
                  },
                  "const": "binary",
                  "description": "Binary."
                }
              ]
            }
          ],
          "title": "The expected encoding of received data.",
          "unevaluatedProperties": false
        },
        "framing": {
          "$ref": "#/definitions/core::option::Option<codecs::decoding::FramingConfig>",
          "_metadata": {
            "docs::human_name": "Framing"
          }
        },
        "headers": {
          "_metadata": {
            "docs::examples": [
              "User-Agent",
              "X-My-Custom-Header"
            ],
            "docs::human_name": "Headers"
          },
          "default": [],
          "description": "These override any values included in the JSON payload with conflicting names.",
          "items": {
            "type": "string"
          },
          "title": "A list of HTTP headers to include in the log event.",
          "type": "array"
        },
        "log_namespace": {
          "_metadata": {
            "docs::hidden": true,
            "docs::human_name": "Log Namespace",
            "docs::optional": true
          },
          "default": null,
          "description": "The namespace to use for logs. This overrides the global setting.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "method": {
          "$ref": "#/definitions/vector::sources::util::http::method::HttpMethod",
          "_metadata": {
            "docs::human_name": "Method"
          },
          "default": "POST",
          "description": "Specifies the action of the HTTP request."
        },
        "path": {
          "_metadata": {
            "docs::examples": [
              "/event/path",
              "/logs"
            ],
            "docs::human_name": "Path"
          },
          "default": "/",
          "description": "The URL path on which log event POST requests are sent.",
          "type": "string"
        },
        "path_key": {
          "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
          "_metadata": {
            "docs::examples": "vector_http_path",
            "docs::human_name": "Path Key"
          },
          "default": "path",
          "description": "The event key in which the requested URL path used to send the request is stored."
        },
        "query_parameters": {
          "_metadata": {
            "docs::examples": [
              "application",
              "source"
            ],
            "docs::human_name": "Query Parameters"
          },
          "default": [],
          "description": "These override any values included in the body with conflicting names.",
          "items": {
            "type": "string"
          },
          "title": "A list of URL query parameters to include in the log event.",
          "type": "array"
        },
        "response_code": {
          "_metadata": {
            "docs::examples": 202,
            "docs::human_name": "Response Code",
            "docs::numeric_type": "uint"
          },
          "default": 200,
          "description": "Specifies the HTTP response status code that will be returned on successful requests.",
          "maximum": 65535,
          "minimum": 0,
          "type": "integer"
        },
        "strict_path": {
          "_metadata": {
            "docs::human_name": "Strict Path"
          },
          "default": true,
          "description": "If set to `true`, only requests using the exact URL path specified in `path` are accepted. Otherwise,\nrequests sent to a URL path that starts with the value of `path` are accepted.\n\nWith `strict_path` set to `false` and `path` set to `\"\"`, the configured HTTP source accepts requests from\nany URL path.",
          "title": "Whether or not to treat the configured `path` as an absolute path.",
          "type": "boolean"
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "required": [
        "address"
      ],
      "type": "object"
    },
    "vector::sources::internal_logs::InternalLogsConfig": {
      "_metadata": {
        "docs::component_name": "internal_logs",
        "docs::component_type": "source"
      },
      "description": "Configuration for the `internal_logs` source.",
      "properties": {
        "host_key": {
          "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
          "_metadata": {
            "docs::human_name": "Host Key"
          },
          "default": "host",
          "description": "By default, the [global `log_schema.host_key` option][global_host_key] is used.\n\nSet to `\"\"` to suppress this key.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
          "title": "Overrides the name of the log field used to add the current hostname to each event."
        },
        "log_namespace": {
          "_metadata": {
            "docs::hidden": true,
            "docs::human_name": "Log Namespace",
            "docs::optional": true
          },
          "default": null,
          "description": "The namespace to use for logs. This overrides the global setting.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "pid_key": {
          "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
          "_metadata": {
            "docs::human_name": "PID Key"
          },
          "default": "pid",
          "description": "By default, `\"pid\"` is used.\n\nSet to `\"\"` to suppress this key.",
          "title": "Overrides the name of the log field used to add the current process ID to each event."
        }
      },
      "type": "object"
    },
    "vector::sources::internal_metrics::InternalMetricsConfig": {
      "_metadata": {
        "docs::component_name": "internal_metrics",
        "docs::component_type": "source"
      },
      "default": {
        "namespace": "vector",
        "scrape_interval_secs": 1,
        "tags": {
          "host_key": "host",
          "pid_key": null
        }
      },
      "description": "Configuration for the `internal_metrics` source.",
      "properties": {
        "namespace": {
          "_metadata": {
            "docs::human_name": "Namespace"
          },
          "default": "vector",
          "description": "Overrides the default namespace for the metrics emitted by the source.",
          "type": "string"
        },
        "scrape_interval_secs": {
          "$ref": "#/definitions/serde_with::DurationFractionalSeconds",
          "_metadata": {
            "docs::human_name": "Scrape Interval"
          },
          "default": 1,
          "description": "The interval between metric gathering, in seconds."
        },
        "tags": {
          "_metadata": {
            "docs::human_name": "Tags"
          },
          "default": {
            "host_key": "host",
            "pid_key": null
          },
          "description": "Tag configuration for the `internal_metrics` source.",
          "properties": {
            "host_key": {
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
              "_metadata": {
                "docs::human_name": "Host Key"
              },
              "default": "host",
              "description": "The value is the peer host's address, including the port. For example, `1.2.3.4:9000`.\n\nBy default, the [global `log_schema.host_key` option][global_host_key] is used.\n\nSet to `\"\"` to suppress this key.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
              "title": "Overrides the name of the tag used to add the peer host to each metric."
            },
            "pid_key": {
              "_metadata": {
                "docs::examples": "pid",
                "docs::human_name": "PID Key",
                "docs::optional": true
              },
              "description": "By default, this is not set and the tag is not automatically added.",
              "title": "Sets the name of the tag to use to add the current process ID to each metric.",
              "type": [
                "string",
                "null"
              ]
            }
          },
          "type": "object",
          "unevaluatedProperties": false
        }
      },
      "type": "object"
    },
    "vector::sources::kafka::KafkaSourceConfig": {
      "_metadata": {
        "docs::component_name": "kafka",
        "docs::component_type": "source"
      },
      "allOf": [
        {
          "properties": {
            "acknowledgements": {
              "$ref": "#/definitions/vector_core::config::SourceAcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              },
              "default": {
                "enabled": null
              },
              "description": "This setting is **deprecated** in favor of enabling `acknowledgements` at the [global][global_acks] or sink level.\n\nEnabling or disabling acknowledgements at the source level has **no effect** on acknowledgement behavior.\n\nSee [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "title": "Controls how acknowledgements are handled by this source."
            },
            "auto_offset_reset": {
              "_metadata": {
                "docs::examples": [
                  "smallest",
                  "earliest",
                  "beginning",
                  "largest",
                  "latest",
                  "end",
                  "error"
                ],
                "docs::human_name": "Auto Offset Reset"
              },
              "default": "largest",
              "description": "See the [librdkafka documentation](https://github.com/edenhill/librdkafka/blob/master/CONFIGURATION.md) for the `auto.offset.reset` option for further clarification.",
              "title": "If offsets for consumer group do not exist, set them using this strategy.",
              "type": "string"
            },
            "bootstrap_servers": {
              "_metadata": {
                "docs::examples": "10.14.22.123:9092,10.14.23.332:9092",
                "docs::human_name": "Bootstrap Servers"
              },
              "description": "These are the servers in a Kafka cluster that a client should use to bootstrap its connection to the cluster,\nallowing discovery of all the other hosts in the cluster.\n\nMust be in the form of `host:port`, and comma-separated.",
              "title": "A comma-separated list of Kafka bootstrap servers.",
              "type": "string"
            },
            "commit_interval_ms": {
              "$ref": "#/definitions/serde_with::DurationMilliSeconds",
              "_metadata": {
                "docs::examples": [
                  5000,
                  10000
                ],
                "docs::human_name": "Commit Interval"
              },
              "default": 5000,
              "description": "The frequency that the consumer offsets are committed (written) to offset storage."
            },
            "decoding": {
              "$ref": "#/definitions/codecs::decoding::DeserializerConfig",
              "_metadata": {
                "docs::human_name": "Decoding"
              },
              "default": {
                "codec": "bytes"
              },
              "description": "Configures how events are decoded from raw bytes."
            },
            "fetch_wait_max_ms": {
              "$ref": "#/definitions/serde_with::DurationMilliSeconds",
              "_metadata": {
                "docs::advanced": true,
                "docs::examples": [
                  50,
                  100
                ],
                "docs::human_name": "Max Fetch Wait Time"
              },
              "default": 100,
              "description": "Maximum time the broker may wait to fill the response."
            },
            "framing": {
              "$ref": "#/definitions/codecs::decoding::FramingConfig",
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Framing"
              },
              "default": {
                "method": "bytes"
              },
              "description": "Framing handles how events are separated when encoded in a raw byte form, where each event is\na frame that must be prefixed, or delimited, in a way that marks where an event begins and\nends within the byte stream.",
              "title": "Framing configuration."
            },
            "group_id": {
              "_metadata": {
                "docs::examples": "consumer-group-name",
                "docs::human_name": "Group ID"
              },
              "description": "The consumer group name to be used to consume events from Kafka.",
              "type": "string"
            },
            "headers_key": {
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
              "_metadata": {
                "docs::examples": "headers",
                "docs::human_name": "Headers Key"
              },
              "default": "headers",
              "description": "The value is the headers of the Kafka message itself.\n\nBy default, `\"headers\"` is used.",
              "title": "Overrides the name of the log field used to add the headers to each event."
            },
            "key_field": {
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
              "_metadata": {
                "docs::examples": "message_key",
                "docs::human_name": "Key Field"
              },
              "default": "message_key",
              "description": "The value is the message key of the Kafka message itself.\n\nBy default, `\"message_key\"` is used.",
              "title": "Overrides the name of the log field used to add the message key to each event."
            },
            "librdkafka_options": {
              "_metadata": {
                "docs::additional_props_description": "A librdkafka configuration option.",
                "docs::advanced": true,
                "docs::examples": {
                  "client.id": "${ENV_VAR}",
                  "fetch.error.backoff.ms": "1000",
                  "socket.send.buffer.bytes": "100"
                },
                "docs::human_name": "Librdkafka Options",
                "docs::optional": true
              },
              "additionalProperties": {
                "type": "string"
              },
              "description": "See the [librdkafka documentation](https://github.com/edenhill/librdkafka/blob/master/CONFIGURATION.md) for details.",
              "title": "Advanced options set directly on the underlying `librdkafka` client.",
              "type": [
                "object",
                "null"
              ]
            },
            "log_namespace": {
              "_metadata": {
                "docs::hidden": true,
                "docs::human_name": "Log Namespace",
                "docs::optional": true
              },
              "default": null,
              "description": "The namespace to use for logs. This overrides the global setting.",
              "type": [
                "boolean",
                "null"
              ]
            },
            "metrics": {
              "_metadata": {
                "docs::human_name": "Metrics"
              },
              "default": {
                "topic_lag_metric": false
              },
              "description": "Metrics configuration.",
              "properties": {
                "topic_lag_metric": {
                  "_metadata": {
                    "docs::human_name": "Topic Lag Metric"
                  },
                  "description": "Expose topic lag metrics for all topics and partitions. Metric names are `kafka_consumer_lag`.",
                  "type": "boolean"
                }
              },
              "required": [
                "topic_lag_metric"
              ],
              "type": "object",
              "unevaluatedProperties": false
            },
            "offset_key": {
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
              "_metadata": {
                "docs::examples": "offset",
                "docs::human_name": "Offset Key"
              },
              "default": "offset",
              "description": "The value is the offset of the Kafka message itself.\n\nBy default, `\"offset\"` is used.",
              "title": "Overrides the name of the log field used to add the offset to each event."
            },
            "partition_key": {
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
              "_metadata": {
                "docs::examples": "partition",
                "docs::human_name": "Partition Key"
              },
              "default": "partition",
              "description": "The value is the partition from which the Kafka message was consumed from.\n\nBy default, `\"partition\"` is used.",
              "title": "Overrides the name of the log field used to add the partition to each event."
            },
            "session_timeout_ms": {
              "$ref": "#/definitions/serde_with::DurationMilliSeconds",
              "_metadata": {
                "docs::advanced": true,
                "docs::examples": [
                  5000,
                  10000
                ],
                "docs::human_name": "Session Timeout"
              },
              "default": 10000,
              "description": "The Kafka session timeout."
            },
            "socket_timeout_ms": {
              "$ref": "#/definitions/serde_with::DurationMilliSeconds",
              "_metadata": {
                "docs::advanced": true,
                "docs::examples": [
                  30000,
                  60000
                ],
                "docs::human_name": "Socket Timeout"
              },
              "default": 60000,
              "description": "Timeout for network requests."
            },
            "topic_key": {
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
              "_metadata": {
                "docs::examples": "topic",
                "docs::human_name": "Topic Key"
              },
              "default": "topic",
              "description": "The value is the topic from which the Kafka message was consumed from.\n\nBy default, `\"topic\"` is used.",
              "title": "Overrides the name of the log field used to add the topic to each event."
            },
            "topics": {
              "_metadata": {
                "docs::examples": [
                  "^(prefix1|prefix2)-.+",
                  "topic-1",
                  "topic-2"
                ],
                "docs::human_name": "Topics"
              },
              "description": "Regular expression syntax is supported if the topic begins with `^`.",
              "items": {
                "type": "string"
              },
              "title": "The Kafka topics names to read events from.",
              "type": "array"
            }
          },
          "required": [
            "bootstrap_servers",
            "group_id",
            "topics"
          ],
          "type": "object"
        },
        {
          "$ref": "#/definitions/vector::kafka::KafkaAuthConfig",
          "description": "Kafka authentication configuration."
        }
      ],
      "description": "Configuration for the `kafka` source."
    },
    "vector::sources::logstash::LogstashConfig": {
      "_metadata": {
        "docs::component_name": "logstash",
        "docs::component_type": "source"
      },
      "description": "Configuration for the `logstash` source.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::SourceAcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "This setting is **deprecated** in favor of enabling `acknowledgements` at the [global][global_acks] or sink level.\n\nEnabling or disabling acknowledgements at the source level has **no effect** on acknowledgement behavior.\n\nSee [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled by this source."
        },
        "address": {
          "$ref": "#/definitions/vector::sources::util::net::SocketListenAddr",
          "_metadata": {
            "docs::human_name": "Address"
          },
          "description": "If a socket address is used, it _must_ include a port.",
          "title": "The socket address to listen for connections on, or `systemd{#N}` to use the Nth socket passed by\nsystemd socket activation."
        },
        "connection_limit": {
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Connection Limit",
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "connections"
          },
          "description": "The maximum number of TCP connections that are allowed at any given time.",
          "maximum": 4294967295,
          "minimum": 0,
          "type": [
            "integer",
            "null"
          ]
        },
        "keepalive": {
          "$ref": "#/definitions/core::option::Option<vector_core::tcp::TcpKeepaliveConfig>",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Keepalive"
          }
        },
        "log_namespace": {
          "_metadata": {
            "docs::hidden": true,
            "docs::human_name": "Log Namespace",
            "docs::optional": true
          },
          "default": null,
          "description": "The namespace to use for logs. This overrides the global setting.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "receive_buffer_bytes": {
          "_metadata": {
            "docs::advanced": true,
            "docs::examples": 65536,
            "docs::human_name": "Receive Buffer Bytes",
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "bytes"
          },
          "description": "The size of the receive buffer used for each connection.",
          "maximum": 9007199254740991,
          "minimum": 0,
          "type": [
            "integer",
            "null"
          ]
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsSourceConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "required": [
        "address"
      ],
      "type": "object"
    },
    "vector::sources::nats::NatsSourceConfig": {
      "_metadata": {
        "docs::component_name": "nats",
        "docs::component_type": "source"
      },
      "description": "Configuration for the `nats` source.",
      "properties": {
        "auth": {
          "$ref": "#/definitions/core::option::Option<vector::nats::NatsAuthConfig>",
          "_metadata": {
            "docs::human_name": "Auth"
          }
        },
        "connection_name": {
          "_metadata": {
            "docs::examples": "vector",
            "docs::human_name": "Connection Name"
          },
          "description": "[nats_connection_name]: https://docs.nats.io/using-nats/developer/connecting/name",
          "title": "A [name][nats_connection_name] assigned to the NATS connection.",
          "type": "string"
        },
        "decoding": {
          "$ref": "#/definitions/codecs::decoding::DeserializerConfig",
          "_metadata": {
            "docs::human_name": "Decoding"
          },
          "default": {
            "codec": "bytes"
          },
          "description": "Configures how events are decoded from raw bytes."
        },
        "framing": {
          "$ref": "#/definitions/codecs::decoding::FramingConfig",
          "_metadata": {
            "docs::human_name": "Framing"
          },
          "default": {
            "method": "bytes"
          },
          "description": "Framing handles how events are separated when encoded in a raw byte form, where each event is\na frame that must be prefixed, or delimited, in a way that marks where an event begins and\nends within the byte stream.",
          "title": "Framing configuration."
        },
        "log_namespace": {
          "_metadata": {
            "docs::hidden": true,
            "docs::human_name": "Log Namespace",
            "docs::optional": true
          },
          "default": null,
          "description": "The namespace to use for logs. This overrides the global setting.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "queue": {
          "_metadata": {
            "docs::human_name": "Queue",
            "docs::optional": true
          },
          "description": "The NATS queue group to join.",
          "type": [
            "string",
            "null"
          ]
        },
        "subject": {
          "_metadata": {
            "docs::examples": [
              "foo",
              "time.us.east",
              "time.*.east",
              "time.>",
              ">"
            ],
            "docs::human_name": "Subject"
          },
          "description": "[nats_subject]: https://docs.nats.io/nats-concepts/subjects",
          "title": "The NATS [subject][nats_subject] to pull messages from.",
          "type": "string"
        },
        "subject_key_field": {
          "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
          "_metadata": {
            "docs::human_name": "Subject Key Field"
          },
          "default": "subject",
          "description": "The `NATS` subject key."
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        },
        "url": {
          "_metadata": {
            "docs::examples": [
              "nats://demo.nats.io",
              "nats://127.0.0.1:4242"
            ],
            "docs::human_name": "URL"
          },
          "description": "The URL takes the form of `nats://server:port`.\nIf the port is not specified it defaults to 4222.",
          "title": "The NATS URL to connect to.",
          "type": "string"
        }
      },
      "required": [
        "connection_name",
        "subject",
        "url"
      ],
      "type": "object"
    },
    "vector::sources::opentelemetry::OpentelemetryConfig": {
      "_metadata": {
        "docs::component_name": "opentelemetry",
        "docs::component_type": "source"
      },
      "description": "Configuration for the `opentelemetry` source.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::SourceAcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "This setting is **deprecated** in favor of enabling `acknowledgements` at the [global][global_acks] or sink level.\n\nEnabling or disabling acknowledgements at the source level has **no effect** on acknowledgement behavior.\n\nSee [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled by this source."
        },
        "grpc": {
          "_metadata": {
            "docs::examples": {
              "address": "0.0.0.0:4317"
            },
            "docs::human_name": "gRPC"
          },
          "description": "Configuration for the `opentelemetry` gRPC server.",
          "properties": {
            "address": {
              "$ref": "#/definitions/stdlib::SocketAddr",
              "_metadata": {
                "docs::examples": [
                  "0.0.0.0:4317",
                  "localhost:4317"
                ],
                "docs::human_name": "Address"
              },
              "description": "It _must_ include a port.",
              "title": "The socket address to listen for connections on."
            },
            "tls": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              },
              "default": null
            }
          },
          "required": [
            "address"
          ],
          "type": "object",
          "unevaluatedProperties": false
        },
        "http": {
          "_metadata": {
            "docs::examples": {
              "address": "0.0.0.0:4318"
            },
            "docs::human_name": "HTTP"
          },
          "description": "Configuration for the `opentelemetry` HTTP server.",
          "properties": {
            "address": {
              "$ref": "#/definitions/stdlib::SocketAddr",
              "_metadata": {
                "docs::examples": [
                  "0.0.0.0:4318",
                  "localhost:4318"
                ],
                "docs::human_name": "Address"
              },
              "description": "It _must_ include a port.",
              "title": "The socket address to listen for connections on."
            },
            "tls": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              },
              "default": null
            }
          },
          "required": [
            "address"
          ],
          "type": "object",
          "unevaluatedProperties": false
        },
        "log_namespace": {
          "_metadata": {
            "docs::hidden": true,
            "docs::human_name": "Log Namespace",
            "docs::optional": true
          },
          "default": null,
          "description": "The namespace to use for logs. This overrides the global setting.",
          "type": [
            "boolean",
            "null"
          ]
        }
      },
      "required": [
        "grpc",
        "http"
      ],
      "type": "object"
    },
    "vector::sources::prometheus::remote_write::PrometheusRemoteWriteConfig": {
      "_metadata": {
        "docs::component_name": "prometheus_remote_write",
        "docs::component_type": "source"
      },
      "description": "Configuration for the `prometheus_remote_write` source.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::SourceAcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "This setting is **deprecated** in favor of enabling `acknowledgements` at the [global][global_acks] or sink level.\n\nEnabling or disabling acknowledgements at the source level has **no effect** on acknowledgement behavior.\n\nSee [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled by this source."
        },
        "address": {
          "$ref": "#/definitions/stdlib::SocketAddr",
          "_metadata": {
            "docs::examples": "0.0.0.0:9090",
            "docs::human_name": "Address"
          },
          "description": "The address _must_ include a port.",
          "title": "The socket address to accept connections on."
        },
        "auth": {
          "$ref": "#/definitions/core::option::Option<vector::sources::util::http::auth::HttpSourceAuthConfig>",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Auth"
          }
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "required": [
        "address"
      ],
      "type": "object"
    },
    "vector::sources::redis::RedisSourceConfig": {
      "_metadata": {
        "docs::component_name": "redis",
        "docs::component_type": "source"
      },
      "description": "Configuration for the `redis` source.",
      "properties": {
        "data_type": {
          "_metadata": {
            "docs::enum_tagging": "external",
            "docs::human_name": "Data Type"
          },
          "default": "list",
          "description": "The Redis data type (`list` or `channel`) to use.",
          "oneOf": [
            {
              "_metadata": {
                "docs::human_name": "List",
                "logical_name": "List"
              },
              "const": "list",
              "description": "The `list` data type."
            },
            {
              "_metadata": {
                "docs::human_name": "Channel",
                "logical_name": "Channel"
              },
              "const": "channel",
              "description": "This is based on Redis' Pub/Sub capabilities.",
              "title": "The `channel` data type."
            }
          ],
          "unevaluatedProperties": false
        },
        "decoding": {
          "$ref": "#/definitions/codecs::decoding::DeserializerConfig",
          "_metadata": {
            "docs::human_name": "Decoding"
          },
          "default": {
            "codec": "bytes"
          },
          "description": "Configures how events are decoded from raw bytes."
        },
        "framing": {
          "$ref": "#/definitions/codecs::decoding::FramingConfig",
          "_metadata": {
            "docs::human_name": "Framing"
          },
          "default": {
            "method": "bytes"
          },
          "description": "Framing handles how events are separated when encoded in a raw byte form, where each event is\na frame that must be prefixed, or delimited, in a way that marks where an event begins and\nends within the byte stream.",
          "title": "Framing configuration."
        },
        "key": {
          "_metadata": {
            "docs::examples": "vector",
            "docs::human_name": "Key"
          },
          "description": "The Redis key to read messages from.",
          "type": "string"
        },
        "list": {
          "_metadata": {
            "docs::human_name": "List",
            "docs::optional": true
          },
          "description": "Options for the Redis `list` data type.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "description": "Options for the Redis `list` data type.",
              "properties": {
                "method": {
                  "_metadata": {
                    "docs::enum_tagging": "external",
                    "docs::human_name": "Method"
                  },
                  "description": "Method for getting events from the `list` data type.",
                  "oneOf": [
                    {
                      "_metadata": {
                        "docs::human_name": "Lpop",
                        "logical_name": "Lpop"
                      },
                      "const": "lpop",
                      "description": "Pop messages from the head of the list."
                    },
                    {
                      "_metadata": {
                        "docs::human_name": "Rpop",
                        "logical_name": "Rpop"
                      },
                      "const": "rpop",
                      "description": "Pop messages from the tail of the list."
                    }
                  ],
                  "unevaluatedProperties": false
                }
              },
              "required": [
                "method"
              ],
              "type": "object"
            }
          ],
          "unevaluatedProperties": false
        },
        "log_namespace": {
          "_metadata": {
            "docs::hidden": true,
            "docs::human_name": "Log Namespace",
            "docs::optional": true
          },
          "default": null,
          "description": "The namespace to use for logs. This overrides the global setting.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "redis_key": {
          "$ref": "#/definitions/core::option::Option<vector_lookup::lookup_v2::optional_path::OptionalValuePath>",
          "_metadata": {
            "docs::examples": "redis_key",
            "docs::human_name": "Redis Key"
          },
          "description": "The value is the Redis key that the event was read from.\n\nBy default, this is not set and the field is not automatically added.",
          "title": "Sets the name of the log field to use to add the key to each event."
        },
        "url": {
          "_metadata": {
            "docs::examples": "redis://127.0.0.1:6379/0",
            "docs::human_name": "URL"
          },
          "description": "The URL must take the form of `protocol://server:port/db` where the `protocol` can either be `redis` or `rediss` for connections secured using TLS.",
          "title": "The Redis URL to connect to.",
          "type": "string"
        }
      },
      "required": [
        "key",
        "url"
      ],
      "type": "object"
    },
    "vector::sources::splunk_hec::SplunkConfig": {
      "_metadata": {
        "docs::component_name": "splunk_hec",
        "docs::component_type": "source"
      },
      "default": {
        "acknowledgements": {
          "ack_idle_cleanup": false,
          "enabled": null,
          "max_idle_time": 300,
          "max_number_of_ack_channels": 1000000,
          "max_pending_acks": 10000000,
          "max_pending_acks_per_channel": 1000000
        },
        "address": "0.0.0.0:8088",
        "log_namespace": null,
        "store_hec_token": false,
        "tls": null,
        "token": null,
        "valid_tokens": null
      },
      "description": "Configuration for the `splunk_hec` source.",
      "properties": {
        "acknowledgements": {
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "ack_idle_cleanup": false,
            "enabled": null,
            "max_idle_time": 300,
            "max_number_of_ack_channels": 1000000,
            "max_pending_acks": 10000000,
            "max_pending_acks_per_channel": 1000000
          },
          "description": "Acknowledgement configuration for the `splunk_hec` source.",
          "properties": {
            "ack_idle_cleanup": {
              "_metadata": {
                "docs::human_name": "Acknowledgement Idle Cleanup"
              },
              "description": "A channel is idling if it is not used for sending data or querying acknowledgement statuses.",
              "title": "Whether or not to remove channels after idling for `max_idle_time` seconds.",
              "type": "boolean"
            },
            "enabled": {
              "_metadata": {
                "docs::human_name": "Enabled",
                "docs::optional": true
              },
              "description": "Enables end-to-end acknowledgements.",
              "type": [
                "boolean",
                "null"
              ]
            },
            "max_idle_time": {
              "_metadata": {
                "docs::human_name": "Max Idle Time",
                "docs::numeric_type": "uint"
              },
              "description": "Channels can potentially idle for longer than this setting but clients should not rely on such behavior.\n\nMinimum of `1`.",
              "maximum": 9007199254740991,
              "minimum": 1,
              "title": "The amount of time, in seconds, a channel is allowed to idle before removal.",
              "type": "integer"
            },
            "max_number_of_ack_channels": {
              "_metadata": {
                "docs::human_name": "Max Number of Acknowledgement Channels",
                "docs::numeric_type": "uint"
              },
              "description": "Minimum of `1`.",
              "maximum": 9007199254740991,
              "minimum": 1,
              "title": "The maximum number of Splunk HEC channels clients can use with this source.",
              "type": "integer"
            },
            "max_pending_acks": {
              "_metadata": {
                "docs::human_name": "Max Number of Pending Acknowledgements",
                "docs::numeric_type": "uint"
              },
              "description": "Equivalent to the `max_number_of_acked_requests_pending_query` Splunk HEC setting.\n\nMinimum of `1`.",
              "maximum": 9007199254740991,
              "minimum": 1,
              "title": "The maximum number of acknowledgement statuses pending query across all channels.",
              "type": "integer"
            },
            "max_pending_acks_per_channel": {
              "_metadata": {
                "docs::human_name": "Max Number of Pending Acknowledgements Per Channel",
                "docs::numeric_type": "uint"
              },
              "description": "Equivalent to the `max_number_of_acked_requests_pending_query_per_ack_channel` Splunk HEC setting.\n\nMinimum of `1`.",
              "maximum": 9007199254740991,
              "minimum": 1,
              "title": "The maximum number of acknowledgement statuses pending query for a single channel.",
              "type": "integer"
            }
          },
          "type": "object",
          "unevaluatedProperties": false
        },
        "address": {
          "$ref": "#/definitions/stdlib::SocketAddr",
          "_metadata": {
            "docs::human_name": "Address"
          },
          "default": "0.0.0.0:8088",
          "description": "The address _must_ include a port.",
          "title": "The socket address to listen for connections on."
        },
        "log_namespace": {
          "_metadata": {
            "docs::hidden": true,
            "docs::human_name": "Log Namespace",
            "docs::optional": true
          },
          "default": null,
          "description": "The namespace to use for logs. This overrides the global settings.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "store_hec_token": {
          "_metadata": {
            "docs::human_name": "Store HEC Token"
          },
          "description": "If set to `true`, when incoming requests contain a Splunk HEC token, the token used is kept in the\nevent metadata and preferentially used if the event is sent to a Splunk HEC sink.",
          "title": "Whether or not to forward the Splunk HEC authentication token with events.",
          "type": "boolean"
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        },
        "token": {
          "$ref": "#/definitions/core::option::Option<vector_common::sensitive_string::SensitiveString>",
          "_metadata": {
            "deprecated_message": "This option has been deprecated, use `valid_tokens` instead.",
            "docs::human_name": "Token"
          },
          "deprecated": true,
          "description": "If supplied, incoming requests must supply this token in the `Authorization` header, just as a client would if\nit was communicating with the Splunk HEC endpoint directly.\n\nIf _not_ supplied, the `Authorization` header is ignored and requests are not authenticated.",
          "title": "Optional authorization token."
        },
        "valid_tokens": {
          "_metadata": {
            "docs::examples": "A94A8FE5CCB19BA61C4C08",
            "docs::human_name": "Valid Tokens",
            "docs::optional": true,
            "sensitive": true
          },
          "description": "If supplied, incoming requests must supply one of these tokens in the `Authorization` header, just as a client\nwould if it was communicating with the Splunk HEC endpoint directly.\n\nIf _not_ supplied, the `Authorization` header is ignored and requests are not authenticated.",
          "items": {
            "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString"
          },
          "title": "A list of valid authorization tokens.",
          "type": [
            "array",
            "null"
          ]
        }
      },
      "type": "object"
    },
    "vector::sources::statsd::StatsdConfig": {
      "_metadata": {
        "docs::component_name": "statsd",
        "docs::component_type": "source",
        "docs::enum_tag_description": "The type of socket to use.",
        "docs::enum_tag_field": "mode",
        "docs::enum_tagging": "internal"
      },
      "description": "Configuration for the `statsd` source.",
      "oneOf": [
        {
          "_metadata": {
            "docs::human_name": "TCP",
            "logical_name": "Tcp"
          },
          "allOf": [
            {
              "description": "TCP configuration for the `statsd` source.",
              "properties": {
                "address": {
                  "$ref": "#/definitions/vector::sources::util::net::SocketListenAddr",
                  "_metadata": {
                    "docs::human_name": "Address"
                  },
                  "description": "If a socket address is used, it _must_ include a port.",
                  "title": "The socket address to listen for connections on, or `systemd{#N}` to use the Nth socket passed by\nsystemd socket activation."
                },
                "connection_limit": {
                  "_metadata": {
                    "docs::human_name": "Connection Limit",
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "connections"
                  },
                  "description": "The maximum number of TCP connections that are allowed at any given time.",
                  "maximum": 4294967295,
                  "minimum": 0,
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "keepalive": {
                  "$ref": "#/definitions/core::option::Option<vector_core::tcp::TcpKeepaliveConfig>",
                  "_metadata": {
                    "docs::human_name": "Keepalive"
                  }
                },
                "receive_buffer_bytes": {
                  "_metadata": {
                    "docs::human_name": "Receive Buffer Bytes",
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes"
                  },
                  "description": "The size of the receive buffer used for each connection.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "shutdown_timeout_secs": {
                  "$ref": "#/definitions/serde_with::DurationSeconds",
                  "_metadata": {
                    "docs::human_name": "Shutdown Timeout"
                  },
                  "default": 30,
                  "description": "The timeout before a connection is forcefully closed during shutdown."
                },
                "tls": {
                  "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsSourceConfig>",
                  "_metadata": {
                    "docs::human_name": "TLS"
                  },
                  "default": null
                }
              },
              "required": [
                "address"
              ],
              "type": "object"
            },
            {
              "properties": {
                "mode": {
                  "_metadata": {
                    "docs::human_name": "Mode"
                  },
                  "const": "tcp",
                  "description": "Listen on TCP."
                }
              },
              "required": [
                "mode"
              ],
              "type": "object"
            }
          ],
          "description": "Listen on TCP."
        },
        {
          "_metadata": {
            "docs::human_name": "UDP",
            "logical_name": "Udp"
          },
          "allOf": [
            {
              "description": "UDP configuration for the `statsd` source.",
              "properties": {
                "address": {
                  "$ref": "#/definitions/vector::sources::util::net::SocketListenAddr",
                  "_metadata": {
                    "docs::human_name": "Address"
                  },
                  "description": "If a socket address is used, it _must_ include a port.",
                  "title": "The socket address to listen for connections on, or `systemd{#N}` to use the Nth socket passed by\nsystemd socket activation."
                },
                "receive_buffer_bytes": {
                  "_metadata": {
                    "docs::human_name": "Receive Buffer Bytes",
                    "docs::numeric_type": "uint",
                    "docs::optional": true
                  },
                  "description": "The size of the receive buffer used for each connection.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "type": [
                    "integer",
                    "null"
                  ]
                }
              },
              "required": [
                "address"
              ],
              "type": "object"
            },
            {
              "properties": {
                "mode": {
                  "_metadata": {
                    "docs::human_name": "Mode"
                  },
                  "const": "udp",
                  "description": "Listen on UDP."
                }
              },
              "required": [
                "mode"
              ],
              "type": "object"
            }
          ],
          "description": "Listen on UDP."
        },
        {
          "_metadata": {
            "docs::human_name": "Unix",
            "logical_name": "Unix"
          },
          "allOf": [
            {
              "description": "Unix domain socket configuration for the `statsd` source.",
              "properties": {
                "path": {
                  "$ref": "#/definitions/stdlib::PathBuf",
                  "_metadata": {
                    "docs::examples": "/path/to/socket",
                    "docs::human_name": "Path"
                  },
                  "description": "This should be an absolute path.",
                  "title": "The Unix socket path."
                }
              },
              "required": [
                "path"
              ],
              "type": "object"
            },
            {
              "properties": {
                "mode": {
                  "_metadata": {
                    "docs::human_name": "Mode"
                  },
                  "const": "unix",
                  "description": "Listen on a Unix domain Socket (UDS)."
                }
              },
              "required": [
                "mode"
              ],
              "type": "object"
            }
          ],
          "description": "Listen on a Unix domain Socket (UDS)."
        }
      ]
    },
    "vector::sources::syslog::SyslogConfig": {
      "_metadata": {
        "docs::component_name": "syslog",
        "docs::component_type": "source"
      },
      "allOf": [
        {
          "properties": {
            "host_key": {
              "$ref": "#/definitions/core::option::Option<vector_lookup::lookup_v2::optional_path::OptionalValuePath>",
              "_metadata": {
                "docs::human_name": "Host Key"
              },
              "description": "If using TCP or UDP, the value is the peer host's address, including the port. For example, `1.2.3.4:9000`. If using\nUDS, the value is the socket path itself.\n\nBy default, the [global `log_schema.host_key` option][global_host_key] is used.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
              "title": "Overrides the name of the log field used to add the peer host to each event."
            },
            "log_namespace": {
              "_metadata": {
                "docs::hidden": true,
                "docs::human_name": "Log Namespace",
                "docs::optional": true
              },
              "default": null,
              "description": "The namespace to use for logs. This overrides the global setting.",
              "type": [
                "boolean",
                "null"
              ]
            },
            "max_length": {
              "_metadata": {
                "docs::human_name": "Max Length",
                "docs::numeric_type": "uint",
                "docs::type_unit": "bytes"
              },
              "default": 102400,
              "description": "Messages larger than this are truncated.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "title": "The maximum buffer size of incoming messages, in bytes.",
              "type": "integer"
            }
          },
          "type": "object"
        },
        {
          "_metadata": {
            "docs::enum_tag_description": "The type of socket to use.",
            "docs::enum_tag_field": "mode",
            "docs::enum_tagging": "internal"
          },
          "description": "Listener mode for the `syslog` source.",
          "oneOf": [
            {
              "_metadata": {
                "docs::human_name": "TCP",
                "logical_name": "Tcp"
              },
              "description": "Listen on TCP.",
              "properties": {
                "address": {
                  "$ref": "#/definitions/vector::sources::util::net::SocketListenAddr",
                  "_metadata": {
                    "docs::human_name": "Address"
                  },
                  "description": "If a socket address is used, it _must_ include a port.",
                  "title": "The socket address to listen for connections on, or `systemd{#N}` to use the Nth socket passed by\nsystemd socket activation."
                },
                "connection_limit": {
                  "_metadata": {
                    "docs::human_name": "Connection Limit",
                    "docs::numeric_type": "uint",
                    "docs::optional": true
                  },
                  "description": "The maximum number of TCP connections that are allowed at any given time.",
                  "maximum": 4294967295,
                  "minimum": 0,
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "keepalive": {
                  "$ref": "#/definitions/core::option::Option<vector_core::tcp::TcpKeepaliveConfig>",
                  "_metadata": {
                    "docs::human_name": "Keepalive"
                  }
                },
                "mode": {
                  "_metadata": {
                    "docs::human_name": "Mode"
                  },
                  "const": "tcp",
                  "description": "Listen on TCP."
                },
                "receive_buffer_bytes": {
                  "_metadata": {
                    "docs::human_name": "Receive Buffer Bytes",
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes"
                  },
                  "description": "This should not typically needed to be changed.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "title": "The size of the receive buffer used for each connection.",
                  "type": [
                    "integer",
                    "null"
                  ]
                },
                "tls": {
                  "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsSourceConfig>",
                  "_metadata": {
                    "docs::human_name": "TLS"
                  }
                }
              },
              "required": [
                "address",
                "mode"
              ],
              "type": "object"
            },
            {
              "_metadata": {
                "docs::human_name": "UDP",
                "logical_name": "Udp"
              },
              "description": "Listen on UDP.",
              "properties": {
                "address": {
                  "$ref": "#/definitions/vector::sources::util::net::SocketListenAddr",
                  "_metadata": {
                    "docs::human_name": "Address"
                  },
                  "description": "If a socket address is used, it _must_ include a port.",
                  "title": "The socket address to listen for connections on, or `systemd{#N}` to use the Nth socket passed by\nsystemd socket activation."
                },
                "mode": {
                  "_metadata": {
                    "docs::human_name": "Mode"
                  },
                  "const": "udp",
                  "description": "Listen on UDP."
                },
                "receive_buffer_bytes": {
                  "_metadata": {
                    "docs::human_name": "Receive Buffer Bytes",
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes"
                  },
                  "description": "This should not typically needed to be changed.",
                  "maximum": 9007199254740991,
                  "minimum": 0,
                  "title": "The size of the receive buffer used for the listening socket.",
                  "type": [
                    "integer",
                    "null"
                  ]
                }
              },
              "required": [
                "address",
                "mode"
              ],
              "type": "object"
            },
            {
              "_metadata": {
                "docs::human_name": "Unix",
                "logical_name": "Unix"
              },
              "description": "Listen on UDS. (Unix domain socket)",
              "properties": {
                "mode": {
                  "_metadata": {
                    "docs::human_name": "Mode"
                  },
                  "const": "unix",
                  "description": "Listen on UDS. (Unix domain socket)"
                },
                "path": {
                  "$ref": "#/definitions/stdlib::PathBuf",
                  "_metadata": {
                    "docs::examples": "/path/to/socket",
                    "docs::human_name": "Path"
                  },
                  "description": "This should be an absolute path.",
                  "title": "The Unix socket path."
                },
                "socket_file_mode": {
                  "_metadata": {
                    "docs::human_name": "Socket File Mode",
                    "docs::numeric_type": "uint",
                    "docs::optional": true
                  },
                  "description": "The file mode value can be specified in any numeric format supported by your configuration\nlanguage, but it is most intuitive to use an octal number.",
                  "maximum": 4294967295,
                  "minimum": 0,
                  "title": "Unix file mode bits to be applied to the unix socket file as its designated file permissions.",
                  "type": [
                    "integer",
                    "null"
                  ]
                }
              },
              "required": [
                "mode",
                "path"
              ],
              "type": "object"
            }
          ]
        }
      ],
      "description": "Configuration for the `syslog` source."
    },
    "vector::sources::util::http::method::HttpMethod": {
      "_metadata": {
        "docs::enum_tagging": "external"
      },
      "description": "HTTP method.",
      "oneOf": [
        {
          "_metadata": {
            "docs::human_name": "Head",
            "logical_name": "Head"
          },
          "const": "HEAD",
          "description": "HTTP HEAD method."
        },
        {
          "_metadata": {
            "docs::human_name": "Get",
            "logical_name": "Get"
          },
          "const": "GET",
          "description": "HTTP GET method."
        },
        {
          "_metadata": {
            "docs::human_name": "Post",
            "logical_name": "Post"
          },
          "const": "POST",
          "description": "HTTP POST method."
        },
        {
          "_metadata": {
            "docs::human_name": "Put",
            "logical_name": "Put"
          },
          "const": "PUT",
          "description": "HTTP Put method."
        },
        {
          "_metadata": {
            "docs::human_name": "Patch",
            "logical_name": "Patch"
          },
          "const": "PATCH",
          "description": "HTTP PATCH method."
        },
        {
          "_metadata": {
            "docs::human_name": "Delete",
            "logical_name": "Delete"
          },
          "const": "DELETE",
          "description": "HTTP DELETE method."
        }
      ],
      "unevaluatedProperties": false
    },
    "vector::sources::util::net::SocketListenAddr": {
      "_metadata": {
        "docs::enum_tagging": "untagged",
        "docs::examples": [
          "0.0.0.0:9000",
          "systemd",
          "systemd#3"
        ]
      },
      "description": "If a socket address is used, it _must_ include a port.",
      "title": "The socket address to listen for connections on, or `systemd{#N}` to use the Nth socket passed by\nsystemd socket activation.",
      "type": "string"
    },
    "vector::sources::vector::VectorConfig": {
      "_metadata": {
        "docs::component_name": "vector",
        "docs::component_type": "source"
      },
      "description": "Configuration for the `vector` source.",
      "properties": {
        "acknowledgements": {
          "$ref": "#/definitions/vector_core::config::SourceAcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          },
          "default": {
            "enabled": null
          },
          "description": "This setting is **deprecated** in favor of enabling `acknowledgements` at the [global][global_acks] or sink level.\n\nEnabling or disabling acknowledgements at the source level has **no effect** on acknowledgement behavior.\n\nSee [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "title": "Controls how acknowledgements are handled by this source."
        },
        "address": {
          "$ref": "#/definitions/stdlib::SocketAddr",
          "_metadata": {
            "docs::human_name": "Address"
          },
          "description": "It _must_ include a port.",
          "title": "The socket address to listen for connections on."
        },
        "log_namespace": {
          "_metadata": {
            "docs::hidden": true,
            "docs::human_name": "Log Namespace",
            "docs::optional": true
          },
          "default": null,
          "description": "The namespace to use for logs. This overrides the global setting.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          },
          "default": null
        },
        "version": {
          "_metadata": {
            "docs::human_name": "Version",
            "docs::optional": true
          },
          "description": "Version of the configuration.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "_metadata": {
                "docs::enum_tagging": "external"
              },
              "description": "Marker type for version two of the configuration for the `vector` source.",
              "oneOf": [
                {
                  "_metadata": {
                    "docs::human_name": "V2",
                    "logical_name": "V2"
                  },
                  "const": "2",
                  "description": "Marker value for version two."
                }
              ]
            }
          ],
          "unevaluatedProperties": false
        }
      },
      "required": [
        "address"
      ],
      "type": "object"
    },
    "vector::template::Template": {
      "_metadata": {
        "docs::templateable": true
      },
      "description": "In many cases, components can be configured so that part of the component's functionality can be\ncustomized on a per-event basis. For example, you have a sink that writes events to a file and you want to\nspecify which file an event should go to by using an event field as part of the\ninput to the filename used.\n\nBy using `Template`, users can specify either fixed strings or templated strings. Templated strings use a common syntax to\nrefer to fields in an event that is used as the input data when rendering the template. An example of a fixed string\nis `my-file.log`. An example of a template string is `my-file-{{key}}.log`, where `{{key}}`\nis the key's value when the template is rendered into a string.",
      "title": "A templated field.",
      "type": "string"
    },
    "vector::transforms::Transforms": {
      "_metadata": {
        "docs::enum_tag_field": "type",
        "docs::enum_tagging": "internal"
      },
      "description": "Configurable transforms in Vector.",
      "oneOf": [
        {
          "_metadata": {
            "docs::human_name": "Aggregate",
            "logical_name": "Aggregate"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::transforms::aggregate::AggregateConfig",
              "description": "Configuration for the `aggregate` transform."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "aggregate",
                  "description": "Aggregate metrics passing through a topology."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Aggregate metrics passing through a topology."
        },
        {
          "_metadata": {
            "docs::human_name": "AWS EC2 Metadata",
            "logical_name": "Ec2Metadata"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::transforms::aws_ec2_metadata::Ec2Metadata",
              "description": "Configuration for the `aws_ec2_metadata` transform."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "aws_ec2_metadata",
                  "description": "Parse metadata emitted by AWS EC2 instances."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Parse metadata emitted by AWS EC2 instances."
        },
        {
          "_metadata": {
            "docs::human_name": "Dedupe",
            "logical_name": "Dedupe"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::transforms::dedupe::DedupeConfig",
              "description": "Configuration for the `dedupe` transform."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "dedupe",
                  "description": "Deduplicate logs passing through a topology."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Deduplicate logs passing through a topology."
        },
        {
          "_metadata": {
            "docs::human_name": "Filter",
            "logical_name": "Filter"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::transforms::filter::FilterConfig",
              "description": "Configuration for the `filter` transform."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "filter",
                  "description": "Filter events based on a set of conditions."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Filter events based on a set of conditions."
        },
        {
          "_metadata": {
            "docs::human_name": "Metric To Log",
            "logical_name": "MetricToLog"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::transforms::metric_to_log::MetricToLogConfig",
              "description": "Configuration for the `metric_to_log` transform."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "metric_to_log",
                  "description": "Convert metric events to log events."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Convert metric events to log events."
        },
        {
          "_metadata": {
            "docs::human_name": "Reduce",
            "logical_name": "Reduce"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::transforms::reduce::ReduceConfig",
              "description": "Configuration for the `reduce` transform."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "reduce",
                  "description": "Collapse multiple log events into a single event based on a set of conditions and merge strategies."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Collapse multiple log events into a single event based on a set of conditions and merge strategies."
        },
        {
          "_metadata": {
            "docs::human_name": "Remap",
            "logical_name": "Remap"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::transforms::remap::RemapConfig",
              "description": "Configuration for the `remap` transform."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "remap",
                  "description": "Modify your observability data as it passes through your topology using Vector Remap Language (VRL)."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Modify your observability data as it passes through your topology using Vector Remap Language (VRL)."
        },
        {
          "_metadata": {
            "docs::human_name": "Route",
            "logical_name": "Route"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::transforms::route::RouteConfig",
              "description": "Configuration for the `route` transform."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "route",
                  "description": "Split a stream of events into multiple sub-streams based on user-supplied conditions."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Split a stream of events into multiple sub-streams based on user-supplied conditions."
        },
        {
          "_metadata": {
            "docs::human_name": "Sample",
            "logical_name": "Sample"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::transforms::sample::SampleConfig",
              "description": "Configuration for the `sample` transform."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "sample",
                  "description": "Sample events from an event stream based on supplied criteria and at a configurable rate."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Sample events from an event stream based on supplied criteria and at a configurable rate."
        },
        {
          "_metadata": {
            "docs::human_name": "Sensitive Data Scanner",
            "logical_name": "SDS"
          },
          "allOf": [
            {
              "$ref": "#/definitions/generate_schema::sds::config::SDSConfig",
              "description": "Configuration for the `sensitive_data_scanner` transform."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "sensitive_data_scanner",
                  "description": "Filter sensitive data out of events."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Filter sensitive data out of events."
        },
        {
          "_metadata": {
            "docs::human_name": "Tag Cardinality Limit",
            "logical_name": "TagCardinalityLimit"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::transforms::tag_cardinality_limit::config::TagCardinalityLimitConfig",
              "description": "Configuration for the `tag_cardinality_limit` transform."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "tag_cardinality_limit",
                  "description": "Limit the cardinality of tags on metrics events as a safeguard against cardinality explosion."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Limit the cardinality of tags on metrics events as a safeguard against cardinality explosion."
        },
        {
          "_metadata": {
            "docs::human_name": "Throttle",
            "logical_name": "Throttle"
          },
          "allOf": [
            {
              "$ref": "#/definitions/vector::transforms::throttle::ThrottleConfig",
              "description": "Configuration for the `throttle` transform."
            },
            {
              "properties": {
                "type": {
                  "_metadata": {
                    "docs::human_name": "Type"
                  },
                  "const": "throttle",
                  "description": "Rate limit logs passing through a topology."
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ],
          "description": "Rate limit logs passing through a topology."
        }
      ]
    },
    "vector::transforms::aggregate::AggregateConfig": {
      "_metadata": {
        "docs::component_name": "aggregate",
        "docs::component_type": "transform"
      },
      "description": "Configuration for the `aggregate` transform.",
      "properties": {
        "interval_ms": {
          "_metadata": {
            "docs::human_name": "Flush Interval",
            "docs::numeric_type": "uint"
          },
          "default": 10000,
          "description": "During this time frame, metrics with the same series data (name, namespace, tags, and so on) are aggregated.",
          "maximum": 9007199254740991,
          "minimum": 0,
          "title": "The interval between flushes, in milliseconds.",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "vector::transforms::aws_ec2_metadata::Ec2Metadata": {
      "_metadata": {
        "docs::component_name": "aws_ec2_metadata",
        "docs::component_type": "transform"
      },
      "description": "Configuration for the `aws_ec2_metadata` transform.",
      "properties": {
        "endpoint": {
          "_metadata": {
            "docs::human_name": "Endpoint"
          },
          "default": "http://169.254.169.254",
          "description": "Overrides the default EC2 metadata endpoint.",
          "type": "string"
        },
        "fields": {
          "_metadata": {
            "docs::examples": [
              "instance-id",
              "local-hostname"
            ],
            "docs::human_name": "Fields"
          },
          "default": [
            "ami-id",
            "availability-zone",
            "instance-id",
            "instance-type",
            "local-hostname",
            "local-ipv4",
            "public-hostname",
            "public-ipv4",
            "region",
            "subnet-id",
            "vpc-id",
            "role-name"
          ],
          "description": "A list of metadata fields to include in each transformed event.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "namespace": {
          "$ref": "#/definitions/core::option::Option<vector_lookup::lookup_v2::optional_path::OptionalTargetPath>",
          "_metadata": {
            "docs::examples": [
              "",
              "ec2",
              "aws.ec2"
            ],
            "docs::human_name": "Namespace"
          },
          "description": "Sets a prefix for all event fields added by the transform."
        },
        "proxy": {
          "$ref": "#/definitions/vector_core::config::proxy::ProxyConfig",
          "_metadata": {
            "docs::human_name": "Proxy"
          },
          "default": {
            "enabled": true,
            "http": null,
            "https": null
          },
          "description": "Configure to proxy traffic through an HTTP(S) proxy when making external requests.\n\nSimilar to common proxy configuration convention, you can set different proxies\nto use based on the type of traffic being proxied, as well as set specific hosts that\nshould not be proxied.",
          "title": "Proxy configuration."
        },
        "refresh_interval_secs": {
          "$ref": "#/definitions/serde_with::DurationSeconds",
          "_metadata": {
            "docs::human_name": "Refresh Interval Secs"
          },
          "default": 10,
          "description": "The interval between querying for updated metadata, in seconds."
        },
        "refresh_timeout_secs": {
          "$ref": "#/definitions/serde_with::DurationSeconds",
          "_metadata": {
            "docs::human_name": "Refresh Timeout Secs"
          },
          "default": 1,
          "description": "The timeout for querying the EC2 metadata endpoint, in seconds."
        },
        "required": {
          "_metadata": {
            "docs::human_name": "Required"
          },
          "default": true,
          "description": "Requires the transform to be able to successfully query the EC2 metadata before starting to process the data.",
          "type": "boolean"
        },
        "tags": {
          "_metadata": {
            "docs::examples": [
              "Name",
              "Project"
            ],
            "docs::human_name": "Tags"
          },
          "default": [],
          "description": "A list of instance tags to include in each transformed event.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "vector::transforms::dedupe::DedupeConfig": {
      "_metadata": {
        "docs::component_name": "dedupe",
        "docs::component_type": "transform"
      },
      "description": "Configuration for the `dedupe` transform.",
      "properties": {
        "cache": {
          "_metadata": {
            "docs::human_name": "Cache"
          },
          "default": {
            "num_events": 5000
          },
          "description": "Caching configuration for deduplication.",
          "properties": {
            "num_events": {
              "_metadata": {
                "docs::human_name": "Num Events",
                "docs::numeric_type": "uint"
              },
              "description": "Number of events to cache and use for comparing incoming events to previously seen events.",
              "maximum": 9007199254740991,
              "minimum": 1,
              "type": "integer"
            }
          },
          "required": [
            "num_events"
          ],
          "type": "object",
          "unevaluatedProperties": false
        },
        "fields": {
          "_metadata": {
            "docs::human_name": "Fields",
            "docs::optional": true
          },
          "default": null,
          "description": "When no field matching configuration is specified, events are matched using the `timestamp`,\n`host`, and `message` fields from an event. The specific field names used are those set in\nthe global [`log schema`][global_log_schema] configuration.\n\n[global_log_schema]: https://vector.dev/docs/reference/configuration/global-options/#log_schema",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "_metadata": {
                "docs::enum_tagging": "external"
              },
              "description": "When no field matching configuration is specified, events are matched using the `timestamp`,\n`host`, and `message` fields from an event. The specific field names used are those set in\nthe global [`log schema`][global_log_schema] configuration.\n\n[global_log_schema]: https://vector.dev/docs/reference/configuration/global-options/#log_schema",
              "oneOf": [
                {
                  "_metadata": {
                    "docs::human_name": "Match Fields",
                    "logical_name": "MatchFields"
                  },
                  "description": "Matches events using only the specified fields.",
                  "properties": {
                    "match": {
                      "_metadata": {
                        "docs::examples": [
                          "field1",
                          "parent.child_field"
                        ],
                        "docs::human_name": "Match"
                      },
                      "description": "A wrapper around `OwnedTargetPath` that allows it to be used in Vector config\nwith prefix default to `PathPrefix::Event`",
                      "items": {
                        "$ref": "#/definitions/vector_lookup::lookup_v2::ConfigTargetPath"
                      },
                      "type": "array"
                    }
                  },
                  "required": [
                    "match"
                  ],
                  "type": "object"
                },
                {
                  "_metadata": {
                    "docs::human_name": "Ignore Fields",
                    "logical_name": "IgnoreFields"
                  },
                  "description": "Matches events using all fields except for the ignored ones.",
                  "properties": {
                    "ignore": {
                      "_metadata": {
                        "docs::examples": [
                          "field1",
                          "parent.child_field",
                          "host",
                          "hostname"
                        ],
                        "docs::human_name": "Ignore"
                      },
                      "description": "A wrapper around `OwnedTargetPath` that allows it to be used in Vector config\nwith prefix default to `PathPrefix::Event`",
                      "items": {
                        "$ref": "#/definitions/vector_lookup::lookup_v2::ConfigTargetPath"
                      },
                      "type": "array"
                    }
                  },
                  "required": [
                    "ignore"
                  ],
                  "type": "object"
                }
              ],
              "title": "Options to control what fields to match against."
            }
          ],
          "title": "Options to control what fields to match against.",
          "unevaluatedProperties": false
        }
      },
      "type": "object"
    },
    "vector::transforms::filter::FilterConfig": {
      "_metadata": {
        "docs::component_name": "filter",
        "docs::component_type": "transform"
      },
      "description": "Configuration for the `filter` transform.",
      "properties": {
        "condition": {
          "$ref": "#/definitions/vector::conditions::AnyCondition",
          "_metadata": {
            "docs::human_name": "Condition"
          },
          "description": "If an event is matched by the condition, it is forwarded. Otherwise, the event is dropped.",
          "title": "The condition that every input event is matched against."
        }
      },
      "required": [
        "condition"
      ],
      "type": "object"
    },
    "vector::transforms::metric_to_log::MetricToLogConfig": {
      "_metadata": {
        "docs::component_name": "metric_to_log",
        "docs::component_type": "transform"
      },
      "description": "Configuration for the `metric_to_log` transform.",
      "properties": {
        "host_tag": {
          "_metadata": {
            "docs::examples": [
              "host",
              "hostname"
            ],
            "docs::human_name": "Host Tag",
            "docs::optional": true
          },
          "description": "If present, the value of the tag is set on the generated log event in the `host` field,\nwhere the field key uses the [global `host_key` option][global_log_schema_host_key].\n\n[global_log_schema_host_key]: https://vector.dev/docs/reference/configuration//global-options#log_schema.host_key",
          "title": "Name of the tag in the metric to use for the source host.",
          "type": [
            "string",
            "null"
          ]
        },
        "log_namespace": {
          "_metadata": {
            "docs::hidden": true,
            "docs::human_name": "Log Namespace",
            "docs::optional": true
          },
          "default": null,
          "description": "The namespace to use for logs. This overrides the global setting.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "metric_tag_values": {
          "$ref": "#/definitions/codecs::MetricTagValues",
          "_metadata": {
            "docs::human_name": "Metric Tag Values"
          },
          "default": "single",
          "description": "When set to `single`, only the last non-bare value of tags are displayed with the\nmetric.  When set to `full`, all metric tags are exposed as separate assignments as\ndescribed by [the `native_json` codec][vector_native_json].\n\n[vector_native_json]: https://github.com/vectordotdev/vector/blob/master/lib/codecs/tests/data/native_encoding/schema.cue",
          "title": "Controls how metric tag values are encoded."
        },
        "timezone": {
          "$ref": "#/definitions/core::option::Option<vrl::compiler::datetime::TimeZone>",
          "_metadata": {
            "docs::human_name": "Timezone"
          },
          "description": "This overrides the [global `timezone`][global_timezone] option. The time zone name may be\nany name in the [TZ database][tz_database] or `local` to indicate system local time.\n\n[global_timezone]: https://vector.dev/docs/reference/configuration//global-options#timezone\n[tz_database]: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones",
          "title": "The name of the time zone to apply to timestamp conversions that do not contain an explicit\ntime zone."
        }
      },
      "type": "object"
    },
    "vector::transforms::reduce::ReduceConfig": {
      "_metadata": {
        "docs::component_name": "reduce",
        "docs::component_type": "transform"
      },
      "description": "Configuration for the `reduce` transform.",
      "properties": {
        "ends_when": {
          "$ref": "#/definitions/core::option::Option<vector::conditions::AnyCondition>",
          "_metadata": {
            "docs::human_name": "Ends When"
          },
          "description": "If this condition resolves to `true` for an event, the current transaction is immediately\nflushed with this event.",
          "title": "A condition used to distinguish the final event of a transaction."
        },
        "expire_after_ms": {
          "$ref": "#/definitions/serde_with::DurationMilliSeconds",
          "_metadata": {
            "docs::human_name": "Expire After"
          },
          "default": 30000,
          "description": "The maximum period of time to wait after the last event is received, in milliseconds, before\na combined event should be considered complete."
        },
        "flush_period_ms": {
          "$ref": "#/definitions/serde_with::DurationMilliSeconds",
          "_metadata": {
            "docs::human_name": "Flush Period"
          },
          "default": 1000,
          "description": "The interval to check for and flush any expired events, in milliseconds."
        },
        "group_by": {
          "_metadata": {
            "docs::examples": [
              "request_id",
              "user_id",
              "transaction_id"
            ],
            "docs::human_name": "Group By"
          },
          "default": [],
          "description": "Each group with matching values for the specified keys is reduced independently, allowing\nyou to keep independent event streams separate. When no fields are specified, all events\nare combined in a single group.\n\nFor example, if `group_by = [\"host\", \"region\"]`, then all incoming events that have the same\nhost and region are grouped together before being reduced.",
          "items": {
            "type": "string"
          },
          "title": "An ordered list of fields by which to group events.",
          "type": "array"
        },
        "max_events": {
          "_metadata": {
            "docs::human_name": "Max Events",
            "docs::numeric_type": "uint",
            "docs::optional": true
          },
          "description": "The maximum number of events to group together.",
          "maximum": 9007199254740991,
          "minimum": 1,
          "type": [
            "integer",
            "null"
          ]
        },
        "merge_strategies": {
          "_metadata": {
            "docs::additional_props_description": "An individual merge strategy.",
            "docs::human_name": "Merge Strategies"
          },
          "additionalProperties": {
            "_metadata": {
              "docs::enum_tagging": "external"
            },
            "description": "Strategies for merging events.",
            "oneOf": [
              {
                "_metadata": {
                  "docs::human_name": "Discard",
                  "logical_name": "Discard"
                },
                "const": "discard",
                "description": "Discard all but the first value found."
              },
              {
                "_metadata": {
                  "docs::human_name": "Retain",
                  "logical_name": "Retain"
                },
                "const": "retain",
                "description": "Works as a way to coalesce by not retaining `null`.",
                "title": "Discard all but the last value found."
              },
              {
                "_metadata": {
                  "docs::human_name": "Sum",
                  "logical_name": "Sum"
                },
                "const": "sum",
                "description": "Sum all numeric values."
              },
              {
                "_metadata": {
                  "docs::human_name": "Max",
                  "logical_name": "Max"
                },
                "const": "max",
                "description": "Keep the maximum numeric value seen."
              },
              {
                "_metadata": {
                  "docs::human_name": "Min",
                  "logical_name": "Min"
                },
                "const": "min",
                "description": "Keep the minimum numeric value seen."
              },
              {
                "_metadata": {
                  "docs::human_name": "Array",
                  "logical_name": "Array"
                },
                "const": "array",
                "description": "Append each value to an array."
              },
              {
                "_metadata": {
                  "docs::human_name": "Concat",
                  "logical_name": "Concat"
                },
                "const": "concat",
                "description": "Concatenate each string value, delimited with a space."
              },
              {
                "_metadata": {
                  "docs::human_name": "Concat Newline",
                  "logical_name": "ConcatNewline"
                },
                "const": "concat_newline",
                "description": "Concatenate each string value, delimited with a newline."
              },
              {
                "_metadata": {
                  "docs::human_name": "Concat Raw",
                  "logical_name": "ConcatRaw"
                },
                "const": "concat_raw",
                "description": "Concatenate each string, without a delimiter."
              },
              {
                "_metadata": {
                  "docs::human_name": "Shortest Array",
                  "logical_name": "ShortestArray"
                },
                "const": "shortest_array",
                "description": "Keep the shortest array seen."
              },
              {
                "_metadata": {
                  "docs::human_name": "Longest Array",
                  "logical_name": "LongestArray"
                },
                "const": "longest_array",
                "description": "Keep the longest array seen."
              },
              {
                "_metadata": {
                  "docs::human_name": "Flat Unique",
                  "logical_name": "FlatUnique"
                },
                "const": "flat_unique",
                "description": "Create a flattened array of all unique values."
              }
            ],
            "unevaluatedProperties": false
          },
          "default": {},
          "description": "For each field specified, the given strategy is used for combining events rather than\nthe default behavior.\n\nThe default behavior is as follows:\n\n- The first value of a string field is kept and subsequent values are discarded.\n- For timestamp fields the first is kept and a new field `[field-name]_end` is added with\n  the last received timestamp value.\n- Numeric values are summed.",
          "title": "A map of field names to custom merge strategies.",
          "type": "object"
        },
        "starts_when": {
          "$ref": "#/definitions/core::option::Option<vector::conditions::AnyCondition>",
          "_metadata": {
            "docs::human_name": "Starts When"
          },
          "description": "If this condition resolves to `true` for an event, the previous transaction is flushed\n(without this event) and a new transaction is started.",
          "title": "A condition used to distinguish the first event of a transaction."
        }
      },
      "type": "object"
    },
    "vector::transforms::remap::RemapConfig": {
      "_metadata": {
        "docs::component_name": "remap",
        "docs::component_type": "transform"
      },
      "description": "Configuration for the `remap` transform.",
      "properties": {
        "drop_on_abort": {
          "_metadata": {
            "docs::human_name": "Drop Event on Abort"
          },
          "default": true,
          "description": "Normally, if a VRL program is manually aborted (using [`abort`][vrl_docs_abort]) when\nprocessing an event, the original, unmodified event is sent downstream. In some cases,\nyou may not wish to send the event any further, such as if certain transformation or\nenrichment is strictly required. Setting `drop_on_abort` to `true` allows you to ensure\nthese events do not get processed any further.\n\nAdditionally, dropped events can potentially be diverted to a specially-named output for\nfurther logging and analysis by setting `reroute_dropped`.\n\n[vrl_docs_abort]: https://vector.dev/docs/reference/vrl/expressions/#abort",
          "title": "Drops any event that is manually aborted during processing.",
          "type": "boolean"
        },
        "drop_on_error": {
          "_metadata": {
            "docs::human_name": "Drop Event on Error"
          },
          "default": false,
          "description": "Normally, if a VRL program encounters an error when processing an event, the original,\nunmodified event is sent downstream. In some cases, you may not want to send the event\nany further, such as if certain transformation or enrichment is strictly required. Setting\n`drop_on_error` to `true` allows you to ensure these events do not get processed any\nfurther.\n\nAdditionally, dropped events can potentially be diverted to a specially named output for\nfurther logging and analysis by setting `reroute_dropped`.",
          "title": "Drops any event that encounters an error during processing.",
          "type": "boolean"
        },
        "file": {
          "$ref": "#/definitions/core::option::Option<std::path::PathBuf>",
          "_metadata": {
            "docs::examples": "./my/program.vrl",
            "docs::human_name": "File"
          },
          "description": "If a relative path is provided, its root is the current working directory.\n\nRequired if `source` is missing.\n\n[vrl]: https://vector.dev/docs/reference/vrl",
          "title": "File path to the [Vector Remap Language][vrl] (VRL) program to execute for each event."
        },
        "metric_tag_values": {
          "$ref": "#/definitions/codecs::MetricTagValues",
          "_metadata": {
            "docs::human_name": "Metric Tag Values"
          },
          "default": "single",
          "description": "When set to `full`, all metric tags are exposed as arrays of either string or null\nvalues.",
          "title": "When set to `single`, metric tag values are exposed as single strings, the\nsame as they were before this config option. Tags with multiple values show the last assigned value, and null values\nare ignored."
        },
        "reroute_dropped": {
          "_metadata": {
            "docs::human_name": "Reroute Dropped Events"
          },
          "default": false,
          "description": "When using `drop_on_error` or `drop_on_abort`, events that are \"dropped\" are processed no\nfurther. In some cases, it may be desirable to keep the events around for further analysis,\ndebugging, or retrying.\n\nIn these cases, `reroute_dropped` can be set to `true` which forwards the original event\nto a specially-named output, `dropped`. The original event is annotated with additional\nfields describing why the event was dropped.",
          "title": "Reroutes dropped events to a named output instead of halting processing on them.",
          "type": "boolean"
        },
        "runtime": {
          "_metadata": {
            "docs::hidden": true,
            "docs::human_name": "Runtime"
          },
          "default": "ast",
          "description": "The runtime to use for executing VRL code.",
          "type": "string"
        },
        "source": {
          "_metadata": {
            "docs::examples": ". = parse_json!(.message)\n.new_field = \"new value\"\n.status = to_int!(.status)\n.duration = parse_duration!(.duration, \"s\")\n.new_name = del(.old_name)",
            "docs::human_name": "Source",
            "docs::optional": true,
            "docs::syntax_override": "remap_program"
          },
          "description": "Required if `file` is missing.\n\n[vrl]: https://vector.dev/docs/reference/vrl",
          "title": "The [Vector Remap Language][vrl] (VRL) program to execute for each event.",
          "type": [
            "string",
            "null"
          ]
        },
        "timezone": {
          "$ref": "#/definitions/core::option::Option<vrl::compiler::datetime::TimeZone>",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Timezone"
          },
          "default": null,
          "description": "This overrides the [global `timezone`][global_timezone] option. The time zone name may be\nany name in the [TZ database][tz_database], or `local` to indicate system local time.\n\n[global_timezone]: https://vector.dev/docs/reference/configuration//global-options#timezone\n[tz_database]: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones",
          "title": "The name of the timezone to apply to timestamp conversions that do not contain an explicit\ntime zone."
        }
      },
      "type": "object"
    },
    "vector::transforms::route::RouteConfig": {
      "_metadata": {
        "docs::component_name": "route",
        "docs::component_type": "transform"
      },
      "description": "Configuration for the `route` transform.",
      "properties": {
        "reroute_unmatched": {
          "_metadata": {
            "docs::human_name": "Reroute Unmatched Events"
          },
          "default": true,
          "description": "Normally, if an event doesn't match any defined route, it is sent to the `<transform_name>._unmatched`\noutput for further processing. In some cases, you may want to simply discard unmatched events and not\nprocess them any further.\n\nIn these cases, `reroute_unmatched` can be set to `false` to disable the `<transform_name>._unmatched`\noutput and instead silently discard any unmatched events.",
          "title": "Reroutes unmatched events to a named output instead of silently discarding them.",
          "type": "boolean"
        },
        "route": {
          "_metadata": {
            "docs::additional_props_description": "An individual route.",
            "docs::human_name": "Route"
          },
          "additionalProperties": {
            "$ref": "#/definitions/vector::conditions::AnyCondition"
          },
          "description": "Each route can then be referenced as an input by other components with the name\n`<transform_name>.<route_id>`. If an event doesn’t match any route, and if `reroute_unmatched`\nis set to `true` (the default), it is sent to the `<transform_name>._unmatched` output.\nOtherwise, the unmatched event is instead silently discarded.\n\nBoth `_unmatched`, as well as `_default`, are reserved output names and thus cannot be used\nas a route name.",
          "title": "A table of route identifiers to logical conditions representing the filter of the route.",
          "type": "object"
        }
      },
      "type": "object"
    },
    "vector::transforms::sample::SampleConfig": {
      "_metadata": {
        "docs::component_name": "sample",
        "docs::component_type": "transform"
      },
      "description": "Configuration for the `sample` transform.",
      "properties": {
        "exclude": {
          "$ref": "#/definitions/core::option::Option<vector::conditions::AnyCondition>",
          "_metadata": {
            "docs::human_name": "Exclude"
          },
          "description": "A logical condition used to exclude events from sampling."
        },
        "key_field": {
          "_metadata": {
            "docs::examples": "message",
            "docs::human_name": "Key Field",
            "docs::optional": true
          },
          "description": "Each unique value for the key creates a bucket of related events to be sampled together\nand the rate is applied to the buckets themselves to sample `1/N` buckets.  The overall rate\nof sampling may differ from the configured one if values in the field are not uniformly\ndistributed. If left unspecified, or if the event doesn’t have `key_field`, then the\nevent is sampled independently.\n\nThis can be useful to, for example, ensure that all logs for a given transaction are\nsampled together, but that overall `1/N` transactions are sampled.",
          "title": "The name of the field whose value is hashed to determine if the event should be\nsampled.",
          "type": [
            "string",
            "null"
          ]
        },
        "rate": {
          "_metadata": {
            "docs::human_name": "Rate",
            "docs::numeric_type": "uint"
          },
          "description": "For example, `rate = 10` means 1 out of every 10 events are forwarded and the rest are\ndropped.",
          "maximum": 9007199254740991,
          "minimum": 0,
          "title": "The rate at which events are forwarded, expressed as `1/N`.",
          "type": "integer"
        }
      },
      "required": [
        "rate"
      ],
      "type": "object"
    },
    "vector::transforms::tag_cardinality_limit::config::TagCardinalityLimitConfig": {
      "_metadata": {
        "docs::component_name": "tag_cardinality_limit",
        "docs::component_type": "transform"
      },
      "allOf": [
        {
          "properties": {
            "limit_exceeded_action": {
              "_metadata": {
                "docs::enum_tagging": "external",
                "docs::human_name": "Limit Exceeded Action"
              },
              "default": "drop_tag",
              "description": "Possible actions to take when an event arrives that would exceed the cardinality limit for one\nor more of its tags.",
              "oneOf": [
                {
                  "_metadata": {
                    "docs::human_name": "Drop Tag",
                    "logical_name": "DropTag"
                  },
                  "const": "drop_tag",
                  "description": "Drop the tag(s) that would exceed the configured limit."
                },
                {
                  "_metadata": {
                    "docs::human_name": "Drop Event",
                    "logical_name": "DropEvent"
                  },
                  "const": "drop_event",
                  "description": "Drop the entire event itself."
                }
              ],
              "unevaluatedProperties": false
            },
            "value_limit": {
              "_metadata": {
                "docs::human_name": "Value Limit",
                "docs::numeric_type": "uint"
              },
              "default": 500,
              "description": "How many distinct values to accept for any given key.",
              "maximum": 9007199254740991,
              "minimum": 0,
              "type": "integer"
            }
          },
          "type": "object"
        },
        {
          "_metadata": {
            "docs::enum_tag_description": "Controls the approach taken for tracking tag cardinality.",
            "docs::enum_tag_field": "mode",
            "docs::enum_tagging": "internal"
          },
          "description": "Controls the approach taken for tracking tag cardinality.",
          "oneOf": [
            {
              "_metadata": {
                "docs::human_name": "Exact",
                "logical_name": "Exact"
              },
              "description": "This mode has higher memory requirements than `probabilistic`, but never falsely outputs\nmetrics with new tags after the limit has been hit.",
              "properties": {
                "mode": {
                  "_metadata": {
                    "docs::human_name": "Mode"
                  },
                  "const": "exact",
                  "description": "This mode has higher memory requirements than `probabilistic`, but never falsely outputs\nmetrics with new tags after the limit has been hit.",
                  "title": "Tracks cardinality exactly."
                }
              },
              "required": [
                "mode"
              ],
              "title": "Tracks cardinality exactly.",
              "type": "object"
            },
            {
              "_metadata": {
                "docs::human_name": "Probabilistic",
                "logical_name": "Probabilistic"
              },
              "allOf": [
                {
                  "description": "Bloom filter configuration in probabilistic mode.",
                  "properties": {
                    "cache_size_per_key": {
                      "_metadata": {
                        "docs::human_name": "Cache Size per Key",
                        "docs::numeric_type": "uint"
                      },
                      "default": 5120000,
                      "description": "The larger the cache size, the less likely it is to have a false positive, or a case where\nwe allow a new value for tag even after we have reached the configured limits.",
                      "maximum": 9007199254740991,
                      "minimum": 0,
                      "title": "The size of the cache for detecting duplicate tags, in bytes.",
                      "type": "integer"
                    }
                  },
                  "type": "object"
                },
                {
                  "properties": {
                    "mode": {
                      "_metadata": {
                        "docs::human_name": "Mode"
                      },
                      "const": "probabilistic",
                      "description": "This mode has lower memory requirements than `exact`, but may occasionally allow metric\nevents to pass through the transform even when they contain new tags that exceed the\nconfigured limit. The rate at which this happens can be controlled by changing the value of\n`cache_size_per_tag`.",
                      "title": "Tracks cardinality probabilistically."
                    }
                  },
                  "required": [
                    "mode"
                  ],
                  "type": "object"
                }
              ],
              "description": "This mode has lower memory requirements than `exact`, but may occasionally allow metric\nevents to pass through the transform even when they contain new tags that exceed the\nconfigured limit. The rate at which this happens can be controlled by changing the value of\n`cache_size_per_tag`.",
              "title": "Tracks cardinality probabilistically."
            }
          ]
        }
      ],
      "description": "Configuration for the `tag_cardinality_limit` transform."
    },
    "vector::transforms::throttle::ThrottleConfig": {
      "_metadata": {
        "docs::component_name": "throttle",
        "docs::component_type": "transform"
      },
      "description": "Configuration for the `throttle` transform.",
      "properties": {
        "exclude": {
          "$ref": "#/definitions/core::option::Option<vector::conditions::AnyCondition>",
          "_metadata": {
            "docs::human_name": "Exclude"
          },
          "description": "A logical condition used to exclude events from sampling."
        },
        "key_field": {
          "$ref": "#/definitions/core::option::Option<vector::template::Template>",
          "_metadata": {
            "docs::examples": [
              "{{ message }}",
              "{{ hostname }}"
            ],
            "docs::human_name": "Key Field"
          },
          "description": "If left unspecified, or if the event doesn't have `key_field`, then the event is not rate\nlimited separately.",
          "title": "The value to group events into separate buckets to be rate limited independently."
        },
        "threshold": {
          "_metadata": {
            "docs::human_name": "Threshold",
            "docs::numeric_type": "uint"
          },
          "description": "Each unique key has its own `threshold`.",
          "maximum": 4294967295,
          "minimum": 0,
          "title": "The number of events allowed for a given bucket per configured `window_secs`.",
          "type": "integer"
        },
        "window_secs": {
          "$ref": "#/definitions/serde_with::DurationFractionalSeconds",
          "_metadata": {
            "docs::human_name": "Time Window"
          },
          "description": "The time window in which the configured `threshold` is applied, in seconds."
        }
      },
      "required": [
        "threshold",
        "window_secs"
      ],
      "type": "object"
    },
    "vector_common::sensitive_string::SensitiveString": {
      "_metadata": {
        "sensitive": true
      },
      "description": "Wrapper for sensitive strings containing credentials",
      "type": "string"
    },
    "vector_core::config::AcknowledgementsConfig": {
      "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
      "properties": {
        "enabled": {
          "_metadata": {
            "docs::human_name": "Enabled",
            "docs::optional": true
          },
          "description": "When enabled for a sink, any source connected to that sink, where the source supports\nend-to-end acknowledgements as well, waits for events to be acknowledged by the sink\nbefore acknowledging them at the source.\n\nEnabling or disabling acknowledgements at the sink level takes precedence over any global\n[`acknowledgements`][global_acks] configuration.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements",
          "title": "Whether or not end-to-end acknowledgements are enabled.",
          "type": [
            "boolean",
            "null"
          ]
        }
      },
      "title": "Controls how acknowledgements are handled for this sink.",
      "type": "object",
      "unevaluatedProperties": false
    },
    "vector_core::config::SourceAcknowledgementsConfig": {
      "deprecated": true,
      "description": "This setting is **deprecated** in favor of enabling `acknowledgements` at the [global][global_acks] or sink level.\n\nEnabling or disabling acknowledgements at the source level has **no effect** on acknowledgement behavior.\n\nSee [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
      "properties": {
        "enabled": {
          "_metadata": {
            "docs::human_name": "Enabled",
            "docs::optional": true
          },
          "description": "Whether or not end-to-end acknowledgements are enabled for this source.",
          "type": [
            "boolean",
            "null"
          ]
        }
      },
      "title": "Controls how acknowledgements are handled by this source.",
      "type": "object",
      "unevaluatedProperties": false
    },
    "vector_core::config::proxy::ProxyConfig": {
      "_metadata": {
        "docs::advanced": true
      },
      "description": "Configure to proxy traffic through an HTTP(S) proxy when making external requests.\n\nSimilar to common proxy configuration convention, you can set different proxies\nto use based on the type of traffic being proxied, as well as set specific hosts that\nshould not be proxied.",
      "properties": {
        "enabled": {
          "_metadata": {
            "docs::human_name": "Enabled"
          },
          "default": true,
          "description": "Enables proxying support.",
          "type": "boolean"
        },
        "http": {
          "_metadata": {
            "docs::examples": "http://foo.bar:3128",
            "docs::human_name": "HTTP",
            "docs::optional": true
          },
          "default": null,
          "description": "Must be a valid URI string.",
          "format": "uri",
          "title": "Proxy endpoint to use when proxying HTTP traffic.",
          "type": [
            "string",
            "null"
          ]
        },
        "https": {
          "_metadata": {
            "docs::examples": "http://foo.bar:3128",
            "docs::human_name": "HTTPS",
            "docs::optional": true
          },
          "default": null,
          "description": "Must be a valid URI string.",
          "format": "uri",
          "title": "Proxy endpoint to use when proxying HTTPS traffic.",
          "type": [
            "string",
            "null"
          ]
        },
        "no_proxy": {
          "_metadata": {
            "docs::examples": [
              "localhost",
              ".foo.bar",
              "*"
            ],
            "docs::human_name": "No Proxy"
          },
          "default": [],
          "description": "Multiple patterns are allowed:\n\n| Pattern             | Example match                                                               |\n| ------------------- | --------------------------------------------------------------------------- |\n| Domain names        | `example.com` matches requests to `example.com`                     |\n| Wildcard domains    | `.example.com` matches requests to `example.com` and its subdomains |\n| IP addresses        | `127.0.0.1` matches requests to `127.0.0.1`                         |\n| [CIDR][cidr] blocks | `192.168.0.0/16` matches requests to any IP addresses in this range     |\n| Splat               | `*` matches all hosts                                                   |\n\n[cidr]: https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing",
          "items": {
            "type": "string"
          },
          "title": "A list of hosts to avoid proxying.",
          "type": "array"
        }
      },
      "title": "Proxy configuration.",
      "type": "object",
      "unevaluatedProperties": false
    },
    "vector_core::tls::settings::TlsConfig": {
      "_metadata": {
        "docs::advanced": true
      },
      "description": "TLS configuration.",
      "properties": {
        "alpn_protocols": {
          "_metadata": {
            "docs::examples": "h2",
            "docs::human_name": "ALPN Protocols",
            "docs::optional": true
          },
          "description": "Declare the supported ALPN protocols, which are used during negotiation with peer. They are prioritized in the order\nthat they are defined.",
          "items": {
            "type": "string"
          },
          "title": "Sets the list of supported ALPN protocols.",
          "type": [
            "array",
            "null"
          ]
        },
        "ca_file": {
          "$ref": "#/definitions/core::option::Option<std::path::PathBuf>",
          "_metadata": {
            "docs::examples": "/path/to/certificate_authority.crt",
            "docs::human_name": "CA File Path"
          },
          "description": "The certificate must be in the DER or PEM (X.509) format. Additionally, the certificate can be provided as an inline string in PEM format.",
          "title": "Absolute path to an additional CA certificate file."
        },
        "crt_file": {
          "$ref": "#/definitions/core::option::Option<std::path::PathBuf>",
          "_metadata": {
            "docs::examples": "/path/to/host_certificate.crt",
            "docs::human_name": "Certificate File Path"
          },
          "description": "The certificate must be in DER, PEM (X.509), or PKCS#12 format. Additionally, the certificate can be provided as\nan inline string in PEM format.\n\nIf this is set, and is not a PKCS#12 archive, `key_file` must also be set.",
          "title": "Absolute path to a certificate file used to identify this server."
        },
        "key_file": {
          "$ref": "#/definitions/core::option::Option<std::path::PathBuf>",
          "_metadata": {
            "docs::examples": "/path/to/host_certificate.key",
            "docs::human_name": "Key File Path"
          },
          "description": "The key must be in DER or PEM (PKCS#8) format. Additionally, the key can be provided as an inline string in PEM format.",
          "title": "Absolute path to a private key file used to identify this server."
        },
        "key_pass": {
          "_metadata": {
            "docs::examples": [
              "${KEY_PASS_ENV_VAR}",
              "PassWord1"
            ],
            "docs::human_name": "Key File Password",
            "docs::optional": true
          },
          "description": "This has no effect unless `key_file` is set.",
          "title": "Passphrase used to unlock the encrypted key file.",
          "type": [
            "string",
            "null"
          ]
        },
        "verify_certificate": {
          "_metadata": {
            "docs::human_name": "Verify Certificate",
            "docs::optional": true
          },
          "description": "If enabled, certificates must not be expired and must be issued by a trusted\nissuer. This verification operates in a hierarchical manner, checking that the leaf certificate (the\ncertificate presented by the client/server) is not only valid, but that the issuer of that certificate is also valid, and\nso on until the verification process reaches a root certificate.\n\nRelevant for both incoming and outgoing connections.\n\nDo NOT set this to `false` unless you understand the risks of not verifying the validity of certificates.",
          "title": "Enables certificate verification.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "verify_hostname": {
          "_metadata": {
            "docs::human_name": "Verify Hostname",
            "docs::optional": true
          },
          "description": "If enabled, the hostname used to connect to the remote host must be present in the TLS certificate presented by\nthe remote host, either as the Common Name or as an entry in the Subject Alternative Name extension.\n\nOnly relevant for outgoing connections.\n\nDo NOT set this to `false` unless you understand the risks of not verifying the remote hostname.",
          "title": "Enables hostname verification.",
          "type": [
            "boolean",
            "null"
          ]
        }
      },
      "type": "object"
    },
    "vector_core::tls::settings::TlsEnableableConfig": {
      "_metadata": {
        "docs::advanced": true
      },
      "allOf": [
        {
          "properties": {
            "enabled": {
              "_metadata": {
                "docs::human_name": "Enabled",
                "docs::optional": true
              },
              "description": "When enabled and used for incoming connections, an identity certificate is also required. See `tls.crt_file` for\nmore information.",
              "title": "Whether or not to require TLS for incoming or outgoing connections.",
              "type": [
                "boolean",
                "null"
              ]
            }
          },
          "type": "object"
        },
        {
          "$ref": "#/definitions/vector_core::tls::settings::TlsConfig",
          "description": "TLS configuration."
        }
      ],
      "description": "Configures the TLS options for incoming/outgoing connections."
    },
    "vector_lookup::lookup_v2::ConfigTargetPath": {
      "description": "A wrapper around `OwnedTargetPath` that allows it to be used in Vector config\nwith prefix default to `PathPrefix::Event`",
      "type": "string"
    },
    "vector_lookup::lookup_v2::ConfigValuePath": {
      "description": "A wrapper around `OwnedValuePath` that allows it to be used in Vector config.\nThis requires a valid path to be used. If you want to allow optional paths,\nuse [optional_path::OptionalValuePath].",
      "type": "string"
    },
    "vector_lookup::lookup_v2::optional_path::OptionalTargetPath": {
      "description": "An optional path that deserializes an empty string to `None`.",
      "type": "string"
    },
    "vector_lookup::lookup_v2::optional_path::OptionalValuePath": {
      "description": "An optional path that deserializes an empty string to `None`.",
      "type": "string"
    }
  },
  "description": "A complete Vector configuration.",
  "unevaluatedProperties": false
}

{
  "$schema": "https://json-schema.org/draft/2019-09/schema",
  "description": "A complete Vector configuration.",
  "allOf": [
    {
      "type": "object",
      "properties": {
        "api": {
          "description": "API options.",
          "default": {
            "enabled": false,
            "address": "127.0.0.1:8686",
            "playground": true
          },
          "type": "object",
          "properties": {
            "address": {
              "description": "The socket address to listen on for the API endpoint.",
              "default": "127.0.0.1:8686",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "description": "An internet socket address, either IPv4 or IPv6.",
                  "type": "string"
                }
              ],
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::optional": true,
                "docs::human_name": "Address"
              }
            },
            "enabled": {
              "description": "Whether or not the API endpoint is available.",
              "default": false,
              "type": "boolean",
              "_metadata": {
                "docs::human_name": "Enabled"
              }
            },
            "playground": {
              "description": "Whether or not to expose the GraphQL playground on the API endpoint.",
              "default": true,
              "type": "boolean",
              "_metadata": {
                "docs::human_name": "Playground"
              }
            }
          },
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::human_name": "API"
          }
        },
        "enrichment_tables": {
          "description": "All configured enrichment tables.",
          "default": {},
          "type": "object",
          "additionalProperties": {
            "description": "Fully resolved enrichment table component.",
            "allOf": [
              {
                "description": "Configurable enrichment tables.",
                "oneOf": [
                  {
                    "description": "Exposes data from a static file as an enrichment table.",
                    "allOf": [
                      {
                        "description": "Configuration for the `file` enrichment table.",
                        "$ref": "#/definitions/vector::enrichment_tables::file::FileConfig"
                      },
                      {
                        "type": "object",
                        "required": [
                          "type"
                        ],
                        "properties": {
                          "type": {
                            "description": "Exposes data from a static file as an enrichment table.",
                            "const": "file",
                            "_metadata": {
                              "docs::human_name": "Type"
                            }
                          }
                        }
                      }
                    ],
                    "_metadata": {
                      "logical_name": "File",
                      "docs::human_name": "File"
                    }
                  },
                  {
                    "title": "Exposes data from a [MaxMind][maxmind] [GeoIP2][geoip2] database as an enrichment table.",
                    "description": "[maxmind]: https://www.maxmind.com/\n[geoip2]: https://www.maxmind.com/en/geoip2-databases",
                    "allOf": [
                      {
                        "description": "Configuration for the `geoip` enrichment table.",
                        "$ref": "#/definitions/vector::enrichment_tables::geoip::GeoipConfig"
                      },
                      {
                        "type": "object",
                        "required": [
                          "type"
                        ],
                        "properties": {
                          "type": {
                            "title": "Exposes data from a [MaxMind][maxmind] [GeoIP2][geoip2] database as an enrichment table.",
                            "description": "[maxmind]: https://www.maxmind.com/\n[geoip2]: https://www.maxmind.com/en/geoip2-databases",
                            "const": "geoip",
                            "_metadata": {
                              "docs::human_name": "Type"
                            }
                          }
                        }
                      }
                    ],
                    "_metadata": {
                      "logical_name": "Geoip",
                      "docs::human_name": "GeoIP"
                    }
                  }
                ],
                "_metadata": {
                  "docs::enum_tagging": "internal",
                  "docs::enum_tag_field": "type"
                }
              }
            ],
            "unevaluatedProperties": false
          },
          "_metadata": {
            "docs::human_name": "Enrichment Tables"
          }
        },
        "enterprise": {
          "title": "Enterprise options for using Datadog's [Observability Pipelines][datadog_op].",
          "description": "[datadog_op]: https://www.datadoghq.com/product/observability-pipelines/",
          "default": null,
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "Enterprise options for using Datadog's [Observability Pipelines][datadog_op].",
              "description": "[datadog_op]: https://www.datadoghq.com/product/observability-pipelines/",
              "type": "object",
              "required": [
                "configuration_key"
              ],
              "properties": {
                "api_key": {
                  "title": "The Datadog [API key][api_key] to send data with.",
                  "description": "[api_key]: https://docs.datadoghq.com/api/?lang=bash#authentication",
                  "default": null,
                  "type": [
                    "string",
                    "null"
                  ],
                  "_metadata": {
                    "docs::optional": true,
                    "docs::human_name": "API Key"
                  }
                },
                "application_key": {
                  "title": "The Datadog application key.",
                  "description": "This is deprecated.",
                  "deprecated": true,
                  "type": [
                    "string",
                    "null"
                  ],
                  "_metadata": {
                    "docs::optional": true,
                    "docs::human_name": "Application Key"
                  }
                },
                "configuration_key": {
                  "description": "The configuration key for Observability Pipelines.",
                  "type": "string",
                  "_metadata": {
                    "docs::human_name": "Configuration Key"
                  }
                },
                "enable_logs_reporting": {
                  "description": "Whether or not to report internal component logs to Observability Pipelines.",
                  "default": true,
                  "type": "boolean",
                  "_metadata": {
                    "docs::human_name": "Enable Logs Reporting"
                  }
                },
                "enabled": {
                  "description": "Whether or not Observability Pipelines support is enabled.",
                  "default": true,
                  "type": "boolean",
                  "_metadata": {
                    "docs::human_name": "Enabled"
                  }
                },
                "endpoint": {
                  "title": "The Datadog endpoint to send data to.",
                  "description": "This is an advanced setting that is generally meant only for testing, and overrides both\n`site` and `region`.\n\nYou should prefer to set `site`.",
                  "type": [
                    "string",
                    "null"
                  ],
                  "_metadata": {
                    "docs::optional": true,
                    "docs::human_name": "Endpoint"
                  }
                },
                "max_retries": {
                  "description": "The maximum number of retries to report Vector's configuration to Observability Pipelines at startup.",
                  "default": 4294967295,
                  "type": "integer",
                  "maximum": 4294967295.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::human_name": "Max Retries"
                  }
                },
                "proxy": {
                  "title": "Proxy configuration.",
                  "description": "Configure to proxy traffic through an HTTP(S) proxy when making external requests.\n\nSimilar to common proxy configuration convention, you can set different proxies\nto use based on the type of traffic being proxied, as well as set specific hosts that\nshould not be proxied.",
                  "default": {
                    "enabled": true,
                    "http": null,
                    "https": null
                  },
                  "$ref": "#/definitions/vector_core::config::proxy::ProxyConfig",
                  "_metadata": {
                    "docs::human_name": "Proxy"
                  }
                },
                "region": {
                  "title": "The Datadog region to send data to.",
                  "description": "This option is deprecated, and the `site` field should be used instead.",
                  "deprecated": true,
                  "$ref": "#/definitions/core::option::Option<vector::common::datadog::Region>",
                  "_metadata": {
                    "docs::human_name": "Region"
                  }
                },
                "reporting_interval_secs": {
                  "description": "The amount of time, in seconds, between reporting host metrics to Observability Pipelines.",
                  "default": 1.0,
                  "type": "number",
                  "maximum": 9007199254740991.0,
                  "minimum": -9007199254740991.0,
                  "_metadata": {
                    "docs::numeric_type": "float",
                    "docs::human_name": "Reporting Interval Secs"
                  }
                },
                "site": {
                  "title": "The Datadog [site][dd_site] to send data to.",
                  "description": "[dd_site]: https://docs.datadoghq.com/getting_started/site",
                  "default": "datadoghq.com",
                  "type": "string",
                  "_metadata": {
                    "docs::human_name": "Site"
                  }
                },
                "tags": {
                  "description": "A map of additional tags for metrics sent to Observability Pipelines.",
                  "type": [
                    "object",
                    "null"
                  ],
                  "additionalProperties": {
                    "type": "string"
                  },
                  "_metadata": {
                    "docs::optional": true,
                    "docs::human_name": "Tags"
                  }
                }
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Enterprise"
          }
        },
        "healthchecks": {
          "description": "Healthcheck options.",
          "default": {
            "enabled": true,
            "require_healthy": false
          },
          "type": "object",
          "properties": {
            "enabled": {
              "title": "Whether or not healthchecks are enabled for all sinks.",
              "description": "Can be overridden on a per-sink basis.",
              "type": "boolean",
              "_metadata": {
                "docs::human_name": "Enabled"
              }
            },
            "require_healthy": {
              "title": "Whether or not to require a sink to report as being healthy during startup.",
              "description": "When enabled and a sink reports not being healthy, Vector will exit during start-up.\n\nCan be alternatively set, and overridden by, the `--require-healthy` command-line flag.",
              "type": "boolean",
              "_metadata": {
                "docs::human_name": "Require Healthy"
              }
            }
          },
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::human_name": "Healthchecks"
          }
        },
        "provider": {
          "title": "Optional configuration provider to use.",
          "description": "Configuration providers allow sourcing configuration information from a source other than\nthe typical configuration files that must be passed to Vector.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "description": "Configurable providers in Vector.",
              "oneOf": [
                {
                  "description": "HTTP.",
                  "allOf": [
                    {
                      "description": "Configuration for the `http` provider.",
                      "$ref": "#/definitions/vector::providers::http::HttpConfig"
                    },
                    {
                      "type": "object",
                      "required": [
                        "type"
                      ],
                      "properties": {
                        "type": {
                          "description": "HTTP.",
                          "const": "http",
                          "_metadata": {
                            "docs::human_name": "Type"
                          }
                        }
                      }
                    }
                  ],
                  "_metadata": {
                    "logical_name": "Http",
                    "docs::human_name": "HTTP"
                  }
                }
              ],
              "_metadata": {
                "docs::enum_tagging": "internal",
                "docs::enum_tag_field": "type"
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Provider"
          }
        },
        "schema": {
          "description": "Schema options.",
          "default": {
            "enabled": false,
            "validation": false,
            "log_namespace": null
          },
          "type": "object",
          "properties": {
            "enabled": {
              "description": "Whether or not schema is enabled.",
              "default": false,
              "type": "boolean",
              "_metadata": {
                "docs::human_name": "Enabled"
              }
            },
            "log_namespace": {
              "description": "Whether or not to enable log namespacing.",
              "type": [
                "boolean",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::human_name": "Log Namespace"
              }
            },
            "validation": {
              "description": "Whether or not schema validation is enabled.",
              "default": false,
              "type": "boolean",
              "_metadata": {
                "docs::human_name": "Validation"
              }
            }
          },
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::hidden": true,
            "docs::human_name": "Schema"
          }
        },
        "secret": {
          "description": "All configured secrets backends.",
          "default": {},
          "type": "object",
          "additionalProperties": {
            "description": "Configurable secret backends in Vector.",
            "oneOf": [
              {
                "description": "Exec.",
                "allOf": [
                  {
                    "description": "Configuration for the `exec` secrets backend.",
                    "$ref": "#/definitions/vector::secrets::exec::ExecBackend"
                  },
                  {
                    "type": "object",
                    "required": [
                      "type"
                    ],
                    "properties": {
                      "type": {
                        "description": "Exec.",
                        "const": "exec",
                        "_metadata": {
                          "docs::human_name": "Type"
                        }
                      }
                    }
                  }
                ],
                "_metadata": {
                  "logical_name": "Exec",
                  "docs::human_name": "Exec"
                }
              },
              {
                "description": "Test.",
                "allOf": [
                  {
                    "description": "Configuration for the `test` secrets backend.",
                    "$ref": "#/definitions/vector::secrets::test::TestBackend"
                  },
                  {
                    "type": "object",
                    "required": [
                      "type"
                    ],
                    "properties": {
                      "type": {
                        "description": "Test.",
                        "const": "test",
                        "_metadata": {
                          "docs::human_name": "Type"
                        }
                      }
                    }
                  }
                ],
                "_metadata": {
                  "docs::hidden": true,
                  "logical_name": "Test",
                  "docs::human_name": "Test"
                }
              }
            ],
            "unevaluatedProperties": false,
            "_metadata": {
              "docs::enum_tagging": "internal",
              "docs::enum_tag_field": "type"
            }
          },
          "_metadata": {
            "docs::human_name": "Secret"
          }
        },
        "sinks": {
          "description": "All configured sinks.",
          "default": {},
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/vector::config::sink::SinkOuter<alloc::string::String>"
          },
          "_metadata": {
            "docs::human_name": "Sinks"
          }
        },
        "sources": {
          "description": "All configured sources.",
          "default": {},
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/vector::config::source::SourceOuter"
          },
          "_metadata": {
            "docs::human_name": "Sources"
          }
        },
        "tests": {
          "description": "All configured unit tests.",
          "default": [],
          "type": "array",
          "items": {
            "description": "A unit test definition.",
            "type": "object",
            "required": [
              "name"
            ],
            "properties": {
              "input": {
                "title": "A unit test input.",
                "description": "An input event to test against.",
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "$ref": "#/definitions/vector::config::TestInput"
                  }
                ],
                "unevaluatedProperties": false,
                "_metadata": {
                  "docs::optional": true,
                  "docs::human_name": "Input"
                }
              },
              "inputs": {
                "title": "A unit test input.",
                "description": "A set of input events to test against.",
                "default": [],
                "type": "array",
                "items": {
                  "$ref": "#/definitions/vector::config::TestInput"
                },
                "_metadata": {
                  "docs::human_name": "Inputs"
                }
              },
              "name": {
                "description": "The name of the unit test.",
                "type": "string",
                "_metadata": {
                  "docs::human_name": "Name"
                }
              },
              "no_outputs_from": {
                "description": "A set of component outputs that should not have emitted any events.",
                "default": [],
                "type": "array",
                "items": {
                  "type": "string"
                },
                "_metadata": {
                  "docs::human_name": "No Outputs From"
                }
              },
              "outputs": {
                "title": "A unit test output.",
                "description": "A set of expected output events after the test has run.",
                "default": [],
                "type": "array",
                "items": {
                  "title": "A unit test output.",
                  "description": "An output describes what we expect a transform to emit when fed a certain event, or events, when\nrunning a unit test.",
                  "type": "object",
                  "required": [
                    "extract_from"
                  ],
                  "properties": {
                    "conditions": {
                      "description": "The conditions to run against the output to validate that they were transformed as expected.",
                      "type": [
                        "array",
                        "null"
                      ],
                      "items": {
                        "$ref": "#/definitions/vector::conditions::AnyCondition"
                      },
                      "_metadata": {
                        "docs::type_override": "condition",
                        "docs::enum_tagging": "untagged",
                        "docs::optional": true,
                        "docs::human_name": "Conditions"
                      }
                    },
                    "extract_from": {
                      "description": "The transform outputs to extract events from.",
                      "oneOf": [
                        {
                          "type": "string",
                          "_metadata": {
                            "logical_name": "One",
                            "docs::human_name": "One"
                          }
                        },
                        {
                          "type": "array",
                          "items": {
                            "type": "string"
                          },
                          "_metadata": {
                            "logical_name": "Many",
                            "docs::human_name": "Many"
                          }
                        }
                      ],
                      "unevaluatedProperties": false,
                      "_metadata": {
                        "docs::enum_tagging": "untagged",
                        "docs::human_name": "Extract From"
                      }
                    }
                  },
                  "unevaluatedProperties": false
                },
                "_metadata": {
                  "docs::human_name": "Outputs"
                }
              }
            },
            "unevaluatedProperties": false
          },
          "_metadata": {
            "docs::human_name": "Tests"
          }
        },
        "transforms": {
          "description": "All configured transforms.",
          "default": {},
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/vector::config::transform::TransformOuter<alloc::string::String>"
          },
          "_metadata": {
            "docs::human_name": "Transforms"
          }
        }
      }
    },
    {
      "description": "Global configuration options.",
      "type": "object",
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled for all sinks by default.",
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how Vector handles event\nacknowledgement.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "data_dir": {
          "title": "The directory used for persisting Vector state data.",
          "description": "This is the directory where Vector will store any state data, such as disk buffers, file\ncheckpoints, and more.\n\nVector must have write permissions to this directory.",
          "default": "/var/lib/vector/",
          "$ref": "#/definitions/core::option::Option<std::path::PathBuf>",
          "_metadata": {
            "docs::human_name": "Data Directory"
          }
        },
        "expire_metrics": {
          "title": "The amount of time, in seconds, that internal metrics will persist after having not been\nupdated before they expire and are removed.",
          "description": "Not set by default, which allows all internal metrics to grow unbounded over time. If you\nhave a configuration that emits many high-cardinality metrics, you may want to consider\nsetting this to a value that ensures that metrics live long enough to be emitted and\ncaptured, but not so long that they continue to build up indefinitely, as this will consume\na small amount of memory for each metric.",
          "default": null,
          "deprecated": true,
          "oneOf": [
            {
              "type": "null"
            },
            {
              "description": "An duration of time.",
              "type": "object",
              "required": [
                "nsecs",
                "secs"
              ],
              "properties": {
                "nsecs": {
                  "type": "integer",
                  "maximum": 4294967295.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::human_name": "Nsecs"
                  }
                },
                "secs": {
                  "type": "integer",
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::human_name": "Secs"
                  }
                }
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Expire Metrics"
          }
        },
        "expire_metrics_secs": {
          "title": "The amount of time, in seconds, that internal metrics will persist after having not been\nupdated before they expire and are removed.",
          "description": "Not set by default, which allows all internal metrics to grow unbounded over time. If you\nhave a configuration that emits many high-cardinality metrics, you may want to consider\nsetting this to a value that ensures that metrics live long enough to be emitted and\ncaptured, but not so long that they continue to build up indefinitely, as this will consume\na small amount of memory for each metric.",
          "default": null,
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0,
          "_metadata": {
            "docs::numeric_type": "float",
            "docs::optional": true,
            "docs::human_name": "Expire Metrics Secs"
          }
        },
        "log_schema": {
          "title": "Default log schema for all events.",
          "description": "This is used if a component does not have its own specific log schema. All events use a log\nschema, whether or not the default is used, to assign event fields on incoming events.",
          "default": {
            "message_key": ".message",
            "timestamp_key": ".timestamp",
            "host_key": ".host",
            "source_type_key": ".source_type",
            "metadata_key": ".metadata"
          },
          "type": "object",
          "properties": {
            "host_key": {
              "title": "The name of the event field to treat as the host which sent the message.",
              "description": "This field will generally represent a real host, or container, that generated the message,\nbut is somewhat source-dependent.",
              "default": ".host",
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalTargetPath",
              "_metadata": {
                "docs::human_name": "Host Key"
              }
            },
            "message_key": {
              "title": "The name of the event field to treat as the event message.",
              "description": "This would be the field that holds the raw message, such as a raw log line.",
              "default": ".message",
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalTargetPath",
              "_metadata": {
                "docs::human_name": "Message Key"
              }
            },
            "metadata_key": {
              "title": "The name of the event field to set the event metadata in.",
              "description": "Generally, this field will be set by Vector to hold event-specific metadata, such as\nannotations by the `remap` transform when an error or abort is encountered.",
              "default": ".metadata",
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalTargetPath",
              "_metadata": {
                "docs::human_name": "Metadata Key"
              }
            },
            "source_type_key": {
              "title": "The name of the event field to set the source identifier in.",
              "description": "This field will be set by the Vector source that the event was created in.",
              "default": ".source_type",
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalTargetPath",
              "_metadata": {
                "docs::human_name": "Source Type Key"
              }
            },
            "timestamp_key": {
              "description": "The name of the event field to treat as the event timestamp.",
              "default": ".timestamp",
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalTargetPath",
              "_metadata": {
                "docs::human_name": "Timestamp Key"
              }
            }
          },
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::human_name": "Log Schema"
          }
        },
        "proxy": {
          "title": "Proxy configuration.",
          "description": "Configure to proxy traffic through an HTTP(S) proxy when making external requests.\n\nSimilar to common proxy configuration convention, you can set different proxies\nto use based on the type of traffic being proxied, as well as set specific hosts that\nshould not be proxied.",
          "default": {
            "enabled": true,
            "http": null,
            "https": null
          },
          "$ref": "#/definitions/vector_core::config::proxy::ProxyConfig",
          "_metadata": {
            "docs::human_name": "Proxy"
          }
        },
        "telemetry": {
          "title": "Telemetry options.",
          "description": "Determines whether `source` and `service` tags should be emitted with the\n`component_sent_*` and `component_received_*` events.",
          "default": {
            "tags": {
              "emit_service": false,
              "emit_source": false
            }
          },
          "type": "object",
          "properties": {
            "tags": {
              "description": "Configures whether to emit certain tags",
              "default": {
                "emit_service": false,
                "emit_source": false
              },
              "type": "object",
              "properties": {
                "emit_service": {
                  "description": "True if the `service` tag should be emitted\nin the `component_received_*` and `component_sent_*`\ntelemetry.",
                  "type": "boolean",
                  "_metadata": {
                    "docs::human_name": "Emit Service"
                  }
                },
                "emit_source": {
                  "description": "True if the `source` tag should be emitted\nin the `component_received_*` and `component_sent_*`\ntelemetry.",
                  "type": "boolean",
                  "_metadata": {
                    "docs::human_name": "Emit Source"
                  }
                }
              },
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::human_name": "Tags"
              }
            }
          },
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::human_name": "Telemetry"
          }
        },
        "timezone": {
          "title": "The name of the time zone to apply to timestamp conversions that do not contain an explicit time zone.",
          "description": "The time zone name may be any name in the [TZ database][tzdb] or `local` to indicate system\nlocal time.\n\n[tzdb]: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones",
          "default": null,
          "$ref": "#/definitions/core::option::Option<vrl::compiler::datetime::TimeZone>",
          "_metadata": {
            "docs::human_name": "Timezone"
          }
        }
      }
    }
  ],
  "unevaluatedProperties": false,
  "definitions": {
    "codecs::MetricTagValues": {
      "description": "The user configuration to choose the metric tag strategy.",
      "oneOf": [
        {
          "description": "Tag values are exposed as single strings, the same as they were before this config\noption. Tags with multiple values show the last assigned value, and null values\nare ignored.",
          "const": "single",
          "_metadata": {
            "logical_name": "Single",
            "docs::human_name": "Single"
          }
        },
        {
          "description": "All tags are exposed as arrays of either string or null values.",
          "const": "full",
          "_metadata": {
            "logical_name": "Full",
            "docs::human_name": "Full"
          }
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::enum_tagging": "external"
      }
    },
    "codecs::decoding::DeserializerConfig": {
      "description": "Configures how events are decoded from raw bytes.",
      "oneOf": [
        {
          "description": "Uses the raw bytes as-is.",
          "type": "object",
          "required": [
            "codec"
          ],
          "properties": {
            "codec": {
              "description": "Uses the raw bytes as-is.",
              "const": "bytes",
              "_metadata": {
                "docs::human_name": "Codec"
              }
            }
          },
          "_metadata": {
            "logical_name": "Bytes",
            "docs::human_name": "Bytes"
          }
        },
        {
          "title": "Decodes the raw bytes as [JSON][json].",
          "description": "[json]: https://www.json.org/",
          "allOf": [
            {
              "description": "Config used to build a `JsonDeserializer`.",
              "type": "object",
              "properties": {
                "json": {
                  "description": "JSON-specific decoding options.",
                  "default": {
                    "lossy": true
                  },
                  "type": "object",
                  "properties": {
                    "lossy": {
                      "title": "Determines whether or not to replace invalid UTF-8 sequences instead of failing.",
                      "description": "When true, invalid UTF-8 sequences are replaced with the [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD].\n\n[U+FFFD]: https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character",
                      "default": true,
                      "type": "boolean",
                      "_metadata": {
                        "docs::human_name": "Lossy"
                      }
                    }
                  },
                  "unevaluatedProperties": false,
                  "_metadata": {
                    "docs::human_name": "JSON"
                  }
                }
              }
            },
            {
              "type": "object",
              "required": [
                "codec"
              ],
              "properties": {
                "codec": {
                  "title": "Decodes the raw bytes as [JSON][json].",
                  "description": "[json]: https://www.json.org/",
                  "const": "json",
                  "_metadata": {
                    "docs::human_name": "Codec"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Json",
            "docs::human_name": "JSON"
          }
        },
        {
          "title": "Decodes the raw bytes as [protobuf][protobuf].",
          "description": "[protobuf]: https://protobuf.dev/",
          "allOf": [
            {
              "description": "Config used to build a `ProtobufDeserializer`.",
              "type": "object",
              "properties": {
                "protobuf": {
                  "description": "Protobuf-specific decoding options.",
                  "default": {
                    "desc_file": "",
                    "message_type": ""
                  },
                  "type": "object",
                  "required": [
                    "desc_file",
                    "message_type"
                  ],
                  "properties": {
                    "desc_file": {
                      "description": "Path to desc file",
                      "$ref": "#/definitions/stdlib::PathBuf",
                      "_metadata": {
                        "docs::human_name": "Desc File"
                      }
                    },
                    "message_type": {
                      "description": "message type. e.g package.message",
                      "type": "string",
                      "_metadata": {
                        "docs::human_name": "Message Type"
                      }
                    }
                  },
                  "unevaluatedProperties": false,
                  "_metadata": {
                    "docs::human_name": "Protobuf"
                  }
                }
              }
            },
            {
              "type": "object",
              "required": [
                "codec"
              ],
              "properties": {
                "codec": {
                  "title": "Decodes the raw bytes as [protobuf][protobuf].",
                  "description": "[protobuf]: https://protobuf.dev/",
                  "const": "protobuf",
                  "_metadata": {
                    "docs::human_name": "Codec"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Protobuf",
            "docs::human_name": "Protobuf"
          }
        },
        {
          "title": "Decodes the raw bytes as a Syslog message.",
          "description": "Decodes either as the [RFC 3164][rfc3164]-style format (\"old\" style) or the\n[RFC 5424][rfc5424]-style format (\"new\" style, includes structured data).\n\n[rfc3164]: https://www.ietf.org/rfc/rfc3164.txt\n[rfc5424]: https://www.ietf.org/rfc/rfc5424.txt",
          "allOf": [
            {
              "description": "Config used to build a `SyslogDeserializer`.",
              "type": "object",
              "properties": {
                "syslog": {
                  "description": "Syslog-specific decoding options.",
                  "default": {
                    "lossy": true
                  },
                  "type": "object",
                  "properties": {
                    "lossy": {
                      "title": "Determines whether or not to replace invalid UTF-8 sequences instead of failing.",
                      "description": "When true, invalid UTF-8 sequences are replaced with the [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD].\n\n[U+FFFD]: https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character",
                      "default": true,
                      "type": "boolean",
                      "_metadata": {
                        "docs::human_name": "Lossy"
                      }
                    }
                  },
                  "unevaluatedProperties": false,
                  "_metadata": {
                    "docs::human_name": "Syslog"
                  }
                }
              }
            },
            {
              "type": "object",
              "required": [
                "codec"
              ],
              "properties": {
                "codec": {
                  "title": "Decodes the raw bytes as a Syslog message.",
                  "description": "Decodes either as the [RFC 3164][rfc3164]-style format (\"old\" style) or the\n[RFC 5424][rfc5424]-style format (\"new\" style, includes structured data).\n\n[rfc3164]: https://www.ietf.org/rfc/rfc3164.txt\n[rfc5424]: https://www.ietf.org/rfc/rfc5424.txt",
                  "const": "syslog",
                  "_metadata": {
                    "docs::human_name": "Codec"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Syslog",
            "docs::human_name": "Syslog"
          }
        },
        {
          "title": "Decodes the raw bytes as Vector’s [native Protocol Buffers format][vector_native_protobuf].",
          "description": "This codec is **[experimental][experimental]**.\n\n[vector_native_protobuf]: https://github.com/vectordotdev/vector/blob/master/lib/vector-core/proto/event.proto\n[experimental]: https://vector.dev/highlights/2022-03-31-native-event-codecs",
          "type": "object",
          "required": [
            "codec"
          ],
          "properties": {
            "codec": {
              "title": "Decodes the raw bytes as Vector’s [native Protocol Buffers format][vector_native_protobuf].",
              "description": "This codec is **[experimental][experimental]**.\n\n[vector_native_protobuf]: https://github.com/vectordotdev/vector/blob/master/lib/vector-core/proto/event.proto\n[experimental]: https://vector.dev/highlights/2022-03-31-native-event-codecs",
              "const": "native",
              "_metadata": {
                "docs::human_name": "Codec"
              }
            }
          },
          "_metadata": {
            "logical_name": "Native",
            "docs::human_name": "Native"
          }
        },
        {
          "title": "Decodes the raw bytes as Vector’s [native JSON format][vector_native_json].",
          "description": "This codec is **[experimental][experimental]**.\n\n[vector_native_json]: https://github.com/vectordotdev/vector/blob/master/lib/codecs/tests/data/native_encoding/schema.cue\n[experimental]: https://vector.dev/highlights/2022-03-31-native-event-codecs",
          "allOf": [
            {
              "description": "Config used to build a `NativeJsonDeserializer`.",
              "type": "object",
              "properties": {
                "native_json": {
                  "description": "Vector's native JSON-specific decoding options.",
                  "default": {
                    "lossy": true
                  },
                  "type": "object",
                  "properties": {
                    "lossy": {
                      "title": "Determines whether or not to replace invalid UTF-8 sequences instead of failing.",
                      "description": "When true, invalid UTF-8 sequences are replaced with the [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD].\n\n[U+FFFD]: https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character",
                      "default": true,
                      "type": "boolean",
                      "_metadata": {
                        "docs::human_name": "Lossy"
                      }
                    }
                  },
                  "unevaluatedProperties": false,
                  "_metadata": {
                    "docs::human_name": "Native JSON"
                  }
                }
              }
            },
            {
              "type": "object",
              "required": [
                "codec"
              ],
              "properties": {
                "codec": {
                  "title": "Decodes the raw bytes as Vector’s [native JSON format][vector_native_json].",
                  "description": "This codec is **[experimental][experimental]**.\n\n[vector_native_json]: https://github.com/vectordotdev/vector/blob/master/lib/codecs/tests/data/native_encoding/schema.cue\n[experimental]: https://vector.dev/highlights/2022-03-31-native-event-codecs",
                  "const": "native_json",
                  "_metadata": {
                    "docs::human_name": "Codec"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "NativeJson",
            "docs::human_name": "Native JSON"
          }
        },
        {
          "title": "Decodes the raw bytes as a [GELF][gelf] message.",
          "description": "[gelf]: https://docs.graylog.org/docs/gelf",
          "allOf": [
            {
              "description": "On GELF decoding behavior:\n  Graylog has a relaxed decoding. They are much more lenient than the spec would\n  suggest. We've elected to take a more strict approach to maintain backwards compatability\n  in the event that we need to change the behavior to be more relaxed, so that prior versions\n  of vector will still work with the new relaxed decoding.\nConfig used to build a `GelfDeserializer`.",
              "type": "object",
              "properties": {
                "gelf": {
                  "description": "GELF-specific decoding options.",
                  "default": {
                    "lossy": true
                  },
                  "type": "object",
                  "properties": {
                    "lossy": {
                      "title": "Determines whether or not to replace invalid UTF-8 sequences instead of failing.",
                      "description": "When true, invalid UTF-8 sequences are replaced with the [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD].\n\n[U+FFFD]: https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character",
                      "default": true,
                      "type": "boolean",
                      "_metadata": {
                        "docs::human_name": "Lossy"
                      }
                    }
                  },
                  "unevaluatedProperties": false,
                  "_metadata": {
                    "docs::human_name": "GELF"
                  }
                }
              }
            },
            {
              "type": "object",
              "required": [
                "codec"
              ],
              "properties": {
                "codec": {
                  "title": "Decodes the raw bytes as a [GELF][gelf] message.",
                  "description": "[gelf]: https://docs.graylog.org/docs/gelf",
                  "const": "gelf",
                  "_metadata": {
                    "docs::human_name": "Codec"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Gelf",
            "docs::human_name": "GELF"
          }
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::enum_tag_description": "The codec to use for decoding events.",
        "docs::enum_tagging": "internal",
        "docs::enum_tag_field": "codec"
      }
    },
    "codecs::decoding::FramingConfig": {
      "title": "Framing configuration.",
      "description": "Framing handles how events are separated when encoded in a raw byte form, where each event is\na frame that must be prefixed, or delimited, in a way that marks where an event begins and\nends within the byte stream.",
      "oneOf": [
        {
          "description": "Byte frames are passed through as-is according to the underlying I/O boundaries (for example, split between messages or stream segments).",
          "type": "object",
          "required": [
            "method"
          ],
          "properties": {
            "method": {
              "description": "Byte frames are passed through as-is according to the underlying I/O boundaries (for example, split between messages or stream segments).",
              "const": "bytes",
              "_metadata": {
                "docs::human_name": "Method"
              }
            }
          },
          "_metadata": {
            "logical_name": "Bytes",
            "docs::human_name": "Bytes"
          }
        },
        {
          "description": "Byte frames which are delimited by a chosen character.",
          "allOf": [
            {
              "description": "Config used to build a `CharacterDelimitedDecoder`.",
              "type": "object",
              "required": [
                "character_delimited"
              ],
              "properties": {
                "character_delimited": {
                  "description": "Options for the character delimited decoder.",
                  "type": "object",
                  "required": [
                    "delimiter"
                  ],
                  "properties": {
                    "delimiter": {
                      "description": "The character that delimits byte sequences.",
                      "type": "integer",
                      "maximum": 255.0,
                      "minimum": 0.0,
                      "_metadata": {
                        "docs::numeric_type": "uint",
                        "docs::human_name": "Delimiter"
                      }
                    },
                    "max_length": {
                      "title": "The maximum length of the byte buffer.",
                      "description": "This length does *not* include the trailing delimiter.\n\nBy default, there is no maximum length enforced. If events are malformed, this can lead to\nadditional resource usage as events continue to be buffered in memory, and can potentially\nlead to memory exhaustion in extreme cases.\n\nIf there is a risk of processing malformed data, such as logs with user-controlled input,\nconsider setting the maximum length to a reasonably large value as a safety net. This\nensures that processing is not actually unbounded.",
                      "type": [
                        "integer",
                        "null"
                      ],
                      "maximum": 9007199254740991.0,
                      "minimum": 0.0,
                      "_metadata": {
                        "docs::numeric_type": "uint",
                        "docs::optional": true,
                        "docs::human_name": "Max Length"
                      }
                    }
                  },
                  "unevaluatedProperties": false,
                  "_metadata": {
                    "docs::human_name": "Character Delimited"
                  }
                }
              }
            },
            {
              "type": "object",
              "required": [
                "method"
              ],
              "properties": {
                "method": {
                  "description": "Byte frames which are delimited by a chosen character.",
                  "const": "character_delimited",
                  "_metadata": {
                    "docs::human_name": "Method"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "CharacterDelimited",
            "docs::human_name": "Character Delimited"
          }
        },
        {
          "description": "Byte frames which are prefixed by an unsigned big-endian 32-bit integer indicating the length.",
          "type": "object",
          "required": [
            "method"
          ],
          "properties": {
            "method": {
              "description": "Byte frames which are prefixed by an unsigned big-endian 32-bit integer indicating the length.",
              "const": "length_delimited",
              "_metadata": {
                "docs::human_name": "Method"
              }
            }
          },
          "_metadata": {
            "logical_name": "LengthDelimited",
            "docs::human_name": "Length Delimited"
          }
        },
        {
          "description": "Byte frames which are delimited by a newline character.",
          "allOf": [
            {
              "description": "Config used to build a `NewlineDelimitedDecoder`.",
              "type": "object",
              "properties": {
                "newline_delimited": {
                  "description": "Options for the newline delimited decoder.",
                  "default": {},
                  "type": "object",
                  "properties": {
                    "max_length": {
                      "title": "The maximum length of the byte buffer.",
                      "description": "This length does *not* include the trailing delimiter.\n\nBy default, there is no maximum length enforced. If events are malformed, this can lead to\nadditional resource usage as events continue to be buffered in memory, and can potentially\nlead to memory exhaustion in extreme cases.\n\nIf there is a risk of processing malformed data, such as logs with user-controlled input,\nconsider setting the maximum length to a reasonably large value as a safety net. This\nensures that processing is not actually unbounded.",
                      "type": [
                        "integer",
                        "null"
                      ],
                      "maximum": 9007199254740991.0,
                      "minimum": 0.0,
                      "_metadata": {
                        "docs::numeric_type": "uint",
                        "docs::optional": true,
                        "docs::human_name": "Max Length"
                      }
                    }
                  },
                  "unevaluatedProperties": false,
                  "_metadata": {
                    "docs::human_name": "Newline Delimited"
                  }
                }
              }
            },
            {
              "type": "object",
              "required": [
                "method"
              ],
              "properties": {
                "method": {
                  "description": "Byte frames which are delimited by a newline character.",
                  "const": "newline_delimited",
                  "_metadata": {
                    "docs::human_name": "Method"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "NewlineDelimited",
            "docs::human_name": "Newline Delimited"
          }
        },
        {
          "title": "Byte frames according to the [octet counting][octet_counting] format.",
          "description": "[octet_counting]: https://tools.ietf.org/html/rfc6587#section-3.4.1",
          "allOf": [
            {
              "description": "Config used to build a `OctetCountingDecoder`.",
              "type": "object",
              "properties": {
                "octet_counting": {
                  "description": "Options for the octet counting decoder.",
                  "default": {},
                  "type": "object",
                  "properties": {
                    "max_length": {
                      "description": "The maximum length of the byte buffer.",
                      "type": [
                        "integer",
                        "null"
                      ],
                      "maximum": 9007199254740991.0,
                      "minimum": 0.0,
                      "_metadata": {
                        "docs::numeric_type": "uint",
                        "docs::optional": true,
                        "docs::human_name": "Max Length"
                      }
                    }
                  },
                  "unevaluatedProperties": false,
                  "_metadata": {
                    "docs::human_name": "Octet Counting"
                  }
                }
              }
            },
            {
              "type": "object",
              "required": [
                "method"
              ],
              "properties": {
                "method": {
                  "title": "Byte frames according to the [octet counting][octet_counting] format.",
                  "description": "[octet_counting]: https://tools.ietf.org/html/rfc6587#section-3.4.1",
                  "const": "octet_counting",
                  "_metadata": {
                    "docs::human_name": "Method"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "OctetCounting",
            "docs::human_name": "Octet Counting"
          }
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::enum_tag_description": "The framing method.",
        "docs::enum_tagging": "internal",
        "docs::enum_tag_field": "method"
      }
    },
    "codecs::encoding::format::csv::CsvSerializerConfig": {
      "description": "Config used to build a `CsvSerializer`.",
      "type": "object",
      "required": [
        "csv"
      ],
      "properties": {
        "csv": {
          "description": "The CSV Serializer Options.",
          "type": "object",
          "required": [
            "fields"
          ],
          "properties": {
            "fields": {
              "title": "Configures the fields that will be encoded, as well as the order in which they\nappear in the output.",
              "description": "If a field is not present in the event, the output will be an empty string.\n\nValues of type `Array`, `Object`, and `Regex` are not supported and the\noutput will be an empty string.",
              "type": "array",
              "items": {
                "$ref": "#/definitions/vector_lookup::lookup_v2::ConfigTargetPath"
              },
              "_metadata": {
                "docs::human_name": "Fields"
              }
            }
          },
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::human_name": "CSV"
          }
        }
      }
    },
    "codecs::encoding::format::json::JsonSerializerConfig": {
      "description": "Config used to build a `JsonSerializer`.",
      "type": "object",
      "properties": {
        "metric_tag_values": {
          "title": "Controls how metric tag values are encoded.",
          "description": "When set to `single`, only the last non-bare value of tags are displayed with the\nmetric.  When set to `full`, all metric tags are exposed as separate assignments.",
          "default": "single",
          "$ref": "#/definitions/codecs::MetricTagValues",
          "_metadata": {
            "docs::human_name": "Metric Tag Values"
          }
        }
      }
    },
    "core::option::Option<codecs::decoding::FramingConfig>": {
      "title": "Framing configuration.",
      "description": "Framing handles how events are separated when encoded in a raw byte form, where each event is\na frame that must be prefixed, or delimited, in a way that marks where an event begins and\nends within the byte stream.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "title": "Framing configuration.",
          "description": "Framing handles how events are separated when encoded in a raw byte form, where each event is\na frame that must be prefixed, or delimited, in a way that marks where an event begins and\nends within the byte stream.",
          "oneOf": [
            {
              "description": "Byte frames are passed through as-is according to the underlying I/O boundaries (for example, split between messages or stream segments).",
              "type": "object",
              "required": [
                "method"
              ],
              "properties": {
                "method": {
                  "description": "Byte frames are passed through as-is according to the underlying I/O boundaries (for example, split between messages or stream segments).",
                  "const": "bytes",
                  "_metadata": {
                    "docs::human_name": "Method"
                  }
                }
              },
              "_metadata": {
                "logical_name": "Bytes",
                "docs::human_name": "Bytes"
              }
            },
            {
              "description": "Byte frames which are delimited by a chosen character.",
              "allOf": [
                {
                  "description": "Config used to build a `CharacterDelimitedDecoder`.",
                  "type": "object",
                  "required": [
                    "character_delimited"
                  ],
                  "properties": {
                    "character_delimited": {
                      "description": "Options for the character delimited decoder.",
                      "type": "object",
                      "required": [
                        "delimiter"
                      ],
                      "properties": {
                        "delimiter": {
                          "description": "The character that delimits byte sequences.",
                          "type": "integer",
                          "maximum": 255.0,
                          "minimum": 0.0,
                          "_metadata": {
                            "docs::numeric_type": "uint",
                            "docs::human_name": "Delimiter"
                          }
                        },
                        "max_length": {
                          "title": "The maximum length of the byte buffer.",
                          "description": "This length does *not* include the trailing delimiter.\n\nBy default, there is no maximum length enforced. If events are malformed, this can lead to\nadditional resource usage as events continue to be buffered in memory, and can potentially\nlead to memory exhaustion in extreme cases.\n\nIf there is a risk of processing malformed data, such as logs with user-controlled input,\nconsider setting the maximum length to a reasonably large value as a safety net. This\nensures that processing is not actually unbounded.",
                          "type": [
                            "integer",
                            "null"
                          ],
                          "maximum": 9007199254740991.0,
                          "minimum": 0.0,
                          "_metadata": {
                            "docs::numeric_type": "uint",
                            "docs::optional": true,
                            "docs::human_name": "Max Length"
                          }
                        }
                      },
                      "unevaluatedProperties": false,
                      "_metadata": {
                        "docs::human_name": "Character Delimited"
                      }
                    }
                  }
                },
                {
                  "type": "object",
                  "required": [
                    "method"
                  ],
                  "properties": {
                    "method": {
                      "description": "Byte frames which are delimited by a chosen character.",
                      "const": "character_delimited",
                      "_metadata": {
                        "docs::human_name": "Method"
                      }
                    }
                  }
                }
              ],
              "_metadata": {
                "logical_name": "CharacterDelimited",
                "docs::human_name": "Character Delimited"
              }
            },
            {
              "description": "Byte frames which are prefixed by an unsigned big-endian 32-bit integer indicating the length.",
              "type": "object",
              "required": [
                "method"
              ],
              "properties": {
                "method": {
                  "description": "Byte frames which are prefixed by an unsigned big-endian 32-bit integer indicating the length.",
                  "const": "length_delimited",
                  "_metadata": {
                    "docs::human_name": "Method"
                  }
                }
              },
              "_metadata": {
                "logical_name": "LengthDelimited",
                "docs::human_name": "Length Delimited"
              }
            },
            {
              "description": "Byte frames which are delimited by a newline character.",
              "allOf": [
                {
                  "description": "Config used to build a `NewlineDelimitedDecoder`.",
                  "type": "object",
                  "properties": {
                    "newline_delimited": {
                      "description": "Options for the newline delimited decoder.",
                      "default": {},
                      "type": "object",
                      "properties": {
                        "max_length": {
                          "title": "The maximum length of the byte buffer.",
                          "description": "This length does *not* include the trailing delimiter.\n\nBy default, there is no maximum length enforced. If events are malformed, this can lead to\nadditional resource usage as events continue to be buffered in memory, and can potentially\nlead to memory exhaustion in extreme cases.\n\nIf there is a risk of processing malformed data, such as logs with user-controlled input,\nconsider setting the maximum length to a reasonably large value as a safety net. This\nensures that processing is not actually unbounded.",
                          "type": [
                            "integer",
                            "null"
                          ],
                          "maximum": 9007199254740991.0,
                          "minimum": 0.0,
                          "_metadata": {
                            "docs::numeric_type": "uint",
                            "docs::optional": true,
                            "docs::human_name": "Max Length"
                          }
                        }
                      },
                      "unevaluatedProperties": false,
                      "_metadata": {
                        "docs::human_name": "Newline Delimited"
                      }
                    }
                  }
                },
                {
                  "type": "object",
                  "required": [
                    "method"
                  ],
                  "properties": {
                    "method": {
                      "description": "Byte frames which are delimited by a newline character.",
                      "const": "newline_delimited",
                      "_metadata": {
                        "docs::human_name": "Method"
                      }
                    }
                  }
                }
              ],
              "_metadata": {
                "logical_name": "NewlineDelimited",
                "docs::human_name": "Newline Delimited"
              }
            },
            {
              "title": "Byte frames according to the [octet counting][octet_counting] format.",
              "description": "[octet_counting]: https://tools.ietf.org/html/rfc6587#section-3.4.1",
              "allOf": [
                {
                  "description": "Config used to build a `OctetCountingDecoder`.",
                  "type": "object",
                  "properties": {
                    "octet_counting": {
                      "description": "Options for the octet counting decoder.",
                      "default": {},
                      "type": "object",
                      "properties": {
                        "max_length": {
                          "description": "The maximum length of the byte buffer.",
                          "type": [
                            "integer",
                            "null"
                          ],
                          "maximum": 9007199254740991.0,
                          "minimum": 0.0,
                          "_metadata": {
                            "docs::numeric_type": "uint",
                            "docs::optional": true,
                            "docs::human_name": "Max Length"
                          }
                        }
                      },
                      "unevaluatedProperties": false,
                      "_metadata": {
                        "docs::human_name": "Octet Counting"
                      }
                    }
                  }
                },
                {
                  "type": "object",
                  "required": [
                    "method"
                  ],
                  "properties": {
                    "method": {
                      "title": "Byte frames according to the [octet counting][octet_counting] format.",
                      "description": "[octet_counting]: https://tools.ietf.org/html/rfc6587#section-3.4.1",
                      "const": "octet_counting",
                      "_metadata": {
                        "docs::human_name": "Method"
                      }
                    }
                  }
                }
              ],
              "_metadata": {
                "logical_name": "OctetCounting",
                "docs::human_name": "Octet Counting"
              }
            }
          ],
          "_metadata": {
            "docs::enum_tag_description": "The framing method.",
            "docs::enum_tagging": "internal",
            "docs::enum_tag_field": "method"
          }
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::optional": true
      }
    },
    "core::option::Option<std::path::PathBuf>": {
      "description": "A file path.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "$ref": "#/definitions/stdlib::PathBuf"
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::optional": true
      }
    },
    "core::option::Option<vector::aws::region::RegionOrEndpoint>": {
      "description": "Configuration of the region/endpoint to use when interacting with an AWS service.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "$ref": "#/definitions/vector::aws::region::RegionOrEndpoint"
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::optional": true
      }
    },
    "core::option::Option<vector::common::datadog::Region>": {
      "description": "A Datadog region.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "description": "A Datadog region.",
          "oneOf": [
            {
              "description": "US region.",
              "const": "us",
              "_metadata": {
                "logical_name": "Us",
                "docs::human_name": "US"
              }
            },
            {
              "description": "EU region.",
              "const": "eu",
              "_metadata": {
                "logical_name": "Eu",
                "docs::human_name": "EU"
              }
            }
          ],
          "_metadata": {
            "docs::enum_tagging": "external"
          }
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::optional": true
      }
    },
    "core::option::Option<vector::conditions::AnyCondition>": {
      "title": "An event matching condition.",
      "description": "Many methods exist for matching events, such as using a VRL expression, a Datadog Search query string,\nor hard-coded matchers like \"must be a metric\" or \"fields A, B, and C must match these constraints\".\n\nAs VRL is the most common way to apply conditions to events, this type provides a shortcut to define VRL expressions\ndirectly in the configuration by passing the VRL expression as a string:\n\n```toml\ncondition = '.message == \"hooray\"'\n```\n\nWhen other condition types are required, they can be specified with an enum-style notation:\n\n```toml\ncondition.type = 'datadog_search'\ncondition.source = 'NOT \"foo\"'\n```",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "title": "An event matching condition.",
          "description": "Many methods exist for matching events, such as using a VRL expression, a Datadog Search query string,\nor hard-coded matchers like \"must be a metric\" or \"fields A, B, and C must match these constraints\".\n\nAs VRL is the most common way to apply conditions to events, this type provides a shortcut to define VRL expressions\ndirectly in the configuration by passing the VRL expression as a string:\n\n```toml\ncondition = '.message == \"hooray\"'\n```\n\nWhen other condition types are required, they can be specified with an enum-style notation:\n\n```toml\ncondition.type = 'datadog_search'\ncondition.source = 'NOT \"foo\"'\n```",
          "oneOf": [
            {
              "description": "A [Vector Remap Language](https://vector.dev/docs/reference/vrl) (VRL) [boolean expression](https://vector.dev/docs/reference/vrl#boolean-expressions).",
              "type": "string",
              "_metadata": {
                "logical_name": "String",
                "docs::human_name": "String"
              }
            },
            {
              "title": "An event matching condition.",
              "description": "A fully-specified condition.",
              "oneOf": [
                {
                  "description": "Matches an event if it is a log.",
                  "type": "object",
                  "required": [
                    "type"
                  ],
                  "properties": {
                    "type": {
                      "description": "Matches an event if it is a log.",
                      "const": "is_log",
                      "_metadata": {
                        "docs::human_name": "Type"
                      }
                    }
                  },
                  "_metadata": {
                    "docs::hidden": true,
                    "logical_name": "IsLog",
                    "docs::human_name": "Is Log"
                  }
                },
                {
                  "description": "Matches an event if it is a metric.",
                  "type": "object",
                  "required": [
                    "type"
                  ],
                  "properties": {
                    "type": {
                      "description": "Matches an event if it is a metric.",
                      "const": "is_metric",
                      "_metadata": {
                        "docs::human_name": "Type"
                      }
                    }
                  },
                  "_metadata": {
                    "docs::hidden": true,
                    "logical_name": "IsMetric",
                    "docs::human_name": "Is Metric"
                  }
                },
                {
                  "description": "Matches an event if it is a trace.",
                  "type": "object",
                  "required": [
                    "type"
                  ],
                  "properties": {
                    "type": {
                      "description": "Matches an event if it is a trace.",
                      "const": "is_trace",
                      "_metadata": {
                        "docs::human_name": "Type"
                      }
                    }
                  },
                  "_metadata": {
                    "docs::hidden": true,
                    "logical_name": "IsTrace",
                    "docs::human_name": "Is Trace"
                  }
                },
                {
                  "description": "Matches an event with a [Vector Remap Language](https://vector.dev/docs/reference/vrl) (VRL) [boolean expression](https://vector.dev/docs/reference/vrl#boolean-expressions).",
                  "allOf": [
                    {
                      "description": "A condition that uses the [Vector Remap Language](https://vector.dev/docs/reference/vrl) (VRL) [boolean expression](https://vector.dev/docs/reference/vrl#boolean-expressions) against an event.",
                      "type": "object",
                      "required": [
                        "source"
                      ],
                      "properties": {
                        "runtime": {
                          "description": "The runtime to use for executing VRL code.",
                          "default": "ast",
                          "type": "string",
                          "_metadata": {
                            "docs::hidden": true,
                            "docs::human_name": "Runtime"
                          }
                        },
                        "source": {
                          "description": "The VRL boolean expression.",
                          "type": "string",
                          "_metadata": {
                            "docs::human_name": "Source"
                          }
                        }
                      }
                    },
                    {
                      "type": "object",
                      "required": [
                        "type"
                      ],
                      "properties": {
                        "type": {
                          "description": "Matches an event with a [Vector Remap Language](https://vector.dev/docs/reference/vrl) (VRL) [boolean expression](https://vector.dev/docs/reference/vrl#boolean-expressions).",
                          "const": "vrl",
                          "_metadata": {
                            "docs::human_name": "Type"
                          }
                        }
                      }
                    }
                  ],
                  "_metadata": {
                    "logical_name": "Vrl",
                    "docs::human_name": "VRL"
                  }
                },
                {
                  "description": "Matches an event with a [Datadog Search](https://docs.datadoghq.com/logs/explorer/search_syntax/) query.",
                  "allOf": [
                    {
                      "description": "A condition that uses the [Datadog Search](https://docs.datadoghq.com/logs/explorer/search_syntax/) query syntax against an event.",
                      "type": "object",
                      "required": [
                        "source"
                      ],
                      "properties": {
                        "source": {
                          "description": "The query string.",
                          "type": "string",
                          "_metadata": {
                            "docs::human_name": "Source"
                          }
                        }
                      }
                    },
                    {
                      "type": "object",
                      "required": [
                        "type"
                      ],
                      "properties": {
                        "type": {
                          "description": "Matches an event with a [Datadog Search](https://docs.datadoghq.com/logs/explorer/search_syntax/) query.",
                          "const": "datadog_search",
                          "_metadata": {
                            "docs::human_name": "Type"
                          }
                        }
                      }
                    }
                  ],
                  "_metadata": {
                    "logical_name": "DatadogSearch",
                    "docs::human_name": "Datadog Search"
                  }
                }
              ],
              "_metadata": {
                "logical_name": "Map",
                "docs::enum_tagging": "internal",
                "docs::enum_tag_field": "type",
                "docs::human_name": "Map"
              }
            }
          ],
          "_metadata": {
            "docs::type_override": "condition",
            "docs::enum_tagging": "untagged"
          }
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::optional": true
      }
    },
    "core::option::Option<vector::http::Auth>": {
      "title": "Configuration of the authentication strategy for HTTP requests.",
      "description": "HTTP authentication should be used with HTTPS only, as the authentication credentials are passed as an\nHTTP header without any additional encryption beyond what is provided by the transport itself.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "title": "Configuration of the authentication strategy for HTTP requests.",
          "description": "HTTP authentication should be used with HTTPS only, as the authentication credentials are passed as an\nHTTP header without any additional encryption beyond what is provided by the transport itself.",
          "oneOf": [
            {
              "title": "Basic authentication.",
              "description": "The username and password are concatenated and encoded via [base64][base64].\n\n[base64]: https://en.wikipedia.org/wiki/Base64",
              "type": "object",
              "required": [
                "password",
                "strategy",
                "user"
              ],
              "properties": {
                "password": {
                  "description": "The basic authentication password.",
                  "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
                  "_metadata": {
                    "docs::examples": [
                      "${PASSWORD}",
                      "password"
                    ],
                    "docs::human_name": "Password"
                  }
                },
                "strategy": {
                  "title": "Basic authentication.",
                  "description": "The username and password are concatenated and encoded via [base64][base64].\n\n[base64]: https://en.wikipedia.org/wiki/Base64",
                  "const": "basic",
                  "_metadata": {
                    "docs::human_name": "Strategy"
                  }
                },
                "user": {
                  "description": "The basic authentication username.",
                  "type": "string",
                  "_metadata": {
                    "docs::examples": [
                      "${USERNAME}",
                      "username"
                    ],
                    "docs::human_name": "User"
                  }
                }
              },
              "_metadata": {
                "logical_name": "Basic",
                "docs::human_name": "Basic"
              }
            },
            {
              "title": "Bearer authentication.",
              "description": "The bearer token value (OAuth2, JWT, etc.) is passed as-is.",
              "type": "object",
              "required": [
                "strategy",
                "token"
              ],
              "properties": {
                "strategy": {
                  "title": "Bearer authentication.",
                  "description": "The bearer token value (OAuth2, JWT, etc.) is passed as-is.",
                  "const": "bearer",
                  "_metadata": {
                    "docs::human_name": "Strategy"
                  }
                },
                "token": {
                  "description": "The bearer authentication token.",
                  "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
                  "_metadata": {
                    "docs::human_name": "Token"
                  }
                }
              },
              "_metadata": {
                "logical_name": "Bearer",
                "docs::human_name": "Bearer"
              }
            }
          ],
          "_metadata": {
            "docs::enum_tag_description": "The authentication strategy to use.",
            "docs::enum_tagging": "internal",
            "docs::enum_tag_field": "strategy"
          }
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::optional": true
      }
    },
    "core::option::Option<vector::nats::NatsAuthConfig>": {
      "description": "Configuration of the authentication strategy when interacting with NATS.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "description": "Configuration of the authentication strategy when interacting with NATS.",
          "oneOf": [
            {
              "description": "Username/password authentication.",
              "type": "object",
              "required": [
                "strategy",
                "user_password"
              ],
              "properties": {
                "strategy": {
                  "description": "Username/password authentication.",
                  "const": "user_password",
                  "_metadata": {
                    "docs::human_name": "Strategy"
                  }
                },
                "user_password": {
                  "description": "Username and password configuration.",
                  "type": "object",
                  "required": [
                    "password",
                    "user"
                  ],
                  "properties": {
                    "password": {
                      "description": "Password.",
                      "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
                      "_metadata": {
                        "docs::human_name": "Password"
                      }
                    },
                    "user": {
                      "description": "Username.",
                      "type": "string",
                      "_metadata": {
                        "docs::human_name": "User"
                      }
                    }
                  },
                  "unevaluatedProperties": false,
                  "_metadata": {
                    "docs::human_name": "User Password"
                  }
                }
              },
              "_metadata": {
                "logical_name": "UserPassword",
                "docs::human_name": "User Password"
              }
            },
            {
              "description": "Token authentication.",
              "type": "object",
              "required": [
                "strategy",
                "token"
              ],
              "properties": {
                "strategy": {
                  "description": "Token authentication.",
                  "const": "token",
                  "_metadata": {
                    "docs::human_name": "Strategy"
                  }
                },
                "token": {
                  "description": "Token configuration.",
                  "type": "object",
                  "required": [
                    "value"
                  ],
                  "properties": {
                    "value": {
                      "description": "Token.",
                      "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
                      "_metadata": {
                        "docs::human_name": "Value"
                      }
                    }
                  },
                  "unevaluatedProperties": false,
                  "_metadata": {
                    "docs::human_name": "Token"
                  }
                }
              },
              "_metadata": {
                "logical_name": "Token",
                "docs::human_name": "Token"
              }
            },
            {
              "description": "Credentials file authentication. (JWT-based)",
              "type": "object",
              "required": [
                "credentials_file",
                "strategy"
              ],
              "properties": {
                "credentials_file": {
                  "description": "Credentials file configuration.",
                  "type": "object",
                  "required": [
                    "path"
                  ],
                  "properties": {
                    "path": {
                      "description": "Path to credentials file.",
                      "type": "string",
                      "_metadata": {
                        "docs::examples": "/etc/nats/nats.creds",
                        "docs::human_name": "Path"
                      }
                    }
                  },
                  "unevaluatedProperties": false,
                  "_metadata": {
                    "docs::human_name": "Credentials File"
                  }
                },
                "strategy": {
                  "description": "Credentials file authentication. (JWT-based)",
                  "const": "credentials_file",
                  "_metadata": {
                    "docs::human_name": "Strategy"
                  }
                }
              },
              "_metadata": {
                "logical_name": "CredentialsFile",
                "docs::human_name": "Credentials File"
              }
            },
            {
              "description": "NKey authentication.",
              "type": "object",
              "required": [
                "nkey",
                "strategy"
              ],
              "properties": {
                "nkey": {
                  "description": "NKeys configuration.",
                  "type": "object",
                  "required": [
                    "nkey",
                    "seed"
                  ],
                  "properties": {
                    "nkey": {
                      "title": "User.",
                      "description": "Conceptually, this is equivalent to a public key.",
                      "type": "string",
                      "_metadata": {
                        "docs::human_name": "Nkey"
                      }
                    },
                    "seed": {
                      "title": "Seed.",
                      "description": "Conceptually, this is equivalent to a private key.",
                      "type": "string",
                      "_metadata": {
                        "docs::human_name": "Seed"
                      }
                    }
                  },
                  "unevaluatedProperties": false,
                  "_metadata": {
                    "docs::human_name": "Nkey"
                  }
                },
                "strategy": {
                  "description": "NKey authentication.",
                  "const": "nkey",
                  "_metadata": {
                    "docs::human_name": "Strategy"
                  }
                }
              },
              "_metadata": {
                "logical_name": "Nkey",
                "docs::human_name": "Nkey"
              }
            }
          ],
          "_metadata": {
            "docs::enum_tag_description": "The strategy used to authenticate with the NATS server.\n\nMore information on NATS authentication, and the various authentication strategies, can be found in the\nNATS [documentation][nats_auth_docs]. For TLS client certificate authentication specifically, see the\n`tls` settings.\n\n[nats_auth_docs]: https://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro",
            "docs::enum_tagging": "internal",
            "docs::enum_tag_field": "strategy"
          }
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::optional": true
      }
    },
    "core::option::Option<vector::sinks::influxdb::InfluxDb1Settings>": {
      "description": "Configuration settings for InfluxDB v0.x/v1.x.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "description": "Configuration settings for InfluxDB v0.x/v1.x.",
          "type": "object",
          "required": [
            "database"
          ],
          "properties": {
            "consistency": {
              "title": "The consistency level to use for writes.",
              "description": "Only relevant when using InfluxDB v0.x/v1.x.",
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::examples": [
                  "any",
                  "one",
                  "quorum",
                  "all"
                ],
                "docs::human_name": "Consistency"
              }
            },
            "database": {
              "title": "The name of the database to write into.",
              "description": "Only relevant when using InfluxDB v0.x/v1.x.",
              "type": "string",
              "_metadata": {
                "docs::examples": [
                  "vector-database",
                  "iot-store"
                ],
                "docs::human_name": "Database"
              }
            },
            "password": {
              "title": "The password to authenticate with.",
              "description": "Only relevant when using InfluxDB v0.x/v1.x.",
              "$ref": "#/definitions/core::option::Option<vector_common::sensitive_string::SensitiveString>",
              "_metadata": {
                "docs::examples": [
                  "${INFLUXDB_PASSWORD}",
                  "influxdb4ever"
                ],
                "docs::human_name": "Password"
              }
            },
            "retention_policy_name": {
              "title": "The target retention policy for writes.",
              "description": "Only relevant when using InfluxDB v0.x/v1.x.",
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::examples": [
                  "autogen",
                  "one_day_only"
                ],
                "docs::human_name": "Retention Policy Name"
              }
            },
            "username": {
              "title": "The username to authenticate with.",
              "description": "Only relevant when using InfluxDB v0.x/v1.x.",
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::examples": [
                  "todd",
                  "vector-source"
                ],
                "docs::human_name": "Username"
              }
            }
          }
        }
      ],
      "_metadata": {
        "docs::optional": true
      }
    },
    "core::option::Option<vector::sinks::influxdb::InfluxDb2Settings>": {
      "description": "Configuration settings for InfluxDB v2.x.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "description": "Configuration settings for InfluxDB v2.x.",
          "type": "object",
          "required": [
            "bucket",
            "org",
            "token"
          ],
          "properties": {
            "bucket": {
              "title": "The name of the bucket to write into.",
              "description": "Only relevant when using InfluxDB v2.x and above.",
              "type": "string",
              "_metadata": {
                "docs::examples": [
                  "vector-bucket",
                  "4d2225e4d3d49f75"
                ],
                "docs::human_name": "Bucket"
              }
            },
            "org": {
              "title": "The name of the organization to write into.",
              "description": "Only relevant when using InfluxDB v2.x and above.",
              "type": "string",
              "_metadata": {
                "docs::examples": [
                  "my-org",
                  "33f2cff0a28e5b63"
                ],
                "docs::human_name": "Org"
              }
            },
            "token": {
              "title": "The [token][token_docs] to authenticate with.",
              "description": "Only relevant when using InfluxDB v2.x and above.\n\n[token_docs]: https://v2.docs.influxdata.com/v2.0/security/tokens/",
              "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
              "_metadata": {
                "docs::examples": [
                  "${INFLUXDB_TOKEN}",
                  "ef8d5de700e7989468166c40fc8a0ccd"
                ],
                "docs::human_name": "Token"
              }
            }
          }
        }
      ],
      "_metadata": {
        "docs::optional": true
      }
    },
    "core::option::Option<vector::sinks::util::buffer::compression::Compression>": {
      "title": "Compression configuration.",
      "description": "All compression algorithms use the default compression level unless otherwise specified.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "title": "Compression configuration.",
          "description": "All compression algorithms use the default compression level unless otherwise specified.",
          "oneOf": [
            {
              "description": "Compression algorithm.",
              "oneOf": [
                {
                  "description": "No compression.",
                  "const": "none",
                  "_metadata": {
                    "logical_name": "None",
                    "docs::human_name": "None"
                  }
                },
                {
                  "title": "[Gzip][gzip] compression.",
                  "description": "[gzip]: https://www.gzip.org/",
                  "const": "gzip",
                  "_metadata": {
                    "logical_name": "Gzip",
                    "docs::human_name": "Gzip"
                  }
                },
                {
                  "title": "[Zlib][zlib] compression.",
                  "description": "[zlib]: https://zlib.net/",
                  "const": "zlib",
                  "_metadata": {
                    "logical_name": "Zlib",
                    "docs::human_name": "Zlib"
                  }
                },
                {
                  "title": "[Zstandard][zstd] compression.",
                  "description": "[zstd]: https://facebook.github.io/zstd/",
                  "const": "zstd",
                  "_metadata": {
                    "logical_name": "Zstd",
                    "docs::human_name": "Zstd"
                  }
                }
              ],
              "_metadata": {
                "docs::enum_tagging": "external"
              }
            },
            {
              "description": "Compression algorithm and compression level.",
              "type": "object",
              "required": [
                "algorithm"
              ],
              "properties": {
                "algorithm": {
                  "description": "Compression algorithm.",
                  "oneOf": [
                    {
                      "description": "No compression.",
                      "const": "none",
                      "_metadata": {
                        "logical_name": "None",
                        "docs::human_name": "None"
                      }
                    },
                    {
                      "title": "[Gzip][gzip] compression.",
                      "description": "[gzip]: https://www.gzip.org/",
                      "const": "gzip",
                      "_metadata": {
                        "logical_name": "Gzip",
                        "docs::human_name": "Gzip"
                      }
                    },
                    {
                      "title": "[Zlib][zlib] compression.",
                      "description": "[zlib]: https://zlib.net/",
                      "const": "zlib",
                      "_metadata": {
                        "logical_name": "Zlib",
                        "docs::human_name": "Zlib"
                      }
                    },
                    {
                      "title": "[Zstandard][zstd] compression.",
                      "description": "[zstd]: https://facebook.github.io/zstd/",
                      "const": "zstd",
                      "_metadata": {
                        "logical_name": "Zstd",
                        "docs::human_name": "Zstd"
                      }
                    }
                  ],
                  "unevaluatedProperties": false,
                  "_metadata": {
                    "docs::enum_tagging": "external",
                    "docs::human_name": "Algorithm"
                  }
                },
                "level": {
                  "description": "Compression level.",
                  "enum": [
                    "none",
                    "fast",
                    "best",
                    "default",
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21
                  ],
                  "_metadata": {
                    "docs::human_name": "Level"
                  }
                }
              },
              "_metadata": {
                "docs::hidden": true
              }
            }
          ],
          "_metadata": {
            "docs::enum_tagging": "external",
            "docs::advanced": true
          }
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::optional": true
      }
    },
    "core::option::Option<vector::sinks::util::uri::UriSerde>": {
      "title": "The URI component of a request.",
      "description": "",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "$ref": "#/definitions/vector::sinks::util::uri::UriSerde"
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::optional": true
      }
    },
    "core::option::Option<vector::sources::util::http::auth::HttpSourceAuthConfig>": {
      "description": "HTTP Basic authentication configuration.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "description": "HTTP Basic authentication configuration.",
          "type": "object",
          "required": [
            "password",
            "username"
          ],
          "properties": {
            "password": {
              "description": "The password for basic authentication.",
              "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
              "_metadata": {
                "docs::examples": [
                  "hunter2",
                  "${PASSWORD}"
                ],
                "docs::human_name": "Password"
              }
            },
            "username": {
              "description": "The username for basic authentication.",
              "type": "string",
              "_metadata": {
                "docs::examples": [
                  "AzureDiamond",
                  "admin"
                ],
                "docs::human_name": "Username"
              }
            }
          }
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::optional": true
      }
    },
    "core::option::Option<vector::sources::util::multiline_config::MultilineConfig>": {
      "description": "Configuration of multi-line aggregation.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "description": "Configuration of multi-line aggregation.",
          "type": "object",
          "required": [
            "condition_pattern",
            "mode",
            "start_pattern",
            "timeout_ms"
          ],
          "properties": {
            "condition_pattern": {
              "title": "Regular expression pattern that is used to determine whether or not more lines should be read.",
              "description": "This setting must be configured in conjunction with `mode`.",
              "type": "string",
              "_metadata": {
                "docs::examples": [
                  "^[\\s]+",
                  "\\\\$",
                  "^(INFO|ERROR) ",
                  ";$"
                ],
                "docs::human_name": "Condition Pattern"
              }
            },
            "mode": {
              "title": "Aggregation mode.",
              "description": "This setting must be configured in conjunction with `condition_pattern`.",
              "oneOf": [
                {
                  "title": "All consecutive lines matching this pattern are included in the group.",
                  "description": "The first line (the line that matched the start pattern) does not need to match the `ContinueThrough` pattern.\n\nThis is useful in cases such as a Java stack trace, where some indicator in the line (such as a leading\nwhitespace) indicates that it is an extension of the proceeding line.",
                  "const": "continue_through",
                  "_metadata": {
                    "logical_name": "ContinueThrough",
                    "docs::human_name": "Continue Through"
                  }
                },
                {
                  "title": "All consecutive lines matching this pattern, plus one additional line, are included in the group.",
                  "description": "This is useful in cases where a log message ends with a continuation marker, such as a backslash, indicating\nthat the following line is part of the same message.",
                  "const": "continue_past",
                  "_metadata": {
                    "logical_name": "ContinuePast",
                    "docs::human_name": "Continue Past"
                  }
                },
                {
                  "title": "All consecutive lines not matching this pattern are included in the group.",
                  "description": "This is useful where a log line contains a marker indicating that it begins a new message.",
                  "const": "halt_before",
                  "_metadata": {
                    "logical_name": "HaltBefore",
                    "docs::human_name": "Halt Before"
                  }
                },
                {
                  "title": "All consecutive lines, up to and including the first line matching this pattern, are included in the group.",
                  "description": "This is useful where a log line ends with a termination marker, such as a semicolon.",
                  "const": "halt_with",
                  "_metadata": {
                    "logical_name": "HaltWith",
                    "docs::human_name": "Halt With"
                  }
                }
              ],
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::enum_tagging": "external",
                "docs::human_name": "Mode"
              }
            },
            "start_pattern": {
              "description": "Regular expression pattern that is used to match the start of a new message.",
              "type": "string",
              "_metadata": {
                "docs::examples": [
                  "^[\\s]+",
                  "\\\\$",
                  "^(INFO|ERROR) ",
                  ";$"
                ],
                "docs::human_name": "Start Pattern"
              }
            },
            "timeout_ms": {
              "title": "The maximum amount of time to wait for the next additional line, in milliseconds.",
              "description": "Once this timeout is reached, the buffered message is guaranteed to be flushed, even if incomplete.",
              "$ref": "#/definitions/serde_with::DurationMilliSeconds",
              "_metadata": {
                "docs::examples": [
                  1000,
                  600000
                ],
                "docs::human_name": "Timeout"
              }
            }
          }
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::optional": true
      }
    },
    "core::option::Option<vector::template::Template>": {
      "title": "A templated field.",
      "description": "In many cases, components can be configured so that part of the component's functionality can be\ncustomized on a per-event basis. For example, you have a sink that writes events to a file and you want to\nspecify which file an event should go to by using an event field as part of the\ninput to the filename used.\n\nBy using `Template`, users can specify either fixed strings or templated strings. Templated strings use a common syntax to\nrefer to fields in an event that is used as the input data when rendering the template. An example of a fixed string\nis `my-file.log`. An example of a template string is `my-file-{{key}}.log`, where `{{key}}`\nis the key's value when the template is rendered into a string.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "$ref": "#/definitions/vector::template::Template"
        }
      ],
      "_metadata": {
        "docs::optional": true
      }
    },
    "core::option::Option<vector_common::sensitive_string::SensitiveString>": {
      "description": "Wrapper for sensitive strings containing credentials",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString"
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::optional": true
      }
    },
    "core::option::Option<vector_core::tcp::TcpKeepaliveConfig>": {
      "description": "TCP keepalive settings for socket-based components.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "description": "TCP keepalive settings for socket-based components.",
          "type": "object",
          "properties": {
            "time_secs": {
              "description": "The time to wait before starting to send TCP keepalive probes on an idle connection.",
              "type": [
                "integer",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "seconds"
              }
            }
          },
          "_metadata": {
            "docs::human_name": "Wait Time"
          }
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::optional": true
      }
    },
    "core::option::Option<vector_core::tls::settings::TlsConfig>": {
      "description": "TLS configuration.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::optional": true
      }
    },
    "core::option::Option<vector_core::tls::settings::TlsEnableableConfig>": {
      "description": "Configures the TLS options for incoming/outgoing connections.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "$ref": "#/definitions/vector_core::tls::settings::TlsEnableableConfig"
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::optional": true
      }
    },
    "core::option::Option<vector_core::tls::settings::TlsSourceConfig>": {
      "description": "TlsEnableableConfig for `sources`, adding metadata from the client certificate.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "description": "TlsEnableableConfig for `sources`, adding metadata from the client certificate.",
          "allOf": [
            {
              "type": "object",
              "properties": {
                "client_metadata_key": {
                  "description": "Event field for client certificate metadata.",
                  "$ref": "#/definitions/core::option::Option<vector_lookup::lookup_v2::optional_path::OptionalValuePath>",
                  "_metadata": {
                    "docs::human_name": "Client Metadata Key"
                  }
                }
              }
            },
            {
              "description": "Configures the TLS options for incoming/outgoing connections.",
              "$ref": "#/definitions/vector_core::tls::settings::TlsEnableableConfig"
            }
          ]
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::optional": true
      }
    },
    "core::option::Option<vector_lookup::lookup_v2::ConfigValuePath>": {
      "description": "A wrapper around `OwnedValuePath` that allows it to be used in Vector config.\nThis requires a valid path to be used. If you want to allow optional paths,\nuse [optional_path::OptionalValuePath].",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "$ref": "#/definitions/vector_lookup::lookup_v2::ConfigValuePath"
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::optional": true
      }
    },
    "core::option::Option<vector_lookup::lookup_v2::optional_path::OptionalTargetPath>": {
      "description": "An optional path that deserializes an empty string to `None`.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalTargetPath"
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::optional": true
      }
    },
    "core::option::Option<vector_lookup::lookup_v2::optional_path::OptionalValuePath>": {
      "description": "An optional path that deserializes an empty string to `None`.",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath"
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::optional": true
      }
    },
    "core::option::Option<vrl::compiler::datetime::TimeZone>": {
      "title": "Timezone reference.",
      "description": "This can refer to any valid timezone as defined in the [TZ database][tzdb], or \"local\" which refers to the system local timezone.\n\n[tzdb]: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones",
      "oneOf": [
        {
          "type": "null"
        },
        {
          "title": "Timezone reference.",
          "description": "This can refer to any valid timezone as defined in the [TZ database][tzdb], or \"local\" which refers to the system local timezone.\n\n[tzdb]: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones",
          "oneOf": [
            {
              "description": "System local timezone.",
              "const": "local",
              "_metadata": {
                "logical_name": "Local",
                "docs::human_name": "Local"
              }
            },
            {
              "title": "A named timezone.",
              "description": "Must be a valid name in the [TZ database][tzdb].\n\n[tzdb]: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones",
              "type": "string",
              "_metadata": {
                "logical_name": "Named",
                "docs::human_name": "Named"
              }
            }
          ],
          "_metadata": {
            "docs::enum_tagging": "untagged",
            "docs::examples": [
              "local",
              "America/New_York",
              "EST5EDT"
            ]
          }
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::optional": true
      }
    },
    "file_source::ReadFromConfig": {
      "description": "File position to use when reading a new file.",
      "oneOf": [
        {
          "description": "Read from the beginning of the file.",
          "const": "beginning",
          "_metadata": {
            "logical_name": "Beginning",
            "docs::human_name": "Beginning"
          }
        },
        {
          "description": "Start reading from the current end of the file.",
          "const": "end",
          "_metadata": {
            "logical_name": "End",
            "docs::human_name": "End"
          }
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::enum_tagging": "external"
      }
    },
    "serde_with::DurationFractionalSeconds": {
      "description": "A span of time, in fractional seconds.",
      "type": "number",
      "maximum": 9007199254740991.0,
      "minimum": -9007199254740991.0,
      "_metadata": {
        "docs::numeric_type": "float",
        "docs::type_unit": "seconds"
      }
    },
    "serde_with::DurationMilliSeconds": {
      "description": "A span of time, in whole milliseconds.",
      "type": "integer",
      "maximum": 9007199254740991.0,
      "minimum": 0.0,
      "_metadata": {
        "docs::numeric_type": "uint",
        "docs::type_unit": "milliseconds"
      }
    },
    "serde_with::DurationSeconds": {
      "description": "A span of time, in whole seconds.",
      "type": "integer",
      "maximum": 9007199254740991.0,
      "minimum": 0.0,
      "_metadata": {
        "docs::numeric_type": "uint",
        "docs::type_unit": "seconds"
      }
    },
    "stdlib::PathBuf": {
      "description": "A file path.",
      "type": "string",
      "pattern": "(\\/.*|[a-zA-Z]:\\\\(?:([^<>:\"\\/\\\\|?*]*[^<>:\"\\/\\\\|?*.]\\\\|..\\\\)*([^<>:\"\\/\\\\|?*]*[^<>:\"\\/\\\\|?*.]\\\\?|..\\\\))?)"
    },
    "stdlib::SocketAddr": {
      "description": "An internet socket address, either IPv4 or IPv6.",
      "type": "string"
    },
    "vector::amqp::AmqpConfig": {
      "description": "AMQP connection options.",
      "type": "object",
      "required": [
        "connection_string"
      ],
      "properties": {
        "connection_string": {
          "title": "URI for the AMQP server.",
          "description": "The URI has the format of\n`amqp://<user>:<password>@<host>:<port>/<vhost>?timeout=<seconds>`.\n\nThe default vhost can be specified by using a value of `%2f`.\n\nTo connect over TLS, a scheme of `amqps` can be specified instead. For example,\n`amqps://...`. Additional TLS settings, such as client certificate verification, can be\nconfigured under the `tls` section.",
          "type": "string",
          "_metadata": {
            "docs::examples": "amqp://user:password@127.0.0.1:5672/%2f?timeout=10",
            "docs::human_name": "Connection String"
          }
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      }
    },
    "vector::aws::auth::AwsAuthentication": {
      "description": "Configuration of the authentication strategy for interacting with AWS services.",
      "anyOf": [
        {
          "description": "Authenticate using a fixed access key and secret pair.",
          "type": "object",
          "required": [
            "access_key_id",
            "secret_access_key"
          ],
          "properties": {
            "access_key_id": {
              "description": "The AWS access key ID.",
              "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
              "_metadata": {
                "docs::examples": "AKIAIOSFODNN7EXAMPLE",
                "docs::human_name": "Access Key ID"
              }
            },
            "assume_role": {
              "title": "The ARN of an [IAM role][iam_role] to assume.",
              "description": "[iam_role]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html",
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::examples": "arn:aws:iam::123456789098:role/my_role",
                "docs::human_name": "Assume Role"
              }
            },
            "external_id": {
              "title": "The optional unique external ID in conjunction with role to assume.",
              "description": "[external_id]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html",
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::examples": "randomEXAMPLEidString",
                "docs::human_name": "External ID"
              }
            },
            "region": {
              "title": "The [AWS region][aws_region] to send STS requests to.",
              "description": "If not set, this will default to the configured region\nfor the service itself.\n\n[aws_region]: https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints",
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::examples": "us-west-2",
                "docs::human_name": "Region"
              }
            },
            "secret_access_key": {
              "description": "The AWS secret access key.",
              "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
              "_metadata": {
                "docs::examples": "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY",
                "docs::human_name": "Secret Access Key"
              }
            }
          },
          "_metadata": {
            "logical_name": "AccessKey",
            "docs::human_name": "Access Key"
          }
        },
        {
          "title": "Authenticate using credentials stored in a file.",
          "description": "Additionally, the specific credential profile to use can be set.\nThe file format must match the credentials file format outlined in\n<https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html>.",
          "type": "object",
          "required": [
            "credentials_file"
          ],
          "properties": {
            "credentials_file": {
              "description": "Path to the credentials file.",
              "type": "string",
              "_metadata": {
                "docs::examples": "/my/aws/credentials",
                "docs::human_name": "Credentials File"
              }
            },
            "profile": {
              "title": "The credentials profile to use.",
              "description": "Used to select AWS credentials from a provided credentials file.",
              "default": "default",
              "type": "string",
              "_metadata": {
                "docs::examples": "develop",
                "docs::human_name": "Profile"
              }
            }
          },
          "_metadata": {
            "logical_name": "File",
            "docs::human_name": "File"
          }
        },
        {
          "description": "Assume the given role ARN.",
          "type": "object",
          "required": [
            "assume_role"
          ],
          "properties": {
            "assume_role": {
              "title": "The ARN of an [IAM role][iam_role] to assume.",
              "description": "[iam_role]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html",
              "type": "string",
              "_metadata": {
                "docs::examples": "arn:aws:iam::123456789098:role/my_role",
                "docs::human_name": "Assume Role"
              }
            },
            "external_id": {
              "title": "The optional unique external ID in conjunction with role to assume.",
              "description": "[external_id]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html",
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::examples": "randomEXAMPLEidString",
                "docs::human_name": "External ID"
              }
            },
            "imds": {
              "description": "Configuration for authenticating with AWS through IMDS.",
              "default": {
                "max_attempts": 4,
                "connect_timeout_seconds": 1,
                "read_timeout_seconds": 1
              },
              "type": "object",
              "properties": {
                "connect_timeout_seconds": {
                  "description": "Connect timeout for IMDS.",
                  "default": 1,
                  "$ref": "#/definitions/serde_with::DurationSeconds",
                  "_metadata": {
                    "docs::human_name": "Connect Timeout Seconds"
                  }
                },
                "max_attempts": {
                  "description": "Number of IMDS retries for fetching tokens and metadata.",
                  "default": 4,
                  "type": "integer",
                  "maximum": 4294967295.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::human_name": "Max Attempts"
                  }
                },
                "read_timeout_seconds": {
                  "description": "Read timeout for IMDS.",
                  "default": 1,
                  "$ref": "#/definitions/serde_with::DurationSeconds",
                  "_metadata": {
                    "docs::human_name": "Read Timeout Seconds"
                  }
                }
              },
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::human_name": "IMDS"
              }
            },
            "load_timeout_secs": {
              "title": "Timeout for assuming the role, in seconds.",
              "description": "Relevant when the default credentials chain or `assume_role` is used.",
              "type": [
                "integer",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "seconds",
                "docs::examples": 30,
                "docs::human_name": "Load Timeout"
              }
            },
            "region": {
              "title": "The [AWS region][aws_region] to send STS requests to.",
              "description": "If not set, this defaults to the configured region\nfor the service itself.\n\n[aws_region]: https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints",
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::examples": "us-west-2",
                "docs::human_name": "Region"
              }
            }
          },
          "_metadata": {
            "logical_name": "Role",
            "docs::human_name": "Role"
          }
        },
        {
          "description": "Default authentication strategy which tries a variety of substrategies in sequential order.",
          "type": "object",
          "properties": {
            "imds": {
              "description": "Configuration for authenticating with AWS through IMDS.",
              "default": {
                "max_attempts": 4,
                "connect_timeout_seconds": 1,
                "read_timeout_seconds": 1
              },
              "type": "object",
              "properties": {
                "connect_timeout_seconds": {
                  "description": "Connect timeout for IMDS.",
                  "default": 1,
                  "$ref": "#/definitions/serde_with::DurationSeconds",
                  "_metadata": {
                    "docs::human_name": "Connect Timeout Seconds"
                  }
                },
                "max_attempts": {
                  "description": "Number of IMDS retries for fetching tokens and metadata.",
                  "default": 4,
                  "type": "integer",
                  "maximum": 4294967295.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::human_name": "Max Attempts"
                  }
                },
                "read_timeout_seconds": {
                  "description": "Read timeout for IMDS.",
                  "default": 1,
                  "$ref": "#/definitions/serde_with::DurationSeconds",
                  "_metadata": {
                    "docs::human_name": "Read Timeout Seconds"
                  }
                }
              },
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::human_name": "IMDS"
              }
            },
            "load_timeout_secs": {
              "title": "Timeout for successfully loading any credentials, in seconds.",
              "description": "Relevant when the default credentials chain or `assume_role` is used.",
              "type": [
                "integer",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "seconds",
                "docs::examples": 30,
                "docs::human_name": "Load Timeout"
              }
            },
            "region": {
              "title": "The [AWS region][aws_region] to send STS requests to.",
              "description": "If not set, this defaults to the configured region\nfor the service itself.\n\n[aws_region]: https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints",
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::examples": "us-west-2",
                "docs::human_name": "Region"
              }
            }
          },
          "_metadata": {
            "logical_name": "Default",
            "docs::human_name": "Default"
          }
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::enum_tagging": "untagged"
      }
    },
    "vector::aws::region::RegionOrEndpoint": {
      "description": "Configuration of the region/endpoint to use when interacting with an AWS service.",
      "default": {
        "region": null,
        "endpoint": null
      },
      "type": "object",
      "properties": {
        "endpoint": {
          "description": "Custom endpoint for use with AWS-compatible services.",
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::examples": "http://127.0.0.0:5000/path/to/service",
            "docs::advanced": true,
            "docs::human_name": "Endpoint"
          }
        },
        "region": {
          "title": "The [AWS region][aws_region] of the target service.",
          "description": "[aws_region]: https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints",
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::examples": "us-east-1",
            "docs::human_name": "Region"
          }
        }
      }
    },
    "vector::codecs::encoding::config::EncodingConfig": {
      "description": "Configures how events are encoded into raw bytes.",
      "allOf": [
        {
          "description": "Serializer configuration.",
          "oneOf": [
            {
              "title": "Encodes an event as an [Apache Avro][apache_avro] message.",
              "description": "[apache_avro]: https://avro.apache.org/",
              "type": "object",
              "required": [
                "avro",
                "codec"
              ],
              "properties": {
                "avro": {
                  "description": "Apache Avro-specific encoder options.",
                  "type": "object",
                  "required": [
                    "schema"
                  ],
                  "properties": {
                    "schema": {
                      "description": "The Avro schema.",
                      "type": "string",
                      "_metadata": {
                        "docs::examples": "{ \"type\": \"record\", \"name\": \"log\", \"fields\": [{ \"name\": \"message\", \"type\": \"string\" }] }",
                        "docs::human_name": "Schema JSON"
                      }
                    }
                  },
                  "unevaluatedProperties": false,
                  "_metadata": {
                    "docs::human_name": "Avro"
                  }
                },
                "codec": {
                  "title": "Encodes an event as an [Apache Avro][apache_avro] message.",
                  "description": "[apache_avro]: https://avro.apache.org/",
                  "const": "avro",
                  "_metadata": {
                    "docs::human_name": "Codec"
                  }
                }
              },
              "_metadata": {
                "logical_name": "Avro",
                "docs::human_name": "Avro"
              }
            },
            {
              "title": "Encodes an event as a CSV message.",
              "description": "This codec must be configured with fields to encode.",
              "allOf": [
                {
                  "description": "Config used to build a `CsvSerializer`.",
                  "$ref": "#/definitions/codecs::encoding::format::csv::CsvSerializerConfig"
                },
                {
                  "type": "object",
                  "required": [
                    "codec"
                  ],
                  "properties": {
                    "codec": {
                      "title": "Encodes an event as a CSV message.",
                      "description": "This codec must be configured with fields to encode.",
                      "const": "csv",
                      "_metadata": {
                        "docs::human_name": "Codec"
                      }
                    }
                  }
                }
              ],
              "_metadata": {
                "logical_name": "Csv",
                "docs::human_name": "CSV"
              }
            },
            {
              "title": "Encodes an event as a [GELF][gelf] message.",
              "description": "[gelf]: https://docs.graylog.org/docs/gelf",
              "type": "object",
              "required": [
                "codec"
              ],
              "properties": {
                "codec": {
                  "title": "Encodes an event as a [GELF][gelf] message.",
                  "description": "[gelf]: https://docs.graylog.org/docs/gelf",
                  "const": "gelf",
                  "_metadata": {
                    "docs::human_name": "Codec"
                  }
                }
              },
              "_metadata": {
                "logical_name": "Gelf",
                "docs::human_name": "GELF"
              }
            },
            {
              "title": "Encodes an event as [JSON][json].",
              "description": "[json]: https://www.json.org/",
              "allOf": [
                {
                  "description": "Config used to build a `JsonSerializer`.",
                  "$ref": "#/definitions/codecs::encoding::format::json::JsonSerializerConfig"
                },
                {
                  "type": "object",
                  "required": [
                    "codec"
                  ],
                  "properties": {
                    "codec": {
                      "title": "Encodes an event as [JSON][json].",
                      "description": "[json]: https://www.json.org/",
                      "const": "json",
                      "_metadata": {
                        "docs::human_name": "Codec"
                      }
                    }
                  }
                }
              ],
              "_metadata": {
                "logical_name": "Json",
                "docs::human_name": "JSON"
              }
            },
            {
              "title": "Encodes an event as a [logfmt][logfmt] message.",
              "description": "[logfmt]: https://brandur.org/logfmt",
              "type": "object",
              "required": [
                "codec"
              ],
              "properties": {
                "codec": {
                  "title": "Encodes an event as a [logfmt][logfmt] message.",
                  "description": "[logfmt]: https://brandur.org/logfmt",
                  "const": "logfmt",
                  "_metadata": {
                    "docs::human_name": "Codec"
                  }
                }
              },
              "_metadata": {
                "logical_name": "Logfmt",
                "docs::human_name": "Logfmt"
              }
            },
            {
              "title": "Encodes an event in the [native Protocol Buffers format][vector_native_protobuf].",
              "description": "This codec is **[experimental][experimental]**.\n\n[vector_native_protobuf]: https://github.com/vectordotdev/vector/blob/master/lib/vector-core/proto/event.proto\n[experimental]: https://vector.dev/highlights/2022-03-31-native-event-codecs",
              "type": "object",
              "required": [
                "codec"
              ],
              "properties": {
                "codec": {
                  "title": "Encodes an event in the [native Protocol Buffers format][vector_native_protobuf].",
                  "description": "This codec is **[experimental][experimental]**.\n\n[vector_native_protobuf]: https://github.com/vectordotdev/vector/blob/master/lib/vector-core/proto/event.proto\n[experimental]: https://vector.dev/highlights/2022-03-31-native-event-codecs",
                  "const": "native",
                  "_metadata": {
                    "docs::human_name": "Codec"
                  }
                }
              },
              "_metadata": {
                "logical_name": "Native",
                "docs::human_name": "Native"
              }
            },
            {
              "title": "Encodes an event in the [native JSON format][vector_native_json].",
              "description": "This codec is **[experimental][experimental]**.\n\n[vector_native_json]: https://github.com/vectordotdev/vector/blob/master/lib/codecs/tests/data/native_encoding/schema.cue\n[experimental]: https://vector.dev/highlights/2022-03-31-native-event-codecs",
              "type": "object",
              "required": [
                "codec"
              ],
              "properties": {
                "codec": {
                  "title": "Encodes an event in the [native JSON format][vector_native_json].",
                  "description": "This codec is **[experimental][experimental]**.\n\n[vector_native_json]: https://github.com/vectordotdev/vector/blob/master/lib/codecs/tests/data/native_encoding/schema.cue\n[experimental]: https://vector.dev/highlights/2022-03-31-native-event-codecs",
                  "const": "native_json",
                  "_metadata": {
                    "docs::human_name": "Codec"
                  }
                }
              },
              "_metadata": {
                "logical_name": "NativeJson",
                "docs::human_name": "Native JSON"
              }
            },
            {
              "title": "No encoding.",
              "description": "This encoding uses the `message` field of a log event.\n\nBe careful if you are modifying your log events (for example, by using a `remap`\ntransform) and removing the message field while doing additional parsing on it, as this\ncould lead to the encoding emitting empty strings for the given event.",
              "type": "object",
              "required": [
                "codec"
              ],
              "properties": {
                "codec": {
                  "title": "No encoding.",
                  "description": "This encoding uses the `message` field of a log event.\n\nBe careful if you are modifying your log events (for example, by using a `remap`\ntransform) and removing the message field while doing additional parsing on it, as this\ncould lead to the encoding emitting empty strings for the given event.",
                  "const": "raw_message",
                  "_metadata": {
                    "docs::human_name": "Codec"
                  }
                }
              },
              "_metadata": {
                "logical_name": "RawMessage",
                "docs::human_name": "Raw Message"
              }
            },
            {
              "title": "Plain text encoding.",
              "description": "This encoding uses the `message` field of a log event. For metrics, it uses an\nencoding that resembles the Prometheus export format.\n\nBe careful if you are modifying your log events (for example, by using a `remap`\ntransform) and removing the message field while doing additional parsing on it, as this\ncould lead to the encoding emitting empty strings for the given event.",
              "allOf": [
                {
                  "description": "Config used to build a `TextSerializer`.",
                  "type": "object",
                  "properties": {
                    "metric_tag_values": {
                      "title": "Controls how metric tag values are encoded.",
                      "description": "When set to `single`, only the last non-bare value of tags are displayed with the\nmetric.  When set to `full`, all metric tags are exposed as separate assignments.",
                      "default": "single",
                      "$ref": "#/definitions/codecs::MetricTagValues",
                      "_metadata": {
                        "docs::human_name": "Metric Tag Values"
                      }
                    }
                  }
                },
                {
                  "type": "object",
                  "required": [
                    "codec"
                  ],
                  "properties": {
                    "codec": {
                      "title": "Plain text encoding.",
                      "description": "This encoding uses the `message` field of a log event. For metrics, it uses an\nencoding that resembles the Prometheus export format.\n\nBe careful if you are modifying your log events (for example, by using a `remap`\ntransform) and removing the message field while doing additional parsing on it, as this\ncould lead to the encoding emitting empty strings for the given event.",
                      "const": "text",
                      "_metadata": {
                        "docs::human_name": "Codec"
                      }
                    }
                  }
                }
              ],
              "_metadata": {
                "logical_name": "Text",
                "docs::human_name": "Text"
              }
            }
          ],
          "_metadata": {
            "docs::enum_tag_description": "The codec to use for encoding events.",
            "docs::enum_tagging": "internal",
            "docs::enum_tag_field": "codec"
          }
        },
        {
          "description": "Transformations to prepare an event for serialization.",
          "type": "object",
          "properties": {
            "except_fields": {
              "description": "List of fields that are excluded from the encoded event.",
              "default": null,
              "type": [
                "array",
                "null"
              ],
              "items": {
                "$ref": "#/definitions/vector_lookup::lookup_v2::ConfigValuePath"
              },
              "_metadata": {
                "docs::optional": true,
                "docs::human_name": "Except Fields"
              }
            },
            "only_fields": {
              "description": "List of fields that are included in the encoded event.",
              "default": null,
              "type": [
                "array",
                "null"
              ],
              "items": {
                "$ref": "#/definitions/vector_lookup::lookup_v2::ConfigValuePath"
              },
              "_metadata": {
                "docs::optional": true,
                "docs::human_name": "Only Fields"
              }
            },
            "timestamp_format": {
              "description": "Format used for timestamp fields.",
              "default": null,
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "description": "The format in which a timestamp should be represented.",
                  "oneOf": [
                    {
                      "description": "Represent the timestamp as a Unix timestamp.",
                      "const": "unix",
                      "_metadata": {
                        "logical_name": "Unix",
                        "docs::human_name": "Unix"
                      }
                    },
                    {
                      "description": "Represent the timestamp as a RFC 3339 timestamp.",
                      "const": "rfc3339",
                      "_metadata": {
                        "logical_name": "Rfc3339",
                        "docs::human_name": "RFC3339"
                      }
                    }
                  ],
                  "_metadata": {
                    "docs::enum_tagging": "external"
                  }
                }
              ],
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::optional": true,
                "docs::human_name": "Timestamp Format"
              }
            }
          }
        }
      ],
      "unevaluatedProperties": false
    },
    "vector::codecs::encoding::config::EncodingConfigWithFraming": {
      "description": "Encoding configuration.",
      "type": "object",
      "required": [
        "encoding"
      ],
      "properties": {
        "encoding": {
          "description": "Configures how events are encoded into raw bytes.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
          "_metadata": {
            "docs::human_name": "Encoding"
          }
        },
        "framing": {
          "description": "Framing configuration.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "description": "Framing configuration.",
              "oneOf": [
                {
                  "description": "Event data is not delimited at all.",
                  "type": "object",
                  "required": [
                    "method"
                  ],
                  "properties": {
                    "method": {
                      "description": "Event data is not delimited at all.",
                      "const": "bytes",
                      "_metadata": {
                        "docs::human_name": "Method"
                      }
                    }
                  },
                  "_metadata": {
                    "logical_name": "Bytes",
                    "docs::human_name": "Bytes"
                  }
                },
                {
                  "description": "Event data is delimited by a single ASCII (7-bit) character.",
                  "allOf": [
                    {
                      "description": "Config used to build a `CharacterDelimitedEncoder`.",
                      "type": "object",
                      "required": [
                        "character_delimited"
                      ],
                      "properties": {
                        "character_delimited": {
                          "description": "Options for the character delimited encoder.",
                          "type": "object",
                          "required": [
                            "delimiter"
                          ],
                          "properties": {
                            "delimiter": {
                              "description": "The ASCII (7-bit) character that delimits byte sequences.",
                              "type": "integer",
                              "maximum": 255.0,
                              "minimum": 0.0,
                              "_metadata": {
                                "docs::numeric_type": "uint",
                                "docs::human_name": "Delimiter"
                              }
                            }
                          },
                          "unevaluatedProperties": false,
                          "_metadata": {
                            "docs::human_name": "Character Delimited"
                          }
                        }
                      }
                    },
                    {
                      "type": "object",
                      "required": [
                        "method"
                      ],
                      "properties": {
                        "method": {
                          "description": "Event data is delimited by a single ASCII (7-bit) character.",
                          "const": "character_delimited",
                          "_metadata": {
                            "docs::human_name": "Method"
                          }
                        }
                      }
                    }
                  ],
                  "_metadata": {
                    "logical_name": "CharacterDelimited",
                    "docs::human_name": "Character Delimited"
                  }
                },
                {
                  "title": "Event data is prefixed with its length in bytes.",
                  "description": "The prefix is a 32-bit unsigned integer, little endian.",
                  "type": "object",
                  "required": [
                    "method"
                  ],
                  "properties": {
                    "method": {
                      "title": "Event data is prefixed with its length in bytes.",
                      "description": "The prefix is a 32-bit unsigned integer, little endian.",
                      "const": "length_delimited",
                      "_metadata": {
                        "docs::human_name": "Method"
                      }
                    }
                  },
                  "_metadata": {
                    "logical_name": "LengthDelimited",
                    "docs::human_name": "Length Delimited"
                  }
                },
                {
                  "description": "Event data is delimited by a newline (LF) character.",
                  "type": "object",
                  "required": [
                    "method"
                  ],
                  "properties": {
                    "method": {
                      "description": "Event data is delimited by a newline (LF) character.",
                      "const": "newline_delimited",
                      "_metadata": {
                        "docs::human_name": "Method"
                      }
                    }
                  },
                  "_metadata": {
                    "logical_name": "NewlineDelimited",
                    "docs::human_name": "Newline Delimited"
                  }
                }
              ],
              "_metadata": {
                "docs::enum_tag_description": "The framing method.",
                "docs::enum_tagging": "internal",
                "docs::enum_tag_field": "method"
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Framing"
          }
        }
      }
    },
    "vector::codecs::encoding::transformer::Transformer": {
      "description": "Transformations to prepare an event for serialization.",
      "type": "object",
      "properties": {
        "except_fields": {
          "description": "List of fields that are excluded from the encoded event.",
          "default": null,
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/vector_lookup::lookup_v2::ConfigValuePath"
          },
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Except Fields"
          }
        },
        "only_fields": {
          "description": "List of fields that are included in the encoded event.",
          "default": null,
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/vector_lookup::lookup_v2::ConfigValuePath"
          },
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Only Fields"
          }
        },
        "timestamp_format": {
          "description": "Format used for timestamp fields.",
          "default": null,
          "oneOf": [
            {
              "type": "null"
            },
            {
              "description": "The format in which a timestamp should be represented.",
              "oneOf": [
                {
                  "description": "Represent the timestamp as a Unix timestamp.",
                  "const": "unix",
                  "_metadata": {
                    "logical_name": "Unix",
                    "docs::human_name": "Unix"
                  }
                },
                {
                  "description": "Represent the timestamp as a RFC 3339 timestamp.",
                  "const": "rfc3339",
                  "_metadata": {
                    "logical_name": "Rfc3339",
                    "docs::human_name": "RFC3339"
                  }
                }
              ],
              "_metadata": {
                "docs::enum_tagging": "external"
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Timestamp Format"
          }
        }
      },
      "unevaluatedProperties": false
    },
    "vector::conditions::AnyCondition": {
      "title": "An event matching condition.",
      "description": "Many methods exist for matching events, such as using a VRL expression, a Datadog Search query string,\nor hard-coded matchers like \"must be a metric\" or \"fields A, B, and C must match these constraints\".\n\nAs VRL is the most common way to apply conditions to events, this type provides a shortcut to define VRL expressions\ndirectly in the configuration by passing the VRL expression as a string:\n\n```toml\ncondition = '.message == \"hooray\"'\n```\n\nWhen other condition types are required, they can be specified with an enum-style notation:\n\n```toml\ncondition.type = 'datadog_search'\ncondition.source = 'NOT \"foo\"'\n```",
      "oneOf": [
        {
          "description": "A [Vector Remap Language](https://vector.dev/docs/reference/vrl) (VRL) [boolean expression](https://vector.dev/docs/reference/vrl#boolean-expressions).",
          "type": "string",
          "_metadata": {
            "logical_name": "String",
            "docs::human_name": "String"
          }
        },
        {
          "title": "An event matching condition.",
          "description": "A fully-specified condition.",
          "oneOf": [
            {
              "description": "Matches an event if it is a log.",
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Matches an event if it is a log.",
                  "const": "is_log",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              },
              "_metadata": {
                "docs::hidden": true,
                "logical_name": "IsLog",
                "docs::human_name": "Is Log"
              }
            },
            {
              "description": "Matches an event if it is a metric.",
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Matches an event if it is a metric.",
                  "const": "is_metric",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              },
              "_metadata": {
                "docs::hidden": true,
                "logical_name": "IsMetric",
                "docs::human_name": "Is Metric"
              }
            },
            {
              "description": "Matches an event if it is a trace.",
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Matches an event if it is a trace.",
                  "const": "is_trace",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              },
              "_metadata": {
                "docs::hidden": true,
                "logical_name": "IsTrace",
                "docs::human_name": "Is Trace"
              }
            },
            {
              "description": "Matches an event with a [Vector Remap Language](https://vector.dev/docs/reference/vrl) (VRL) [boolean expression](https://vector.dev/docs/reference/vrl#boolean-expressions).",
              "allOf": [
                {
                  "description": "A condition that uses the [Vector Remap Language](https://vector.dev/docs/reference/vrl) (VRL) [boolean expression](https://vector.dev/docs/reference/vrl#boolean-expressions) against an event.",
                  "type": "object",
                  "required": [
                    "source"
                  ],
                  "properties": {
                    "runtime": {
                      "description": "The runtime to use for executing VRL code.",
                      "default": "ast",
                      "type": "string",
                      "_metadata": {
                        "docs::hidden": true,
                        "docs::human_name": "Runtime"
                      }
                    },
                    "source": {
                      "description": "The VRL boolean expression.",
                      "type": "string",
                      "_metadata": {
                        "docs::human_name": "Source"
                      }
                    }
                  }
                },
                {
                  "type": "object",
                  "required": [
                    "type"
                  ],
                  "properties": {
                    "type": {
                      "description": "Matches an event with a [Vector Remap Language](https://vector.dev/docs/reference/vrl) (VRL) [boolean expression](https://vector.dev/docs/reference/vrl#boolean-expressions).",
                      "const": "vrl",
                      "_metadata": {
                        "docs::human_name": "Type"
                      }
                    }
                  }
                }
              ],
              "_metadata": {
                "logical_name": "Vrl",
                "docs::human_name": "VRL"
              }
            },
            {
              "description": "Matches an event with a [Datadog Search](https://docs.datadoghq.com/logs/explorer/search_syntax/) query.",
              "allOf": [
                {
                  "description": "A condition that uses the [Datadog Search](https://docs.datadoghq.com/logs/explorer/search_syntax/) query syntax against an event.",
                  "type": "object",
                  "required": [
                    "source"
                  ],
                  "properties": {
                    "source": {
                      "description": "The query string.",
                      "type": "string",
                      "_metadata": {
                        "docs::human_name": "Source"
                      }
                    }
                  }
                },
                {
                  "type": "object",
                  "required": [
                    "type"
                  ],
                  "properties": {
                    "type": {
                      "description": "Matches an event with a [Datadog Search](https://docs.datadoghq.com/logs/explorer/search_syntax/) query.",
                      "const": "datadog_search",
                      "_metadata": {
                        "docs::human_name": "Type"
                      }
                    }
                  }
                }
              ],
              "_metadata": {
                "logical_name": "DatadogSearch",
                "docs::human_name": "Datadog Search"
              }
            }
          ],
          "_metadata": {
            "logical_name": "Map",
            "docs::enum_tagging": "internal",
            "docs::enum_tag_field": "type",
            "docs::human_name": "Map"
          }
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::type_override": "condition",
        "docs::enum_tagging": "untagged"
      }
    },
    "vector::config::TestInput": {
      "title": "A unit test input.",
      "description": "An input describes not only the type of event to insert, but also which transform within the\nconfiguration to insert it to.",
      "type": "object",
      "required": [
        "insert_at"
      ],
      "properties": {
        "insert_at": {
          "description": "The name of the transform to insert the input event to.",
          "type": "string",
          "_metadata": {
            "docs::human_name": "Insert At"
          }
        },
        "log_fields": {
          "title": "The set of log fields to use when creating a log input event.",
          "description": "Only relevant when `type` is `log`.",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "description": "Value for a log field.",
            "oneOf": [
              {
                "description": "A string.",
                "type": "string",
                "_metadata": {
                  "logical_name": "String",
                  "docs::human_name": "String"
                }
              },
              {
                "description": "An integer.",
                "type": "integer",
                "maximum": 9007199254740991.0,
                "minimum": -9007199254740991.0,
                "_metadata": {
                  "docs::numeric_type": "int",
                  "logical_name": "Integer",
                  "docs::human_name": "Integer"
                }
              },
              {
                "description": "A floating-point number.",
                "type": "number",
                "maximum": 9007199254740991.0,
                "minimum": -9007199254740991.0,
                "_metadata": {
                  "docs::numeric_type": "float",
                  "logical_name": "Float",
                  "docs::human_name": "Float"
                }
              },
              {
                "description": "A boolean.",
                "type": "boolean",
                "_metadata": {
                  "logical_name": "Boolean",
                  "docs::human_name": "Boolean"
                }
              }
            ],
            "unevaluatedProperties": false,
            "_metadata": {
              "docs::enum_tagging": "untagged"
            }
          },
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Log Fields"
          }
        },
        "metric": {
          "title": "The metric to use as an input event.",
          "description": "Only relevant when `type` is `metric`.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "description": "A metric.",
              "allOf": [
                {
                  "description": "Metrics series.",
                  "allOf": [
                    {
                      "type": "object",
                      "properties": {
                        "tags": {
                          "description": "Tags for a metric series.",
                          "oneOf": [
                            {
                              "type": "null"
                            },
                            {
                              "description": "Tags for a metric series.",
                              "type": "object",
                              "additionalProperties": {
                                "description": "Tag values for a metric series.  This may be empty, a single value, or a set of values. This is\nused to provide the storage for `TagValueSet`.",
                                "oneOf": [
                                  {
                                    "description": "This represents a set containing no value.",
                                    "const": "Empty",
                                    "_metadata": {
                                      "logical_name": "Empty",
                                      "docs::human_name": "Empty"
                                    }
                                  },
                                  {
                                    "description": "This represents a set containing a single value. This is stored separately to avoid the\noverhead of allocating a hash table for the common case of a single value for a tag.",
                                    "type": "object",
                                    "required": [
                                      "Single"
                                    ],
                                    "properties": {
                                      "Single": {
                                        "description": "A single tag value, either a bare tag or a value.",
                                        "oneOf": [
                                          {
                                            "description": "Bare tag value.",
                                            "type": "null",
                                            "_metadata": {
                                              "logical_name": "Bare",
                                              "docs::human_name": "Bare"
                                            }
                                          },
                                          {
                                            "description": "Tag value containing a string.",
                                            "type": "string",
                                            "_metadata": {
                                              "logical_name": "Value",
                                              "docs::human_name": "Value"
                                            }
                                          }
                                        ],
                                        "unevaluatedProperties": false,
                                        "_metadata": {
                                          "docs::enum_tagging": "untagged",
                                          "docs::human_name": "Single"
                                        }
                                      }
                                    },
                                    "_metadata": {
                                      "logical_name": "Single",
                                      "docs::human_name": "Single"
                                    }
                                  },
                                  {
                                    "description": "This holds an actual set of values. This variant will be automatically created when a single\nvalue is added to, and reduced down to a single value when the length is reduced to 1.  An\nindex set is used for this set, as it preserves the insertion order of the contained\nelements. This allows us to retrieve the last element inserted which in turn allows us to\nemulate the set having a single value.",
                                    "type": "object",
                                    "required": [
                                      "Set"
                                    ],
                                    "properties": {
                                      "Set": {
                                        "type": "array",
                                        "items": {
                                          "description": "A single tag value, either a bare tag or a value.",
                                          "oneOf": [
                                            {
                                              "description": "Bare tag value.",
                                              "type": "null",
                                              "_metadata": {
                                                "logical_name": "Bare",
                                                "docs::human_name": "Bare"
                                              }
                                            },
                                            {
                                              "description": "Tag value containing a string.",
                                              "type": "string",
                                              "_metadata": {
                                                "logical_name": "Value",
                                                "docs::human_name": "Value"
                                              }
                                            }
                                          ],
                                          "unevaluatedProperties": false,
                                          "_metadata": {
                                            "docs::enum_tagging": "untagged"
                                          }
                                        },
                                        "uniqueItems": true,
                                        "_metadata": {
                                          "docs::human_name": "Set"
                                        }
                                      }
                                    },
                                    "_metadata": {
                                      "logical_name": "Set",
                                      "docs::human_name": "Set"
                                    }
                                  }
                                ],
                                "unevaluatedProperties": false,
                                "_metadata": {
                                  "docs::enum_tagging": "external"
                                }
                              }
                            }
                          ],
                          "unevaluatedProperties": false,
                          "_metadata": {
                            "docs::optional": true,
                            "docs::human_name": "Tags"
                          }
                        }
                      }
                    },
                    {
                      "description": "Metric name.",
                      "type": "object",
                      "required": [
                        "name"
                      ],
                      "properties": {
                        "name": {
                          "title": "The name of the metric.",
                          "description": "This would typically be a name for the metric itself, unrelated to where the metric\noriginates from. For example, if the metric represented the amount of used system memory, it\nmay be called `memory.used`.",
                          "type": "string",
                          "_metadata": {
                            "docs::human_name": "Name"
                          }
                        },
                        "namespace": {
                          "title": "The namespace of the metric.",
                          "description": "Namespace represents a grouping for a metric where the name itself may otherwise be too\ngeneric. For example, while the name of a metric may be `memory.used` for the amount of used\nsystem memory, the namespace could differentiate that by being `system` for the total amount\nof used memory across the system, or `vector` for the amount of used system memory specific\nto Vector, and so on.",
                          "type": [
                            "string",
                            "null"
                          ],
                          "_metadata": {
                            "docs::optional": true,
                            "docs::human_name": "Namespace"
                          }
                        }
                      }
                    }
                  ]
                },
                {
                  "description": "Metric data.",
                  "allOf": [
                    {
                      "type": "object",
                      "required": [
                        "kind"
                      ],
                      "properties": {
                        "kind": {
                          "title": "Metric kind.",
                          "description": "Metrics can be either absolute of incremental. Absolute metrics represent a sort of \"last write wins\" scenario,\nwhere the latest absolute value seen is meant to be the actual metric value.  In contrast, and perhaps intuitively,\nincremental metrics are meant to be additive, such that we don't know what total value of the metric is, but we know\nthat we'll be adding or subtracting the given value from it.\n\nGenerally speaking, most metrics storage systems deal with incremental updates. A notable exception is Prometheus,\nwhich deals with, and expects, absolute values from clients.",
                          "$ref": "#/definitions/vector_core::event::metric::MetricKind",
                          "_metadata": {
                            "docs::human_name": "Kind"
                          }
                        }
                      }
                    },
                    {
                      "description": "Metric time.",
                      "type": "object",
                      "properties": {
                        "interval_ms": {
                          "title": "The interval, in milliseconds, of this metric.",
                          "description": "Intervals represent the time window over which this metric applies, and is generally only\nused for tracking rates (change over time) on counters.",
                          "type": [
                            "integer",
                            "null"
                          ],
                          "maximum": 4294967295.0,
                          "minimum": 1.0,
                          "_metadata": {
                            "docs::numeric_type": "uint",
                            "docs::optional": true,
                            "docs::human_name": "Interval Ms"
                          }
                        },
                        "timestamp": {
                          "title": "The timestamp of when the metric was created.",
                          "description": "Metrics may sometimes have no timestamp, or have no meaningful value if the metric is an\naggregation or transformed heavily enough from its original form such that the original\ntimestamp would not represent a meaningful value.",
                          "type": [
                            "string",
                            "null"
                          ],
                          "_metadata": {
                            "docs::optional": true,
                            "docs::human_name": "Timestamp"
                          }
                        }
                      }
                    },
                    {
                      "description": "Metric value.\nContainer for the actual value of a metric.",
                      "oneOf": [
                        {
                          "description": "A cumulative numerical value that can only increase or be reset to zero.",
                          "type": "object",
                          "required": [
                            "counter"
                          ],
                          "properties": {
                            "counter": {
                              "type": "object",
                              "required": [
                                "value"
                              ],
                              "properties": {
                                "value": {
                                  "description": "The value of the counter.",
                                  "type": "number",
                                  "maximum": 9007199254740991.0,
                                  "minimum": -9007199254740991.0,
                                  "_metadata": {
                                    "docs::numeric_type": "float",
                                    "docs::human_name": "Value"
                                  }
                                }
                              },
                              "unevaluatedProperties": false,
                              "_metadata": {
                                "docs::human_name": "Counter"
                              }
                            }
                          },
                          "_metadata": {
                            "logical_name": "Counter",
                            "docs::human_name": "Counter"
                          }
                        },
                        {
                          "description": "A single numerical value that can arbitrarily go up and down.",
                          "type": "object",
                          "required": [
                            "gauge"
                          ],
                          "properties": {
                            "gauge": {
                              "type": "object",
                              "required": [
                                "value"
                              ],
                              "properties": {
                                "value": {
                                  "description": "The value of the gauge.",
                                  "type": "number",
                                  "maximum": 9007199254740991.0,
                                  "minimum": -9007199254740991.0,
                                  "_metadata": {
                                    "docs::numeric_type": "float",
                                    "docs::human_name": "Value"
                                  }
                                }
                              },
                              "unevaluatedProperties": false,
                              "_metadata": {
                                "docs::human_name": "Gauge"
                              }
                            }
                          },
                          "_metadata": {
                            "logical_name": "Gauge",
                            "docs::human_name": "Gauge"
                          }
                        },
                        {
                          "description": "A set of (unordered) unique values for a key.",
                          "type": "object",
                          "required": [
                            "set"
                          ],
                          "properties": {
                            "set": {
                              "type": "object",
                              "required": [
                                "values"
                              ],
                              "properties": {
                                "values": {
                                  "description": "The values in the set.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  },
                                  "uniqueItems": true,
                                  "_metadata": {
                                    "docs::human_name": "Values"
                                  }
                                }
                              },
                              "unevaluatedProperties": false,
                              "_metadata": {
                                "docs::human_name": "Set"
                              }
                            }
                          },
                          "_metadata": {
                            "logical_name": "Set",
                            "docs::human_name": "Set"
                          }
                        },
                        {
                          "description": "A set of observations without any aggregation or sampling.",
                          "type": "object",
                          "required": [
                            "distribution"
                          ],
                          "properties": {
                            "distribution": {
                              "type": "object",
                              "required": [
                                "samples",
                                "statistic"
                              ],
                              "properties": {
                                "samples": {
                                  "description": "The observed values within this distribution.",
                                  "type": "array",
                                  "items": {
                                    "description": "A single observation.",
                                    "type": "object",
                                    "required": [
                                      "rate",
                                      "value"
                                    ],
                                    "properties": {
                                      "rate": {
                                        "description": "The rate at which the value was observed.",
                                        "type": "integer",
                                        "maximum": 4294967295.0,
                                        "minimum": 0.0,
                                        "_metadata": {
                                          "docs::numeric_type": "uint",
                                          "docs::human_name": "Rate"
                                        }
                                      },
                                      "value": {
                                        "description": "The value of the observation.",
                                        "type": "number",
                                        "maximum": 9007199254740991.0,
                                        "minimum": -9007199254740991.0,
                                        "_metadata": {
                                          "docs::numeric_type": "float",
                                          "docs::human_name": "Value"
                                        }
                                      }
                                    },
                                    "unevaluatedProperties": false
                                  },
                                  "_metadata": {
                                    "docs::human_name": "Samples"
                                  }
                                },
                                "statistic": {
                                  "description": "The type of statistics to derive for this distribution.",
                                  "oneOf": [
                                    {
                                      "description": "A histogram representation.",
                                      "const": "histogram",
                                      "_metadata": {
                                        "logical_name": "Histogram",
                                        "docs::human_name": "Histogram"
                                      }
                                    },
                                    {
                                      "description": "Corresponds to Datadog's Distribution Metric\n<https://docs.datadoghq.com/developers/metrics/types/?tab=distribution#definition>",
                                      "const": "summary",
                                      "_metadata": {
                                        "logical_name": "Summary",
                                        "docs::human_name": "Summary"
                                      }
                                    }
                                  ],
                                  "unevaluatedProperties": false,
                                  "_metadata": {
                                    "docs::enum_tagging": "external",
                                    "docs::human_name": "Statistic"
                                  }
                                }
                              },
                              "unevaluatedProperties": false,
                              "_metadata": {
                                "docs::human_name": "Distribution"
                              }
                            }
                          },
                          "_metadata": {
                            "logical_name": "Distribution",
                            "docs::human_name": "Distribution"
                          }
                        },
                        {
                          "title": "A set of observations which are counted into buckets.",
                          "description": "It also contains the total count of all observations and their sum to allow calculating the mean.",
                          "type": "object",
                          "required": [
                            "aggregated_histogram"
                          ],
                          "properties": {
                            "aggregated_histogram": {
                              "type": "object",
                              "required": [
                                "buckets",
                                "count",
                                "sum"
                              ],
                              "properties": {
                                "buckets": {
                                  "title": "A histogram bucket.",
                                  "description": "The buckets within this histogram.",
                                  "type": "array",
                                  "items": {
                                    "title": "A histogram bucket.",
                                    "description": "Histogram buckets represent the `count` of observations where the value of the observations does\nnot exceed the specified `upper_limit`.",
                                    "type": "object",
                                    "required": [
                                      "count",
                                      "upper_limit"
                                    ],
                                    "properties": {
                                      "count": {
                                        "description": "The number of values tracked in this bucket.",
                                        "type": "integer",
                                        "maximum": 9007199254740991.0,
                                        "minimum": 0.0,
                                        "_metadata": {
                                          "docs::numeric_type": "uint",
                                          "docs::human_name": "Count"
                                        }
                                      },
                                      "upper_limit": {
                                        "description": "The upper limit of values in the bucket.",
                                        "type": "number",
                                        "maximum": 9007199254740991.0,
                                        "minimum": -9007199254740991.0,
                                        "_metadata": {
                                          "docs::numeric_type": "float",
                                          "docs::human_name": "Upper Limit"
                                        }
                                      }
                                    },
                                    "unevaluatedProperties": false
                                  },
                                  "_metadata": {
                                    "docs::human_name": "Buckets"
                                  }
                                },
                                "count": {
                                  "description": "The total number of observations contained within this histogram.",
                                  "type": "integer",
                                  "maximum": 9007199254740991.0,
                                  "minimum": 0.0,
                                  "_metadata": {
                                    "docs::numeric_type": "uint",
                                    "docs::human_name": "Count"
                                  }
                                },
                                "sum": {
                                  "description": "The sum of all observations contained within this histogram.",
                                  "type": "number",
                                  "maximum": 9007199254740991.0,
                                  "minimum": -9007199254740991.0,
                                  "_metadata": {
                                    "docs::numeric_type": "float",
                                    "docs::human_name": "Sum"
                                  }
                                }
                              },
                              "unevaluatedProperties": false,
                              "_metadata": {
                                "docs::human_name": "Aggregated Histogram"
                              }
                            }
                          },
                          "_metadata": {
                            "logical_name": "AggregatedHistogram",
                            "docs::human_name": "Aggregated Histogram"
                          }
                        },
                        {
                          "title": "A set of observations which are represented by quantiles.",
                          "description": "Each quantile contains the upper value of the quantile (0 <= φ <= 1). It also contains the total count of all\nobservations and their sum to allow calculating the mean.",
                          "type": "object",
                          "required": [
                            "aggregated_summary"
                          ],
                          "properties": {
                            "aggregated_summary": {
                              "type": "object",
                              "required": [
                                "count",
                                "quantiles",
                                "sum"
                              ],
                              "properties": {
                                "count": {
                                  "description": "The total number of observations contained within this summary.",
                                  "type": "integer",
                                  "maximum": 9007199254740991.0,
                                  "minimum": 0.0,
                                  "_metadata": {
                                    "docs::numeric_type": "uint",
                                    "docs::human_name": "Count"
                                  }
                                },
                                "quantiles": {
                                  "title": "A single quantile observation.",
                                  "description": "The quantiles measured from this summary.",
                                  "type": "array",
                                  "items": {
                                    "title": "A single quantile observation.",
                                    "description": "Quantiles themselves are \"cut points dividing the range of a probability distribution into\ncontinuous intervals with equal probabilities\". [[1][quantiles_wikipedia]].\n\nWe use quantiles to measure the value along these probability distributions for representing\nclient-side aggregations of distributions, which represent a collection of observations over a\nspecific time window.\n\nIn general, we typically use the term \"quantile\" to represent the concept of _percentiles_,\nwhich deal with whole integers -- 0, 1, 2, .., 99, 100 -- even though quantiles are\nfloating-point numbers and can represent higher-precision cut points, such as 0.9999, or the\n99.99th percentile.\n\n[quantiles_wikipedia]: https://en.wikipedia.org/wiki/Quantile",
                                    "type": "object",
                                    "required": [
                                      "quantile",
                                      "value"
                                    ],
                                    "properties": {
                                      "quantile": {
                                        "title": "The value of the quantile.",
                                        "description": "This value must be between 0.0 and 1.0, inclusive.",
                                        "type": "number",
                                        "maximum": 9007199254740991.0,
                                        "minimum": -9007199254740991.0,
                                        "_metadata": {
                                          "docs::numeric_type": "float",
                                          "docs::human_name": "Quantile"
                                        }
                                      },
                                      "value": {
                                        "description": "The estimated value of the given quantile within the probability distribution.",
                                        "type": "number",
                                        "maximum": 9007199254740991.0,
                                        "minimum": -9007199254740991.0,
                                        "_metadata": {
                                          "docs::numeric_type": "float",
                                          "docs::human_name": "Value"
                                        }
                                      }
                                    },
                                    "unevaluatedProperties": false
                                  },
                                  "_metadata": {
                                    "docs::human_name": "Quantiles"
                                  }
                                },
                                "sum": {
                                  "description": "The sum of all observations contained within this histogram.",
                                  "type": "number",
                                  "maximum": 9007199254740991.0,
                                  "minimum": -9007199254740991.0,
                                  "_metadata": {
                                    "docs::numeric_type": "float",
                                    "docs::human_name": "Sum"
                                  }
                                }
                              },
                              "unevaluatedProperties": false,
                              "_metadata": {
                                "docs::human_name": "Aggregated Summary"
                              }
                            }
                          },
                          "_metadata": {
                            "logical_name": "AggregatedSummary",
                            "docs::human_name": "Aggregated Summary"
                          }
                        },
                        {
                          "title": "A data structure that can answer questions about the cumulative distribution of the contained samples in\nspace-efficient way.",
                          "description": "Sketches represent the data in a way that queries over it have bounded error guarantees without needing to hold\nevery single sample in memory. They are also, typically, able to be merged with other sketches of the same type\nsuch that client-side _and_ server-side aggregation can be accomplished without loss of accuracy in the queries.",
                          "type": "object",
                          "required": [
                            "sketch"
                          ],
                          "properties": {
                            "sketch": {
                              "type": "object",
                              "required": [
                                "sketch"
                              ],
                              "properties": {
                                "sketch": {
                                  "description": "A generalized metrics sketch.",
                                  "oneOf": [
                                    {
                                      "title": "[DDSketch][ddsketch] implementation based on the [Datadog Agent][ddagent].",
                                      "description": "While DDSketch has open-source implementations based on the white paper, the version used in\nthe Datadog Agent itself is subtly different. This version is suitable for sending directly\nto Datadog's sketch ingest endpoint.\n\n[ddsketch]: https://www.vldb.org/pvldb/vol12/p2195-masson.pdf\n[ddagent]: https://github.com/DataDog/datadog-agent",
                                      "type": "object",
                                      "required": [
                                        "AgentDDSketch"
                                      ],
                                      "properties": {
                                        "AgentDDSketch": {
                                          "title": "[DDSketch][ddsketch] implementation based on the [Datadog Agent][ddagent].",
                                          "description": "This implementation is subtly different from the open-source implementations of `DDSketch`, as\nDatadog made some slight tweaks to configuration values and in-memory layout to optimize it for\ninsertion performance within the agent.\n\nWe've mimicked the agent version of `DDSketch` here in order to support a future where we can\ntake sketches shipped by the agent, handle them internally, merge them, and so on, without any\nloss of accuracy, eventually forwarding them to Datadog ourselves.\n\nAs such, this implementation is constrained in the same ways: the configuration parameters\ncannot be changed, the collapsing strategy is fixed, and we support a limited number of methods\nfor inserting into the sketch.\n\nImportantly, we have a special function, again taken from the agent version, to allow us to\ninterpolate histograms, specifically our own aggregated histograms, into a sketch so that we can\nemit useful default quantiles, rather than having to ship the buckets -- upper bound and count\n-- to a downstream system that might have no native way to do the same thing, basically\nproviding no value as they have no way to render useful data from them.\n\n[ddsketch]: https://www.vldb.org/pvldb/vol12/p2195-masson.pdf\n[ddagent]: https://github.com/DataDog/datadog-agent",
                                          "type": "object",
                                          "required": [
                                            "avg",
                                            "bins",
                                            "count",
                                            "max",
                                            "min",
                                            "sum"
                                          ],
                                          "properties": {
                                            "avg": {
                                              "description": "The average value of all observations within the sketch.",
                                              "type": "number",
                                              "maximum": 9007199254740991.0,
                                              "minimum": -9007199254740991.0,
                                              "_metadata": {
                                                "docs::numeric_type": "float",
                                                "docs::human_name": "Avg"
                                              }
                                            },
                                            "bins": {
                                              "title": "A split representation of sketch bins.",
                                              "description": "The bins within the sketch.",
                                              "type": "object",
                                              "required": [
                                                "k",
                                                "n"
                                              ],
                                              "properties": {
                                                "k": {
                                                  "description": "The bin keys.",
                                                  "type": "array",
                                                  "items": {
                                                    "type": "integer",
                                                    "maximum": 32767.0,
                                                    "minimum": -32768.0,
                                                    "_metadata": {
                                                      "docs::numeric_type": "int"
                                                    }
                                                  },
                                                  "_metadata": {
                                                    "docs::numeric_type": "int",
                                                    "docs::human_name": "K"
                                                  }
                                                },
                                                "n": {
                                                  "description": "The bin counts.",
                                                  "type": "array",
                                                  "items": {
                                                    "type": "integer",
                                                    "maximum": 65535.0,
                                                    "minimum": 0.0,
                                                    "_metadata": {
                                                      "docs::numeric_type": "uint"
                                                    }
                                                  },
                                                  "_metadata": {
                                                    "docs::numeric_type": "uint",
                                                    "docs::human_name": "N"
                                                  }
                                                }
                                              },
                                              "unevaluatedProperties": false,
                                              "_metadata": {
                                                "docs::human_name": "Bins"
                                              }
                                            },
                                            "count": {
                                              "description": "The number of observations within the sketch.",
                                              "type": "integer",
                                              "maximum": 4294967295.0,
                                              "minimum": 0.0,
                                              "_metadata": {
                                                "docs::numeric_type": "uint",
                                                "docs::human_name": "Count"
                                              }
                                            },
                                            "max": {
                                              "description": "The maximum value of all observations within the sketch.",
                                              "type": "number",
                                              "maximum": 9007199254740991.0,
                                              "minimum": -9007199254740991.0,
                                              "_metadata": {
                                                "docs::numeric_type": "float",
                                                "docs::human_name": "Max"
                                              }
                                            },
                                            "min": {
                                              "description": "The minimum value of all observations within the sketch.",
                                              "type": "number",
                                              "maximum": 9007199254740991.0,
                                              "minimum": -9007199254740991.0,
                                              "_metadata": {
                                                "docs::numeric_type": "float",
                                                "docs::human_name": "Min"
                                              }
                                            },
                                            "sum": {
                                              "description": "The sum of all observations within the sketch.",
                                              "type": "number",
                                              "maximum": 9007199254740991.0,
                                              "minimum": -9007199254740991.0,
                                              "_metadata": {
                                                "docs::numeric_type": "float",
                                                "docs::human_name": "Sum"
                                              }
                                            }
                                          },
                                          "unevaluatedProperties": false,
                                          "_metadata": {
                                            "docs::human_name": "Agent Dd Sketch"
                                          }
                                        }
                                      },
                                      "_metadata": {
                                        "logical_name": "AgentDDSketch",
                                        "docs::human_name": "Agent Dd Sketch"
                                      }
                                    }
                                  ],
                                  "unevaluatedProperties": false,
                                  "_metadata": {
                                    "docs::enum_tagging": "external",
                                    "docs::human_name": "Sketch"
                                  }
                                }
                              },
                              "unevaluatedProperties": false,
                              "_metadata": {
                                "docs::human_name": "Sketch"
                              }
                            }
                          },
                          "_metadata": {
                            "logical_name": "Sketch",
                            "docs::human_name": "Sketch"
                          }
                        }
                      ],
                      "_metadata": {
                        "docs::enum_tagging": "external"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Metric"
          }
        },
        "type": {
          "title": "The type of the input event.",
          "description": "Can be either `raw`, `log`, or `metric.",
          "default": "raw",
          "type": "string",
          "_metadata": {
            "docs::human_name": "Type"
          }
        },
        "value": {
          "title": "The raw string value to use as the input event.",
          "description": "Use this only when the input event should be a raw event (i.e. unprocessed/undecoded log\nevent) and when the input type is set to `raw`.",
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Value"
          }
        }
      }
    },
    "vector::config::id::Inputs<alloc::string::String>": {
      "title": "A list of upstream [source][sources] or [transform][transforms] IDs.",
      "description": "Wildcards (`*`) are supported.\n\nSee [configuration][configuration] for more info.\n\n[sources]: https://vector.dev/docs/reference/configuration/sources/\n[transforms]: https://vector.dev/docs/reference/configuration/transforms/\n[configuration]: https://vector.dev/docs/reference/configuration/",
      "type": "array",
      "items": {
        "type": "string"
      },
      "_metadata": {
        "docs::examples": [
          "my-source-or-transform-id",
          "prefix-*"
        ]
      }
    },
    "vector::config::sink::SinkOuter<alloc::string::String>": {
      "description": "Fully resolved sink component.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "inputs"
          ],
          "properties": {
            "buffer": {
              "title": "Configures the buffering behavior for this sink.",
              "description": "More information about the individual buffer types, and buffer behavior, can be found in the\n[Buffering Model][buffering_model] section.\n\n[buffering_model]: /docs/about/under-the-hood/architecture/buffering-model/",
              "default": {
                "type": "memory",
                "max_events": 500,
                "when_full": "block"
              },
              "oneOf": [
                {
                  "description": "A single stage buffer topology.",
                  "oneOf": [
                    {
                      "title": "Events are buffered in memory.",
                      "description": "This is more performant, but less durable. Data will be lost if Vector is restarted\nforcefully or crashes.",
                      "type": "object",
                      "required": [
                        "type"
                      ],
                      "properties": {
                        "max_events": {
                          "description": "The maximum number of events allowed in the buffer.",
                          "default": 500,
                          "type": "integer",
                          "maximum": 9007199254740991.0,
                          "minimum": 1.0,
                          "_metadata": {
                            "docs::numeric_type": "uint",
                            "docs::human_name": "Max Events"
                          }
                        },
                        "type": {
                          "title": "Events are buffered in memory.",
                          "description": "This is more performant, but less durable. Data will be lost if Vector is restarted\nforcefully or crashes.",
                          "const": "memory",
                          "_metadata": {
                            "docs::human_name": "Type"
                          }
                        },
                        "when_full": {
                          "description": "Event handling behavior when a buffer is full.",
                          "default": "block",
                          "oneOf": [
                            {
                              "title": "Wait for free space in the buffer.",
                              "description": "This applies backpressure up the topology, signalling that sources should slow down\nthe acceptance/consumption of events. This means that while no data is lost, data will pile\nup at the edge.",
                              "const": "block",
                              "_metadata": {
                                "logical_name": "Block",
                                "docs::human_name": "Block"
                              }
                            },
                            {
                              "title": "Drops the event instead of waiting for free space in buffer.",
                              "description": "The event will be intentionally dropped. This mode is typically used when performance is the\nhighest priority, and it is preferable to temporarily lose events rather than cause a\nslowdown in the acceptance/consumption of events.",
                              "const": "drop_newest",
                              "_metadata": {
                                "logical_name": "DropNewest",
                                "docs::human_name": "Drop Newest"
                              }
                            },
                            {
                              "title": "Overflows to the next stage in the buffer topology.",
                              "description": "If the current buffer stage is full, attempt to send this event to the next buffer stage.\nThat stage may also be configured overflow, and so on, but ultimately the last stage in a\nbuffer topology must use one of the other handling behaviors. This means that next stage may\npotentially be able to buffer the event, but it may also block or drop the event.\n\nThis mode can only be used when two or more buffer stages are configured.",
                              "const": "overflow",
                              "_metadata": {
                                "docs::hidden": true,
                                "logical_name": "Overflow",
                                "docs::human_name": "Overflow"
                              }
                            }
                          ],
                          "unevaluatedProperties": false,
                          "_metadata": {
                            "docs::enum_tagging": "external",
                            "docs::human_name": "When Full"
                          }
                        }
                      },
                      "_metadata": {
                        "logical_name": "Memory",
                        "docs::human_name": "Memory"
                      }
                    },
                    {
                      "title": "Events are buffered on disk.",
                      "description": "This is less performant, but more durable. Data that has been synchronized to disk will not\nbe lost if Vector is restarted forcefully or crashes.\n\nData is synchronized to disk every 500ms.",
                      "type": "object",
                      "required": [
                        "max_size",
                        "type"
                      ],
                      "properties": {
                        "max_size": {
                          "title": "The maximum size of the buffer on disk.",
                          "description": "Must be at least ~256 megabytes (268435488 bytes).",
                          "type": "integer",
                          "maximum": 9007199254740991.0,
                          "minimum": 268435488.0,
                          "_metadata": {
                            "docs::numeric_type": "uint",
                            "docs::type_unit": "bytes",
                            "docs::human_name": "Max Size"
                          }
                        },
                        "type": {
                          "title": "Events are buffered on disk.",
                          "description": "This is less performant, but more durable. Data that has been synchronized to disk will not\nbe lost if Vector is restarted forcefully or crashes.\n\nData is synchronized to disk every 500ms.",
                          "const": "disk",
                          "_metadata": {
                            "docs::human_name": "Type"
                          }
                        },
                        "when_full": {
                          "description": "Event handling behavior when a buffer is full.",
                          "default": "block",
                          "oneOf": [
                            {
                              "title": "Wait for free space in the buffer.",
                              "description": "This applies backpressure up the topology, signalling that sources should slow down\nthe acceptance/consumption of events. This means that while no data is lost, data will pile\nup at the edge.",
                              "const": "block",
                              "_metadata": {
                                "logical_name": "Block",
                                "docs::human_name": "Block"
                              }
                            },
                            {
                              "title": "Drops the event instead of waiting for free space in buffer.",
                              "description": "The event will be intentionally dropped. This mode is typically used when performance is the\nhighest priority, and it is preferable to temporarily lose events rather than cause a\nslowdown in the acceptance/consumption of events.",
                              "const": "drop_newest",
                              "_metadata": {
                                "logical_name": "DropNewest",
                                "docs::human_name": "Drop Newest"
                              }
                            },
                            {
                              "title": "Overflows to the next stage in the buffer topology.",
                              "description": "If the current buffer stage is full, attempt to send this event to the next buffer stage.\nThat stage may also be configured overflow, and so on, but ultimately the last stage in a\nbuffer topology must use one of the other handling behaviors. This means that next stage may\npotentially be able to buffer the event, but it may also block or drop the event.\n\nThis mode can only be used when two or more buffer stages are configured.",
                              "const": "overflow",
                              "_metadata": {
                                "docs::hidden": true,
                                "logical_name": "Overflow",
                                "docs::human_name": "Overflow"
                              }
                            }
                          ],
                          "unevaluatedProperties": false,
                          "_metadata": {
                            "docs::enum_tagging": "external",
                            "docs::human_name": "When Full"
                          }
                        }
                      },
                      "_metadata": {
                        "logical_name": "DiskV2",
                        "docs::human_name": "Disk V2"
                      }
                    }
                  ],
                  "_metadata": {
                    "logical_name": "Single",
                    "docs::enum_tag_description": "The type of buffer to use.",
                    "docs::enum_tagging": "internal",
                    "docs::enum_tag_field": "type",
                    "docs::human_name": "Single"
                  }
                },
                {
                  "description": "A chained buffer topology.",
                  "type": "array",
                  "items": {
                    "description": "A specific type of buffer stage.",
                    "oneOf": [
                      {
                        "title": "Events are buffered in memory.",
                        "description": "This is more performant, but less durable. Data will be lost if Vector is restarted\nforcefully or crashes.",
                        "type": "object",
                        "required": [
                          "type"
                        ],
                        "properties": {
                          "max_events": {
                            "description": "The maximum number of events allowed in the buffer.",
                            "default": 500,
                            "type": "integer",
                            "maximum": 9007199254740991.0,
                            "minimum": 1.0,
                            "_metadata": {
                              "docs::numeric_type": "uint",
                              "docs::human_name": "Max Events"
                            }
                          },
                          "type": {
                            "title": "Events are buffered in memory.",
                            "description": "This is more performant, but less durable. Data will be lost if Vector is restarted\nforcefully or crashes.",
                            "const": "memory",
                            "_metadata": {
                              "docs::human_name": "Type"
                            }
                          },
                          "when_full": {
                            "description": "Event handling behavior when a buffer is full.",
                            "default": "block",
                            "oneOf": [
                              {
                                "title": "Wait for free space in the buffer.",
                                "description": "This applies backpressure up the topology, signalling that sources should slow down\nthe acceptance/consumption of events. This means that while no data is lost, data will pile\nup at the edge.",
                                "const": "block",
                                "_metadata": {
                                  "logical_name": "Block",
                                  "docs::human_name": "Block"
                                }
                              },
                              {
                                "title": "Drops the event instead of waiting for free space in buffer.",
                                "description": "The event will be intentionally dropped. This mode is typically used when performance is the\nhighest priority, and it is preferable to temporarily lose events rather than cause a\nslowdown in the acceptance/consumption of events.",
                                "const": "drop_newest",
                                "_metadata": {
                                  "logical_name": "DropNewest",
                                  "docs::human_name": "Drop Newest"
                                }
                              },
                              {
                                "title": "Overflows to the next stage in the buffer topology.",
                                "description": "If the current buffer stage is full, attempt to send this event to the next buffer stage.\nThat stage may also be configured overflow, and so on, but ultimately the last stage in a\nbuffer topology must use one of the other handling behaviors. This means that next stage may\npotentially be able to buffer the event, but it may also block or drop the event.\n\nThis mode can only be used when two or more buffer stages are configured.",
                                "const": "overflow",
                                "_metadata": {
                                  "docs::hidden": true,
                                  "logical_name": "Overflow",
                                  "docs::human_name": "Overflow"
                                }
                              }
                            ],
                            "unevaluatedProperties": false,
                            "_metadata": {
                              "docs::enum_tagging": "external",
                              "docs::human_name": "When Full"
                            }
                          }
                        },
                        "_metadata": {
                          "logical_name": "Memory",
                          "docs::human_name": "Memory"
                        }
                      },
                      {
                        "title": "Events are buffered on disk.",
                        "description": "This is less performant, but more durable. Data that has been synchronized to disk will not\nbe lost if Vector is restarted forcefully or crashes.\n\nData is synchronized to disk every 500ms.",
                        "type": "object",
                        "required": [
                          "max_size",
                          "type"
                        ],
                        "properties": {
                          "max_size": {
                            "title": "The maximum size of the buffer on disk.",
                            "description": "Must be at least ~256 megabytes (268435488 bytes).",
                            "type": "integer",
                            "maximum": 9007199254740991.0,
                            "minimum": 268435488.0,
                            "_metadata": {
                              "docs::numeric_type": "uint",
                              "docs::type_unit": "bytes",
                              "docs::human_name": "Max Size"
                            }
                          },
                          "type": {
                            "title": "Events are buffered on disk.",
                            "description": "This is less performant, but more durable. Data that has been synchronized to disk will not\nbe lost if Vector is restarted forcefully or crashes.\n\nData is synchronized to disk every 500ms.",
                            "const": "disk",
                            "_metadata": {
                              "docs::human_name": "Type"
                            }
                          },
                          "when_full": {
                            "description": "Event handling behavior when a buffer is full.",
                            "default": "block",
                            "oneOf": [
                              {
                                "title": "Wait for free space in the buffer.",
                                "description": "This applies backpressure up the topology, signalling that sources should slow down\nthe acceptance/consumption of events. This means that while no data is lost, data will pile\nup at the edge.",
                                "const": "block",
                                "_metadata": {
                                  "logical_name": "Block",
                                  "docs::human_name": "Block"
                                }
                              },
                              {
                                "title": "Drops the event instead of waiting for free space in buffer.",
                                "description": "The event will be intentionally dropped. This mode is typically used when performance is the\nhighest priority, and it is preferable to temporarily lose events rather than cause a\nslowdown in the acceptance/consumption of events.",
                                "const": "drop_newest",
                                "_metadata": {
                                  "logical_name": "DropNewest",
                                  "docs::human_name": "Drop Newest"
                                }
                              },
                              {
                                "title": "Overflows to the next stage in the buffer topology.",
                                "description": "If the current buffer stage is full, attempt to send this event to the next buffer stage.\nThat stage may also be configured overflow, and so on, but ultimately the last stage in a\nbuffer topology must use one of the other handling behaviors. This means that next stage may\npotentially be able to buffer the event, but it may also block or drop the event.\n\nThis mode can only be used when two or more buffer stages are configured.",
                                "const": "overflow",
                                "_metadata": {
                                  "docs::hidden": true,
                                  "logical_name": "Overflow",
                                  "docs::human_name": "Overflow"
                                }
                              }
                            ],
                            "unevaluatedProperties": false,
                            "_metadata": {
                              "docs::enum_tagging": "external",
                              "docs::human_name": "When Full"
                            }
                          }
                        },
                        "_metadata": {
                          "logical_name": "DiskV2",
                          "docs::human_name": "Disk V2"
                        }
                      }
                    ],
                    "unevaluatedProperties": false,
                    "_metadata": {
                      "docs::enum_tag_description": "The type of buffer to use.",
                      "docs::enum_tagging": "internal",
                      "docs::enum_tag_field": "type"
                    }
                  },
                  "_metadata": {
                    "docs::enum_tag_description": "The type of buffer to use.",
                    "docs::enum_tagging": "internal",
                    "docs::enum_tag_field": "type",
                    "logical_name": "Chained",
                    "docs::human_name": "Chained"
                  }
                }
              ],
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::enum_tagging": "untagged",
                "docs::human_name": "Buffer"
              }
            },
            "healthcheck": {
              "description": "Healthcheck configuration.",
              "default": {
                "enabled": true,
                "uri": null
              },
              "type": "object",
              "properties": {
                "enabled": {
                  "description": "Whether or not to check the health of the sink when Vector starts up.",
                  "type": "boolean",
                  "_metadata": {
                    "docs::human_name": "Enabled"
                  }
                },
                "uri": {
                  "title": "The full URI to make HTTP healthcheck requests to.",
                  "description": "This must be a valid URI, which requires at least the scheme and host. All other\ncomponents -- port, path, etc -- are allowed as well.",
                  "format": "uri",
                  "$ref": "#/definitions/core::option::Option<vector::sinks::util::uri::UriSerde>",
                  "_metadata": {
                    "docs::human_name": "URI"
                  }
                }
              },
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Healthcheck"
              }
            },
            "healthcheck_uri": {
              "title": "The full URI to make HTTP healthcheck requests to.",
              "description": "This must be a valid URI, which requires at least the scheme and host. All other\ncomponents -- port, path, etc -- are allowed as well.",
              "deprecated": true,
              "format": "uri",
              "$ref": "#/definitions/core::option::Option<vector::sinks::util::uri::UriSerde>",
              "_metadata": {
                "docs::hidden": true,
                "docs::human_name": "Healthcheck URI"
              }
            },
            "inputs": {
              "title": "A list of upstream [source][sources] or [transform][transforms] IDs.",
              "description": "Wildcards (`*`) are supported.\n\nSee [configuration][configuration] for more info.\n\n[sources]: https://vector.dev/docs/reference/configuration/sources/\n[transforms]: https://vector.dev/docs/reference/configuration/transforms/\n[configuration]: https://vector.dev/docs/reference/configuration/",
              "$ref": "#/definitions/vector::config::id::Inputs<alloc::string::String>",
              "_metadata": {
                "docs::human_name": "Inputs"
              }
            },
            "proxy": {
              "title": "Proxy configuration.",
              "description": "Configure to proxy traffic through an HTTP(S) proxy when making external requests.\n\nSimilar to common proxy configuration convention, you can set different proxies\nto use based on the type of traffic being proxied, as well as set specific hosts that\nshould not be proxied.",
              "default": {
                "enabled": true,
                "http": null,
                "https": null
              },
              "$ref": "#/definitions/vector_core::config::proxy::ProxyConfig",
              "_metadata": {
                "docs::human_name": "Proxy"
              }
            }
          }
        },
        {
          "description": "Configurable sinks in Vector.",
          "$ref": "#/definitions/vector::sinks::Sinks",
          "_metadata": {
            "docs::hidden": true
          }
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::component_base_type": "sink"
      }
    },
    "vector::config::source::SourceOuter": {
      "description": "Fully resolved source component.",
      "allOf": [
        {
          "type": "object",
          "properties": {
            "proxy": {
              "title": "Proxy configuration.",
              "description": "Configure to proxy traffic through an HTTP(S) proxy when making external requests.\n\nSimilar to common proxy configuration convention, you can set different proxies\nto use based on the type of traffic being proxied, as well as set specific hosts that\nshould not be proxied.",
              "default": {
                "enabled": true,
                "http": null,
                "https": null
              },
              "$ref": "#/definitions/vector_core::config::proxy::ProxyConfig",
              "_metadata": {
                "docs::human_name": "Proxy"
              }
            }
          }
        },
        {
          "description": "Configurable sources in Vector.",
          "$ref": "#/definitions/vector::sources::Sources",
          "_metadata": {
            "docs::hidden": true
          }
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::component_base_type": "source"
      }
    },
    "vector::config::transform::TransformOuter<alloc::string::String>": {
      "description": "Fully resolved transform component.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "inputs"
          ],
          "properties": {
            "inputs": {
              "title": "A list of upstream [source][sources] or [transform][transforms] IDs.",
              "description": "Wildcards (`*`) are supported.\n\nSee [configuration][configuration] for more info.\n\n[sources]: https://vector.dev/docs/reference/configuration/sources/\n[transforms]: https://vector.dev/docs/reference/configuration/transforms/\n[configuration]: https://vector.dev/docs/reference/configuration/",
              "$ref": "#/definitions/vector::config::id::Inputs<alloc::string::String>",
              "_metadata": {
                "docs::human_name": "Inputs"
              }
            }
          }
        },
        {
          "description": "Configurable transforms in Vector.",
          "$ref": "#/definitions/vector::transforms::Transforms",
          "_metadata": {
            "docs::hidden": true
          }
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::component_base_type": "transform"
      }
    },
    "vector::config::unit_test::unit_test_components::UnitTestSinkConfig": {
      "description": "Configuration for the `unit_test` sink.",
      "type": "object",
      "required": [
        "test_name",
        "transform_ids"
      ],
      "properties": {
        "test_name": {
          "description": "Name of the test that this sink is being used for.",
          "type": "string",
          "_metadata": {
            "docs::human_name": "Test Name"
          }
        },
        "transform_ids": {
          "description": "List of names of the transform/branch associated with this sink.",
          "type": "array",
          "items": {
            "type": "string"
          },
          "_metadata": {
            "docs::human_name": "Transform IDs"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "unit_test"
      }
    },
    "vector::config::unit_test::unit_test_components::UnitTestSourceConfig": {
      "description": "Configuration for the `unit_test` source.",
      "type": "object",
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "unit_test"
      }
    },
    "vector::config::unit_test::unit_test_components::UnitTestStreamSinkConfig": {
      "description": "Configuration for the `unit_test_stream` sink.",
      "type": "object",
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "unit_test_stream"
      }
    },
    "vector::config::unit_test::unit_test_components::UnitTestStreamSourceConfig": {
      "description": "Configuration for the `unit_test_stream` source.",
      "type": "object",
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "unit_test_stream"
      }
    },
    "vector::enrichment_tables::file::FileConfig": {
      "description": "Configuration for the `file` enrichment table.",
      "type": "object",
      "required": [
        "file"
      ],
      "properties": {
        "file": {
          "description": "File-specific settings.",
          "type": "object",
          "required": [
            "encoding",
            "path"
          ],
          "properties": {
            "encoding": {
              "description": "File encoding configuration.",
              "oneOf": [
                {
                  "title": "Decodes the file as a [CSV][csv] (comma-separated values) file.",
                  "description": "[csv]: https://wikipedia.org/wiki/Comma-separated_values",
                  "type": "object",
                  "required": [
                    "type"
                  ],
                  "properties": {
                    "delimiter": {
                      "description": "The delimiter used to separate fields in each row of the CSV file.",
                      "default": ",",
                      "type": "string",
                      "maxLength": 1,
                      "minLength": 1,
                      "_metadata": {
                        "docs::human_name": "Delimiter"
                      }
                    },
                    "include_headers": {
                      "title": "Whether or not the file contains column headers.",
                      "description": "When set to `true`, the first row of the CSV file will be read as the header row, and\nthe values will be used for the names of each column. This is the default behavior.\n\nWhen set to `false`, columns are referred to by their numerical index.",
                      "default": true,
                      "type": "boolean",
                      "_metadata": {
                        "docs::human_name": "Include Headers"
                      }
                    },
                    "type": {
                      "title": "Decodes the file as a [CSV][csv] (comma-separated values) file.",
                      "description": "[csv]: https://wikipedia.org/wiki/Comma-separated_values",
                      "const": "csv",
                      "_metadata": {
                        "docs::human_name": "Type"
                      }
                    }
                  },
                  "_metadata": {
                    "logical_name": "Csv",
                    "docs::human_name": "CSV"
                  }
                }
              ],
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::enum_tagging": "internal",
                "docs::enum_tag_field": "type",
                "docs::human_name": "Encoding"
              }
            },
            "path": {
              "title": "The path of the enrichment table file.",
              "description": "Currently, only [CSV][csv] files are supported.\n\n[csv]: https://en.wikipedia.org/wiki/Comma-separated_values",
              "$ref": "#/definitions/stdlib::PathBuf",
              "_metadata": {
                "docs::human_name": "Path"
              }
            }
          },
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::human_name": "File"
          }
        },
        "schema": {
          "title": "Key/value pairs representing mapped log field names and types.",
          "description": "This is used to coerce log fields from strings into their proper types. The available types are listed in the `Types` list below.\n\nTimestamp coercions need to be prefaced with `timestamp|`, for example `\"timestamp|%F\"`. Timestamp specifiers can use either of the following:\n\n1. One of the built-in-formats listed in the `Timestamp Formats` table below.\n2. The [time format specifiers][chrono_fmt] from Rust’s `chrono` library.\n\n### Types\n\n- **`bool`**\n- **`string`**\n- **`float`**\n- **`integer`**\n- **`date`**\n- **`timestamp`** (see the table below for formats)\n\n### Timestamp Formats\n\n| Format               | Description                                                                      | Example                          |\n|----------------------|----------------------------------------------------------------------------------|----------------------------------|\n| `%F %T`              | `YYYY-MM-DD HH:MM:SS`                                                            | `2020-12-01 02:37:54`            |\n| `%v %T`              | `DD-Mmm-YYYY HH:MM:SS`                                                           | `01-Dec-2020 02:37:54`           |\n| `%FT%T`              | [ISO 8601][iso8601]/[RFC 3339][rfc3339], without time zone                       | `2020-12-01T02:37:54`            |\n| `%FT%TZ`             | [ISO 8601][iso8601]/[RFC 3339][rfc3339], UTC                                     | `2020-12-01T09:37:54Z`           |\n| `%+`                 | [ISO 8601][iso8601]/[RFC 3339][rfc3339], UTC, with time zone                     | `2020-12-01T02:37:54-07:00`      |\n| `%a, %d %b %Y %T`    | [RFC 822][rfc822]/[RFC 2822][rfc2822], without time zone                         | `Tue, 01 Dec 2020 02:37:54`      |\n| `%a %b %e %T %Y`     | [ctime][ctime] format                                                            | `Tue Dec 1 02:37:54 2020`        |\n| `%s`                 | [UNIX timestamp][unix_ts]                                                        | `1606790274`                     |\n| `%a %d %b %T %Y`     | [date][date] command, without time zone                                          | `Tue 01 Dec 02:37:54 2020`       |\n| `%a %d %b %T %Z %Y`  | [date][date] command, with time zone                                             | `Tue 01 Dec 02:37:54 PST 2020`   |\n| `%a %d %b %T %z %Y`  | [date][date] command, with numeric time zone                                     | `Tue 01 Dec 02:37:54 -0700 2020` |\n| `%a %d %b %T %#z %Y` | [date][date] command, with numeric time zone (minutes can be missing or present) | `Tue 01 Dec 02:37:54 -07 2020`   |\n\n[date]: https://man7.org/linux/man-pages/man1/date.1.html\n[ctime]: https://www.cplusplus.com/reference/ctime\n[unix_ts]: https://en.wikipedia.org/wiki/Unix_time\n[rfc822]: https://tools.ietf.org/html/rfc822#section-5\n[rfc2822]: https://tools.ietf.org/html/rfc2822#section-3.3\n[iso8601]: https://en.wikipedia.org/wiki/ISO_8601\n[rfc3339]: https://tools.ietf.org/html/rfc3339\n[chrono_fmt]: https://docs.rs/chrono/latest/chrono/format/strftime/index.html#specifiers",
          "default": {},
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "_metadata": {
            "docs::human_name": "Schema"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "enrichment_table",
        "docs::component_name": "file"
      }
    },
    "vector::enrichment_tables::geoip::GeoipConfig": {
      "description": "Configuration for the `geoip` enrichment table.",
      "type": "object",
      "required": [
        "path"
      ],
      "properties": {
        "locale": {
          "title": "The locale to use when querying the database.",
          "description": "MaxMind includes localized versions of some of the fields within their database, such as\ncountry name. This setting can control which of those localized versions are returned by the\ntransform.\n\nMore information on which portions of the geolocation data are localized, and what languages\nare available, can be found [here][locale_docs].\n\n[locale_docs]: https://support.maxmind.com/hc/en-us/articles/4414877149467-IP-Geolocation-Data#h_01FRRGRYTGZB29ERDBZCX3MR8Q",
          "default": "en",
          "type": "string",
          "_metadata": {
            "docs::human_name": "Locale"
          }
        },
        "path": {
          "title": "Path to the [MaxMind GeoIP2][geoip2] or [GeoLite2 binary city database file][geolite2]\n(**GeoLite2-City.mmdb**).",
          "description": "Other databases, such as the country database, are not supported.\n\n[geoip2]: https://dev.maxmind.com/geoip/geoip2/downloadable\n[geolite2]: https://dev.maxmind.com/geoip/geoip2/geolite2/#Download_Access",
          "type": "string",
          "_metadata": {
            "docs::human_name": "Path"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "enrichment_table",
        "docs::component_name": "geoip"
      }
    },
    "vector::gcp::GcpAuthConfig": {
      "description": "Configuration of the authentication strategy for interacting with GCP services.",
      "type": "object",
      "properties": {
        "api_key": {
          "title": "An [API key][gcp_api_key].",
          "description": "Either an API key or a path to a service account credentials JSON file can be specified.\n\nIf both are unset, the `GOOGLE_APPLICATION_CREDENTIALS` environment variable is checked for a filename. If no\nfilename is named, an attempt is made to fetch an instance service account for the compute instance the program is\nrunning on. If this is not on a GCE instance, then you must define it with an API key or service account\ncredentials JSON file.\n\n[gcp_api_key]: https://cloud.google.com/docs/authentication/api-keys",
          "$ref": "#/definitions/core::option::Option<vector_common::sensitive_string::SensitiveString>",
          "_metadata": {
            "docs::human_name": "API Key"
          }
        },
        "credentials_path": {
          "title": "Path to a [service account][gcp_service_account_credentials] credentials JSON file.",
          "description": "Either an API key or a path to a service account credentials JSON file can be specified.\n\nIf both are unset, the `GOOGLE_APPLICATION_CREDENTIALS` environment variable is checked for a filename. If no\nfilename is named, an attempt is made to fetch an instance service account for the compute instance the program is\nrunning on. If this is not on a GCE instance, then you must define it with an API key or service account\ncredentials JSON file.\n\n[gcp_service_account_credentials]: https://cloud.google.com/docs/authentication/production#manually",
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Credentials Path"
          }
        },
        "skip_authentication": {
          "description": "Skip all authentication handling. For use with integration tests only.",
          "default": false,
          "type": "boolean",
          "_metadata": {
            "docs::hidden": true,
            "docs::human_name": "Skip Authentication"
          }
        }
      }
    },
    "vector::kafka::KafkaAuthConfig": {
      "description": "Kafka authentication configuration.",
      "type": "object",
      "properties": {
        "sasl": {
          "description": "Configuration for SASL authentication when interacting with Kafka.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "description": "Configuration for SASL authentication when interacting with Kafka.",
              "type": "object",
              "properties": {
                "enabled": {
                  "title": "Enables SASL authentication.",
                  "description": "Only `PLAIN`- and `SCRAM`-based mechanisms are supported when configuring SASL authentication using `sasl.*`. For\nother mechanisms, `librdkafka_options.*` must be used directly to configure other `librdkafka`-specific values.\nIf using `sasl.kerberos.*` as an example, where `*` is `service.name`, `principal`, `kinit.md`, etc., then\n`librdkafka_options.*` as a result becomes `librdkafka_options.sasl.kerberos.service.name`,\n`librdkafka_options.sasl.kerberos.principal`, etc.\n\nSee the [librdkafka documentation](https://github.com/edenhill/librdkafka/blob/master/CONFIGURATION.md) for details.\n\nSASL authentication is not supported on Windows.",
                  "type": [
                    "boolean",
                    "null"
                  ],
                  "_metadata": {
                    "docs::optional": true,
                    "docs::human_name": "Enabled"
                  }
                },
                "mechanism": {
                  "description": "The SASL mechanism to use.",
                  "type": [
                    "string",
                    "null"
                  ],
                  "_metadata": {
                    "docs::optional": true,
                    "docs::examples": [
                      "SCRAM-SHA-256",
                      "SCRAM-SHA-512"
                    ],
                    "docs::human_name": "Mechanism"
                  }
                },
                "password": {
                  "description": "The SASL password.",
                  "$ref": "#/definitions/core::option::Option<vector_common::sensitive_string::SensitiveString>",
                  "_metadata": {
                    "docs::examples": "password",
                    "docs::human_name": "Password"
                  }
                },
                "username": {
                  "description": "The SASL username.",
                  "type": [
                    "string",
                    "null"
                  ],
                  "_metadata": {
                    "docs::optional": true,
                    "docs::examples": "username",
                    "docs::human_name": "Username"
                  }
                }
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "SASL"
          }
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "TLS"
          }
        }
      }
    },
    "vector::providers::http::HttpConfig": {
      "description": "Configuration for the `http` provider.",
      "default": {
        "url": null,
        "request": {
          "headers": {}
        },
        "poll_interval_secs": 30
      },
      "allOf": [
        {
          "type": "object",
          "properties": {
            "poll_interval_secs": {
              "description": "How often to poll the provider, in seconds.",
              "type": "integer",
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::human_name": "Poll Interval Secs"
              }
            },
            "proxy": {
              "title": "Proxy configuration.",
              "description": "Configure to proxy traffic through an HTTP(S) proxy when making external requests.\n\nSimilar to common proxy configuration convention, you can set different proxies\nto use based on the type of traffic being proxied, as well as set specific hosts that\nshould not be proxied.",
              "default": {
                "enabled": true,
                "http": null,
                "https": null
              },
              "$ref": "#/definitions/vector_core::config::proxy::ProxyConfig",
              "_metadata": {
                "docs::human_name": "Proxy"
              }
            },
            "request": {
              "description": "Request settings.",
              "type": "object",
              "properties": {
                "headers": {
                  "description": "HTTP headers to add to the request.",
                  "default": {},
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  },
                  "_metadata": {
                    "docs::human_name": "Headers"
                  }
                }
              },
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::human_name": "Request"
              }
            },
            "url": {
              "description": "URL for the HTTP provider.",
              "type": [
                "string",
                "null"
              ],
              "format": "uri",
              "_metadata": {
                "docs::optional": true,
                "docs::human_name": "URL"
              }
            }
          }
        },
        {
          "description": "TLS configuration.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
            }
          ],
          "_metadata": {
            "docs::optional": true
          }
        }
      ],
      "_metadata": {
        "docs::component_type": "provider",
        "docs::component_name": "http"
      }
    },
    "vector::secrets::exec::ExecBackend": {
      "description": "Configuration for the `exec` secrets backend.",
      "type": "object",
      "required": [
        "command"
      ],
      "properties": {
        "command": {
          "title": "Command arguments to execute.",
          "description": "The path to the script or binary must be the first argument.",
          "type": "array",
          "items": {
            "type": "string"
          },
          "_metadata": {
            "docs::human_name": "Command"
          }
        },
        "timeout": {
          "description": "The timeout, in seconds, to wait for the command to complete.",
          "default": 5,
          "type": "integer",
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::human_name": "Timeout"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "secrets",
        "docs::component_name": "exec"
      }
    },
    "vector::secrets::test::TestBackend": {
      "description": "Configuration for the `test` secrets backend.",
      "type": "object",
      "required": [
        "replacement"
      ],
      "properties": {
        "replacement": {
          "description": "Fixed value to replace all secrets with.",
          "type": "string",
          "_metadata": {
            "docs::human_name": "Replacement"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "secrets",
        "docs::component_name": "test"
      }
    },
    "vector::sinks::Sinks": {
      "description": "Configurable sinks in Vector.",
      "oneOf": [
        {
          "description": "Send events to AMQP 0.9.1 compatible brokers like RabbitMQ.",
          "allOf": [
            {
              "title": "Configuration for the `amqp` sink.",
              "description": "Supports AMQP version 0.9.1",
              "$ref": "#/definitions/vector::sinks::amqp::config::AmqpSinkConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Send events to AMQP 0.9.1 compatible brokers like RabbitMQ.",
                  "const": "amqp",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "AMQP",
            "logical_name": "AmqpSink"
          }
        },
        {
          "description": "Deliver log and metric event data to AppSignal.",
          "allOf": [
            {
              "description": "Configuration for the `appsignal` sink.",
              "$ref": "#/definitions/vector::sinks::appsignal::config::AppsignalConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Deliver log and metric event data to AppSignal.",
                  "const": "appsignal",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "AppSignal",
            "logical_name": "Appsignal"
          }
        },
        {
          "description": "Publish log events to AWS CloudWatch Logs.",
          "allOf": [
            {
              "description": "Configuration for the `aws_cloudwatch_logs` sink.",
              "$ref": "#/definitions/vector::sinks::aws_cloudwatch_logs::config::CloudwatchLogsSinkConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Publish log events to AWS CloudWatch Logs.",
                  "const": "aws_cloudwatch_logs",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "AWS CloudWatch Logs",
            "logical_name": "CloudwatchLogsSink"
          }
        },
        {
          "description": "Publish metric events to AWS CloudWatch Metrics.",
          "allOf": [
            {
              "description": "Configuration for the `aws_cloudwatch_metrics` sink.",
              "$ref": "#/definitions/vector::sinks::aws_cloudwatch_metrics::CloudWatchMetricsSinkConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Publish metric events to AWS CloudWatch Metrics.",
                  "const": "aws_cloudwatch_metrics",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "AWS CloudWatch Metrics",
            "logical_name": "CloudWatchMetricsSink"
          }
        },
        {
          "description": "Publish logs to AWS Kinesis Data Firehose topics.",
          "allOf": [
            {
              "description": "Configuration for the `aws_kinesis_firehose` sink.",
              "$ref": "#/definitions/vector::sinks::aws_kinesis::firehose::config::KinesisFirehoseSinkConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Publish logs to AWS Kinesis Data Firehose topics.",
                  "const": "aws_kinesis_firehose",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "AWS Kinesis Firehose",
            "logical_name": "KinesisFirehoseSink"
          }
        },
        {
          "description": "Publish logs to AWS Kinesis Streams topics.",
          "allOf": [
            {
              "description": "Configuration for the `aws_kinesis_streams` sink.",
              "$ref": "#/definitions/vector::sinks::aws_kinesis::streams::config::KinesisStreamsSinkConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Publish logs to AWS Kinesis Streams topics.",
                  "const": "aws_kinesis_streams",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "AWS Kinesis Streams",
            "logical_name": "KinesisStreamsSink"
          }
        },
        {
          "description": "Store observability events in the AWS S3 object storage system.",
          "allOf": [
            {
              "description": "Configuration for the `aws_s3` sink.",
              "$ref": "#/definitions/vector::sinks::aws_s3::config::S3SinkConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Store observability events in the AWS S3 object storage system.",
                  "const": "aws_s3",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "AWS S3",
            "logical_name": "S3Sink"
          }
        },
        {
          "description": "Publish observability events to AWS Simple Notification Service topics.",
          "allOf": [
            {
              "description": "Configuration for the `aws_sns` sink.",
              "$ref": "#/definitions/vector::sinks::aws_s_s::sns::config::SnsSinkConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Publish observability events to AWS Simple Notification Service topics.",
                  "const": "aws_sns",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "AWS Sns",
            "logical_name": "SnsSink"
          }
        },
        {
          "description": "Publish observability events to AWS Simple Queue Service topics.",
          "allOf": [
            {
              "description": "Configuration for the `aws_sqs` sink.",
              "$ref": "#/definitions/vector::sinks::aws_s_s::sqs::config::SqsSinkConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Publish observability events to AWS Simple Queue Service topics.",
                  "const": "aws_sqs",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "AWS SQS",
            "logical_name": "SqsSink"
          }
        },
        {
          "description": "Deliver log events to Axiom.",
          "allOf": [
            {
              "description": "Configuration for the `axiom` sink.",
              "$ref": "#/definitions/vector::sinks::axiom::AxiomConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Deliver log events to Axiom.",
                  "const": "axiom",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Axiom",
            "logical_name": "Axiom"
          }
        },
        {
          "description": "Store your observability data in Azure Blob Storage.",
          "allOf": [
            {
              "description": "Configuration for the `azure_blob` sink.",
              "$ref": "#/definitions/vector::sinks::azure_blob::config::AzureBlobSinkConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Store your observability data in Azure Blob Storage.",
                  "const": "azure_blob",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Azure Blob",
            "logical_name": "AzureBlobSink"
          }
        },
        {
          "description": "Publish log events to the Azure Monitor Logs service.",
          "allOf": [
            {
              "description": "Configuration for the `azure_monitor_logs` sink.",
              "$ref": "#/definitions/vector::sinks::azure_monitor_logs::config::AzureMonitorLogsConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Publish log events to the Azure Monitor Logs service.",
                  "const": "azure_monitor_logs",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Azure Monitor Logs",
            "logical_name": "AzureMonitorLogs"
          }
        },
        {
          "description": "Send observability events nowhere, which can be useful for debugging purposes.",
          "allOf": [
            {
              "description": "Configuration for the `blackhole` sink.",
              "$ref": "#/definitions/vector::sinks::blackhole::config::BlackholeConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Send observability events nowhere, which can be useful for debugging purposes.",
                  "const": "blackhole",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Blackhole",
            "logical_name": "Blackhole"
          }
        },
        {
          "description": "Deliver log data to a ClickHouse database.",
          "allOf": [
            {
              "description": "Configuration for the `clickhouse` sink.",
              "$ref": "#/definitions/vector::sinks::clickhouse::config::ClickhouseConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Deliver log data to a ClickHouse database.",
                  "const": "clickhouse",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "ClickHouse",
            "logical_name": "Clickhouse"
          }
        },
        {
          "description": "Display observability events in the console, which can be useful for debugging purposes.",
          "allOf": [
            {
              "description": "Configuration for the `console` sink.",
              "$ref": "#/definitions/vector::sinks::console::config::ConsoleSinkConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Display observability events in the console, which can be useful for debugging purposes.",
                  "const": "console",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Console",
            "logical_name": "ConsoleSink"
          }
        },
        {
          "description": "Deliver log data to a Databend database.",
          "allOf": [
            {
              "description": "Configuration for the `databend` sink.",
              "$ref": "#/definitions/vector::sinks::databend::config::DatabendConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Deliver log data to a Databend database.",
                  "const": "databend",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Databend",
            "logical_name": "Databend"
          }
        },
        {
          "description": "Publish observability events to the Datadog Events API.",
          "allOf": [
            {
              "description": "Configuration for the `datadog_events` sink.",
              "$ref": "#/definitions/vector::sinks::datadog::events::config::DatadogEventsConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Publish observability events to the Datadog Events API.",
                  "const": "datadog_events",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Datadog Events",
            "logical_name": "DatadogEvents"
          }
        },
        {
          "description": "Publish log events to Datadog.",
          "allOf": [
            {
              "description": "Configuration for the `datadog_logs` sink.",
              "$ref": "#/definitions/vector::sinks::datadog::logs::config::DatadogLogsConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Publish log events to Datadog.",
                  "const": "datadog_logs",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Datadog Logs",
            "logical_name": "DatadogLogs"
          }
        },
        {
          "description": "Publish metric events to Datadog.",
          "allOf": [
            {
              "description": "Configuration for the `datadog_metrics` sink.",
              "$ref": "#/definitions/vector::sinks::datadog::metrics::config::DatadogMetricsConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Publish metric events to Datadog.",
                  "const": "datadog_metrics",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Datadog Metrics",
            "logical_name": "DatadogMetrics"
          }
        },
        {
          "description": "Publish trace events to Datadog.",
          "allOf": [
            {
              "description": "Configuration for the `datadog_traces` sink.",
              "$ref": "#/definitions/vector::sinks::datadog::traces::config::DatadogTracesConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Publish trace events to Datadog.",
                  "const": "datadog_traces",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Datadog Traces",
            "logical_name": "DatadogTraces"
          }
        },
        {
          "description": "Index observability events in Elasticsearch.",
          "allOf": [
            {
              "description": "Configuration for the `elasticsearch` sink.",
              "$ref": "#/definitions/vector::sinks::elasticsearch::config::ElasticsearchConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Index observability events in Elasticsearch.",
                  "const": "elasticsearch",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Elasticsearch",
            "logical_name": "Elasticsearch"
          }
        },
        {
          "description": "Output observability events into files.",
          "allOf": [
            {
              "description": "Configuration for the `file` sink.",
              "$ref": "#/definitions/vector::sinks::file::FileSinkConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Output observability events into files.",
                  "const": "file",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "File",
            "logical_name": "FileSink"
          }
        },
        {
          "description": "Store unstructured log events in Google Chronicle.",
          "allOf": [
            {
              "description": "Configuration for the `gcp_chronicle_unstructured` sink.",
              "$ref": "#/definitions/vector::sinks::gcp::chronicle_unstructured::ChronicleUnstructuredConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Store unstructured log events in Google Chronicle.",
                  "const": "gcp_chronicle_unstructured",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "GCP Chronicle Unstructured",
            "logical_name": "ChronicleUnstructured"
          }
        },
        {
          "description": "Store observability events in GCP Cloud Storage.",
          "allOf": [
            {
              "description": "Configuration for the `gcp_cloud_storage` sink.",
              "$ref": "#/definitions/vector::sinks::gcp::cloud_storage::GcsSinkConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Store observability events in GCP Cloud Storage.",
                  "const": "gcp_cloud_storage",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "GCP Cloud Storage",
            "logical_name": "GcsSink"
          }
        },
        {
          "description": "Publish observability events to GCP's Pub/Sub messaging system.",
          "allOf": [
            {
              "description": "Configuration for the `gcp_pubsub` sink.",
              "$ref": "#/definitions/vector::sinks::gcp::pubsub::PubsubConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Publish observability events to GCP's Pub/Sub messaging system.",
                  "const": "gcp_pubsub",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "GCP Pub/Sub",
            "logical_name": "Pubsub"
          }
        },
        {
          "description": "Deliver logs to GCP's Cloud Operations suite.",
          "allOf": [
            {
              "description": "Configuration for the `gcp_stackdriver_logs` sink.",
              "$ref": "#/definitions/vector::sinks::gcp::stackdriver::logs::config::StackdriverConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Deliver logs to GCP's Cloud Operations suite.",
                  "const": "gcp_stackdriver_logs",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "GCP Stackdriver Logs",
            "logical_name": "Stackdriver"
          }
        },
        {
          "description": "Deliver metrics to GCP's Cloud Monitoring system.",
          "allOf": [
            {
              "description": "Configuration for the `gcp_stackdriver_metrics` sink.",
              "$ref": "#/definitions/vector::sinks::gcp::stackdriver_metrics::StackdriverConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Deliver metrics to GCP's Cloud Monitoring system.",
                  "const": "gcp_stackdriver_metrics",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "GCP Stackdriver Metrics",
            "logical_name": "Stackdriver"
          }
        },
        {
          "description": "Ingest metrics data into GreptimeDB.",
          "allOf": [
            {
              "description": "Configuration items for GreptimeDB",
              "$ref": "#/definitions/vector::sinks::greptimedb::GreptimeDBConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Ingest metrics data into GreptimeDB.",
                  "const": "greptimedb",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Greptimedb",
            "logical_name": "GreptimeDB"
          }
        },
        {
          "description": "Deliver log events to Honeycomb.",
          "allOf": [
            {
              "description": "Configuration for the `honeycomb` sink.",
              "$ref": "#/definitions/vector::sinks::honeycomb::config::HoneycombConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Deliver log events to Honeycomb.",
                  "const": "honeycomb",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Honeycomb",
            "logical_name": "Honeycomb"
          }
        },
        {
          "description": "Deliver observability event data to an HTTP server.",
          "allOf": [
            {
              "description": "Configuration for the `http` sink.",
              "$ref": "#/definitions/vector::sinks::http::config::HttpSinkConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Deliver observability event data to an HTTP server.",
                  "const": "http",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "HTTP",
            "logical_name": "HttpSink"
          }
        },
        {
          "description": "Deliver log event data to Humio.",
          "allOf": [
            {
              "description": "Configuration for the `humio_logs` sink.",
              "$ref": "#/definitions/vector::sinks::humio::logs::HumioLogsConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Deliver log event data to Humio.",
                  "const": "humio_logs",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Humio Logs",
            "logical_name": "HumioLogs"
          }
        },
        {
          "description": "Deliver metric event data to Humio.",
          "allOf": [
            {
              "description": "Configuration for the `humio_metrics` sink.",
              "$ref": "#/definitions/vector::sinks::humio::metrics::HumioMetricsConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Deliver metric event data to Humio.",
                  "const": "humio_metrics",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Humio Metrics",
            "logical_name": "HumioMetrics"
          }
        },
        {
          "description": "Deliver log event data to InfluxDB.",
          "allOf": [
            {
              "description": "Configuration for the `influxdb_logs` sink.",
              "$ref": "#/definitions/vector::sinks::influxdb::logs::InfluxDbLogsConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Deliver log event data to InfluxDB.",
                  "const": "influxdb_logs",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "InfluxDB Logs",
            "logical_name": "InfluxDbLogs"
          }
        },
        {
          "description": "Deliver metric event data to InfluxDB.",
          "allOf": [
            {
              "description": "Configuration for the `influxdb_metrics` sink.",
              "$ref": "#/definitions/vector::sinks::influxdb::metrics::InfluxDbConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Deliver metric event data to InfluxDB.",
                  "const": "influxdb_metrics",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "InfluxDB Metrics",
            "logical_name": "InfluxDb"
          }
        },
        {
          "description": "Publish observability event data to Apache Kafka topics.",
          "allOf": [
            {
              "description": "Configuration for the `kafka` sink.",
              "$ref": "#/definitions/vector::sinks::kafka::config::KafkaSinkConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Publish observability event data to Apache Kafka topics.",
                  "const": "kafka",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Kafka",
            "logical_name": "KafkaSink"
          }
        },
        {
          "description": "Deliver log event data to LogDNA.",
          "allOf": [
            {
              "description": "Configuration for the `logdna` sink.",
              "$ref": "#/definitions/vector::sinks::mezmo::LogdnaConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Deliver log event data to LogDNA.",
                  "const": "logdna",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "LogDNA",
            "logical_name": "Logdna"
          }
        },
        {
          "description": "Deliver log event data to the Loki aggregation system.",
          "allOf": [
            {
              "description": "Configuration for the `loki` sink.",
              "$ref": "#/definitions/vector::sinks::loki::config::LokiConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Deliver log event data to the Loki aggregation system.",
                  "const": "loki",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Loki",
            "logical_name": "Loki"
          }
        },
        {
          "description": "Deliver log event data to Mezmo.",
          "allOf": [
            {
              "description": "Configuration for the `mezmo` (formerly `logdna`) sink.",
              "$ref": "#/definitions/vector::sinks::mezmo::MezmoConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Deliver log event data to Mezmo.",
                  "const": "mezmo",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Mezmo",
            "logical_name": "Mezmo"
          }
        },
        {
          "description": "Publish observability data to subjects on the NATS messaging system.",
          "allOf": [
            {
              "description": "Configuration for the `nats` sink.",
              "$ref": "#/definitions/vector::sinks::nats::config::NatsSinkConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Publish observability data to subjects on the NATS messaging system.",
                  "const": "nats",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "NATS",
            "logical_name": "NatsSink"
          }
        },
        {
          "description": "Deliver events to New Relic.",
          "allOf": [
            {
              "description": "Configuration for the `new_relic` sink.",
              "$ref": "#/definitions/vector::sinks::new_relic::config::NewRelicConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Deliver events to New Relic.",
                  "const": "new_relic",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "New Relic",
            "logical_name": "NewRelic"
          }
        },
        {
          "description": "Deliver log events to Papertrail from SolarWinds.",
          "allOf": [
            {
              "description": "Configuration for the `papertrail` sink.",
              "$ref": "#/definitions/vector::sinks::papertrail::PapertrailConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Deliver log events to Papertrail from SolarWinds.",
                  "const": "papertrail",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Papertrail",
            "logical_name": "Papertrail"
          }
        },
        {
          "description": "Expose metric events on a Prometheus compatible endpoint.",
          "allOf": [
            {
              "description": "Configuration for the `prometheus_exporter` sink.",
              "$ref": "#/definitions/vector::sinks::prometheus::exporter::PrometheusExporterConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Expose metric events on a Prometheus compatible endpoint.",
                  "const": "prometheus_exporter",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Prometheus Exporter",
            "logical_name": "PrometheusExporter"
          }
        },
        {
          "description": "Deliver metric data to a Prometheus remote write endpoint.",
          "allOf": [
            {
              "description": "Configuration for the `prometheus_remote_write` sink.",
              "$ref": "#/definitions/vector::sinks::prometheus::remote_write::RemoteWriteConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Deliver metric data to a Prometheus remote write endpoint.",
                  "const": "prometheus_remote_write",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Prometheus Remote Write",
            "logical_name": "RemoteWrite"
          }
        },
        {
          "description": "Publish observability events to Apache Pulsar topics.",
          "allOf": [
            {
              "description": "Configuration for the `pulsar` sink.",
              "$ref": "#/definitions/vector::sinks::pulsar::config::PulsarSinkConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Publish observability events to Apache Pulsar topics.",
                  "const": "pulsar",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Pulsar",
            "logical_name": "PulsarSink"
          }
        },
        {
          "description": "Publish observability data to Redis.",
          "allOf": [
            {
              "description": "Configuration for the `redis` sink.",
              "$ref": "#/definitions/vector::sinks::redis::config::RedisSinkConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Publish observability data to Redis.",
                  "const": "redis",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Redis",
            "logical_name": "RedisSink"
          }
        },
        {
          "description": "Publish log events to Sematext.",
          "allOf": [
            {
              "description": "Configuration for the `sematext_logs` sink.",
              "$ref": "#/definitions/vector::sinks::sematext::logs::SematextLogsConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Publish log events to Sematext.",
                  "const": "sematext_logs",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Sematext Logs",
            "logical_name": "SematextLogs"
          }
        },
        {
          "description": "Publish metric events to Sematext.",
          "allOf": [
            {
              "description": "Configuration for the `sematext_metrics` sink.",
              "$ref": "#/definitions/vector::sinks::sematext::metrics::SematextMetricsConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Publish metric events to Sematext.",
                  "const": "sematext_metrics",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Sematext Metrics",
            "logical_name": "SematextMetrics"
          }
        },
        {
          "description": "Deliver logs to a remote socket endpoint.",
          "allOf": [
            {
              "description": "Configuration for the `socket` sink.",
              "$ref": "#/definitions/vector::sinks::socket::SocketSinkConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Deliver logs to a remote socket endpoint.",
                  "const": "socket",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Socket",
            "logical_name": "SocketSink"
          }
        },
        {
          "description": "Deliver log data to Splunk's HTTP Event Collector.",
          "allOf": [
            {
              "description": "Configuration for the `splunk_hec_logs` sink.",
              "$ref": "#/definitions/vector::sinks::splunk_hec::logs::config::HecLogsSinkConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Deliver log data to Splunk's HTTP Event Collector.",
                  "const": "splunk_hec_logs",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Splunk HEC Logs",
            "logical_name": "HecLogsSink"
          }
        },
        {
          "description": "Deliver metric data to Splunk's HTTP Event Collector.",
          "allOf": [
            {
              "description": "Configuration of the `splunk_hec_metrics` sink.",
              "$ref": "#/definitions/vector::sinks::splunk_hec::metrics::config::HecMetricsSinkConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Deliver metric data to Splunk's HTTP Event Collector.",
                  "const": "splunk_hec_metrics",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Splunk HEC Metrics",
            "logical_name": "HecMetricsSink"
          }
        },
        {
          "description": "Deliver metric data to a StatsD aggregator.",
          "allOf": [
            {
              "description": "Configuration for the `statsd` sink.",
              "$ref": "#/definitions/vector::sinks::statsd::config::StatsdSinkConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Deliver metric data to a StatsD aggregator.",
                  "const": "statsd",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "StatsD",
            "logical_name": "StatsdSink"
          }
        },
        {
          "description": "Unit test.",
          "allOf": [
            {
              "description": "Configuration for the `unit_test` sink.",
              "$ref": "#/definitions/vector::config::unit_test::unit_test_components::UnitTestSinkConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Unit test.",
                  "const": "unit_test",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Unit Test",
            "logical_name": "UnitTestSink"
          }
        },
        {
          "description": "Unit test stream.",
          "allOf": [
            {
              "description": "Configuration for the `unit_test_stream` sink.",
              "$ref": "#/definitions/vector::config::unit_test::unit_test_components::UnitTestStreamSinkConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Unit test stream.",
                  "const": "unit_test_stream",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Unit Test Stream",
            "logical_name": "UnitTestStreamSink"
          }
        },
        {
          "description": "Relay observability data to a Vector instance.",
          "allOf": [
            {
              "description": "Configuration for the `vector` sink.",
              "$ref": "#/definitions/vector::sinks::vector::config::VectorConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Relay observability data to a Vector instance.",
                  "const": "vector",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Vector",
            "logical_name": "Vector"
          }
        },
        {
          "description": "WebHDFS.",
          "allOf": [
            {
              "description": "Configuration for the `webhdfs` sink.",
              "$ref": "#/definitions/vector::sinks::webhdfs::config::WebHdfsConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "WebHDFS.",
                  "const": "webhdfs",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "WebHDFS",
            "logical_name": "WebHdfs"
          }
        },
        {
          "description": "Deliver observability event data to a websocket listener.",
          "allOf": [
            {
              "description": "Configuration for the `websocket` sink.",
              "$ref": "#/definitions/vector::sinks::websocket::config::WebSocketSinkConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Deliver observability event data to a websocket listener.",
                  "const": "websocket",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Websocket",
            "logical_name": "WebSocketSink"
          }
        }
      ],
      "_metadata": {
        "docs::enum_tagging": "internal",
        "docs::enum_tag_field": "type"
      }
    },
    "vector::sinks::amqp::config::AmqpSinkConfig": {
      "title": "Configuration for the `amqp` sink.",
      "description": "Supports AMQP version 0.9.1",
      "allOf": [
        {
          "type": "object",
          "required": [
            "encoding",
            "exchange"
          ],
          "properties": {
            "acknowledgements": {
              "title": "Controls how acknowledgements are handled for this sink.",
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              }
            },
            "encoding": {
              "description": "Configures how events are encoded into raw bytes.",
              "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
              "_metadata": {
                "docs::human_name": "Encoding"
              }
            },
            "exchange": {
              "description": "The exchange to publish messages to.",
              "$ref": "#/definitions/vector::template::Template",
              "_metadata": {
                "docs::human_name": "Exchange"
              }
            },
            "properties": {
              "title": "Configure the AMQP message properties.",
              "description": "AMQP message properties.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "title": "Configure the AMQP message properties.",
                  "description": "AMQP properties configuration.",
                  "type": "object",
                  "properties": {
                    "content_encoding": {
                      "description": "Content-Encoding for the AMQP messages.",
                      "type": [
                        "string",
                        "null"
                      ],
                      "_metadata": {
                        "docs::optional": true,
                        "docs::human_name": "Content Encoding"
                      }
                    },
                    "content_type": {
                      "description": "Content-Type for the AMQP messages.",
                      "type": [
                        "string",
                        "null"
                      ],
                      "_metadata": {
                        "docs::optional": true,
                        "docs::human_name": "Content Type"
                      }
                    }
                  }
                }
              ],
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::optional": true,
                "docs::human_name": "Properties"
              }
            },
            "routing_key": {
              "description": "Template used to generate a routing key which corresponds to a queue binding.",
              "$ref": "#/definitions/core::option::Option<vector::template::Template>",
              "_metadata": {
                "docs::human_name": "Routing Key"
              }
            }
          }
        },
        {
          "description": "AMQP connection options.",
          "$ref": "#/definitions/vector::amqp::AmqpConfig"
        }
      ],
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "amqp"
      }
    },
    "vector::sinks::appsignal::config::AppsignalConfig": {
      "description": "Configuration for the `appsignal` sink.",
      "type": "object",
      "required": [
        "push_api_key"
      ],
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled for this sink.",
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "type": "object",
          "properties": {
            "max_bytes": {
              "title": "The maximum size of a batch that is processed by a sink.",
              "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
              "default": 450000,
              "type": [
                "integer",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "bytes",
                "docs::human_name": "Max Bytes"
              }
            },
            "max_events": {
              "description": "The maximum size of a batch before it is flushed.",
              "default": 100,
              "type": [
                "integer",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "events",
                "docs::human_name": "Max Events"
              }
            },
            "timeout_secs": {
              "description": "The maximum age of a batch before it is flushed.",
              "default": 1.0,
              "type": [
                "number",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": -9007199254740991.0,
              "_metadata": {
                "docs::numeric_type": "float",
                "docs::optional": true,
                "docs::type_unit": "seconds",
                "docs::human_name": "Timeout"
              }
            }
          },
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Batch"
          }
        },
        "compression": {
          "title": "Compression configuration.",
          "description": "All compression algorithms use the default compression level unless otherwise specified.",
          "default": "gzip",
          "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
          "_metadata": {
            "docs::human_name": "Compression"
          }
        },
        "encoding": {
          "description": "Transformations to prepare an event for serialization.",
          "default": {},
          "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer",
          "_metadata": {
            "docs::human_name": "Encoding"
          }
        },
        "endpoint": {
          "description": "The URI for the AppSignal API to send data to.",
          "default": "https://appsignal-endpoint.net",
          "type": "string",
          "format": "uri",
          "_metadata": {
            "docs::examples": "https://appsignal-endpoint.net",
            "docs::human_name": "Endpoint"
          }
        },
        "push_api_key": {
          "description": "A valid app-level AppSignal Push API key.",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "docs::examples": [
              "00000000-0000-0000-0000-000000000000",
              "${APPSIGNAL_PUSH_API_KEY}"
            ],
            "docs::human_name": "Push API Key"
          }
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "initial_concurrency": 1,
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          }
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "appsignal"
      }
    },
    "vector::sinks::aws_cloudwatch_logs::config::CloudwatchLogsSinkConfig": {
      "description": "Configuration for the `aws_cloudwatch_logs` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "encoding",
            "group_name",
            "stream_name"
          ],
          "properties": {
            "acknowledgements": {
              "title": "Controls how acknowledgements are handled for this sink.",
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              }
            },
            "assume_role": {
              "title": "The ARN of an [IAM role][iam_role] to assume at startup.",
              "description": "[iam_role]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html",
              "deprecated": true,
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::hidden": true,
                "docs::human_name": "Assume Role"
              }
            },
            "auth": {
              "description": "Configuration of the authentication strategy for interacting with AWS services.",
              "default": {
                "load_timeout_secs": null,
                "imds": {
                  "max_attempts": 4,
                  "connect_timeout_seconds": 1,
                  "read_timeout_seconds": 1
                },
                "region": null
              },
              "$ref": "#/definitions/vector::aws::auth::AwsAuthentication",
              "_metadata": {
                "docs::human_name": "Auth"
              }
            },
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "type": "object",
              "properties": {
                "max_bytes": {
                  "title": "The maximum size of a batch that is processed by a sink.",
                  "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
                  "default": 1048576,
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes",
                    "docs::human_name": "Max Bytes"
                  }
                },
                "max_events": {
                  "description": "The maximum size of a batch before it is flushed.",
                  "default": 10000,
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "events",
                    "docs::human_name": "Max Events"
                  }
                },
                "timeout_secs": {
                  "description": "The maximum age of a batch before it is flushed.",
                  "default": 1.0,
                  "type": [
                    "number",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": -9007199254740991.0,
                  "_metadata": {
                    "docs::numeric_type": "float",
                    "docs::optional": true,
                    "docs::type_unit": "seconds",
                    "docs::human_name": "Timeout"
                  }
                }
              },
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Batch"
              }
            },
            "compression": {
              "title": "Compression configuration.",
              "description": "All compression algorithms use the default compression level unless otherwise specified.",
              "default": "none",
              "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
              "_metadata": {
                "docs::human_name": "Compression"
              }
            },
            "create_missing_group": {
              "title": "Dynamically create a [log group][log_group] if it does not already exist.",
              "description": "This ignores `create_missing_stream` directly after creating the group and creates\nthe first stream.\n\n[log_group]: https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html",
              "default": true,
              "type": "boolean",
              "_metadata": {
                "docs::human_name": "Create Missing Group"
              }
            },
            "create_missing_stream": {
              "title": "Dynamically create a [log stream][log_stream] if it does not already exist.",
              "description": "[log_stream]: https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html",
              "default": true,
              "type": "boolean",
              "_metadata": {
                "docs::human_name": "Create Missing Stream"
              }
            },
            "encoding": {
              "description": "Configures how events are encoded into raw bytes.",
              "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
              "_metadata": {
                "docs::human_name": "Encoding"
              }
            },
            "group_name": {
              "title": "The [group name][group_name] of the target CloudWatch Logs stream.",
              "description": "[group_name]: https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html",
              "$ref": "#/definitions/vector::template::Template",
              "_metadata": {
                "docs::examples": [
                  "group-name",
                  "{{ file }}"
                ],
                "docs::human_name": "Group Name"
              }
            },
            "request": {
              "description": "Outbound HTTP request settings.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "initial_concurrency": 1,
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                },
                "headers": {}
              },
              "$ref": "#/definitions/vector::sinks::util::http::RequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              }
            },
            "stream_name": {
              "title": "The [stream name][stream_name] of the target CloudWatch Logs stream.",
              "description": "There can only be one writer to a log stream at a time. If multiple instances are writing to\nthe same log group, the stream name must include an identifier that is guaranteed to be\nunique per instance.\n\n[stream_name]: https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html",
              "$ref": "#/definitions/vector::template::Template",
              "_metadata": {
                "docs::examples": [
                  "{{ host }}",
                  "%Y-%m-%d",
                  "stream-name"
                ],
                "docs::human_name": "Stream Name"
              }
            },
            "tls": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              }
            }
          }
        },
        {
          "title": "The [AWS region][aws_region] of the target service.",
          "description": "[aws_region]: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html",
          "$ref": "#/definitions/vector::aws::region::RegionOrEndpoint"
        }
      ],
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "aws_cloudwatch_logs"
      }
    },
    "vector::sinks::aws_cloudwatch_metrics::CloudWatchMetricsSinkConfig": {
      "description": "Configuration for the `aws_cloudwatch_metrics` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "default_namespace"
          ],
          "properties": {
            "acknowledgements": {
              "title": "Controls how acknowledgements are handled for this sink.",
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              }
            },
            "assume_role": {
              "title": "The ARN of an [IAM role][iam_role] to assume at startup.",
              "description": "[iam_role]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html",
              "deprecated": true,
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::hidden": true,
                "docs::human_name": "Assume Role"
              }
            },
            "auth": {
              "description": "Configuration of the authentication strategy for interacting with AWS services.",
              "default": {
                "load_timeout_secs": null,
                "imds": {
                  "max_attempts": 4,
                  "connect_timeout_seconds": 1,
                  "read_timeout_seconds": 1
                },
                "region": null
              },
              "$ref": "#/definitions/vector::aws::auth::AwsAuthentication",
              "_metadata": {
                "docs::human_name": "Auth"
              }
            },
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "type": "object",
              "properties": {
                "max_bytes": {
                  "title": "The maximum size of a batch that is processed by a sink.",
                  "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
                  "default": null,
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes",
                    "docs::human_name": "Max Bytes"
                  }
                },
                "max_events": {
                  "description": "The maximum size of a batch before it is flushed.",
                  "default": 20,
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "events",
                    "docs::human_name": "Max Events"
                  }
                },
                "timeout_secs": {
                  "description": "The maximum age of a batch before it is flushed.",
                  "default": 1.0,
                  "type": [
                    "number",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": -9007199254740991.0,
                  "_metadata": {
                    "docs::numeric_type": "float",
                    "docs::optional": true,
                    "docs::type_unit": "seconds",
                    "docs::human_name": "Timeout"
                  }
                }
              },
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Batch"
              }
            },
            "compression": {
              "title": "Compression configuration.",
              "description": "All compression algorithms use the default compression level unless otherwise specified.",
              "default": "none",
              "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
              "_metadata": {
                "docs::human_name": "Compression"
              }
            },
            "default_namespace": {
              "title": "The default [namespace][namespace] to use for metrics that do not have one.",
              "description": "Metrics with the same name can only be differentiated by their namespace, and not all\nmetrics have their own namespace.\n\n[namespace]: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Namespace",
              "type": "string",
              "_metadata": {
                "docs::examples": "service",
                "docs::human_name": "Default Namespace"
              }
            },
            "request": {
              "title": "Middleware settings for outbound requests.",
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "initial_concurrency": 1,
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                }
              },
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              }
            },
            "tls": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              }
            }
          }
        },
        {
          "title": "The [AWS region][aws_region] of the target service.",
          "description": "[aws_region]: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html",
          "$ref": "#/definitions/vector::aws::region::RegionOrEndpoint"
        }
      ],
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "aws_cloudwatch_metrics"
      }
    },
    "vector::sinks::aws_kinesis::config::KinesisSinkBaseConfig": {
      "description": "Base configuration for the `aws_kinesis_` sinks.\nThe actual specific sink configuration types should either wrap this in a newtype wrapper,\nor should extend it in a new struct with `serde(flatten)`.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "encoding",
            "stream_name"
          ],
          "properties": {
            "acknowledgements": {
              "title": "Controls how acknowledgements are handled for this sink.",
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              }
            },
            "auth": {
              "description": "Configuration of the authentication strategy for interacting with AWS services.",
              "default": {
                "load_timeout_secs": null,
                "imds": {
                  "max_attempts": 4,
                  "connect_timeout_seconds": 1,
                  "read_timeout_seconds": 1
                },
                "region": null
              },
              "$ref": "#/definitions/vector::aws::auth::AwsAuthentication",
              "_metadata": {
                "docs::human_name": "Auth"
              }
            },
            "compression": {
              "title": "Compression configuration.",
              "description": "All compression algorithms use the default compression level unless otherwise specified.",
              "default": "none",
              "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
              "_metadata": {
                "docs::human_name": "Compression"
              }
            },
            "encoding": {
              "description": "Configures how events are encoded into raw bytes.",
              "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
              "_metadata": {
                "docs::human_name": "Encoding"
              }
            },
            "request": {
              "title": "Middleware settings for outbound requests.",
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "initial_concurrency": 1,
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                }
              },
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              }
            },
            "request_retry_partial": {
              "description": "Whether or not to retry successful requests containing partial failures.",
              "default": false,
              "type": "boolean",
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Request Retry Partial"
              }
            },
            "stream_name": {
              "title": "The [stream name][stream_name] of the target Kinesis Firehose delivery stream.",
              "description": "[stream_name]: https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html",
              "type": "string",
              "_metadata": {
                "docs::examples": "my-stream",
                "docs::human_name": "Stream Name"
              }
            },
            "tls": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              }
            }
          }
        },
        {
          "description": "Configuration of the region/endpoint to use when interacting with an AWS service.",
          "$ref": "#/definitions/vector::aws::region::RegionOrEndpoint"
        }
      ]
    },
    "vector::sinks::aws_kinesis::firehose::config::KinesisFirehoseSinkConfig": {
      "description": "Configuration for the `aws_kinesis_firehose` sink.",
      "allOf": [
        {
          "type": "object",
          "properties": {
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "type": "object",
              "properties": {
                "max_bytes": {
                  "title": "The maximum size of a batch that is processed by a sink.",
                  "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
                  "default": 4194304,
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes",
                    "docs::human_name": "Max Bytes"
                  }
                },
                "max_events": {
                  "description": "The maximum size of a batch before it is flushed.",
                  "default": 500,
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "events",
                    "docs::human_name": "Max Events"
                  }
                },
                "timeout_secs": {
                  "description": "The maximum age of a batch before it is flushed.",
                  "default": 1.0,
                  "type": [
                    "number",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": -9007199254740991.0,
                  "_metadata": {
                    "docs::numeric_type": "float",
                    "docs::optional": true,
                    "docs::type_unit": "seconds",
                    "docs::human_name": "Timeout"
                  }
                }
              },
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Batch"
              }
            }
          }
        },
        {
          "description": "Base configuration for the `aws_kinesis_` sinks.\nThe actual specific sink configuration types should either wrap this in a newtype wrapper,\nor should extend it in a new struct with `serde(flatten)`.",
          "$ref": "#/definitions/vector::sinks::aws_kinesis::config::KinesisSinkBaseConfig"
        }
      ],
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "aws_kinesis_firehose"
      }
    },
    "vector::sinks::aws_kinesis::streams::config::KinesisStreamsSinkConfig": {
      "description": "Configuration for the `aws_kinesis_streams` sink.",
      "allOf": [
        {
          "type": "object",
          "properties": {
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "type": "object",
              "properties": {
                "max_bytes": {
                  "title": "The maximum size of a batch that is processed by a sink.",
                  "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
                  "default": 5000000,
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes",
                    "docs::human_name": "Max Bytes"
                  }
                },
                "max_events": {
                  "description": "The maximum size of a batch before it is flushed.",
                  "default": 500,
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "events",
                    "docs::human_name": "Max Events"
                  }
                },
                "timeout_secs": {
                  "description": "The maximum age of a batch before it is flushed.",
                  "default": 1.0,
                  "type": [
                    "number",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": -9007199254740991.0,
                  "_metadata": {
                    "docs::numeric_type": "float",
                    "docs::optional": true,
                    "docs::type_unit": "seconds",
                    "docs::human_name": "Timeout"
                  }
                }
              },
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Batch"
              }
            },
            "partition_key_field": {
              "title": "The log field used as the Kinesis record’s partition key value.",
              "description": "If not specified, a unique partition key is generated for each Kinesis record.",
              "$ref": "#/definitions/core::option::Option<vector_lookup::lookup_v2::ConfigValuePath>",
              "_metadata": {
                "docs::examples": "user_id",
                "docs::human_name": "Partition Key Field"
              }
            }
          }
        },
        {
          "description": "Base configuration for the `aws_kinesis_` sinks.\nThe actual specific sink configuration types should either wrap this in a newtype wrapper,\nor should extend it in a new struct with `serde(flatten)`.",
          "$ref": "#/definitions/vector::sinks::aws_kinesis::config::KinesisSinkBaseConfig"
        }
      ],
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "aws_kinesis_streams"
      }
    },
    "vector::sinks::aws_s3::config::S3SinkConfig": {
      "description": "Configuration for the `aws_s3` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "bucket"
          ],
          "properties": {
            "acknowledgements": {
              "title": "Controls how acknowledgements are handled for this sink.",
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              }
            },
            "auth": {
              "description": "Configuration of the authentication strategy for interacting with AWS services.",
              "default": {
                "load_timeout_secs": null,
                "imds": {
                  "max_attempts": 4,
                  "connect_timeout_seconds": 1,
                  "read_timeout_seconds": 1
                },
                "region": null
              },
              "$ref": "#/definitions/vector::aws::auth::AwsAuthentication",
              "_metadata": {
                "docs::human_name": "Auth"
              }
            },
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::BulkSizeBasedDefaultBatchSettings>",
              "_metadata": {
                "docs::human_name": "Batch"
              }
            },
            "bucket": {
              "title": "The S3 bucket name.",
              "description": "This must not include a leading `s3://` or a trailing `/`.",
              "type": "string",
              "_metadata": {
                "docs::examples": "my-bucket",
                "docs::human_name": "Bucket"
              }
            },
            "compression": {
              "title": "Compression configuration.",
              "description": "All compression algorithms use the default compression level unless otherwise specified.\n\nSome cloud storage API clients and browsers handle decompression transparently, so\ndepending on how they are accessed, files may not always appear to be compressed.",
              "default": "gzip",
              "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
              "_metadata": {
                "docs::human_name": "Compression"
              }
            },
            "filename_append_uuid": {
              "title": "Whether or not to append a UUID v4 token to the end of the object key.",
              "description": "The UUID is appended to the timestamp portion of the object key, such that if the object key\ngenerated is `date=2022-07-18/1658176486`, setting this field to `true` results\nin an object key that looks like `date=2022-07-18/1658176486-30f6652c-71da-4f9f-800d-a1189c47c547`.\n\nThis ensures there are no name collisions, and can be useful in high-volume workloads where\nobject keys must be unique.",
              "default": true,
              "type": "boolean",
              "_metadata": {
                "docs::human_name": "Append UUID to Filename"
              }
            },
            "filename_extension": {
              "title": "The filename extension to use in the object key.",
              "description": "This overrides setting the extension based on the configured `compression`.",
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::examples": "json",
                "docs::human_name": "Filename Extension"
              }
            },
            "filename_time_format": {
              "title": "The timestamp format for the time component of the object key.",
              "description": "By default, object keys are appended with a timestamp that reflects when the objects are\nsent to S3, such that the resulting object key is functionally equivalent to joining the key\nprefix with the formatted timestamp, such as `date=2022-07-18/1658176486`.\n\nThis would represent a `key_prefix` set to `date=%F/` and the timestamp of Mon Jul 18 2022\n20:34:44 GMT+0000, with the `filename_time_format` being set to `%s`, which renders\ntimestamps in seconds since the Unix epoch.\n\nSupports the common [`strftime`][chrono_strftime_specifiers] specifiers found in most\nlanguages.\n\nWhen set to an empty string, no timestamp is appended to the key prefix.\n\n[chrono_strftime_specifiers]: https://docs.rs/chrono/latest/chrono/format/strftime/index.html#specifiers",
              "default": "%s",
              "type": "string",
              "_metadata": {
                "docs::human_name": "Filename Time Format"
              }
            },
            "key_prefix": {
              "title": "A prefix to apply to all object keys.",
              "description": "Prefixes are useful for partitioning objects, such as by creating an object key that\nstores objects under a particular directory. If using a prefix for this purpose, it must end\nin `/` to act as a directory path. A trailing `/` is **not** automatically added.",
              "default": "date=%F",
              "type": "string",
              "_metadata": {
                "docs::templateable": true,
                "docs::examples": [
                  "date=%F/hour=%H",
                  "year=%Y/month=%m/day=%d",
                  "application_id={{ application_id }}/date=%F"
                ],
                "docs::human_name": "Key Prefix"
              }
            },
            "request": {
              "title": "Middleware settings for outbound requests.",
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "initial_concurrency": 1,
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                }
              },
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              }
            },
            "tls": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              }
            }
          }
        },
        {
          "description": "Per-operation configuration when writing objects to S3.",
          "type": "object",
          "properties": {
            "acl": {
              "title": "Canned ACL to apply to the created objects.",
              "description": "For more information, see [Canned ACL][canned_acl].\n\n[canned_acl]: https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "title": "S3 Canned ACLs.",
                  "description": "For more information, see [Canned ACL][canned_acl].\n\n[canned_acl]: https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl",
                  "oneOf": [
                    {
                      "title": "Bucket/object are private.",
                      "description": "The bucket/object owner is granted the `FULL_CONTROL` permission, and no one else has\naccess.\n\nThis is the default.",
                      "const": "private",
                      "_metadata": {
                        "logical_name": "Private",
                        "docs::human_name": "Private"
                      }
                    },
                    {
                      "title": "Bucket/object can be read publicly.",
                      "description": "The bucket/object owner is granted the `FULL_CONTROL` permission, and anyone in the\n`AllUsers` grantee group is granted the `READ` permission.",
                      "const": "public-read",
                      "_metadata": {
                        "logical_name": "PublicRead",
                        "docs::human_name": "Public Read"
                      }
                    },
                    {
                      "title": "Bucket/object can be read and written publicly.",
                      "description": "The bucket/object owner is granted the `FULL_CONTROL` permission, and anyone in the\n`AllUsers` grantee group is granted the `READ` and `WRITE` permissions.\n\nThis is generally not recommended.",
                      "const": "public-read-write",
                      "_metadata": {
                        "logical_name": "PublicReadWrite",
                        "docs::human_name": "Public Read Write"
                      }
                    },
                    {
                      "title": "Bucket/object are private, and readable by EC2.",
                      "description": "The bucket/object owner is granted the `FULL_CONTROL` permission, and the AWS EC2 service is\ngranted the `READ` permission for the purpose of reading Amazon Machine Image (AMI) bundles\nfrom the given bucket.",
                      "const": "aws-exec-read",
                      "_metadata": {
                        "logical_name": "AwsExecRead",
                        "docs::human_name": "AWS Exec Read"
                      }
                    },
                    {
                      "title": "Bucket/object can be read by authenticated users.",
                      "description": "The bucket/object owner is granted the `FULL_CONTROL` permission, and anyone in the\n`AuthenticatedUsers` grantee group is granted the `READ` permission.",
                      "const": "authenticated-read",
                      "_metadata": {
                        "logical_name": "AuthenticatedRead",
                        "docs::human_name": "Authenticated Read"
                      }
                    },
                    {
                      "title": "Object is private, except to the bucket owner.",
                      "description": "The object owner is granted the `FULL_CONTROL` permission, and the bucket owner is granted the `READ` permission.\n\nOnly relevant when specified for an object: this canned ACL is otherwise ignored when\nspecified for a bucket.",
                      "const": "bucket-owner-read",
                      "_metadata": {
                        "logical_name": "BucketOwnerRead",
                        "docs::human_name": "Bucket Owner Read"
                      }
                    },
                    {
                      "title": "Object is semi-private.",
                      "description": "Both the object owner and bucket owner are granted the `FULL_CONTROL` permission.\n\nOnly relevant when specified for an object: this canned ACL is otherwise ignored when\nspecified for a bucket.",
                      "const": "bucket-owner-full-control",
                      "_metadata": {
                        "logical_name": "BucketOwnerFullControl",
                        "docs::human_name": "Bucket Owner Full Control"
                      }
                    },
                    {
                      "title": "Bucket can have logs written.",
                      "description": "The `LogDelivery` grantee group is granted `WRITE` and `READ_ACP` permissions.\n\nOnly relevant when specified for a bucket: this canned ACL is otherwise ignored when\nspecified for an object.\n\nFor more information about logs, see [Amazon S3 Server Access Logging][serverlogs].\n\n[serverlogs]: https://docs.aws.amazon.com/AmazonS3/latest/dev/ServerLogs.html",
                      "const": "log-delivery-write",
                      "_metadata": {
                        "logical_name": "LogDeliveryWrite",
                        "docs::human_name": "Log Delivery Write"
                      }
                    }
                  ],
                  "_metadata": {
                    "docs::enum_tagging": "external"
                  }
                }
              ],
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::optional": true,
                "docs::human_name": "ACL"
              }
            },
            "content_encoding": {
              "title": "Overrides what content encoding has been applied to the object.",
              "description": "Directly comparable to the `Content-Encoding` HTTP header.\n\nIf not specified, the compression scheme used dictates this value.",
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::examples": "gzip",
                "docs::human_name": "Content Encoding"
              }
            },
            "content_type": {
              "title": "Overrides the MIME type of the object.",
              "description": "Directly comparable to the `Content-Type` HTTP header.\n\nIf not specified, the compression scheme used dictates this value.\nWhen `compression` is set to `none`, the value `text/x-log` is used.",
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::examples": "application/gzip",
                "docs::human_name": "Content Type"
              }
            },
            "grant_full_control": {
              "title": "Grants `READ`, `READ_ACP`, and `WRITE_ACP` permissions on the created objects to the named [grantee].",
              "description": "This allows the grantee to read the created objects and their metadata, as well as read and\nmodify the ACL on the created objects.\n\n[grantee]: https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#specifying-grantee",
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::examples": [
                  "79a59df900b949e55d96a1e698fbacedfd6e09d98eacf8f8d5218e7cd47ef2be",
                  "person@email.com",
                  "http://acs.amazonaws.com/groups/global/AllUsers"
                ],
                "docs::human_name": "Grant Full Control"
              }
            },
            "grant_read": {
              "title": "Grants `READ` permissions on the created objects to the named [grantee].",
              "description": "This allows the grantee to read the created objects and their metadata.\n\n[grantee]: https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#specifying-grantee",
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::examples": [
                  "79a59df900b949e55d96a1e698fbacedfd6e09d98eacf8f8d5218e7cd47ef2be",
                  "person@email.com",
                  "http://acs.amazonaws.com/groups/global/AllUsers"
                ],
                "docs::human_name": "Grant Read"
              }
            },
            "grant_read_acp": {
              "title": "Grants `READ_ACP` permissions on the created objects to the named [grantee].",
              "description": "This allows the grantee to read the ACL on the created objects.\n\n[grantee]: https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#specifying-grantee",
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::examples": [
                  "79a59df900b949e55d96a1e698fbacedfd6e09d98eacf8f8d5218e7cd47ef2be",
                  "person@email.com",
                  "http://acs.amazonaws.com/groups/global/AllUsers"
                ],
                "docs::human_name": "Grant Read ACP"
              }
            },
            "grant_write_acp": {
              "title": "Grants `WRITE_ACP` permissions on the created objects to the named [grantee].",
              "description": "This allows the grantee to modify the ACL on the created objects.\n\n[grantee]: https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#specifying-grantee",
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::examples": [
                  "79a59df900b949e55d96a1e698fbacedfd6e09d98eacf8f8d5218e7cd47ef2be",
                  "person@email.com",
                  "http://acs.amazonaws.com/groups/global/AllUsers"
                ],
                "docs::human_name": "Grant Write ACP"
              }
            },
            "server_side_encryption": {
              "title": "AWS S3 Server-Side Encryption algorithms.",
              "description": "The Server-side Encryption algorithm used when storing these objects.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "title": "AWS S3 Server-Side Encryption algorithms.",
                  "description": "More information on each algorithm can be found in the [AWS documentation][aws_docs].\n\n[aws_docs]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/serv-side-encryption.html",
                  "oneOf": [
                    {
                      "title": "Each object is encrypted with AES-256 using a unique key.",
                      "description": "This corresponds to the `SSE-S3` option.",
                      "const": "AES256",
                      "_metadata": {
                        "logical_name": "Aes256",
                        "docs::human_name": "AES-256"
                      }
                    },
                    {
                      "title": "Each object is encrypted with AES-256 using keys managed by AWS KMS.",
                      "description": "Depending on whether or not a KMS key ID is specified, this corresponds either to the\n`SSE-KMS` option (keys generated/managed by KMS) or the `SSE-C` option (keys generated by\nthe customer, managed by KMS).",
                      "const": "aws:kms",
                      "_metadata": {
                        "logical_name": "AwsKms",
                        "docs::human_name": "AWS KMS"
                      }
                    }
                  ],
                  "_metadata": {
                    "docs::enum_tagging": "external"
                  }
                }
              ],
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::optional": true,
                "docs::human_name": "Server Side Encryption"
              }
            },
            "ssekms_key_id": {
              "title": "Specifies the ID of the AWS Key Management Service (AWS KMS) symmetrical customer managed\ncustomer master key (CMK) that is used for the created objects.",
              "description": "Only applies when `server_side_encryption` is configured to use KMS.\n\nIf not specified, Amazon S3 uses the AWS managed CMK in AWS to protect the data.",
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::examples": "abcd1234",
                "docs::templateable": true,
                "docs::human_name": "SSE-KMS Key ID"
              }
            },
            "storage_class": {
              "title": "The storage class for the created objects.",
              "description": "See the [S3 Storage Classes][s3_storage_classes] for more details.\n\n[s3_storage_classes]: https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html",
              "default": "STANDARD",
              "oneOf": [
                {
                  "description": "Standard Redundancy.",
                  "const": "STANDARD",
                  "_metadata": {
                    "logical_name": "Standard",
                    "docs::human_name": "Standard"
                  }
                },
                {
                  "description": "Reduced Redundancy.",
                  "const": "REDUCED_REDUNDANCY",
                  "_metadata": {
                    "logical_name": "ReducedRedundancy",
                    "docs::human_name": "Reduced Redundancy"
                  }
                },
                {
                  "description": "Intelligent Tiering.",
                  "const": "INTELLIGENT_TIERING",
                  "_metadata": {
                    "logical_name": "IntelligentTiering",
                    "docs::human_name": "Intelligent Tiering"
                  }
                },
                {
                  "description": "Infrequently Accessed.",
                  "const": "STANDARD_IA",
                  "_metadata": {
                    "logical_name": "StandardIa",
                    "docs::human_name": "Standard Ia"
                  }
                },
                {
                  "description": "Infrequently Accessed (single Availability zone).",
                  "const": "ONEZONE_IA",
                  "_metadata": {
                    "logical_name": "OnezoneIa",
                    "docs::human_name": "Onezone Ia"
                  }
                },
                {
                  "description": "Glacier Flexible Retrieval.",
                  "const": "GLACIER",
                  "_metadata": {
                    "logical_name": "Glacier",
                    "docs::human_name": "Glacier"
                  }
                },
                {
                  "description": "Glacier Deep Archive.",
                  "const": "DEEP_ARCHIVE",
                  "_metadata": {
                    "logical_name": "DeepArchive",
                    "docs::human_name": "Deep Archive"
                  }
                }
              ],
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::enum_tagging": "external",
                "docs::human_name": "Storage Class"
              }
            },
            "tags": {
              "description": "The tag-set for the object.",
              "type": [
                "object",
                "null"
              ],
              "additionalProperties": {
                "type": "string"
              },
              "_metadata": {
                "docs::optional": true,
                "docs::additional_props_description": "A single tag.",
                "docs::examples": {
                  "Project": "Blue",
                  "PHI": "True",
                  "Classification": "confidential"
                },
                "docs::human_name": "Tags"
              }
            }
          }
        },
        {
          "description": "Configuration of the region/endpoint to use when interacting with an AWS service.",
          "$ref": "#/definitions/vector::aws::region::RegionOrEndpoint"
        },
        {
          "description": "Encoding configuration.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfigWithFraming"
        }
      ],
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "aws_s3"
      }
    },
    "vector::sinks::aws_s_s::config::BaseSSSinkConfig": {
      "description": "Base Configuration `aws_s_s` for sns and sqs sink.",
      "type": "object",
      "required": [
        "encoding"
      ],
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled for this sink.",
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "assume_role": {
          "title": "The ARN of an [IAM role][iam_role] to assume at startup.",
          "description": "[iam_role]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html",
          "deprecated": true,
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::hidden": true,
            "docs::human_name": "Assume Role"
          }
        },
        "auth": {
          "description": "Configuration of the authentication strategy for interacting with AWS services.",
          "default": {
            "load_timeout_secs": null,
            "imds": {
              "max_attempts": 4,
              "connect_timeout_seconds": 1,
              "read_timeout_seconds": 1
            },
            "region": null
          },
          "$ref": "#/definitions/vector::aws::auth::AwsAuthentication",
          "_metadata": {
            "docs::human_name": "Auth"
          }
        },
        "encoding": {
          "description": "Configures how events are encoded into raw bytes.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
          "_metadata": {
            "docs::human_name": "Encoding"
          }
        },
        "message_deduplication_id": {
          "title": "The message deduplication ID value to allow AWS to identify duplicate messages.",
          "description": "This value is a template which should result in a unique string for each event. See the [AWS\ndocumentation][deduplication_id_docs] for more about how AWS does message deduplication.\n\n[deduplication_id_docs]: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/using-messagededuplicationid-property.html",
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::examples": "{{ transaction_id }}",
            "docs::human_name": "Message Deduplication ID"
          }
        },
        "message_group_id": {
          "title": "The tag that specifies that a message belongs to a specific message group.",
          "description": "Can be applied only to FIFO queues.",
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::examples": [
              "vector",
              "vector-%Y-%m-%d"
            ],
            "docs::human_name": "Message Group ID"
          }
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "initial_concurrency": 1,
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          }
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      }
    },
    "vector::sinks::aws_s_s::sns::config::SnsSinkConfig": {
      "description": "Configuration for the `aws_sns` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "topic_arn"
          ],
          "properties": {
            "topic_arn": {
              "description": "The ARN of the Amazon SNS topic to which messages are sent.",
              "type": "string",
              "format": "uri",
              "_metadata": {
                "docs::examples": "arn:aws:sns:us-east-2:123456789012:MyTopic",
                "docs::human_name": "Topic Arn"
              }
            }
          }
        },
        {
          "description": "Configuration of the region/endpoint to use when interacting with an AWS service.",
          "$ref": "#/definitions/vector::aws::region::RegionOrEndpoint"
        },
        {
          "description": "Base Configuration `aws_s_s` for sns and sqs sink.",
          "$ref": "#/definitions/vector::sinks::aws_s_s::config::BaseSSSinkConfig"
        }
      ],
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "aws_sns"
      }
    },
    "vector::sinks::aws_s_s::sqs::config::SqsSinkConfig": {
      "description": "Configuration for the `aws_sqs` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "queue_url"
          ],
          "properties": {
            "queue_url": {
              "description": "The URL of the Amazon SQS queue to which messages are sent.",
              "type": "string",
              "format": "uri",
              "_metadata": {
                "docs::examples": "https://sqs.us-east-2.amazonaws.com/123456789012/MyQueue",
                "docs::human_name": "Queue URL"
              }
            }
          }
        },
        {
          "description": "Configuration of the region/endpoint to use when interacting with an AWS service.",
          "$ref": "#/definitions/vector::aws::region::RegionOrEndpoint"
        },
        {
          "description": "Base Configuration `aws_s_s` for sns and sqs sink.",
          "$ref": "#/definitions/vector::sinks::aws_s_s::config::BaseSSSinkConfig"
        }
      ],
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "aws_sqs"
      }
    },
    "vector::sinks::axiom::AxiomConfig": {
      "description": "Configuration for the `axiom` sink.",
      "type": "object",
      "required": [
        "dataset",
        "token"
      ],
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled for this sink.",
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "compression": {
          "title": "Compression configuration.",
          "description": "All compression algorithms use the default compression level unless otherwise specified.",
          "default": "none",
          "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
          "_metadata": {
            "docs::human_name": "Compression"
          }
        },
        "dataset": {
          "description": "The Axiom dataset to write to.",
          "type": "string",
          "_metadata": {
            "docs::examples": [
              "${AXIOM_DATASET}",
              "vector.dev"
            ],
            "docs::human_name": "Dataset"
          }
        },
        "org_id": {
          "title": "The Axiom organization ID.",
          "description": "Only required when using personal tokens.",
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::examples": [
              "${AXIOM_ORG_ID}",
              "123abc"
            ],
            "docs::human_name": "Org ID"
          }
        },
        "request": {
          "description": "Outbound HTTP request settings.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "initial_concurrency": 1,
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            },
            "headers": {}
          },
          "$ref": "#/definitions/vector::sinks::util::http::RequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          }
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        },
        "token": {
          "description": "The Axiom API token.",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "docs::examples": [
              "${AXIOM_TOKEN}",
              "123abc"
            ],
            "docs::human_name": "Token"
          }
        },
        "url": {
          "title": "URI of the Axiom endpoint to send data to.",
          "description": "Only required if not using Axiom Cloud.",
          "type": [
            "string",
            "null"
          ],
          "format": "uri",
          "_metadata": {
            "docs::optional": true,
            "docs::examples": [
              "https://axiom.my-domain.com",
              "${AXIOM_URL}"
            ],
            "docs::human_name": "URL"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "axiom"
      }
    },
    "vector::sinks::azure_blob::config::AzureBlobSinkConfig": {
      "description": "Configuration for the `azure_blob` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "container_name"
          ],
          "properties": {
            "acknowledgements": {
              "title": "Controls how acknowledgements are handled for this sink.",
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              }
            },
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::BulkSizeBasedDefaultBatchSettings>",
              "_metadata": {
                "docs::human_name": "Batch"
              }
            },
            "blob_append_uuid": {
              "title": "Whether or not to append a UUID v4 token to the end of the blob key.",
              "description": "The UUID is appended to the timestamp portion of the object key, such that if the blob key\ngenerated is `date=2022-07-18/1658176486`, setting this field to `true` results\nin an blob key that looks like\n`date=2022-07-18/1658176486-30f6652c-71da-4f9f-800d-a1189c47c547`.\n\nThis ensures there are no name collisions, and can be useful in high-volume workloads where\nblob keys must be unique.",
              "type": [
                "boolean",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::human_name": "Blob Append UUID"
              }
            },
            "blob_prefix": {
              "title": "A prefix to apply to all blob keys.",
              "description": "Prefixes are useful for partitioning objects, such as by creating a blob key that\nstores blobs under a particular directory. If using a prefix for this purpose, it must end\nin `/` to act as a directory path. A trailing `/` is **not** automatically added.",
              "default": "blob/%F/",
              "$ref": "#/definitions/vector::template::Template",
              "_metadata": {
                "docs::examples": [
                  "date/%F/hour/%H/",
                  "year=%Y/month=%m/day=%d/",
                  "kubernetes/{{ metadata.cluster }}/{{ metadata.application_name }}/"
                ],
                "docs::human_name": "Blob Prefix"
              }
            },
            "blob_time_format": {
              "title": "The timestamp format for the time component of the blob key.",
              "description": "By default, blob keys are appended with a timestamp that reflects when the blob are sent to\nAzure Blob Storage, such that the resulting blob key is functionally equivalent to joining\nthe blob prefix with the formatted timestamp, such as `date=2022-07-18/1658176486`.\n\nThis would represent a `blob_prefix` set to `date=%F/` and the timestamp of Mon Jul 18 2022\n20:34:44 GMT+0000, with the `filename_time_format` being set to `%s`, which renders\ntimestamps in seconds since the Unix epoch.\n\nSupports the common [`strftime`][chrono_strftime_specifiers] specifiers found in most\nlanguages.\n\nWhen set to an empty string, no timestamp is appended to the blob prefix.\n\n[chrono_strftime_specifiers]: https://docs.rs/chrono/latest/chrono/format/strftime/index.html#specifiers",
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::syntax_override": "strftime",
                "docs::human_name": "Blob Time Format"
              }
            },
            "compression": {
              "title": "Compression configuration.",
              "description": "All compression algorithms use the default compression level unless otherwise specified.",
              "default": "gzip",
              "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
              "_metadata": {
                "docs::human_name": "Compression"
              }
            },
            "connection_string": {
              "title": "The Azure Blob Storage Account connection string.",
              "description": "Authentication with access key is the only supported authentication method.\n\nEither `storage_account`, or this field, must be specified.",
              "$ref": "#/definitions/core::option::Option<vector_common::sensitive_string::SensitiveString>",
              "_metadata": {
                "docs::examples": "DefaultEndpointsProtocol=https;AccountName=mylogstorage;AccountKey=storageaccountkeybase64encoded;EndpointSuffix=core.windows.net",
                "docs::human_name": "Connection String"
              }
            },
            "container_name": {
              "description": "The Azure Blob Storage Account container name.",
              "type": "string",
              "_metadata": {
                "docs::examples": "my-logs",
                "docs::human_name": "Container Name"
              }
            },
            "endpoint": {
              "title": "The Azure Blob Storage Endpoint URL.",
              "description": "This is used to override the default blob storage endpoint URL in cases where you are using\ncredentials read from the environment/managed identities or access tokens without using an\nexplicit connection_string (which already explicitly supports overriding the blob endpoint\nURL).\n\nThis may only be used with `storage_account` and is ignored when used with\n`connection_string`.",
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::examples": [
                  "https://test.blob.core.usgovcloudapi.net/",
                  "https://test.blob.core.windows.net/"
                ],
                "docs::human_name": "Endpoint"
              }
            },
            "request": {
              "title": "Middleware settings for outbound requests.",
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "initial_concurrency": 1,
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                }
              },
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              }
            },
            "storage_account": {
              "title": "The Azure Blob Storage Account name.",
              "description": "Attempts to load credentials for the account in the following ways, in order:\n\n- read from environment variables ([more information][env_cred_docs])\n- looks for a [Managed Identity][managed_ident_docs]\n- uses the `az` CLI tool to get an access token ([more information][az_cli_docs])\n\nEither `connection_string`, or this field, must be specified.\n\n[env_cred_docs]: https://docs.rs/azure_identity/latest/azure_identity/struct.EnvironmentCredential.html\n[managed_ident_docs]: https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview\n[az_cli_docs]: https://docs.microsoft.com/en-us/cli/azure/account?view=azure-cli-latest#az-account-get-access-token",
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::examples": "mylogstorage",
                "docs::human_name": "Storage Account"
              }
            }
          }
        },
        {
          "description": "Encoding configuration.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfigWithFraming"
        }
      ],
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "azure_blob"
      }
    },
    "vector::sinks::azure_monitor_logs::config::AzureMonitorLogsConfig": {
      "description": "Configuration for the `azure_monitor_logs` sink.",
      "type": "object",
      "required": [
        "customer_id",
        "log_type",
        "shared_key"
      ],
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled for this sink.",
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "azure_resource_id": {
          "title": "The [Resource ID][resource_id] of the Azure resource the data should be associated with.",
          "description": "[resource_id]: https://docs.microsoft.com/en-us/azure/azure-monitor/platform/data-collector-api#request-headers",
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::examples": [
              "/subscriptions/11111111-1111-1111-1111-111111111111/resourceGroups/otherResourceGroup/providers/Microsoft.Storage/storageAccounts/examplestorage",
              "/subscriptions/11111111-1111-1111-1111-111111111111/resourceGroups/examplegroup/providers/Microsoft.SQL/servers/serverName/databases/databaseName"
            ],
            "docs::human_name": "Azure Resource ID"
          }
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::RealtimeSizeBasedDefaultBatchSettings>",
          "_metadata": {
            "docs::human_name": "Batch"
          }
        },
        "customer_id": {
          "title": "The [unique identifier][uniq_id] for the Log Analytics workspace.",
          "description": "[uniq_id]: https://docs.microsoft.com/en-us/azure/azure-monitor/platform/data-collector-api#request-uri-parameters",
          "type": "string",
          "_metadata": {
            "docs::examples": [
              "5ce893d9-2c32-4b6c-91a9-b0887c2de2d6",
              "97ce69d9-b4be-4241-8dbd-d265edcf06c4"
            ],
            "docs::human_name": "Customer ID"
          }
        },
        "encoding": {
          "description": "Transformations to prepare an event for serialization.",
          "default": {},
          "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer",
          "_metadata": {
            "docs::human_name": "Encoding"
          }
        },
        "host": {
          "title": "[Alternative host][alt_host] for dedicated Azure regions.",
          "description": "[alt_host]: https://docs.azure.cn/en-us/articles/guidance/developerdifferences#check-endpoints-in-azure",
          "default": "ods.opinsights.azure.com",
          "type": "string",
          "_metadata": {
            "docs::examples": [
              "ods.opinsights.azure.us",
              "ods.opinsights.azure.cn"
            ],
            "docs::human_name": "Host"
          }
        },
        "log_type": {
          "title": "The [record type][record_type] of the data that is being submitted.",
          "description": "Can only contain letters, numbers, and underscores (_), and may not exceed 100 characters.\n\n[record_type]: https://docs.microsoft.com/en-us/azure/azure-monitor/platform/data-collector-api#request-headers",
          "type": "string",
          "pattern": "[a-zA-Z0-9_]{1,100}",
          "_metadata": {
            "docs::examples": [
              "MyTableName",
              "MyRecordType"
            ],
            "docs::human_name": "Log Type"
          }
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "initial_concurrency": 1,
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          }
        },
        "shared_key": {
          "title": "The [primary or the secondary key][shared_key] for the Log Analytics workspace.",
          "description": "[shared_key]: https://docs.microsoft.com/en-us/azure/azure-monitor/platform/data-collector-api#authorization",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "docs::examples": [
              "SERsIYhgMVlJB6uPsq49gCxNiruf6v0vhMYE+lfzbSGcXjdViZdV/e5pEMTYtw9f8SkVLf4LFlLCc2KxtRZfCA==",
              "${AZURE_MONITOR_SHARED_KEY_ENV_VAR}"
            ],
            "docs::human_name": "Shared Key"
          }
        },
        "time_generated_key": {
          "title": "Use this option to customize the log field used as [`TimeGenerated`][1] in Azure.",
          "description": "The setting of `log_schema.timestamp_key`, usually `timestamp`, is used here by default.\nThis field should be used in rare cases where `TimeGenerated` should point to a specific log\nfield. For example, use this field to set the log field `source_timestamp` as holding the\nvalue that should be used as `TimeGenerated` on the Azure side.\n\n[1]: https://learn.microsoft.com/en-us/azure/azure-monitor/logs/log-standard-columns#timegenerated",
          "$ref": "#/definitions/core::option::Option<vector_lookup::lookup_v2::optional_path::OptionalValuePath>",
          "_metadata": {
            "docs::examples": "time_generated",
            "docs::human_name": "Time Generated Key"
          }
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "azure_monitor_logs"
      }
    },
    "vector::sinks::blackhole::config::BlackholeConfig": {
      "description": "Configuration for the `blackhole` sink.",
      "default": {
        "print_interval_secs": 1,
        "rate": null
      },
      "type": "object",
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled for this sink.",
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "print_interval_secs": {
          "title": "The interval between reporting a summary of activity.",
          "description": "Set to `0` to disable reporting.",
          "default": 1,
          "$ref": "#/definitions/serde_with::DurationSeconds",
          "_metadata": {
            "docs::human_name": "Print Interval",
            "docs::examples": 10
          }
        },
        "rate": {
          "title": "The number of events, per second, that the sink is allowed to consume.",
          "description": "By default, there is no limit.",
          "type": [
            "integer",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::examples": 1000,
            "docs::human_name": "Rate"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "blackhole"
      }
    },
    "vector::sinks::clickhouse::config::ClickhouseConfig": {
      "description": "Configuration for the `clickhouse` sink.",
      "type": "object",
      "required": [
        "endpoint",
        "table"
      ],
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled for this sink.",
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "auth": {
          "$ref": "#/definitions/core::option::Option<vector::http::Auth>",
          "_metadata": {
            "docs::human_name": "Auth"
          }
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::RealtimeSizeBasedDefaultBatchSettings>",
          "_metadata": {
            "docs::human_name": "Batch"
          }
        },
        "compression": {
          "title": "Compression configuration.",
          "description": "All compression algorithms use the default compression level unless otherwise specified.",
          "default": "gzip",
          "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
          "_metadata": {
            "docs::human_name": "Compression"
          }
        },
        "database": {
          "description": "The database that contains the table that data is inserted into.",
          "$ref": "#/definitions/core::option::Option<vector::template::Template>",
          "_metadata": {
            "docs::examples": "mydatabase",
            "docs::human_name": "Database"
          }
        },
        "date_time_best_effort": {
          "description": "Sets `date_time_input_format` to `best_effort`, allowing ClickHouse to properly parse RFC3339/ISO 8601.",
          "default": false,
          "type": "boolean",
          "_metadata": {
            "docs::human_name": "Date Time Best Effort"
          }
        },
        "encoding": {
          "description": "Transformations to prepare an event for serialization.",
          "default": {},
          "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer",
          "_metadata": {
            "docs::human_name": "Encoding"
          }
        },
        "endpoint": {
          "description": "The endpoint of the ClickHouse server.",
          "$ref": "#/definitions/vector::sinks::util::uri::UriSerde",
          "_metadata": {
            "docs::examples": "http://localhost:8123",
            "docs::human_name": "Endpoint"
          }
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "initial_concurrency": 1,
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          }
        },
        "skip_unknown_fields": {
          "description": "Sets `input_format_skip_unknown_fields`, allowing ClickHouse to discard fields not present in the table schema.",
          "default": false,
          "type": "boolean",
          "_metadata": {
            "docs::human_name": "Skip Unknown Fields"
          }
        },
        "table": {
          "description": "The table that data is inserted into.",
          "$ref": "#/definitions/vector::template::Template",
          "_metadata": {
            "docs::examples": "mytable",
            "docs::human_name": "Table"
          }
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "clickhouse"
      }
    },
    "vector::sinks::console::config::ConsoleSinkConfig": {
      "description": "Configuration for the `console` sink.",
      "allOf": [
        {
          "type": "object",
          "properties": {
            "acknowledgements": {
              "title": "Controls how acknowledgements are handled for this sink.",
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              }
            },
            "target": {
              "title": "The [standard stream][standard_streams] to write to.",
              "description": "[standard_streams]: https://en.wikipedia.org/wiki/Standard_streams",
              "default": "stdout",
              "oneOf": [
                {
                  "title": "Write output to [STDOUT][stdout].",
                  "description": "[stdout]: https://en.wikipedia.org/wiki/Standard_streams#Standard_output_(stdout)",
                  "const": "stdout",
                  "_metadata": {
                    "logical_name": "Stdout",
                    "docs::human_name": "Stdout"
                  }
                },
                {
                  "title": "Write output to [STDERR][stderr].",
                  "description": "[stderr]: https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)",
                  "const": "stderr",
                  "_metadata": {
                    "logical_name": "Stderr",
                    "docs::human_name": "Stderr"
                  }
                }
              ],
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::enum_tagging": "external",
                "docs::human_name": "Target"
              }
            }
          }
        },
        {
          "description": "Encoding configuration.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfigWithFraming"
        }
      ],
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "console"
      }
    },
    "vector::sinks::databend::config::DatabendConfig": {
      "description": "Configuration for the `databend` sink.",
      "type": "object",
      "required": [
        "endpoint",
        "table"
      ],
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled for this sink.",
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "auth": {
          "$ref": "#/definitions/core::option::Option<vector::http::Auth>",
          "_metadata": {
            "docs::human_name": "Auth"
          }
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::RealtimeSizeBasedDefaultBatchSettings>",
          "_metadata": {
            "docs::human_name": "Batch"
          }
        },
        "compression": {
          "description": "Compression configuration.",
          "default": "none",
          "oneOf": [
            {
              "description": "No compression.",
              "const": "none",
              "_metadata": {
                "logical_name": "None",
                "docs::human_name": "None"
              }
            },
            {
              "title": "[Gzip][gzip] compression.",
              "description": "[gzip]: https://www.gzip.org/",
              "const": "gzip",
              "_metadata": {
                "logical_name": "Gzip",
                "docs::human_name": "Gzip"
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::enum_tag_description": "The compression algorithm to use for sending.",
            "docs::enum_tagging": "external",
            "docs::human_name": "Compression"
          }
        },
        "database": {
          "description": "The database that contains the table that data is inserted into.",
          "default": "default",
          "type": "string",
          "_metadata": {
            "docs::examples": "mydatabase",
            "docs::human_name": "Database"
          }
        },
        "encoding": {
          "description": "Configures how events are encoded into raw bytes.",
          "default": {
            "codec": "json"
          },
          "allOf": [
            {
              "description": "Serializer configuration for Databend.",
              "oneOf": [
                {
                  "title": "Encodes an event as a CSV message.",
                  "description": "This codec must be configured with fields to encode.",
                  "allOf": [
                    {
                      "description": "Options for the CSV encoder.",
                      "$ref": "#/definitions/codecs::encoding::format::csv::CsvSerializerConfig"
                    },
                    {
                      "type": "object",
                      "required": [
                        "codec"
                      ],
                      "properties": {
                        "codec": {
                          "title": "Encodes an event as a CSV message.",
                          "description": "This codec must be configured with fields to encode.",
                          "const": "csv",
                          "_metadata": {
                            "docs::human_name": "Codec"
                          }
                        }
                      }
                    }
                  ],
                  "_metadata": {
                    "logical_name": "Csv",
                    "docs::human_name": "CSV"
                  }
                },
                {
                  "title": "Encodes an event as [JSON][json].",
                  "description": "[json]: https://www.json.org/",
                  "allOf": [
                    {
                      "description": "Encoding options specific to the Json serializer.",
                      "$ref": "#/definitions/codecs::encoding::format::json::JsonSerializerConfig"
                    },
                    {
                      "type": "object",
                      "required": [
                        "codec"
                      ],
                      "properties": {
                        "codec": {
                          "title": "Encodes an event as [JSON][json].",
                          "description": "[json]: https://www.json.org/",
                          "const": "json",
                          "_metadata": {
                            "docs::human_name": "Codec"
                          }
                        }
                      }
                    }
                  ],
                  "_metadata": {
                    "logical_name": "Json",
                    "docs::human_name": "JSON"
                  }
                }
              ],
              "_metadata": {
                "docs::enum_tag_description": "The codec to use for encoding events.",
                "docs::enum_tagging": "internal",
                "docs::enum_tag_field": "codec"
              }
            },
            {
              "description": "Transformations to prepare an event for serialization.",
              "type": "object",
              "properties": {
                "except_fields": {
                  "description": "List of fields that are excluded from the encoded event.",
                  "default": null,
                  "type": [
                    "array",
                    "null"
                  ],
                  "items": {
                    "$ref": "#/definitions/vector_lookup::lookup_v2::ConfigValuePath"
                  },
                  "_metadata": {
                    "docs::optional": true,
                    "docs::human_name": "Except Fields"
                  }
                },
                "only_fields": {
                  "description": "List of fields that are included in the encoded event.",
                  "default": null,
                  "type": [
                    "array",
                    "null"
                  ],
                  "items": {
                    "$ref": "#/definitions/vector_lookup::lookup_v2::ConfigValuePath"
                  },
                  "_metadata": {
                    "docs::optional": true,
                    "docs::human_name": "Only Fields"
                  }
                },
                "timestamp_format": {
                  "description": "Format used for timestamp fields.",
                  "default": null,
                  "oneOf": [
                    {
                      "type": "null"
                    },
                    {
                      "description": "The format in which a timestamp should be represented.",
                      "oneOf": [
                        {
                          "description": "Represent the timestamp as a Unix timestamp.",
                          "const": "unix",
                          "_metadata": {
                            "logical_name": "Unix",
                            "docs::human_name": "Unix"
                          }
                        },
                        {
                          "description": "Represent the timestamp as a RFC 3339 timestamp.",
                          "const": "rfc3339",
                          "_metadata": {
                            "logical_name": "Rfc3339",
                            "docs::human_name": "RFC3339"
                          }
                        }
                      ],
                      "_metadata": {
                        "docs::enum_tagging": "external"
                      }
                    }
                  ],
                  "unevaluatedProperties": false,
                  "_metadata": {
                    "docs::optional": true,
                    "docs::human_name": "Timestamp Format"
                  }
                }
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::human_name": "Encoding"
          }
        },
        "endpoint": {
          "description": "The endpoint of the Databend server.",
          "$ref": "#/definitions/vector::sinks::util::uri::UriSerde",
          "_metadata": {
            "docs::examples": "http://localhost:8000",
            "docs::human_name": "Endpoint"
          }
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "initial_concurrency": 1,
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          }
        },
        "table": {
          "description": "The table that data is inserted into.",
          "type": "string",
          "_metadata": {
            "docs::examples": "mytable",
            "docs::human_name": "Table"
          }
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "databend"
      }
    },
    "vector::sinks::datadog::DatadogCommonConfig": {
      "description": "Shared configuration for Datadog sinks.\nContains the maximum set of common settings that applies to all DD sink components.",
      "type": "object",
      "required": [
        "default_api_key"
      ],
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled for this sink.",
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "default_api_key": {
          "title": "The default Datadog [API key][api_key] to use in authentication of HTTP requests.",
          "description": "If an event has a Datadog [API key][api_key] set explicitly in its metadata, it takes\nprecedence over this setting.\n\n[api_key]: https://docs.datadoghq.com/api/?lang=bash#authentication",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "docs::examples": [
              "${DATADOG_API_KEY_ENV_VAR}",
              "ef8d5de700e7989468166c40fc8a0ccd"
            ],
            "docs::human_name": "Default API Key"
          }
        },
        "endpoint": {
          "title": "The endpoint to send observability data to.",
          "description": "The endpoint must contain an HTTP scheme, and may specify a\nhostname or IP address and port.\n\nIf set, overrides the `site` option.",
          "default": null,
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::advanced": true,
            "docs::examples": [
              "http://127.0.0.1:8080",
              "http://example.com:12345"
            ],
            "docs::human_name": "Endpoint"
          }
        },
        "site": {
          "title": "The Datadog [site][dd_site] to send observability data to.",
          "description": "[dd_site]: https://docs.datadoghq.com/getting_started/site",
          "default": "datadoghq.com",
          "type": "string",
          "_metadata": {
            "docs::examples": [
              "us3.datadoghq.com",
              "datadoghq.eu"
            ],
            "docs::human_name": "Site"
          }
        },
        "tls": {
          "default": null,
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      }
    },
    "vector::sinks::datadog::events::config::DatadogEventsConfig": {
      "description": "Configuration for the `datadog_events` sink.",
      "allOf": [
        {
          "type": "object",
          "properties": {
            "region": {
              "description": "The Datadog region to send events to.",
              "default": null,
              "deprecated": true,
              "$ref": "#/definitions/core::option::Option<vector::common::datadog::Region>",
              "_metadata": {
                "deprecated_message": "This option has been deprecated, use the `site` option instead.",
                "docs::human_name": "Region"
              }
            },
            "request": {
              "title": "Middleware settings for outbound requests.",
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "initial_concurrency": 1,
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                }
              },
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              }
            }
          }
        },
        {
          "description": "Shared configuration for Datadog sinks.\nContains the maximum set of common settings that applies to all DD sink components.",
          "$ref": "#/definitions/vector::sinks::datadog::DatadogCommonConfig"
        }
      ],
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "datadog_events"
      }
    },
    "vector::sinks::datadog::logs::config::DatadogLogsConfig": {
      "description": "Configuration for the `datadog_logs` sink.",
      "allOf": [
        {
          "type": "object",
          "properties": {
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "type": "object",
              "properties": {
                "max_bytes": {
                  "title": "The maximum size of a batch that is processed by a sink.",
                  "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
                  "default": 4250000,
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes",
                    "docs::human_name": "Max Bytes"
                  }
                },
                "max_events": {
                  "description": "The maximum size of a batch before it is flushed.",
                  "default": 1000,
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "events",
                    "docs::human_name": "Max Events"
                  }
                },
                "timeout_secs": {
                  "description": "The maximum age of a batch before it is flushed.",
                  "default": 5.0,
                  "type": [
                    "number",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": -9007199254740991.0,
                  "_metadata": {
                    "docs::numeric_type": "float",
                    "docs::optional": true,
                    "docs::type_unit": "seconds",
                    "docs::human_name": "Timeout"
                  }
                }
              },
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Batch"
              }
            },
            "compression": {
              "default": null,
              "$ref": "#/definitions/core::option::Option<vector::sinks::util::buffer::compression::Compression>",
              "_metadata": {
                "docs::human_name": "Compression"
              }
            },
            "encoding": {
              "description": "Transformations to prepare an event for serialization.",
              "default": {},
              "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer",
              "_metadata": {
                "docs::human_name": "Encoding"
              }
            },
            "region": {
              "description": "The Datadog region to send logs to.",
              "default": null,
              "deprecated": true,
              "$ref": "#/definitions/core::option::Option<vector::common::datadog::Region>",
              "_metadata": {
                "deprecated_message": "This option has been deprecated, use the `site` option instead.",
                "docs::human_name": "Region"
              }
            },
            "request": {
              "description": "Outbound HTTP request settings.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "initial_concurrency": 1,
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                },
                "headers": {}
              },
              "$ref": "#/definitions/vector::sinks::util::http::RequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              }
            }
          }
        },
        {
          "description": "Shared configuration for Datadog sinks.\nContains the maximum set of common settings that applies to all DD sink components.",
          "$ref": "#/definitions/vector::sinks::datadog::DatadogCommonConfig"
        }
      ],
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "datadog_logs"
      }
    },
    "vector::sinks::datadog::metrics::config::DatadogMetricsConfig": {
      "description": "Configuration for the `datadog_metrics` sink.",
      "allOf": [
        {
          "type": "object",
          "properties": {
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "type": "object",
              "properties": {
                "max_bytes": {
                  "title": "The maximum size of a batch that is processed by a sink.",
                  "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
                  "default": null,
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes",
                    "docs::human_name": "Max Bytes"
                  }
                },
                "max_events": {
                  "description": "The maximum size of a batch before it is flushed.",
                  "default": 100000,
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "events",
                    "docs::human_name": "Max Events"
                  }
                },
                "timeout_secs": {
                  "description": "The maximum age of a batch before it is flushed.",
                  "default": 2.0,
                  "type": [
                    "number",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": -9007199254740991.0,
                  "_metadata": {
                    "docs::numeric_type": "float",
                    "docs::optional": true,
                    "docs::type_unit": "seconds",
                    "docs::human_name": "Timeout"
                  }
                }
              },
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Batch"
              }
            },
            "default_namespace": {
              "title": "Sets the default namespace for any metrics sent.",
              "description": "This namespace is only used if a metric has no existing namespace. When a namespace is\npresent, it is used as a prefix to the metric name, and separated with a period (`.`).",
              "default": null,
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::examples": "myservice",
                "docs::human_name": "Default Namespace"
              }
            },
            "region": {
              "description": "The Datadog region to send metrics to.",
              "default": null,
              "deprecated": true,
              "$ref": "#/definitions/core::option::Option<vector::common::datadog::Region>",
              "_metadata": {
                "deprecated_message": "This option has been deprecated, use the `site` option instead.",
                "docs::human_name": "Region"
              }
            },
            "request": {
              "title": "Middleware settings for outbound requests.",
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "initial_concurrency": 1,
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                }
              },
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              }
            }
          }
        },
        {
          "description": "Shared configuration for Datadog sinks.\nContains the maximum set of common settings that applies to all DD sink components.",
          "$ref": "#/definitions/vector::sinks::datadog::DatadogCommonConfig"
        }
      ],
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "datadog_metrics"
      }
    },
    "vector::sinks::datadog::traces::config::DatadogTracesConfig": {
      "description": "Configuration for the `datadog_traces` sink.",
      "allOf": [
        {
          "type": "object",
          "properties": {
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "type": "object",
              "properties": {
                "max_bytes": {
                  "title": "The maximum size of a batch that is processed by a sink.",
                  "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
                  "default": 3000000,
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes",
                    "docs::human_name": "Max Bytes"
                  }
                },
                "max_events": {
                  "description": "The maximum size of a batch before it is flushed.",
                  "default": 1000,
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "events",
                    "docs::human_name": "Max Events"
                  }
                },
                "timeout_secs": {
                  "description": "The maximum age of a batch before it is flushed.",
                  "default": 10.0,
                  "type": [
                    "number",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": -9007199254740991.0,
                  "_metadata": {
                    "docs::numeric_type": "float",
                    "docs::optional": true,
                    "docs::type_unit": "seconds",
                    "docs::human_name": "Timeout"
                  }
                }
              },
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Batch"
              }
            },
            "compression": {
              "default": null,
              "$ref": "#/definitions/core::option::Option<vector::sinks::util::buffer::compression::Compression>",
              "_metadata": {
                "docs::human_name": "Compression"
              }
            },
            "request": {
              "title": "Middleware settings for outbound requests.",
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "initial_concurrency": 1,
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                }
              },
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              }
            }
          }
        },
        {
          "description": "Shared configuration for Datadog sinks.\nContains the maximum set of common settings that applies to all DD sink components.",
          "$ref": "#/definitions/vector::sinks::datadog::DatadogCommonConfig"
        }
      ],
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "datadog_traces"
      }
    },
    "vector::sinks::elasticsearch::config::ElasticsearchConfig": {
      "description": "Configuration for the `elasticsearch` sink.",
      "type": "object",
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled for this sink.",
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "api_version": {
          "description": "The API version of Elasticsearch.",
          "default": "auto",
          "oneOf": [
            {
              "title": "Auto-detect the API version.",
              "description": "If the [cluster state version endpoint][es_version] isn't reachable, a warning is logged to\nstdout, and the version is assumed to be V6 if the `suppress_type_name` option is set to\n`true`. Otherwise, the version is assumed to be V8. In the future, the sink instead\nreturns an error during configuration parsing, since a wrongly assumed version could lead to\nincorrect API calls.\n\n[es_version]: https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-state.html#cluster-state-api-path-params",
              "const": "auto",
              "_metadata": {
                "logical_name": "Auto",
                "docs::human_name": "Auto"
              }
            },
            {
              "description": "Use the Elasticsearch 6.x API.",
              "const": "v6",
              "_metadata": {
                "logical_name": "V6",
                "docs::human_name": "V6"
              }
            },
            {
              "description": "Use the Elasticsearch 7.x API.",
              "const": "v7",
              "_metadata": {
                "logical_name": "V7",
                "docs::human_name": "V7"
              }
            },
            {
              "description": "Use the Elasticsearch 8.x API.",
              "const": "v8",
              "_metadata": {
                "logical_name": "V8",
                "docs::human_name": "V8"
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::enum_tagging": "external",
            "docs::human_name": "API Version"
          }
        },
        "auth": {
          "description": "Elasticsearch Authentication strategies.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "description": "Elasticsearch Authentication strategies.",
              "oneOf": [
                {
                  "description": "HTTP Basic Authentication.",
                  "type": "object",
                  "required": [
                    "password",
                    "strategy",
                    "user"
                  ],
                  "properties": {
                    "password": {
                      "description": "Basic authentication password.",
                      "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
                      "_metadata": {
                        "docs::examples": [
                          "${ELASTICSEARCH_PASSWORD}",
                          "password"
                        ],
                        "docs::human_name": "Password"
                      }
                    },
                    "strategy": {
                      "description": "HTTP Basic Authentication.",
                      "const": "basic",
                      "_metadata": {
                        "docs::human_name": "Strategy"
                      }
                    },
                    "user": {
                      "description": "Basic authentication username.",
                      "type": "string",
                      "_metadata": {
                        "docs::examples": [
                          "${ELASTICSEARCH_USERNAME}",
                          "username"
                        ],
                        "docs::human_name": "User"
                      }
                    }
                  },
                  "_metadata": {
                    "logical_name": "Basic",
                    "docs::human_name": "Basic"
                  }
                },
                {
                  "description": "Amazon OpenSearch Service-specific authentication.",
                  "allOf": [
                    {
                      "description": "Configuration of the authentication strategy for interacting with AWS services.",
                      "anyOf": [
                        {
                          "description": "Authenticate using a fixed access key and secret pair.",
                          "type": "object",
                          "required": [
                            "access_key_id",
                            "secret_access_key"
                          ],
                          "properties": {
                            "access_key_id": {
                              "description": "The AWS access key ID.",
                              "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
                              "_metadata": {
                                "docs::examples": "AKIAIOSFODNN7EXAMPLE",
                                "docs::human_name": "Access Key ID"
                              }
                            },
                            "assume_role": {
                              "title": "The ARN of an [IAM role][iam_role] to assume.",
                              "description": "[iam_role]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html",
                              "type": [
                                "string",
                                "null"
                              ],
                              "_metadata": {
                                "docs::optional": true,
                                "docs::examples": "arn:aws:iam::123456789098:role/my_role",
                                "docs::human_name": "Assume Role"
                              }
                            },
                            "external_id": {
                              "title": "The optional unique external ID in conjunction with role to assume.",
                              "description": "[external_id]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html",
                              "type": [
                                "string",
                                "null"
                              ],
                              "_metadata": {
                                "docs::optional": true,
                                "docs::examples": "randomEXAMPLEidString",
                                "docs::human_name": "External ID"
                              }
                            },
                            "region": {
                              "title": "The [AWS region][aws_region] to send STS requests to.",
                              "description": "If not set, this will default to the configured region\nfor the service itself.\n\n[aws_region]: https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints",
                              "type": [
                                "string",
                                "null"
                              ],
                              "_metadata": {
                                "docs::optional": true,
                                "docs::examples": "us-west-2",
                                "docs::human_name": "Region"
                              }
                            },
                            "secret_access_key": {
                              "description": "The AWS secret access key.",
                              "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
                              "_metadata": {
                                "docs::examples": "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY",
                                "docs::human_name": "Secret Access Key"
                              }
                            }
                          },
                          "_metadata": {
                            "logical_name": "AccessKey",
                            "docs::human_name": "Access Key"
                          }
                        },
                        {
                          "title": "Authenticate using credentials stored in a file.",
                          "description": "Additionally, the specific credential profile to use can be set.\nThe file format must match the credentials file format outlined in\n<https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html>.",
                          "type": "object",
                          "required": [
                            "credentials_file"
                          ],
                          "properties": {
                            "credentials_file": {
                              "description": "Path to the credentials file.",
                              "type": "string",
                              "_metadata": {
                                "docs::examples": "/my/aws/credentials",
                                "docs::human_name": "Credentials File"
                              }
                            },
                            "profile": {
                              "title": "The credentials profile to use.",
                              "description": "Used to select AWS credentials from a provided credentials file.",
                              "default": "default",
                              "type": "string",
                              "_metadata": {
                                "docs::examples": "develop",
                                "docs::human_name": "Profile"
                              }
                            }
                          },
                          "_metadata": {
                            "logical_name": "File",
                            "docs::human_name": "File"
                          }
                        },
                        {
                          "description": "Assume the given role ARN.",
                          "type": "object",
                          "required": [
                            "assume_role"
                          ],
                          "properties": {
                            "assume_role": {
                              "title": "The ARN of an [IAM role][iam_role] to assume.",
                              "description": "[iam_role]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html",
                              "type": "string",
                              "_metadata": {
                                "docs::examples": "arn:aws:iam::123456789098:role/my_role",
                                "docs::human_name": "Assume Role"
                              }
                            },
                            "external_id": {
                              "title": "The optional unique external ID in conjunction with role to assume.",
                              "description": "[external_id]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html",
                              "type": [
                                "string",
                                "null"
                              ],
                              "_metadata": {
                                "docs::optional": true,
                                "docs::examples": "randomEXAMPLEidString",
                                "docs::human_name": "External ID"
                              }
                            },
                            "imds": {
                              "description": "Configuration for authenticating with AWS through IMDS.",
                              "default": {
                                "max_attempts": 4,
                                "connect_timeout_seconds": 1,
                                "read_timeout_seconds": 1
                              },
                              "type": "object",
                              "properties": {
                                "connect_timeout_seconds": {
                                  "description": "Connect timeout for IMDS.",
                                  "default": 1,
                                  "$ref": "#/definitions/serde_with::DurationSeconds",
                                  "_metadata": {
                                    "docs::human_name": "Connect Timeout Seconds"
                                  }
                                },
                                "max_attempts": {
                                  "description": "Number of IMDS retries for fetching tokens and metadata.",
                                  "default": 4,
                                  "type": "integer",
                                  "maximum": 4294967295.0,
                                  "minimum": 0.0,
                                  "_metadata": {
                                    "docs::numeric_type": "uint",
                                    "docs::human_name": "Max Attempts"
                                  }
                                },
                                "read_timeout_seconds": {
                                  "description": "Read timeout for IMDS.",
                                  "default": 1,
                                  "$ref": "#/definitions/serde_with::DurationSeconds",
                                  "_metadata": {
                                    "docs::human_name": "Read Timeout Seconds"
                                  }
                                }
                              },
                              "unevaluatedProperties": false,
                              "_metadata": {
                                "docs::human_name": "IMDS"
                              }
                            },
                            "load_timeout_secs": {
                              "title": "Timeout for assuming the role, in seconds.",
                              "description": "Relevant when the default credentials chain or `assume_role` is used.",
                              "type": [
                                "integer",
                                "null"
                              ],
                              "maximum": 9007199254740991.0,
                              "minimum": 0.0,
                              "_metadata": {
                                "docs::numeric_type": "uint",
                                "docs::optional": true,
                                "docs::type_unit": "seconds",
                                "docs::examples": 30,
                                "docs::human_name": "Load Timeout"
                              }
                            },
                            "region": {
                              "title": "The [AWS region][aws_region] to send STS requests to.",
                              "description": "If not set, this defaults to the configured region\nfor the service itself.\n\n[aws_region]: https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints",
                              "type": [
                                "string",
                                "null"
                              ],
                              "_metadata": {
                                "docs::optional": true,
                                "docs::examples": "us-west-2",
                                "docs::human_name": "Region"
                              }
                            }
                          },
                          "_metadata": {
                            "logical_name": "Role",
                            "docs::human_name": "Role"
                          }
                        },
                        {
                          "description": "Default authentication strategy which tries a variety of substrategies in sequential order.",
                          "type": "object",
                          "properties": {
                            "imds": {
                              "description": "Configuration for authenticating with AWS through IMDS.",
                              "default": {
                                "max_attempts": 4,
                                "connect_timeout_seconds": 1,
                                "read_timeout_seconds": 1
                              },
                              "type": "object",
                              "properties": {
                                "connect_timeout_seconds": {
                                  "description": "Connect timeout for IMDS.",
                                  "default": 1,
                                  "$ref": "#/definitions/serde_with::DurationSeconds",
                                  "_metadata": {
                                    "docs::human_name": "Connect Timeout Seconds"
                                  }
                                },
                                "max_attempts": {
                                  "description": "Number of IMDS retries for fetching tokens and metadata.",
                                  "default": 4,
                                  "type": "integer",
                                  "maximum": 4294967295.0,
                                  "minimum": 0.0,
                                  "_metadata": {
                                    "docs::numeric_type": "uint",
                                    "docs::human_name": "Max Attempts"
                                  }
                                },
                                "read_timeout_seconds": {
                                  "description": "Read timeout for IMDS.",
                                  "default": 1,
                                  "$ref": "#/definitions/serde_with::DurationSeconds",
                                  "_metadata": {
                                    "docs::human_name": "Read Timeout Seconds"
                                  }
                                }
                              },
                              "unevaluatedProperties": false,
                              "_metadata": {
                                "docs::human_name": "IMDS"
                              }
                            },
                            "load_timeout_secs": {
                              "title": "Timeout for successfully loading any credentials, in seconds.",
                              "description": "Relevant when the default credentials chain or `assume_role` is used.",
                              "type": [
                                "integer",
                                "null"
                              ],
                              "maximum": 9007199254740991.0,
                              "minimum": 0.0,
                              "_metadata": {
                                "docs::numeric_type": "uint",
                                "docs::optional": true,
                                "docs::type_unit": "seconds",
                                "docs::examples": 30,
                                "docs::human_name": "Load Timeout"
                              }
                            },
                            "region": {
                              "title": "The [AWS region][aws_region] to send STS requests to.",
                              "description": "If not set, this defaults to the configured region\nfor the service itself.\n\n[aws_region]: https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints",
                              "type": [
                                "string",
                                "null"
                              ],
                              "_metadata": {
                                "docs::optional": true,
                                "docs::examples": "us-west-2",
                                "docs::human_name": "Region"
                              }
                            }
                          },
                          "_metadata": {
                            "logical_name": "Default",
                            "docs::human_name": "Default"
                          }
                        }
                      ],
                      "_metadata": {
                        "docs::enum_tagging": "untagged"
                      }
                    },
                    {
                      "type": "object",
                      "required": [
                        "strategy"
                      ],
                      "properties": {
                        "strategy": {
                          "description": "Amazon OpenSearch Service-specific authentication.",
                          "const": "aws",
                          "_metadata": {
                            "docs::human_name": "Strategy"
                          }
                        }
                      }
                    }
                  ],
                  "_metadata": {
                    "logical_name": "Aws",
                    "docs::human_name": "AWS"
                  }
                }
              ],
              "_metadata": {
                "docs::enum_tag_description": "The authentication strategy to use.",
                "docs::enum_tagging": "internal",
                "docs::enum_tag_field": "strategy"
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Auth"
          }
        },
        "aws": {
          "default": null,
          "$ref": "#/definitions/core::option::Option<vector::aws::region::RegionOrEndpoint>",
          "_metadata": {
            "docs::human_name": "AWS"
          }
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::RealtimeSizeBasedDefaultBatchSettings>",
          "_metadata": {
            "docs::human_name": "Batch"
          }
        },
        "bulk": {
          "description": "Elasticsearch bulk mode configuration.",
          "default": {
            "action": "index",
            "index": "vector-%Y.%m.%d"
          },
          "type": "object",
          "properties": {
            "action": {
              "title": "Action to use when making requests to the [Elasticsearch Bulk API][es_bulk].",
              "description": "Only `index` and `create` actions are supported.\n\n[es_bulk]: https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html",
              "default": "index",
              "$ref": "#/definitions/vector::template::Template",
              "_metadata": {
                "docs::examples": [
                  "create",
                  "{{ action }}"
                ],
                "docs::human_name": "Action"
              }
            },
            "index": {
              "description": "The name of the index to write events to.",
              "default": "vector-%Y.%m.%d",
              "$ref": "#/definitions/vector::template::Template",
              "_metadata": {
                "docs::examples": [
                  "application-{{ application_id }}-%Y-%m-%d",
                  "{{ index }}"
                ],
                "docs::human_name": "Index"
              }
            }
          },
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::human_name": "Bulk"
          }
        },
        "compression": {
          "title": "Compression configuration.",
          "description": "All compression algorithms use the default compression level unless otherwise specified.",
          "default": "none",
          "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
          "_metadata": {
            "docs::human_name": "Compression"
          }
        },
        "data_stream": {
          "description": "Elasticsearch data stream mode configuration.",
          "default": null,
          "oneOf": [
            {
              "type": "null"
            },
            {
              "description": "Elasticsearch data stream mode configuration.",
              "type": "object",
              "properties": {
                "auto_routing": {
                  "title": "Automatically routes events by deriving the data stream name using specific event fields.",
                  "description": "The format of the data stream name is `<type>-<dataset>-<namespace>`, where each value comes\nfrom the `data_stream` configuration field of the same name.\n\nIf enabled, the value of the `data_stream.type`, `data_stream.dataset`, and\n`data_stream.namespace` event fields are used if they are present. Otherwise, the values\nset in this configuration are used.",
                  "default": true,
                  "type": "boolean",
                  "_metadata": {
                    "docs::human_name": "Auto Routing"
                  }
                },
                "dataset": {
                  "description": "The data stream dataset used to construct the data stream at index time.",
                  "default": "generic",
                  "$ref": "#/definitions/vector::template::Template",
                  "_metadata": {
                    "docs::examples": [
                      "generic",
                      "nginx",
                      "{{ service }}"
                    ],
                    "docs::human_name": "Dataset"
                  }
                },
                "namespace": {
                  "description": "The data stream namespace used to construct the data stream at index time.",
                  "default": "default",
                  "$ref": "#/definitions/vector::template::Template",
                  "_metadata": {
                    "docs::examples": "{{ environment }}",
                    "docs::human_name": "Namespace"
                  }
                },
                "sync_fields": {
                  "title": "Automatically adds and syncs the `data_stream.*` event fields if they are missing from the event.",
                  "description": "This ensures that fields match the name of the data stream that is receiving events.",
                  "default": true,
                  "type": "boolean",
                  "_metadata": {
                    "docs::human_name": "Sync Fields"
                  }
                },
                "type": {
                  "description": "The data stream type used to construct the data stream at index time.",
                  "default": "logs",
                  "$ref": "#/definitions/vector::template::Template",
                  "_metadata": {
                    "docs::examples": [
                      "metrics",
                      "synthetics",
                      "{{ type }}"
                    ],
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Data Stream"
          }
        },
        "distribution": {
          "description": "Options for determining the health of an endpoint.",
          "default": null,
          "oneOf": [
            {
              "type": "null"
            },
            {
              "description": "Options for determining the health of an endpoint.",
              "type": "object",
              "properties": {
                "retry_initial_backoff_secs": {
                  "description": "Initial delay between attempts to reactivate endpoints once they become unhealthy.",
                  "default": 1,
                  "type": "integer",
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::type_unit": "seconds",
                    "docs::human_name": "Retry Initial Backoff"
                  }
                },
                "retry_max_duration_secs": {
                  "description": "Maximum delay between attempts to reactivate endpoints once they become unhealthy.",
                  "default": 3600,
                  "$ref": "#/definitions/serde_with::DurationSeconds",
                  "_metadata": {
                    "docs::human_name": "Max Retry Duration"
                  }
                }
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Distribution"
          }
        },
        "doc_type": {
          "title": "The [`doc_type`][doc_type] for your index data.",
          "description": "This is only relevant for Elasticsearch <= 6.X. If you are using >= 7.0 you do not need to\nset this option since Elasticsearch has removed it.\n\n[doc_type]: https://www.elastic.co/guide/en/elasticsearch/reference/6.8/actions-index.html",
          "default": "_doc",
          "type": "string",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Doc Type"
          }
        },
        "encoding": {
          "description": "Transformations to prepare an event for serialization.",
          "default": {},
          "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Encoding"
          }
        },
        "endpoint": {
          "title": "The Elasticsearch endpoint to send logs to.",
          "description": "The endpoint must contain an HTTP scheme, and may specify a\nhostname or IP address and port.",
          "default": null,
          "deprecated": true,
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "deprecated_message": "This option has been deprecated, the `endpoints` option should be used instead.",
            "docs::human_name": "Endpoint"
          }
        },
        "endpoints": {
          "title": "A list of Elasticsearch endpoints to send logs to.",
          "description": "The endpoint must contain an HTTP scheme, and may specify a\nhostname or IP address and port.",
          "default": [],
          "type": "array",
          "items": {
            "type": "string"
          },
          "_metadata": {
            "docs::examples": [
              "http://10.24.32.122:9000",
              "https://example.com",
              "https://user:password@example.com"
            ],
            "docs::human_name": "Endpoints"
          }
        },
        "id_key": {
          "title": "The name of the event key that should map to Elasticsearch’s [`_id` field][es_id].",
          "description": "By default, the `_id` field is not set, which allows Elasticsearch to set this\nautomatically. Setting your own Elasticsearch IDs can [hinder performance][perf_doc].\n\n[es_id]: https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-id-field.html\n[perf_doc]: https://www.elastic.co/guide/en/elasticsearch/reference/master/tune-for-indexing-speed.html#_use_auto_generated_ids",
          "default": null,
          "$ref": "#/definitions/core::option::Option<vector_lookup::lookup_v2::ConfigValuePath>",
          "_metadata": {
            "docs::advanced": true,
            "docs::examples": [
              "id",
              "_id"
            ],
            "docs::human_name": "ID Key"
          }
        },
        "metrics": {
          "description": "Configuration for the `metric_to_log` transform.",
          "default": null,
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/vector::transforms::metric_to_log::MetricToLogConfig"
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Metrics"
          }
        },
        "mode": {
          "description": "Elasticsearch Indexing mode.",
          "default": "bulk",
          "oneOf": [
            {
              "description": "Ingests documents in bulk, using the bulk API `index` action.",
              "const": "bulk",
              "_metadata": {
                "logical_name": "Bulk",
                "docs::human_name": "Bulk"
              }
            },
            {
              "title": "Ingests documents in bulk, using the bulk API `create` action.",
              "description": "Elasticsearch Data Streams only support the `create` action.",
              "const": "data_stream",
              "_metadata": {
                "logical_name": "DataStream",
                "docs::human_name": "Data Stream"
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::enum_tagging": "external",
            "docs::human_name": "Mode"
          }
        },
        "pipeline": {
          "description": "The name of the pipeline to apply.",
          "default": null,
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::advanced": true,
            "docs::examples": "pipeline-name",
            "docs::human_name": "Pipeline"
          }
        },
        "query": {
          "description": "Custom parameters to add to the query string for each HTTP request sent to Elasticsearch.",
          "default": null,
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "type": "string"
          },
          "_metadata": {
            "docs::optional": true,
            "docs::advanced": true,
            "docs::additional_props_description": "A query string parameter.",
            "docs::examples": {
              "X-Powered-By": "Vector"
            },
            "docs::human_name": "Query"
          }
        },
        "request": {
          "description": "Outbound HTTP request settings.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "initial_concurrency": 1,
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            },
            "headers": {}
          },
          "$ref": "#/definitions/vector::sinks::util::http::RequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          }
        },
        "request_retry_partial": {
          "title": "Whether or not to retry successful requests containing partial failures.",
          "description": "To avoid duplicates in Elasticsearch, please use option `id_key`.",
          "default": false,
          "type": "boolean",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Request Retry Partial"
          }
        },
        "suppress_type_name": {
          "title": "Whether or not to send the `type` field to Elasticsearch.",
          "description": "The `type` field was deprecated in Elasticsearch 7.x and removed in Elasticsearch 8.x.\n\nIf enabled, the `doc_type` option is ignored.",
          "default": false,
          "deprecated": true,
          "type": "boolean",
          "_metadata": {
            "deprecated_message": "This option has been deprecated, the `api_version` option should be used instead.",
            "docs::human_name": "Suppress Type Name"
          }
        },
        "tls": {
          "default": null,
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "elasticsearch"
      }
    },
    "vector::sinks::file::FileSinkConfig": {
      "description": "Configuration for the `file` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "path"
          ],
          "properties": {
            "acknowledgements": {
              "title": "Controls how acknowledgements are handled for this sink.",
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              }
            },
            "compression": {
              "description": "Compression configuration.",
              "default": "none",
              "oneOf": [
                {
                  "title": "[Gzip][gzip] compression.",
                  "description": "[gzip]: https://www.gzip.org/",
                  "const": "gzip",
                  "_metadata": {
                    "logical_name": "Gzip",
                    "docs::human_name": "Gzip"
                  }
                },
                {
                  "title": "[Zstandard][zstd] compression.",
                  "description": "[zstd]: https://facebook.github.io/zstd/",
                  "const": "zstd",
                  "_metadata": {
                    "logical_name": "Zstd",
                    "docs::human_name": "Zstd"
                  }
                },
                {
                  "description": "No compression.",
                  "const": "none",
                  "_metadata": {
                    "logical_name": "None",
                    "docs::human_name": "None"
                  }
                }
              ],
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::enum_tagging": "external",
                "docs::human_name": "Compression"
              }
            },
            "idle_timeout_secs": {
              "title": "The amount of time that a file can be idle and stay open.",
              "description": "After not receiving any events in this amount of time, the file is flushed and closed.",
              "default": 30,
              "$ref": "#/definitions/serde_with::DurationSeconds",
              "_metadata": {
                "docs::examples": 600,
                "docs::human_name": "Idle Timeout"
              }
            },
            "path": {
              "title": "File path to write events to.",
              "description": "Compression format extension must be explicit.",
              "$ref": "#/definitions/vector::template::Template",
              "_metadata": {
                "docs::examples": [
                  "/tmp/vector-%Y-%m-%d.log",
                  "/tmp/application-{{ application_id }}-%Y-%m-%d.log",
                  "/tmp/vector-%Y-%m-%d.log.zst"
                ],
                "docs::human_name": "Path"
              }
            }
          }
        },
        {
          "description": "Encoding configuration.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfigWithFraming"
        }
      ],
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "file"
      }
    },
    "vector::sinks::gcp::chronicle_unstructured::ChronicleUnstructuredConfig": {
      "description": "Configuration for the `gcp_chronicle_unstructured` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "customer_id",
            "encoding",
            "log_type"
          ],
          "properties": {
            "acknowledgements": {
              "title": "Controls how acknowledgements are handled for this sink.",
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              }
            },
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "type": "object",
              "properties": {
                "max_bytes": {
                  "title": "The maximum size of a batch that is processed by a sink.",
                  "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
                  "default": 1000000,
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes",
                    "docs::human_name": "Max Bytes"
                  }
                },
                "max_events": {
                  "description": "The maximum size of a batch before it is flushed.",
                  "default": null,
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "events",
                    "docs::human_name": "Max Events"
                  }
                },
                "timeout_secs": {
                  "description": "The maximum age of a batch before it is flushed.",
                  "default": 15.0,
                  "type": [
                    "number",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": -9007199254740991.0,
                  "_metadata": {
                    "docs::numeric_type": "float",
                    "docs::optional": true,
                    "docs::type_unit": "seconds",
                    "docs::human_name": "Timeout"
                  }
                }
              },
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Batch"
              }
            },
            "customer_id": {
              "description": "The Unique identifier (UUID) corresponding to the Chronicle instance.",
              "type": "string",
              "format": "uuid",
              "_metadata": {
                "docs::examples": "c8c65bfa-5f2c-42d4-9189-64bb7b939f2c",
                "docs::human_name": "Customer ID"
              }
            },
            "encoding": {
              "description": "Configures how events are encoded into raw bytes.",
              "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
              "_metadata": {
                "docs::human_name": "Encoding"
              }
            },
            "endpoint": {
              "description": "The endpoint to send data to.",
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::examples": [
                  "127.0.0.1:8080",
                  "example.com:12345"
                ],
                "docs::human_name": "Endpoint"
              }
            },
            "log_type": {
              "title": "The type of log entries in a request.",
              "description": "This must be one of the [supported log types][unstructured_log_types_doc], otherwise\nChronicle rejects the entry with an error.\n\n[unstructured_log_types_doc]: https://cloud.google.com/chronicle/docs/ingestion/parser-list/supported-default-parsers",
              "$ref": "#/definitions/vector::template::Template",
              "_metadata": {
                "docs::examples": [
                  "WINDOWS_DNS",
                  "{{ log_type }}"
                ],
                "docs::human_name": "Log Type"
              }
            },
            "region": {
              "description": "The GCP region to use.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "description": "Google Chronicle regions.",
                  "oneOf": [
                    {
                      "description": "EU region.",
                      "const": "eu",
                      "_metadata": {
                        "logical_name": "Eu",
                        "docs::human_name": "EU"
                      }
                    },
                    {
                      "description": "US region.",
                      "const": "us",
                      "_metadata": {
                        "logical_name": "Us",
                        "docs::human_name": "US"
                      }
                    },
                    {
                      "description": "APAC region.",
                      "const": "asia",
                      "_metadata": {
                        "logical_name": "Asia",
                        "docs::human_name": "Asia"
                      }
                    }
                  ],
                  "_metadata": {
                    "docs::enum_tagging": "external"
                  }
                }
              ],
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::optional": true,
                "docs::human_name": "Region"
              }
            },
            "request": {
              "title": "Middleware settings for outbound requests.",
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "initial_concurrency": 1,
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                }
              },
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              }
            },
            "tls": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              }
            }
          }
        },
        {
          "description": "Configuration of the authentication strategy for interacting with GCP services.",
          "$ref": "#/definitions/vector::gcp::GcpAuthConfig"
        }
      ],
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "gcp_chronicle_unstructured"
      }
    },
    "vector::sinks::gcp::cloud_storage::GcsSinkConfig": {
      "description": "Configuration for the `gcp_cloud_storage` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "bucket"
          ],
          "properties": {
            "acknowledgements": {
              "title": "Controls how acknowledgements are handled for this sink.",
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              }
            },
            "acl": {
              "title": "The Predefined ACL to apply to created objects.",
              "description": "For more information, see [Predefined ACLs][predefined_acls].\n\n[predefined_acls]: https://cloud.google.com/storage/docs/access-control/lists#predefined-acl",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "title": "GCS Predefined ACLs.",
                  "description": "For more information, see [Predefined ACLs][predefined_acls].\n\n[predefined_acls]: https://cloud.google.com/storage/docs/access-control/lists#predefined-acl",
                  "oneOf": [
                    {
                      "title": "Bucket/object can be read by authenticated users.",
                      "description": "The bucket/object owner is granted the `OWNER` permission, and anyone authenticated Google\naccount holder is granted the `READER` permission.",
                      "const": "authenticated-read",
                      "_metadata": {
                        "logical_name": "AuthenticatedRead",
                        "docs::human_name": "Authenticated Read"
                      }
                    },
                    {
                      "title": "Object is semi-private.",
                      "description": "Both the object owner and bucket owner are granted the `OWNER` permission.\n\nOnly relevant when specified for an object: this predefined ACL is otherwise ignored when\nspecified for a bucket.",
                      "const": "bucket-owner-full-control",
                      "_metadata": {
                        "logical_name": "BucketOwnerFullControl",
                        "docs::human_name": "Bucket Owner Full Control"
                      }
                    },
                    {
                      "title": "Object is private, except to the bucket owner.",
                      "description": "The object owner is granted the `OWNER` permission, and the bucket owner is granted the\n`READER` permission.\n\nOnly relevant when specified for an object: this predefined ACL is otherwise ignored when\nspecified for a bucket.",
                      "const": "bucket-owner-read",
                      "_metadata": {
                        "logical_name": "BucketOwnerRead",
                        "docs::human_name": "Bucket Owner Read"
                      }
                    },
                    {
                      "title": "Bucket/object are private.",
                      "description": "The bucket/object owner is granted the `OWNER` permission, and no one else has\naccess.",
                      "const": "private",
                      "_metadata": {
                        "logical_name": "Private",
                        "docs::human_name": "Private"
                      }
                    },
                    {
                      "title": "Bucket/object are private within the project.",
                      "description": "Project owners and project editors are granted the `OWNER` permission, and anyone who is\npart of the project team is granted the `READER` permission.\n\nThis is the default.",
                      "const": "project-private",
                      "_metadata": {
                        "logical_name": "ProjectPrivate",
                        "docs::human_name": "Project Private"
                      }
                    },
                    {
                      "title": "Bucket/object can be read publically.",
                      "description": "The bucket/object owner is granted the `OWNER` permission, and all other users, whether\nauthenticated or anonymous, are granted the `READER` permission.",
                      "const": "public-read",
                      "_metadata": {
                        "logical_name": "PublicRead",
                        "docs::human_name": "Public Read"
                      }
                    }
                  ],
                  "_metadata": {
                    "docs::enum_tagging": "external"
                  }
                }
              ],
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::optional": true,
                "docs::human_name": "ACL"
              }
            },
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::BulkSizeBasedDefaultBatchSettings>",
              "_metadata": {
                "docs::human_name": "Batch"
              }
            },
            "bucket": {
              "description": "The GCS bucket name.",
              "type": "string",
              "_metadata": {
                "docs::examples": "my-bucket",
                "docs::human_name": "Bucket"
              }
            },
            "compression": {
              "title": "Compression configuration.",
              "description": "All compression algorithms use the default compression level unless otherwise specified.",
              "default": "none",
              "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
              "_metadata": {
                "docs::human_name": "Compression"
              }
            },
            "filename_append_uuid": {
              "title": "Whether or not to append a UUID v4 token to the end of the object key.",
              "description": "The UUID is appended to the timestamp portion of the object key, such that if the object key\ngenerated is `date=2022-07-18/1658176486`, setting this field to `true` results\nin an object key that looks like `date=2022-07-18/1658176486-30f6652c-71da-4f9f-800d-a1189c47c547`.\n\nThis ensures there are no name collisions, and can be useful in high-volume workloads where\nobject keys must be unique.",
              "default": true,
              "type": "boolean",
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Filename Append UUID"
              }
            },
            "filename_extension": {
              "title": "The filename extension to use in the object key.",
              "description": "If not specified, the extension is determined by the compression scheme used.",
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::advanced": true,
                "docs::human_name": "Filename Extension"
              }
            },
            "filename_time_format": {
              "title": "The timestamp format for the time component of the object key.",
              "description": "By default, object keys are appended with a timestamp that reflects when the objects are\nsent to S3, such that the resulting object key is functionally equivalent to joining the key\nprefix with the formatted timestamp, such as `date=2022-07-18/1658176486`.\n\nThis would represent a `key_prefix` set to `date=%F/` and the timestamp of Mon Jul 18 2022\n20:34:44 GMT+0000, with the `filename_time_format` being set to `%s`, which renders\ntimestamps in seconds since the Unix epoch.\n\nSupports the common [`strftime`][chrono_strftime_specifiers] specifiers found in most\nlanguages.\n\nWhen set to an empty string, no timestamp is appended to the key prefix.\n\n[chrono_strftime_specifiers]: https://docs.rs/chrono/latest/chrono/format/strftime/index.html#specifiers",
              "default": "%s",
              "type": "string",
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Filename Time Format"
              }
            },
            "key_prefix": {
              "title": "A prefix to apply to all object keys.",
              "description": "Prefixes are useful for partitioning objects, such as by creating an object key that\nstores objects under a particular directory. If using a prefix for this purpose, it must end\nin `/` in order to act as a directory path. A trailing `/` is **not** automatically added.",
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::templateable": true,
                "docs::examples": [
                  "date=%F/",
                  "date=%F/hour=%H/",
                  "year=%Y/month=%m/day=%d/",
                  "application_id={{ application_id }}/date=%F/"
                ],
                "docs::advanced": true,
                "docs::human_name": "Key Prefix"
              }
            },
            "metadata": {
              "title": "The set of metadata `key:value` pairs for the created objects.",
              "description": "For more information, see the [custom metadata][custom_metadata] documentation.\n\n[custom_metadata]: https://cloud.google.com/storage/docs/metadata#custom-metadata",
              "type": [
                "object",
                "null"
              ],
              "additionalProperties": {
                "type": "string"
              },
              "_metadata": {
                "docs::optional": true,
                "docs::additional_props_description": "A key/value pair.",
                "docs::advanced": true,
                "docs::human_name": "Metadata"
              }
            },
            "request": {
              "title": "Middleware settings for outbound requests.",
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "initial_concurrency": 1,
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                }
              },
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              }
            },
            "storage_class": {
              "title": "The storage class for created objects.",
              "description": "For more information, see the [storage classes][storage_classes] documentation.\n\n[storage_classes]: https://cloud.google.com/storage/docs/storage-classes",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "title": "GCS storage classes.",
                  "description": "For more information, see [Storage classes][storage_classes].\n\n[storage_classes]: https://cloud.google.com/storage/docs/storage-classes",
                  "oneOf": [
                    {
                      "title": "Standard storage.",
                      "description": "This is the default.",
                      "const": "STANDARD",
                      "_metadata": {
                        "logical_name": "Standard",
                        "docs::human_name": "Standard"
                      }
                    },
                    {
                      "description": "Nearline storage.",
                      "const": "NEARLINE",
                      "_metadata": {
                        "logical_name": "Nearline",
                        "docs::human_name": "Nearline"
                      }
                    },
                    {
                      "description": "Coldline storage.",
                      "const": "COLDLINE",
                      "_metadata": {
                        "logical_name": "Coldline",
                        "docs::human_name": "Coldline"
                      }
                    },
                    {
                      "description": "Archive storage.",
                      "const": "ARCHIVE",
                      "_metadata": {
                        "logical_name": "Archive",
                        "docs::human_name": "Archive"
                      }
                    }
                  ],
                  "_metadata": {
                    "docs::enum_tagging": "external"
                  }
                }
              ],
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::optional": true,
                "docs::human_name": "Storage Class"
              }
            },
            "tls": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              }
            }
          }
        },
        {
          "description": "Encoding configuration.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfigWithFraming"
        },
        {
          "description": "Configuration of the authentication strategy for interacting with GCP services.",
          "$ref": "#/definitions/vector::gcp::GcpAuthConfig"
        }
      ],
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "gcp_cloud_storage"
      }
    },
    "vector::sinks::gcp::pubsub::PubsubConfig": {
      "description": "Configuration for the `gcp_pubsub` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "encoding",
            "project",
            "topic"
          ],
          "properties": {
            "acknowledgements": {
              "title": "Controls how acknowledgements are handled for this sink.",
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              }
            },
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "type": "object",
              "properties": {
                "max_bytes": {
                  "title": "The maximum size of a batch that is processed by a sink.",
                  "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
                  "default": 10000000,
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes",
                    "docs::human_name": "Max Bytes"
                  }
                },
                "max_events": {
                  "description": "The maximum size of a batch before it is flushed.",
                  "default": 1000,
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "events",
                    "docs::human_name": "Max Events"
                  }
                },
                "timeout_secs": {
                  "description": "The maximum age of a batch before it is flushed.",
                  "default": 1.0,
                  "type": [
                    "number",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": -9007199254740991.0,
                  "_metadata": {
                    "docs::numeric_type": "float",
                    "docs::optional": true,
                    "docs::type_unit": "seconds",
                    "docs::human_name": "Timeout"
                  }
                }
              },
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Batch"
              }
            },
            "encoding": {
              "description": "Configures how events are encoded into raw bytes.",
              "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
              "_metadata": {
                "docs::human_name": "Encoding"
              }
            },
            "endpoint": {
              "title": "The endpoint to which to publish events.",
              "description": "The scheme (`http` or `https`) must be specified. No path should be included since the paths defined\nby the [`GCP Pub/Sub`][pubsub_api] API are used.\n\nThe trailing slash `/` must not be included.\n\n[pubsub_api]: https://cloud.google.com/pubsub/docs/reference/rest",
              "default": "https://pubsub.googleapis.com",
              "type": "string",
              "_metadata": {
                "docs::examples": "https://us-central1-pubsub.googleapis.com",
                "docs::human_name": "Endpoint"
              }
            },
            "project": {
              "description": "The project name to which to publish events.",
              "type": "string",
              "_metadata": {
                "docs::examples": "vector-123456",
                "docs::human_name": "Project"
              }
            },
            "request": {
              "title": "Middleware settings for outbound requests.",
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "initial_concurrency": 1,
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                }
              },
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              }
            },
            "tls": {
              "default": null,
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              }
            },
            "topic": {
              "description": "The topic within the project to which to publish events.",
              "type": "string",
              "_metadata": {
                "docs::examples": "this-is-a-topic",
                "docs::human_name": "Topic"
              }
            }
          }
        },
        {
          "description": "Configuration of the authentication strategy for interacting with GCP services.",
          "default": {
            "api_key": null,
            "credentials_path": null
          },
          "$ref": "#/definitions/vector::gcp::GcpAuthConfig"
        }
      ],
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "gcp_pubsub"
      }
    },
    "vector::sinks::gcp::stackdriver::logs::config::StackdriverConfig": {
      "description": "Configuration for the `gcp_stackdriver_logs` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "log_id",
            "resource"
          ],
          "properties": {
            "acknowledgements": {
              "title": "Controls how acknowledgements are handled for this sink.",
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              }
            },
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::RealtimeSizeBasedDefaultBatchSettings>",
              "_metadata": {
                "docs::human_name": "Batch"
              }
            },
            "encoding": {
              "description": "Transformations to prepare an event for serialization.",
              "default": {},
              "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer",
              "_metadata": {
                "docs::human_name": "Encoding"
              }
            },
            "log_id": {
              "title": "The log ID to which to publish logs.",
              "description": "This is a name you create to identify this log stream.",
              "$ref": "#/definitions/vector::template::Template",
              "_metadata": {
                "docs::human_name": "Log ID"
              }
            },
            "request": {
              "title": "Middleware settings for outbound requests.",
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "initial_concurrency": 1,
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                }
              },
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              }
            },
            "resource": {
              "title": "A monitored resource.",
              "description": "The monitored resource to associate the logs with.",
              "allOf": [
                {
                  "type": "object",
                  "required": [
                    "type"
                  ],
                  "properties": {
                    "type": {
                      "title": "The monitored resource type.",
                      "description": "For example, the type of a Compute Engine VM instance is `gce_instance`.\nSee the [Google Cloud Platform monitored resource documentation][gcp_resources] for\nmore details.\n\n[gcp_resources]: https://cloud.google.com/monitoring/api/resources",
                      "type": "string",
                      "_metadata": {
                        "docs::human_name": "Type"
                      }
                    }
                  }
                },
                {
                  "description": "Type-specific labels.",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/definitions/vector::template::Template"
                  },
                  "_metadata": {
                    "docs::additional_props_description": "A type-specific label.",
                    "docs::examples": {
                      "zone": "{{ zone }}",
                      "instanceId": "Twilight"
                    }
                  }
                }
              ],
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::human_name": "Resource"
              }
            },
            "severity_key": {
              "title": "The field of the log event from which to take the outgoing log’s `severity` field.",
              "description": "The named field is removed from the log event if present, and must be either an integer\nbetween 0 and 800 or a string containing one of the [severity level names][sev_names] (case\nis ignored) or a common prefix such as `err`.\n\nIf no severity key is specified, the severity of outgoing records is set to 0 (`DEFAULT`).\n\nSee the [GCP Stackdriver Logging LogSeverity description][logsev_docs] for more details on\nthe value of the `severity` field.\n\n[sev_names]: https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logseverity\n[logsev_docs]: https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logseverity",
              "$ref": "#/definitions/core::option::Option<vector_lookup::lookup_v2::ConfigValuePath>",
              "_metadata": {
                "docs::examples": "severity",
                "docs::human_name": "Severity Key"
              }
            },
            "tls": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              }
            }
          }
        },
        {
          "description": "Logging locations.",
          "oneOf": [
            {
              "title": "The billing account ID to which to publish logs.",
              "description": "Exactly one of `billing_account_id`, `folder_id`, `organization_id`, or `project_id` must be set.",
              "type": "object",
              "required": [
                "billing_account_id"
              ],
              "properties": {
                "billing_account_id": {
                  "type": "string",
                  "_metadata": {
                    "docs::human_name": "Billing Account ID"
                  }
                }
              },
              "_metadata": {
                "docs::examples": "012345-6789AB-CDEF01",
                "logical_name": "BillingAccount",
                "docs::human_name": "Billing Account"
              }
            },
            {
              "title": "The folder ID to which to publish logs.",
              "description": "See the [Google Cloud Platform folder documentation][folder_docs] for more details.\n\nExactly one of `billing_account_id`, `folder_id`, `organization_id`, or `project_id` must be set.\n\n[folder_docs]: https://cloud.google.com/resource-manager/docs/creating-managing-folders",
              "type": "object",
              "required": [
                "folder_id"
              ],
              "properties": {
                "folder_id": {
                  "type": "string",
                  "_metadata": {
                    "docs::human_name": "Folder ID"
                  }
                }
              },
              "_metadata": {
                "docs::examples": "My Folder",
                "logical_name": "Folder",
                "docs::human_name": "Folder"
              }
            },
            {
              "title": "The organization ID to which to publish logs.",
              "description": "This would be the identifier assigned to your organization on Google Cloud Platform.\n\nExactly one of `billing_account_id`, `folder_id`, `organization_id`, or `project_id` must be set.",
              "type": "object",
              "required": [
                "organization_id"
              ],
              "properties": {
                "organization_id": {
                  "type": "string",
                  "_metadata": {
                    "docs::human_name": "Organization ID"
                  }
                }
              },
              "_metadata": {
                "docs::examples": "622418129737",
                "logical_name": "Organization",
                "docs::human_name": "Organization"
              }
            },
            {
              "title": "The project ID to which to publish logs.",
              "description": "See the [Google Cloud Platform project management documentation][project_docs] for more details.\n\nExactly one of `billing_account_id`, `folder_id`, `organization_id`, or `project_id` must be set.\n\n[project_docs]: https://cloud.google.com/resource-manager/docs/creating-managing-projects",
              "type": "object",
              "required": [
                "project_id"
              ],
              "properties": {
                "project_id": {
                  "type": "string",
                  "_metadata": {
                    "docs::human_name": "Project ID"
                  }
                }
              },
              "_metadata": {
                "docs::examples": "vector-123456",
                "logical_name": "Project",
                "docs::human_name": "Project"
              }
            }
          ],
          "_metadata": {
            "docs::enum_tagging": "external"
          }
        },
        {
          "description": "Configuration of the authentication strategy for interacting with GCP services.",
          "$ref": "#/definitions/vector::gcp::GcpAuthConfig"
        }
      ],
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "gcp_stackdriver_logs"
      }
    },
    "vector::sinks::gcp::stackdriver_metrics::StackdriverConfig": {
      "description": "Configuration for the `gcp_stackdriver_metrics` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "project_id",
            "resource"
          ],
          "properties": {
            "acknowledgements": {
              "title": "Controls how acknowledgements are handled for this sink.",
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              }
            },
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "type": "object",
              "properties": {
                "max_bytes": {
                  "title": "The maximum size of a batch that is processed by a sink.",
                  "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
                  "default": null,
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes",
                    "docs::human_name": "Max Bytes"
                  }
                },
                "max_events": {
                  "description": "The maximum size of a batch before it is flushed.",
                  "default": 1,
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "events",
                    "docs::human_name": "Max Events"
                  }
                },
                "timeout_secs": {
                  "description": "The maximum age of a batch before it is flushed.",
                  "default": 1.0,
                  "type": [
                    "number",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": -9007199254740991.0,
                  "_metadata": {
                    "docs::numeric_type": "float",
                    "docs::optional": true,
                    "docs::type_unit": "seconds",
                    "docs::human_name": "Timeout"
                  }
                }
              },
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Batch"
              }
            },
            "default_namespace": {
              "title": "The default namespace to use for metrics that do not have one.",
              "description": "Metrics with the same name can only be differentiated by their namespace, and not all\nmetrics have their own namespace.",
              "default": "namespace",
              "type": "string",
              "_metadata": {
                "docs::human_name": "Default Namespace"
              }
            },
            "project_id": {
              "title": "The project ID to which to publish metrics.",
              "description": "See the [Google Cloud Platform project management documentation][project_docs] for more details.\n\n[project_docs]: https://cloud.google.com/resource-manager/docs/creating-managing-projects",
              "type": "string",
              "_metadata": {
                "docs::human_name": "Project ID"
              }
            },
            "request": {
              "title": "Middleware settings for outbound requests.",
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "initial_concurrency": 1,
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                }
              },
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              }
            },
            "resource": {
              "title": "A monitored resource.",
              "description": "The monitored resource to associate the metrics with.",
              "allOf": [
                {
                  "type": "object",
                  "required": [
                    "type"
                  ],
                  "properties": {
                    "type": {
                      "title": "The monitored resource type.",
                      "description": "For example, the type of a Compute Engine VM instance is `gce_instance`.",
                      "type": "string",
                      "_metadata": {
                        "docs::examples": [
                          "global",
                          "gce_instance"
                        ],
                        "docs::human_name": "Type"
                      }
                    }
                  }
                },
                {
                  "description": "Type-specific labels.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  },
                  "_metadata": {
                    "docs::additional_props_description": "Values for all of the labels listed in the associated monitored resource descriptor.\n\nFor example, Compute Engine VM instances use the labels `projectId`, `instanceId`, and `zone`.",
                    "docs::examples": {
                      "projectId": "vector-123456",
                      "instanceId": "Twilight",
                      "type": "global",
                      "zone": "us-central1-a"
                    }
                  }
                }
              ],
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::human_name": "Resource"
              }
            },
            "tls": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              }
            }
          }
        },
        {
          "description": "Configuration of the authentication strategy for interacting with GCP services.",
          "$ref": "#/definitions/vector::gcp::GcpAuthConfig"
        }
      ],
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "gcp_stackdriver_metrics"
      }
    },
    "vector::sinks::greptimedb::GreptimeDBConfig": {
      "description": "Configuration items for GreptimeDB",
      "type": "object",
      "required": [
        "endpoint"
      ],
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled for this sink.",
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "type": "object",
          "properties": {
            "max_bytes": {
              "title": "The maximum size of a batch that is processed by a sink.",
              "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
              "default": null,
              "type": [
                "integer",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "bytes",
                "docs::human_name": "Max Bytes"
              }
            },
            "max_events": {
              "description": "The maximum size of a batch before it is flushed.",
              "default": 20,
              "type": [
                "integer",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "events",
                "docs::human_name": "Max Events"
              }
            },
            "timeout_secs": {
              "description": "The maximum age of a batch before it is flushed.",
              "default": 1.0,
              "type": [
                "number",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": -9007199254740991.0,
              "_metadata": {
                "docs::numeric_type": "float",
                "docs::optional": true,
                "docs::type_unit": "seconds",
                "docs::human_name": "Timeout"
              }
            }
          },
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Batch"
          }
        },
        "dbname": {
          "title": "The GreptimeDB [database][database] name to connect.",
          "description": "Default to `public`, the default database of GreptimeDB.\n\nDatabase can be created via `create database` statement on\nGreptimeDB. If you are using GreptimeCloud, use `dbname` from the\nconnection information of your instance.\n\n[database]: https://docs.greptime.com/user-guide/concepts/key-concepts#database",
          "default": "public",
          "type": "string",
          "_metadata": {
            "docs::examples": "public",
            "docs::human_name": "Dbname"
          }
        },
        "endpoint": {
          "title": "The host and port of GreptimeDB gRPC service.",
          "description": "This sink uses GreptimeDB's gRPC interface for data ingestion. By\ndefault, GreptimeDB listens to port 4001 for gRPC protocol.\n\nThe address _must_ include a port.",
          "type": "string",
          "_metadata": {
            "docs::examples": [
              "example.com:4001",
              "1nge17d2r3ns.ap-southeast-1.aws.greptime.cloud:4001"
            ],
            "docs::human_name": "Endpoint"
          }
        },
        "password": {
          "title": "The password for your GreptimeDB instance.",
          "description": "This is required if your instance has authentication enabled.",
          "default": null,
          "$ref": "#/definitions/core::option::Option<vector_common::sensitive_string::SensitiveString>",
          "_metadata": {
            "docs::examples": "password",
            "docs::human_name": "Password"
          }
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "initial_concurrency": 1,
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          }
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        },
        "username": {
          "title": "The username for your GreptimeDB instance.",
          "description": "This is required if your instance has authentication enabled.",
          "default": null,
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::examples": "username",
            "docs::human_name": "Username"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "greptimedb"
      }
    },
    "vector::sinks::honeycomb::config::HoneycombConfig": {
      "description": "Configuration for the `honeycomb` sink.",
      "type": "object",
      "required": [
        "api_key",
        "dataset"
      ],
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled for this sink.",
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "api_key": {
          "description": "The API key that is used to authenticate against Honeycomb.",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "docs::examples": [
              "${HONEYCOMB_API_KEY}",
              "some-api-key"
            ],
            "docs::human_name": "API Key"
          }
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "type": "object",
          "properties": {
            "max_bytes": {
              "title": "The maximum size of a batch that is processed by a sink.",
              "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
              "default": 100000,
              "type": [
                "integer",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "bytes",
                "docs::human_name": "Max Bytes"
              }
            },
            "max_events": {
              "description": "The maximum size of a batch before it is flushed.",
              "default": null,
              "type": [
                "integer",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "events",
                "docs::human_name": "Max Events"
              }
            },
            "timeout_secs": {
              "description": "The maximum age of a batch before it is flushed.",
              "default": 1.0,
              "type": [
                "number",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": -9007199254740991.0,
              "_metadata": {
                "docs::numeric_type": "float",
                "docs::optional": true,
                "docs::type_unit": "seconds",
                "docs::human_name": "Timeout"
              }
            }
          },
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Batch"
          }
        },
        "dataset": {
          "description": "The dataset to which logs are sent.",
          "type": "string",
          "_metadata": {
            "docs::examples": "my-honeycomb-dataset",
            "docs::human_name": "Dataset"
          }
        },
        "encoding": {
          "description": "Transformations to prepare an event for serialization.",
          "default": {},
          "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer",
          "_metadata": {
            "docs::human_name": "Encoding"
          }
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "initial_concurrency": 1,
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "honeycomb"
      }
    },
    "vector::sinks::http::config::HttpSinkConfig": {
      "description": "Configuration for the `http` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "uri"
          ],
          "properties": {
            "acknowledgements": {
              "title": "Controls how acknowledgements are handled for this sink.",
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              }
            },
            "auth": {
              "$ref": "#/definitions/core::option::Option<vector::http::Auth>",
              "_metadata": {
                "docs::human_name": "Auth"
              }
            },
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::RealtimeSizeBasedDefaultBatchSettings>",
              "_metadata": {
                "docs::human_name": "Batch"
              }
            },
            "compression": {
              "title": "Compression configuration.",
              "description": "All compression algorithms use the default compression level unless otherwise specified.",
              "default": "none",
              "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
              "_metadata": {
                "docs::human_name": "Compression"
              }
            },
            "headers": {
              "description": "A list of custom headers to add to each request.",
              "deprecated": true,
              "type": [
                "object",
                "null"
              ],
              "additionalProperties": {
                "type": "string"
              },
              "_metadata": {
                "docs::optional": true,
                "deprecated_message": "This option has been deprecated, use `request.headers` instead.",
                "docs::additional_props_description": "An HTTP request header and it's value.",
                "docs::human_name": "Headers"
              }
            },
            "method": {
              "title": "HTTP method.",
              "description": "The HTTP method to use when making the request.",
              "default": "post",
              "oneOf": [
                {
                  "description": "GET.",
                  "const": "get",
                  "_metadata": {
                    "logical_name": "Get",
                    "docs::human_name": "Get"
                  }
                },
                {
                  "description": "HEAD.",
                  "const": "head",
                  "_metadata": {
                    "logical_name": "Head",
                    "docs::human_name": "Head"
                  }
                },
                {
                  "description": "POST.",
                  "const": "post",
                  "_metadata": {
                    "logical_name": "Post",
                    "docs::human_name": "Post"
                  }
                },
                {
                  "description": "PUT.",
                  "const": "put",
                  "_metadata": {
                    "logical_name": "Put",
                    "docs::human_name": "Put"
                  }
                },
                {
                  "description": "DELETE.",
                  "const": "delete",
                  "_metadata": {
                    "logical_name": "Delete",
                    "docs::human_name": "Delete"
                  }
                },
                {
                  "description": "OPTIONS.",
                  "const": "options",
                  "_metadata": {
                    "logical_name": "Options",
                    "docs::human_name": "Options"
                  }
                },
                {
                  "description": "TRACE.",
                  "const": "trace",
                  "_metadata": {
                    "logical_name": "Trace",
                    "docs::human_name": "Trace"
                  }
                },
                {
                  "description": "PATCH.",
                  "const": "patch",
                  "_metadata": {
                    "logical_name": "Patch",
                    "docs::human_name": "Patch"
                  }
                }
              ],
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::enum_tagging": "external",
                "docs::human_name": "Method"
              }
            },
            "payload_prefix": {
              "title": "A string to prefix the payload with.",
              "description": "This option is ignored if the encoding is not character delimited JSON.\n\nIf specified, the `payload_suffix` must also be specified and together they must produce a valid JSON object.",
              "default": "",
              "type": "string",
              "_metadata": {
                "docs::examples": "{\"data\":",
                "docs::human_name": "Payload Prefix"
              }
            },
            "payload_suffix": {
              "title": "A string to suffix the payload with.",
              "description": "This option is ignored if the encoding is not character delimited JSON.\n\nIf specified, the `payload_prefix` must also be specified and together they must produce a valid JSON object.",
              "default": "",
              "type": "string",
              "_metadata": {
                "docs::examples": "}",
                "docs::human_name": "Payload Suffix"
              }
            },
            "request": {
              "description": "Outbound HTTP request settings.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "initial_concurrency": 1,
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                },
                "headers": {}
              },
              "$ref": "#/definitions/vector::sinks::util::http::RequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              }
            },
            "tls": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              }
            },
            "uri": {
              "title": "The full URI to make HTTP requests to.",
              "description": "This should include the protocol and host, but can also include the port, path, and any other valid part of a URI.",
              "$ref": "#/definitions/vector::sinks::util::uri::UriSerde",
              "_metadata": {
                "docs::examples": "https://10.22.212.22:9000/endpoint",
                "docs::human_name": "URI"
              }
            }
          }
        },
        {
          "description": "Encoding configuration.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfigWithFraming"
        }
      ],
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "http"
      }
    },
    "vector::sinks::humio::logs::HumioLogsConfig": {
      "description": "Configuration for the `humio_logs` sink.",
      "type": "object",
      "required": [
        "encoding",
        "token"
      ],
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled for this sink.",
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::splunk_hec::common::util::SplunkHecDefaultBatchSettings>",
          "_metadata": {
            "docs::human_name": "Batch"
          }
        },
        "compression": {
          "title": "Compression configuration.",
          "description": "All compression algorithms use the default compression level unless otherwise specified.",
          "default": "none",
          "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
          "_metadata": {
            "docs::human_name": "Compression"
          }
        },
        "encoding": {
          "description": "Configures how events are encoded into raw bytes.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
          "_metadata": {
            "docs::human_name": "Encoding"
          }
        },
        "endpoint": {
          "title": "The base URL of the Humio instance.",
          "description": "The scheme (`http` or `https`) must be specified. No path should be included since the paths defined\nby the [`Splunk`][splunk] API are used.\n\n[splunk]: https://docs.splunk.com/Documentation/Splunk/8.0.0/Data/HECRESTendpoints",
          "default": "https://cloud.humio.com",
          "type": "string",
          "_metadata": {
            "docs::examples": [
              "http://127.0.0.1",
              "https://example.com"
            ],
            "docs::human_name": "Endpoint"
          }
        },
        "event_type": {
          "title": "The type of events sent to this sink. Humio uses this as the name of the parser to use to ingest the data.",
          "description": "If unset, Humio defaults it to none.",
          "$ref": "#/definitions/core::option::Option<vector::template::Template>",
          "_metadata": {
            "docs::examples": [
              "json",
              "none",
              "{{ event_type }}"
            ],
            "docs::human_name": "Event Type"
          }
        },
        "host_key": {
          "title": "Overrides the name of the log field used to retrieve the hostname to send to Humio.",
          "description": "By default, the [global `log_schema.host_key` option][global_host_key] is used.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
          "default": "host",
          "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
          "_metadata": {
            "docs::human_name": "Host Key"
          }
        },
        "index": {
          "title": "Optional name of the repository to ingest into.",
          "description": "In public-facing APIs, this must (if present) be equal to the repository used to create the ingest token used for authentication.\n\nIn private cluster setups, Humio can be configured to allow these to be different.\n\nFor more information, see [Humio’s Format of Data][humio_data_format].\n\n[humio_data_format]: https://docs.humio.com/integrations/data-shippers/hec/#format-of-data",
          "default": null,
          "$ref": "#/definitions/core::option::Option<vector::template::Template>",
          "_metadata": {
            "docs::examples": [
              "{{ host }}",
              "custom_index"
            ],
            "docs::human_name": "Index"
          }
        },
        "indexed_fields": {
          "title": "Event fields to be added to Humio’s extra fields.",
          "description": "Can be used to tag events by specifying fields starting with `#`.\n\nFor more information, see [Humio’s Format of Data][humio_data_format].\n\n[humio_data_format]: https://docs.humio.com/integrations/data-shippers/hec/#format-of-data",
          "default": [],
          "type": "array",
          "items": {
            "$ref": "#/definitions/vector_lookup::lookup_v2::ConfigValuePath"
          },
          "_metadata": {
            "docs::human_name": "Indexed Fields"
          }
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "initial_concurrency": 1,
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          }
        },
        "source": {
          "title": "The source of events sent to this sink.",
          "description": "Typically the filename the logs originated from. Maps to `@source` in Humio.",
          "$ref": "#/definitions/core::option::Option<vector::template::Template>",
          "_metadata": {
            "docs::human_name": "Source"
          }
        },
        "timestamp_key": {
          "title": "Overrides the name of the log field used to retrieve the timestamp to send to Humio.",
          "description": "By default, the [global `log_schema.timestamp_key` option][global_timestamp_key] is used.\n\n[global_timestamp_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.timestamp_key",
          "default": "timestamp",
          "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
          "_metadata": {
            "docs::human_name": "Timestamp Key"
          }
        },
        "timestamp_nanos_key": {
          "description": "Overrides the name of the log field used to retrieve the nanosecond-enabled timestamp to send to Humio.",
          "default": "@timestamp.nanos",
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Timestamp Nanos Key"
          }
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        },
        "token": {
          "description": "The Humio ingestion token.",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "docs::examples": [
              "${HUMIO_TOKEN}",
              "A94A8FE5CCB19BA61C4C08"
            ],
            "docs::human_name": "Token"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "humio_logs"
      }
    },
    "vector::sinks::humio::metrics::HumioMetricsConfig": {
      "description": "Configuration for the `humio_metrics` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "token"
          ],
          "properties": {
            "acknowledgements": {
              "title": "Controls how acknowledgements are handled for this sink.",
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              }
            },
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::splunk_hec::common::util::SplunkHecDefaultBatchSettings>",
              "_metadata": {
                "docs::human_name": "Batch"
              }
            },
            "compression": {
              "title": "Compression configuration.",
              "description": "All compression algorithms use the default compression level unless otherwise specified.",
              "default": "none",
              "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
              "_metadata": {
                "docs::human_name": "Compression"
              }
            },
            "endpoint": {
              "title": "The base URL of the Humio instance.",
              "description": "The scheme (`http` or `https`) must be specified. No path should be included since the paths defined\nby the [`Splunk`][splunk] API are used.\n\n[splunk]: https://docs.splunk.com/Documentation/Splunk/8.0.0/Data/HECRESTendpoints",
              "default": "https://cloud.humio.com",
              "type": "string",
              "_metadata": {
                "docs::examples": [
                  "http://127.0.0.1",
                  "https://example.com"
                ],
                "docs::human_name": "Endpoint"
              }
            },
            "event_type": {
              "title": "The type of events sent to this sink. Humio uses this as the name of the parser to use to ingest the data.",
              "description": "If unset, Humio defaults it to none.",
              "$ref": "#/definitions/core::option::Option<vector::template::Template>",
              "_metadata": {
                "docs::examples": [
                  "json",
                  "none",
                  "{{ event_type }}"
                ],
                "docs::human_name": "Event Type"
              }
            },
            "host_key": {
              "title": "Overrides the name of the log field used to retrieve the hostname to send to Humio.",
              "description": "By default, the [global `log_schema.host_key` option][global_host_key] is used.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
              "default": "host",
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
              "_metadata": {
                "docs::human_name": "Host Key"
              }
            },
            "index": {
              "title": "Optional name of the repository to ingest into.",
              "description": "In public-facing APIs, this must (if present) be equal to the repository used to create the ingest token used for authentication.\n\nIn private cluster setups, Humio can be configured to allow these to be different.\n\nFor more information, see [Humio’s Format of Data][humio_data_format].\n\n[humio_data_format]: https://docs.humio.com/integrations/data-shippers/hec/#format-of-data",
              "default": null,
              "$ref": "#/definitions/core::option::Option<vector::template::Template>",
              "_metadata": {
                "docs::examples": [
                  "{{ host }}",
                  "custom_index"
                ],
                "docs::human_name": "Index"
              }
            },
            "indexed_fields": {
              "title": "Event fields to be added to Humio’s extra fields.",
              "description": "Can be used to tag events by specifying fields starting with `#`.\n\nFor more information, see [Humio’s Format of Data][humio_data_format].\n\n[humio_data_format]: https://docs.humio.com/integrations/data-shippers/hec/#format-of-data",
              "default": [],
              "type": "array",
              "items": {
                "$ref": "#/definitions/vector_lookup::lookup_v2::ConfigValuePath"
              },
              "_metadata": {
                "docs::human_name": "Indexed Fields"
              }
            },
            "request": {
              "title": "Middleware settings for outbound requests.",
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "initial_concurrency": 1,
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                }
              },
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              }
            },
            "source": {
              "title": "The source of events sent to this sink.",
              "description": "Typically the filename the metrics originated from. Maps to `@source` in Humio.",
              "$ref": "#/definitions/core::option::Option<vector::template::Template>",
              "_metadata": {
                "docs::human_name": "Source"
              }
            },
            "tls": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              }
            },
            "token": {
              "description": "The Humio ingestion token.",
              "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
              "_metadata": {
                "docs::examples": [
                  "${HUMIO_TOKEN}",
                  "A94A8FE5CCB19BA61C4C08"
                ],
                "docs::human_name": "Token"
              }
            }
          }
        },
        {
          "description": "Configuration for the `metric_to_log` transform.",
          "$ref": "#/definitions/vector::transforms::metric_to_log::MetricToLogConfig"
        }
      ],
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "humio_metrics"
      }
    },
    "vector::sinks::influxdb::logs::InfluxDbLogsConfig": {
      "description": "Configuration for the `influxdb_logs` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "endpoint"
          ],
          "properties": {
            "acknowledgements": {
              "title": "Controls how acknowledgements are handled for this sink.",
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              }
            },
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "type": "object",
              "properties": {
                "max_bytes": {
                  "title": "The maximum size of a batch that is processed by a sink.",
                  "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
                  "default": 1000000,
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes",
                    "docs::human_name": "Max Bytes"
                  }
                },
                "max_events": {
                  "description": "The maximum size of a batch before it is flushed.",
                  "default": null,
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "events",
                    "docs::human_name": "Max Events"
                  }
                },
                "timeout_secs": {
                  "description": "The maximum age of a batch before it is flushed.",
                  "default": 1.0,
                  "type": [
                    "number",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": -9007199254740991.0,
                  "_metadata": {
                    "docs::numeric_type": "float",
                    "docs::optional": true,
                    "docs::type_unit": "seconds",
                    "docs::human_name": "Timeout"
                  }
                }
              },
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Batch"
              }
            },
            "encoding": {
              "description": "Transformations to prepare an event for serialization.",
              "default": {},
              "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer",
              "_metadata": {
                "docs::human_name": "Encoding"
              }
            },
            "endpoint": {
              "title": "The endpoint to send data to.",
              "description": "This should be a full HTTP URI, including the scheme, host, and port.",
              "type": "string",
              "_metadata": {
                "docs::examples": "http://localhost:8086",
                "docs::human_name": "Endpoint"
              }
            },
            "host_key": {
              "title": "Use this option to customize the key containing the hostname.",
              "description": "The setting of `log_schema.host_key`, usually `host`, is used here by default.",
              "$ref": "#/definitions/core::option::Option<vector_lookup::lookup_v2::optional_path::OptionalValuePath>",
              "_metadata": {
                "docs::examples": "hostname",
                "docs::human_name": "Host Key"
              }
            },
            "measurement": {
              "description": "The name of the InfluxDB measurement that is written to.",
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::examples": "vector-logs",
                "docs::human_name": "Measurement"
              }
            },
            "message_key": {
              "title": "Use this option to customize the key containing the message.",
              "description": "The setting of `log_schema.message_key`, usually `message`, is used here by default.",
              "$ref": "#/definitions/core::option::Option<vector_lookup::lookup_v2::optional_path::OptionalValuePath>",
              "_metadata": {
                "docs::examples": "text",
                "docs::human_name": "Message Key"
              }
            },
            "namespace": {
              "title": "The namespace of the measurement name to use.",
              "description": "When specified, the measurement name is `<namespace>.vector`.",
              "deprecated": true,
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "deprecated_message": "This field is deprecated, and `measurement` should be used instead.",
                "docs::examples": "service",
                "docs::human_name": "Namespace"
              }
            },
            "request": {
              "title": "Middleware settings for outbound requests.",
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "initial_concurrency": 1,
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                }
              },
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              }
            },
            "source_type_key": {
              "title": "Use this option to customize the key containing the source_type.",
              "description": "The setting of `log_schema.source_type_key`, usually `source_type`, is used here by default.",
              "$ref": "#/definitions/core::option::Option<vector_lookup::lookup_v2::optional_path::OptionalValuePath>",
              "_metadata": {
                "docs::examples": "source",
                "docs::human_name": "Source Type Key"
              }
            },
            "tags": {
              "title": "The list of names of log fields that should be added as tags to each measurement.",
              "description": "By default Vector adds `metric_type` as well as the configured `log_schema.host_key` and\n`log_schema.source_type_key` options.",
              "default": [],
              "type": "array",
              "items": {
                "type": "string"
              },
              "_metadata": {
                "docs::examples": [
                  "field1",
                  "parent.child_field"
                ],
                "docs::human_name": "Tags"
              }
            },
            "tls": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              }
            }
          }
        },
        {
          "$ref": "#/definitions/core::option::Option<vector::sinks::influxdb::InfluxDb1Settings>"
        },
        {
          "$ref": "#/definitions/core::option::Option<vector::sinks::influxdb::InfluxDb2Settings>"
        }
      ],
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "influxdb_logs"
      }
    },
    "vector::sinks::influxdb::metrics::InfluxDbConfig": {
      "description": "Configuration for the `influxdb_metrics` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "endpoint"
          ],
          "properties": {
            "acknowledgements": {
              "title": "Controls how acknowledgements are handled for this sink.",
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              }
            },
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "type": "object",
              "properties": {
                "max_bytes": {
                  "title": "The maximum size of a batch that is processed by a sink.",
                  "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
                  "default": null,
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes",
                    "docs::human_name": "Max Bytes"
                  }
                },
                "max_events": {
                  "description": "The maximum size of a batch before it is flushed.",
                  "default": 20,
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "events",
                    "docs::human_name": "Max Events"
                  }
                },
                "timeout_secs": {
                  "description": "The maximum age of a batch before it is flushed.",
                  "default": 1.0,
                  "type": [
                    "number",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": -9007199254740991.0,
                  "_metadata": {
                    "docs::numeric_type": "float",
                    "docs::optional": true,
                    "docs::type_unit": "seconds",
                    "docs::human_name": "Timeout"
                  }
                }
              },
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Batch"
              }
            },
            "default_namespace": {
              "title": "Sets the default namespace for any metrics sent.",
              "description": "This namespace is only used if a metric has no existing namespace. When a namespace is\npresent, it is used as a prefix to the metric name, and separated with a period (`.`).",
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::examples": "service",
                "docs::human_name": "Default Namespace"
              }
            },
            "endpoint": {
              "title": "The endpoint to send data to.",
              "description": "This should be a full HTTP URI, including the scheme, host, and port.",
              "type": "string",
              "_metadata": {
                "docs::examples": "http://localhost:8086/",
                "docs::human_name": "Endpoint"
              }
            },
            "quantiles": {
              "description": "The list of quantiles to calculate when sending distribution metrics.",
              "default": [
                0.5,
                0.75,
                0.9,
                0.95,
                0.99
              ],
              "type": "array",
              "items": {
                "type": "number",
                "maximum": 9007199254740991.0,
                "minimum": -9007199254740991.0,
                "_metadata": {
                  "docs::numeric_type": "float"
                }
              },
              "_metadata": {
                "docs::numeric_type": "float",
                "docs::human_name": "Quantiles"
              }
            },
            "request": {
              "title": "Middleware settings for outbound requests.",
              "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
              "default": {
                "timeout_secs": 60,
                "rate_limit_duration_secs": 1,
                "rate_limit_num": 9223372036854775807,
                "retry_attempts": 9223372036854775807,
                "retry_max_duration_secs": 3600,
                "retry_initial_backoff_secs": 1,
                "adaptive_concurrency": {
                  "initial_concurrency": 1,
                  "decrease_ratio": 0.9,
                  "ewma_alpha": 0.4,
                  "rtt_deviation_scale": 2.5
                }
              },
              "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
              "_metadata": {
                "docs::human_name": "Request"
              }
            },
            "tags": {
              "description": "A map of additional tags, in the key/value pair format, to add to each measurement.",
              "type": [
                "object",
                "null"
              ],
              "additionalProperties": {
                "type": "string"
              },
              "_metadata": {
                "docs::optional": true,
                "docs::additional_props_description": "A tag key/value pair.",
                "docs::examples": {
                  "region": "us-west-1"
                },
                "docs::human_name": "Tags"
              }
            },
            "tls": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              }
            }
          }
        },
        {
          "$ref": "#/definitions/core::option::Option<vector::sinks::influxdb::InfluxDb1Settings>"
        },
        {
          "$ref": "#/definitions/core::option::Option<vector::sinks::influxdb::InfluxDb2Settings>"
        }
      ],
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "influxdb_metrics"
      }
    },
    "vector::sinks::kafka::config::KafkaSinkConfig": {
      "description": "Configuration for the `kafka` sink.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "bootstrap_servers",
            "encoding",
            "topic"
          ],
          "properties": {
            "acknowledgements": {
              "title": "Controls how acknowledgements are handled for this sink.",
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              }
            },
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "type": "object",
              "properties": {
                "max_bytes": {
                  "title": "The maximum size of a batch that is processed by a sink.",
                  "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
                  "default": null,
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes",
                    "docs::human_name": "Max Bytes"
                  }
                },
                "max_events": {
                  "description": "The maximum size of a batch before it is flushed.",
                  "default": null,
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "events",
                    "docs::human_name": "Max Events"
                  }
                },
                "timeout_secs": {
                  "description": "The maximum age of a batch before it is flushed.",
                  "default": 1.0,
                  "type": [
                    "number",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": -9007199254740991.0,
                  "_metadata": {
                    "docs::numeric_type": "float",
                    "docs::optional": true,
                    "docs::type_unit": "seconds",
                    "docs::human_name": "Timeout"
                  }
                }
              },
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Batch"
              }
            },
            "bootstrap_servers": {
              "title": "A comma-separated list of Kafka bootstrap servers.",
              "description": "These are the servers in a Kafka cluster that a client should use to bootstrap its\nconnection to the cluster, allowing discovery of all the other hosts in the cluster.\n\nMust be in the form of `host:port`, and comma-separated.",
              "type": "string",
              "_metadata": {
                "docs::examples": "10.14.22.123:9092,10.14.23.332:9092",
                "docs::human_name": "Bootstrap Servers"
              }
            },
            "compression": {
              "description": "Supported compression types for Kafka.",
              "default": "none",
              "oneOf": [
                {
                  "description": "No compression.",
                  "const": "none",
                  "_metadata": {
                    "logical_name": "None",
                    "docs::human_name": "None"
                  }
                },
                {
                  "description": "Gzip.",
                  "const": "gzip",
                  "_metadata": {
                    "logical_name": "Gzip",
                    "docs::human_name": "Gzip"
                  }
                },
                {
                  "description": "Snappy.",
                  "const": "snappy",
                  "_metadata": {
                    "logical_name": "Snappy",
                    "docs::human_name": "Snappy"
                  }
                },
                {
                  "description": "LZ4.",
                  "const": "lz4",
                  "_metadata": {
                    "logical_name": "Lz4",
                    "docs::human_name": "LZ4"
                  }
                },
                {
                  "description": "Zstandard.",
                  "const": "zstd",
                  "_metadata": {
                    "logical_name": "Zstd",
                    "docs::human_name": "Zstd"
                  }
                }
              ],
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::advanced": true,
                "docs::enum_tagging": "external",
                "docs::human_name": "Compression"
              }
            },
            "encoding": {
              "description": "Configures how events are encoded into raw bytes.",
              "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
              "_metadata": {
                "docs::human_name": "Encoding"
              }
            },
            "headers_key": {
              "title": "The log field name to use for the Kafka headers.",
              "description": "If omitted, no headers are written.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/definitions/vector_lookup::lookup_v2::ConfigTargetPath"
                }
              ],
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::advanced": true,
                "docs::examples": "headers",
                "docs::optional": true,
                "docs::human_name": "Headers Key"
              }
            },
            "key_field": {
              "title": "The log field name or tag key to use for the topic key.",
              "description": "If the field does not exist in the log or in the tags, a blank value is used. If\nunspecified, the key is not sent.\n\nKafka uses a hash of the key to choose the partition or uses round-robin if the record has\nno key.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/definitions/vector_lookup::lookup_v2::ConfigTargetPath"
                }
              ],
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::advanced": true,
                "docs::examples": [
                  "user_id",
                  ".my_topic",
                  "%my_topic"
                ],
                "docs::optional": true,
                "docs::human_name": "Key Field"
              }
            },
            "librdkafka_options": {
              "title": "A map of advanced options to pass directly to the underlying `librdkafka` client.",
              "description": "For more information on configuration options, see [Configuration properties][config_props_docs].\n\n[config_props_docs]: https://github.com/edenhill/librdkafka/blob/master/CONFIGURATION.md",
              "default": {},
              "type": "object",
              "additionalProperties": {
                "type": "string"
              },
              "_metadata": {
                "docs::examples": {
                  "fetch.error.backoff.ms": "1000",
                  "socket.send.buffer.bytes": "100",
                  "client.id": "${ENV_VAR}"
                },
                "docs::advanced": true,
                "docs::additional_props_description": "A librdkafka configuration option.",
                "docs::human_name": "Librdkafka Options"
              }
            },
            "message_timeout_ms": {
              "description": "Local message timeout, in milliseconds.",
              "default": 300000,
              "$ref": "#/definitions/serde_with::DurationMilliSeconds",
              "_metadata": {
                "docs::examples": [
                  150000,
                  450000
                ],
                "docs::human_name": "Message Timeout",
                "docs::advanced": true
              }
            },
            "socket_timeout_ms": {
              "description": "Default timeout, in milliseconds, for network requests.",
              "default": 60000,
              "$ref": "#/definitions/serde_with::DurationMilliSeconds",
              "_metadata": {
                "docs::examples": [
                  30000,
                  60000
                ],
                "docs::advanced": true,
                "docs::human_name": "Socket Timeout"
              }
            },
            "topic": {
              "description": "The Kafka topic name to write events to.",
              "$ref": "#/definitions/vector::template::Template",
              "_metadata": {
                "docs::templateable": true,
                "docs::examples": [
                  "topic-1234",
                  "logs-{{unit}}-%Y-%m-%d"
                ],
                "docs::human_name": "Topic"
              }
            }
          }
        },
        {
          "description": "Kafka authentication configuration.",
          "$ref": "#/definitions/vector::kafka::KafkaAuthConfig"
        }
      ],
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "kafka"
      }
    },
    "vector::sinks::loki::config::LokiConfig": {
      "description": "Configuration for the `loki` sink.",
      "type": "object",
      "required": [
        "encoding",
        "endpoint"
      ],
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled for this sink.",
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "auth": {
          "$ref": "#/definitions/core::option::Option<vector::http::Auth>",
          "_metadata": {
            "docs::human_name": "Auth"
          }
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "type": "object",
          "properties": {
            "max_bytes": {
              "title": "The maximum size of a batch that is processed by a sink.",
              "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
              "default": 1000000,
              "type": [
                "integer",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "bytes",
                "docs::human_name": "Max Bytes"
              }
            },
            "max_events": {
              "description": "The maximum size of a batch before it is flushed.",
              "default": 100000,
              "type": [
                "integer",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "events",
                "docs::human_name": "Max Events"
              }
            },
            "timeout_secs": {
              "description": "The maximum age of a batch before it is flushed.",
              "default": 1.0,
              "type": [
                "number",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": -9007199254740991.0,
              "_metadata": {
                "docs::numeric_type": "float",
                "docs::optional": true,
                "docs::type_unit": "seconds",
                "docs::human_name": "Timeout"
              }
            }
          },
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Batch"
          }
        },
        "compression": {
          "description": "Compression configuration.",
          "default": "snappy",
          "oneOf": [
            {
              "title": "Compression configuration.",
              "description": "Basic compression.",
              "oneOf": [
                {
                  "description": "Compression algorithm.",
                  "oneOf": [
                    {
                      "description": "No compression.",
                      "const": "none",
                      "_metadata": {
                        "logical_name": "None",
                        "docs::human_name": "None"
                      }
                    },
                    {
                      "title": "[Gzip][gzip] compression.",
                      "description": "[gzip]: https://www.gzip.org/",
                      "const": "gzip",
                      "_metadata": {
                        "logical_name": "Gzip",
                        "docs::human_name": "Gzip"
                      }
                    },
                    {
                      "title": "[Zlib][zlib] compression.",
                      "description": "[zlib]: https://zlib.net/",
                      "const": "zlib",
                      "_metadata": {
                        "logical_name": "Zlib",
                        "docs::human_name": "Zlib"
                      }
                    },
                    {
                      "title": "[Zstandard][zstd] compression.",
                      "description": "[zstd]: https://facebook.github.io/zstd/",
                      "const": "zstd",
                      "_metadata": {
                        "logical_name": "Zstd",
                        "docs::human_name": "Zstd"
                      }
                    }
                  ],
                  "_metadata": {
                    "docs::enum_tagging": "external"
                  }
                },
                {
                  "description": "Compression algorithm and compression level.",
                  "type": "object",
                  "required": [
                    "algorithm"
                  ],
                  "properties": {
                    "algorithm": {
                      "description": "Compression algorithm.",
                      "oneOf": [
                        {
                          "description": "No compression.",
                          "const": "none",
                          "_metadata": {
                            "logical_name": "None",
                            "docs::human_name": "None"
                          }
                        },
                        {
                          "title": "[Gzip][gzip] compression.",
                          "description": "[gzip]: https://www.gzip.org/",
                          "const": "gzip",
                          "_metadata": {
                            "logical_name": "Gzip",
                            "docs::human_name": "Gzip"
                          }
                        },
                        {
                          "title": "[Zlib][zlib] compression.",
                          "description": "[zlib]: https://zlib.net/",
                          "const": "zlib",
                          "_metadata": {
                            "logical_name": "Zlib",
                            "docs::human_name": "Zlib"
                          }
                        },
                        {
                          "title": "[Zstandard][zstd] compression.",
                          "description": "[zstd]: https://facebook.github.io/zstd/",
                          "const": "zstd",
                          "_metadata": {
                            "logical_name": "Zstd",
                            "docs::human_name": "Zstd"
                          }
                        }
                      ],
                      "unevaluatedProperties": false,
                      "_metadata": {
                        "docs::enum_tagging": "external",
                        "docs::human_name": "Algorithm"
                      }
                    },
                    "level": {
                      "description": "Compression level.",
                      "enum": [
                        "none",
                        "fast",
                        "best",
                        "default",
                        0,
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20,
                        21
                      ],
                      "_metadata": {
                        "docs::human_name": "Level"
                      }
                    }
                  },
                  "_metadata": {
                    "docs::hidden": true
                  }
                }
              ],
              "_metadata": {
                "logical_name": "Original",
                "docs::enum_tagging": "external",
                "docs::advanced": true,
                "docs::human_name": "Original"
              }
            },
            {
              "description": "Loki-specific compression.",
              "oneOf": [
                {
                  "title": "Snappy compression.",
                  "description": "This implies sending push requests as Protocol Buffers.",
                  "const": "snappy",
                  "_metadata": {
                    "logical_name": "Snappy",
                    "docs::human_name": "Snappy"
                  }
                }
              ],
              "_metadata": {
                "logical_name": "Extended",
                "docs::enum_tagging": "external",
                "docs::human_name": "Extended"
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::enum_tagging": "untagged",
            "docs::human_name": "Compression"
          }
        },
        "encoding": {
          "description": "Configures how events are encoded into raw bytes.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
          "_metadata": {
            "docs::human_name": "Encoding"
          }
        },
        "endpoint": {
          "title": "The base URL of the Loki instance.",
          "description": "The `path` value is appended to this.",
          "$ref": "#/definitions/vector::sinks::util::uri::UriSerde",
          "_metadata": {
            "docs::examples": "http://localhost:3100",
            "docs::human_name": "Endpoint"
          }
        },
        "labels": {
          "title": "A set of labels that are attached to each batch of events.",
          "description": "Both keys and values are templateable, which enables you to attach dynamic labels to events.\n\nValid label keys include `*`, and prefixes ending with `*`, to allow for the expansion of\nobjects into multiple labels. See [Label expansion][label_expansion] for more information.\n\nNote: If the set of labels has high cardinality, this can cause drastic performance issues\nwith Loki. To prevent this from happening, reduce the number of unique label keys and\nvalues.\n\n[label_expansion]: https://vector.dev/docs/reference/configuration/sinks/loki/#label-expansion",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/vector::template::Template"
          },
          "_metadata": {
            "docs::examples": {
              "{{ event_field }}": "{{ some_other_event_field }}",
              "\"*\"": "{{ metadata }}",
              "\"pod_labels_*\"": "{{ kubernetes.pod_labels }}",
              "source": "vector"
            },
            "docs::additional_props_description": "A Loki label.",
            "docs::human_name": "Labels"
          }
        },
        "out_of_order_action": {
          "title": "Out-of-order event behavior.",
          "description": "Some sources may generate events with timestamps that aren't in chronological order. Even though the\nsink sorts the events before sending them to Loki, there is a chance that another event could come in\nthat is out of order with the latest events sent to Loki. Prior to Loki 2.4.0, this\nwas not supported and would result in an error during the push request.\n\nIf you're using Loki 2.4.0 or newer, `Accept` is the preferred action, which lets Loki handle\nany necessary sorting/reordering. If you're using an earlier version, then you must use `Drop`\nor `RewriteTimestamp` depending on which option makes the most sense for your use case.",
          "default": "drop",
          "oneOf": [
            {
              "description": "Drop the event.",
              "const": "drop",
              "_metadata": {
                "logical_name": "Drop",
                "docs::human_name": "Drop"
              }
            },
            {
              "description": "Rewrite the timestamp of the event to the timestamp of the latest event seen by the sink.",
              "const": "rewrite_timestamp",
              "_metadata": {
                "logical_name": "RewriteTimestamp",
                "docs::human_name": "Rewrite Timestamp"
              }
            },
            {
              "title": "Accept the event.",
              "description": "The event is not dropped and is sent without modification.\n\nRequires Loki 2.4.0 or newer.",
              "const": "accept",
              "_metadata": {
                "logical_name": "Accept",
                "docs::human_name": "Accept"
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::enum_tagging": "external",
            "docs::human_name": "Out Of Order Action"
          }
        },
        "path": {
          "description": "The path to use in the URL of the Loki instance.",
          "default": "/loki/api/v1/push",
          "type": "string",
          "_metadata": {
            "docs::human_name": "Path"
          }
        },
        "remove_label_fields": {
          "description": "Whether or not to delete fields from the event when they are used as labels.",
          "default": false,
          "type": "boolean",
          "_metadata": {
            "docs::human_name": "Remove Label Fields"
          }
        },
        "remove_timestamp": {
          "title": "Whether or not to remove the timestamp from the event payload.",
          "description": "The timestamp is still sent as event metadata for Loki to use for indexing.",
          "default": true,
          "type": "boolean",
          "_metadata": {
            "docs::human_name": "Remove Timestamp"
          }
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "initial_concurrency": 1,
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          }
        },
        "tenant_id": {
          "title": "The [tenant ID][tenant_id] to specify in requests to Loki.",
          "description": "When running Loki locally, a tenant ID is not required.\n\n[tenant_id]: https://grafana.com/docs/loki/latest/operations/multi-tenancy/",
          "$ref": "#/definitions/core::option::Option<vector::template::Template>",
          "_metadata": {
            "docs::examples": [
              "some_tenant_id",
              "{{ event_field }}"
            ],
            "docs::human_name": "Tenant ID"
          }
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "loki"
      }
    },
    "vector::sinks::mezmo::LogdnaConfig": {
      "description": "Configuration for the `logdna` sink.",
      "$ref": "#/definitions/vector::sinks::mezmo::MezmoConfig",
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "logdna",
        "deprecated": "The `logdna` sink has been renamed. Please use `mezmo` instead."
      }
    },
    "vector::sinks::mezmo::MezmoConfig": {
      "description": "Configuration for the `mezmo` (formerly `logdna`) sink.",
      "type": "object",
      "required": [
        "api_key",
        "hostname"
      ],
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled for this sink.",
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "api_key": {
          "description": "The Ingestion API key.",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "docs::examples": [
              "${LOGDNA_API_KEY}",
              "ef8d5de700e7989468166c40fc8a0ccd"
            ],
            "docs::human_name": "API Key"
          }
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::RealtimeSizeBasedDefaultBatchSettings>",
          "_metadata": {
            "docs::human_name": "Batch"
          }
        },
        "default_app": {
          "description": "The default app that is set for events that do not contain a `file` or `app` field.",
          "default": "vector",
          "type": "string",
          "_metadata": {
            "docs::examples": "my-app",
            "docs::human_name": "Default App"
          }
        },
        "default_env": {
          "description": "The default environment that is set for events that do not contain an `env` field.",
          "default": "production",
          "type": "string",
          "_metadata": {
            "docs::examples": "staging",
            "docs::human_name": "Default Env"
          }
        },
        "encoding": {
          "description": "Transformations to prepare an event for serialization.",
          "default": {},
          "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer",
          "_metadata": {
            "docs::human_name": "Encoding"
          }
        },
        "endpoint": {
          "title": "The HTTP endpoint to send logs to.",
          "description": "Both IP address and hostname are accepted formats.",
          "default": "https://logs.mezmo.com/",
          "$ref": "#/definitions/vector::sinks::util::uri::UriSerde",
          "_metadata": {
            "docs::examples": [
              "http://127.0.0.1",
              "http://example.com"
            ],
            "docs::human_name": "Endpoint"
          }
        },
        "hostname": {
          "description": "The hostname that is attached to each batch of events.",
          "$ref": "#/definitions/vector::template::Template",
          "_metadata": {
            "docs::examples": [
              "${HOSTNAME}",
              "my-local-machine"
            ],
            "docs::human_name": "Hostname"
          }
        },
        "ip": {
          "description": "The IP address that is attached to each batch of events.",
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::examples": "0.0.0.0",
            "docs::human_name": "IP Address"
          }
        },
        "mac": {
          "description": "The MAC address that is attached to each batch of events.",
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::examples": "my-mac-address",
            "docs::human_name": "MAC Address"
          }
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "initial_concurrency": 1,
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          }
        },
        "tags": {
          "description": "The tags that are attached to each batch of events.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/vector::template::Template"
          },
          "_metadata": {
            "docs::templateable": true,
            "docs::optional": true,
            "docs::examples": [
              "tag1",
              "tag2"
            ],
            "docs::human_name": "Tags"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "mezmo"
      }
    },
    "vector::sinks::nats::config::NatsSinkConfig": {
      "description": "Configuration for the `nats` sink.",
      "type": "object",
      "required": [
        "encoding",
        "subject",
        "url"
      ],
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled for this sink.",
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "auth": {
          "$ref": "#/definitions/core::option::Option<vector::nats::NatsAuthConfig>",
          "_metadata": {
            "docs::human_name": "Auth"
          }
        },
        "connection_name": {
          "title": "A NATS [name][nats_connection_name] assigned to the NATS connection.",
          "description": "[nats_connection_name]: https://docs.nats.io/using-nats/developer/connecting/name",
          "default": "vector",
          "type": "string",
          "_metadata": {
            "docs::examples": "foo",
            "docs::human_name": "Connection Name"
          }
        },
        "encoding": {
          "description": "Configures how events are encoded into raw bytes.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
          "_metadata": {
            "docs::human_name": "Encoding"
          }
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "initial_concurrency": 1,
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          }
        },
        "subject": {
          "title": "The NATS [subject][nats_subject] to publish messages to.",
          "description": "[nats_subject]: https://docs.nats.io/nats-concepts/subjects",
          "$ref": "#/definitions/vector::template::Template",
          "_metadata": {
            "docs::templateable": true,
            "docs::examples": [
              "{{ host }}",
              "foo",
              "time.us.east",
              "time.*.east",
              "time.>",
              ">"
            ],
            "docs::human_name": "Subject"
          }
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        },
        "url": {
          "title": "The NATS [URL][nats_url] to connect to.",
          "description": "The URL must take the form of `nats://server:port`.\nIf the port is not specified it defaults to 4222.\n\n[nats_url]: https://docs.nats.io/using-nats/developer/connecting#nats-url",
          "type": "string",
          "_metadata": {
            "docs::examples": [
              "nats://demo.nats.io",
              "nats://127.0.0.1:4242"
            ],
            "docs::human_name": "URL"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "nats"
      }
    },
    "vector::sinks::new_relic::config::NewRelicConfig": {
      "description": "Configuration for the `new_relic` sink.",
      "type": "object",
      "required": [
        "account_id",
        "api",
        "license_key"
      ],
      "properties": {
        "account_id": {
          "description": "The New Relic account ID.",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "docs::examples": [
              "xxxx",
              "${NEW_RELIC_ACCOUNT_KEY}"
            ],
            "docs::human_name": "Account ID"
          }
        },
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled for this sink.",
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "api": {
          "description": "New Relic API endpoint.",
          "oneOf": [
            {
              "description": "Events API.",
              "const": "events",
              "_metadata": {
                "logical_name": "Events",
                "docs::human_name": "Events"
              }
            },
            {
              "description": "Metrics API.",
              "const": "metrics",
              "_metadata": {
                "logical_name": "Metrics",
                "docs::human_name": "Metrics"
              }
            },
            {
              "description": "Logs API.",
              "const": "logs",
              "_metadata": {
                "logical_name": "Logs",
                "docs::human_name": "Logs"
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::enum_tagging": "external",
            "docs::human_name": "API"
          }
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "type": "object",
          "properties": {
            "max_bytes": {
              "title": "The maximum size of a batch that is processed by a sink.",
              "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
              "default": 1000000,
              "type": [
                "integer",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "bytes",
                "docs::human_name": "Max Bytes"
              }
            },
            "max_events": {
              "description": "The maximum size of a batch before it is flushed.",
              "default": 100,
              "type": [
                "integer",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "events",
                "docs::human_name": "Max Events"
              }
            },
            "timeout_secs": {
              "description": "The maximum age of a batch before it is flushed.",
              "default": 1.0,
              "type": [
                "number",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": -9007199254740991.0,
              "_metadata": {
                "docs::numeric_type": "float",
                "docs::optional": true,
                "docs::type_unit": "seconds",
                "docs::human_name": "Timeout"
              }
            }
          },
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Batch"
          }
        },
        "compression": {
          "title": "Compression configuration.",
          "description": "All compression algorithms use the default compression level unless otherwise specified.",
          "default": "gzip",
          "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
          "_metadata": {
            "docs::human_name": "Compression"
          }
        },
        "encoding": {
          "description": "Transformations to prepare an event for serialization.",
          "default": {},
          "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer",
          "_metadata": {
            "docs::human_name": "Encoding"
          }
        },
        "license_key": {
          "description": "A valid New Relic license key.",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "docs::examples": [
              "xxxx",
              "${NEW_RELIC_LICENSE_KEY}"
            ],
            "docs::human_name": "License Key"
          }
        },
        "region": {
          "description": "New Relic region.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "description": "New Relic region.",
              "oneOf": [
                {
                  "description": "US region.",
                  "const": "us",
                  "_metadata": {
                    "logical_name": "Us",
                    "docs::human_name": "US"
                  }
                },
                {
                  "description": "EU region.",
                  "const": "eu",
                  "_metadata": {
                    "logical_name": "Eu",
                    "docs::human_name": "EU"
                  }
                }
              ],
              "_metadata": {
                "docs::enum_tagging": "external"
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Region"
          }
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "initial_concurrency": 1,
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "new_relic"
      }
    },
    "vector::sinks::papertrail::PapertrailConfig": {
      "description": "Configuration for the `papertrail` sink.",
      "type": "object",
      "required": [
        "encoding",
        "endpoint"
      ],
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled for this sink.",
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "encoding": {
          "description": "Configures how events are encoded into raw bytes.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
          "_metadata": {
            "docs::human_name": "Encoding"
          }
        },
        "endpoint": {
          "description": "The TCP endpoint to send logs to.",
          "$ref": "#/definitions/vector::sinks::util::uri::UriSerde",
          "_metadata": {
            "docs::examples": "logs.papertrailapp.com:12345",
            "docs::human_name": "Endpoint"
          }
        },
        "keepalive": {
          "$ref": "#/definitions/core::option::Option<vector_core::tcp::TcpKeepaliveConfig>",
          "_metadata": {
            "docs::human_name": "Keepalive"
          }
        },
        "process": {
          "description": "The value to use as the `process` in Papertrail.",
          "default": "vector",
          "$ref": "#/definitions/vector::template::Template",
          "_metadata": {
            "docs::examples": [
              "{{ process }}",
              "my-process"
            ],
            "docs::human_name": "Process"
          }
        },
        "send_buffer_bytes": {
          "description": "Configures the send buffer size using the `SO_SNDBUF` option on the socket.",
          "type": [
            "integer",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::human_name": "Send Buffer Bytes"
          }
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "papertrail"
      }
    },
    "vector::sinks::prometheus::exporter::PrometheusExporterConfig": {
      "description": "Configuration for the `prometheus_exporter` sink.",
      "type": "object",
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled for this sink.",
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "address": {
          "title": "The address to expose for scraping.",
          "description": "The metrics are exposed at the typical Prometheus exporter path, `/metrics`.",
          "default": "0.0.0.0:9598",
          "$ref": "#/definitions/stdlib::SocketAddr",
          "_metadata": {
            "docs::examples": "192.160.0.10:9598",
            "docs::human_name": "Address"
          }
        },
        "auth": {
          "$ref": "#/definitions/core::option::Option<vector::http::Auth>",
          "_metadata": {
            "docs::human_name": "Auth"
          }
        },
        "buckets": {
          "title": "Default buckets to use for aggregating [distribution][dist_metric_docs] metrics into histograms.",
          "description": "[dist_metric_docs]: https://vector.dev/docs/about/under-the-hood/architecture/data-model/metric/#distribution",
          "default": [
            0.005,
            0.01,
            0.025,
            0.05,
            0.1,
            0.25,
            0.5,
            1.0,
            2.5,
            5.0,
            10.0
          ],
          "type": "array",
          "items": {
            "type": "number",
            "maximum": 9007199254740991.0,
            "minimum": -9007199254740991.0,
            "_metadata": {
              "docs::numeric_type": "float"
            }
          },
          "_metadata": {
            "docs::numeric_type": "float",
            "docs::advanced": true,
            "docs::human_name": "Buckets"
          }
        },
        "default_namespace": {
          "title": "The default namespace for any metrics sent.",
          "description": "This namespace is only used if a metric has no existing namespace. When a namespace is\npresent, it is used as a prefix to the metric name, and separated with an underscore (`_`).\n\nIt should follow the Prometheus [naming conventions][prom_naming_docs].\n\n[prom_naming_docs]: https://prometheus.io/docs/practices/naming/#metric-names",
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::advanced": true,
            "docs::human_name": "Default Namespace"
          }
        },
        "distributions_as_summaries": {
          "title": "Whether or not to render [distributions][dist_metric_docs] as an [aggregated histogram][prom_agg_hist_docs] or  [aggregated summary][prom_agg_summ_docs].",
          "description": "While distributions as a lossless way to represent a set of samples for a\nmetric is supported, Prometheus clients (the application being scraped, which is this sink) must\naggregate locally into either an aggregated histogram or aggregated summary.\n\n[dist_metric_docs]: https://vector.dev/docs/about/under-the-hood/architecture/data-model/metric/#distribution\n[prom_agg_hist_docs]: https://prometheus.io/docs/concepts/metric_types/#histogram\n[prom_agg_summ_docs]: https://prometheus.io/docs/concepts/metric_types/#summary",
          "default": false,
          "type": "boolean",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Distributions As Summaries"
          }
        },
        "flush_period_secs": {
          "title": "The interval, in seconds, on which metrics are flushed.",
          "description": "On the flush interval, if a metric has not been seen since the last flush interval, it is\nconsidered expired and is removed.\n\nBe sure to configure this value higher than your client’s scrape interval.",
          "default": 60,
          "$ref": "#/definitions/serde_with::DurationSeconds",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Flush Interval"
          }
        },
        "quantiles": {
          "title": "Quantiles to use for aggregating [distribution][dist_metric_docs] metrics into a summary.",
          "description": "[dist_metric_docs]: https://vector.dev/docs/about/under-the-hood/architecture/data-model/metric/#distribution",
          "default": [
            0.5,
            0.75,
            0.9,
            0.95,
            0.99
          ],
          "type": "array",
          "items": {
            "type": "number",
            "maximum": 9007199254740991.0,
            "minimum": -9007199254740991.0,
            "_metadata": {
              "docs::numeric_type": "float"
            }
          },
          "_metadata": {
            "docs::numeric_type": "float",
            "docs::advanced": true,
            "docs::human_name": "Quantiles"
          }
        },
        "suppress_timestamp": {
          "title": "Suppresses timestamps on the Prometheus output.",
          "description": "This can sometimes be useful when the source of metrics leads to their timestamps being too\nfar in the past for Prometheus to allow them, such as when aggregating metrics over long\ntime periods, or when replaying old metrics from a disk buffer.",
          "default": false,
          "type": "boolean",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Suppress Timestamp"
          }
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "prometheus_exporter"
      }
    },
    "vector::sinks::prometheus::remote_write::RemoteWriteConfig": {
      "description": "Configuration for the `prometheus_remote_write` sink.",
      "type": "object",
      "required": [
        "endpoint"
      ],
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled for this sink.",
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "auth": {
          "description": "Authentication strategies.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "description": "Authentication strategies.",
              "oneOf": [
                {
                  "description": "HTTP Basic Authentication.",
                  "type": "object",
                  "required": [
                    "password",
                    "strategy",
                    "user"
                  ],
                  "properties": {
                    "password": {
                      "description": "Basic authentication password.",
                      "type": "string",
                      "_metadata": {
                        "docs::human_name": "Password"
                      }
                    },
                    "strategy": {
                      "description": "HTTP Basic Authentication.",
                      "const": "basic",
                      "_metadata": {
                        "docs::human_name": "Strategy"
                      }
                    },
                    "user": {
                      "description": "Basic authentication username.",
                      "type": "string",
                      "_metadata": {
                        "docs::human_name": "User"
                      }
                    }
                  },
                  "_metadata": {
                    "logical_name": "Basic",
                    "docs::human_name": "Basic"
                  }
                },
                {
                  "title": "Bearer authentication.",
                  "description": "A bearer token (OAuth2, JWT, etc) is passed as-is.",
                  "type": "object",
                  "required": [
                    "strategy",
                    "token"
                  ],
                  "properties": {
                    "strategy": {
                      "title": "Bearer authentication.",
                      "description": "A bearer token (OAuth2, JWT, etc) is passed as-is.",
                      "const": "bearer",
                      "_metadata": {
                        "docs::human_name": "Strategy"
                      }
                    },
                    "token": {
                      "description": "The bearer token to send.",
                      "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
                      "_metadata": {
                        "docs::human_name": "Token"
                      }
                    }
                  },
                  "_metadata": {
                    "logical_name": "Bearer",
                    "docs::human_name": "Bearer"
                  }
                },
                {
                  "description": "Amazon Prometheus Service-specific authentication.",
                  "allOf": [
                    {
                      "description": "Configuration of the authentication strategy for interacting with AWS services.",
                      "anyOf": [
                        {
                          "description": "Authenticate using a fixed access key and secret pair.",
                          "type": "object",
                          "required": [
                            "access_key_id",
                            "secret_access_key"
                          ],
                          "properties": {
                            "access_key_id": {
                              "description": "The AWS access key ID.",
                              "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
                              "_metadata": {
                                "docs::examples": "AKIAIOSFODNN7EXAMPLE",
                                "docs::human_name": "Access Key ID"
                              }
                            },
                            "assume_role": {
                              "title": "The ARN of an [IAM role][iam_role] to assume.",
                              "description": "[iam_role]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html",
                              "type": [
                                "string",
                                "null"
                              ],
                              "_metadata": {
                                "docs::optional": true,
                                "docs::examples": "arn:aws:iam::123456789098:role/my_role",
                                "docs::human_name": "Assume Role"
                              }
                            },
                            "external_id": {
                              "title": "The optional unique external ID in conjunction with role to assume.",
                              "description": "[external_id]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html",
                              "type": [
                                "string",
                                "null"
                              ],
                              "_metadata": {
                                "docs::optional": true,
                                "docs::examples": "randomEXAMPLEidString",
                                "docs::human_name": "External ID"
                              }
                            },
                            "region": {
                              "title": "The [AWS region][aws_region] to send STS requests to.",
                              "description": "If not set, this will default to the configured region\nfor the service itself.\n\n[aws_region]: https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints",
                              "type": [
                                "string",
                                "null"
                              ],
                              "_metadata": {
                                "docs::optional": true,
                                "docs::examples": "us-west-2",
                                "docs::human_name": "Region"
                              }
                            },
                            "secret_access_key": {
                              "description": "The AWS secret access key.",
                              "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
                              "_metadata": {
                                "docs::examples": "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY",
                                "docs::human_name": "Secret Access Key"
                              }
                            }
                          },
                          "_metadata": {
                            "logical_name": "AccessKey",
                            "docs::human_name": "Access Key"
                          }
                        },
                        {
                          "title": "Authenticate using credentials stored in a file.",
                          "description": "Additionally, the specific credential profile to use can be set.\nThe file format must match the credentials file format outlined in\n<https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html>.",
                          "type": "object",
                          "required": [
                            "credentials_file"
                          ],
                          "properties": {
                            "credentials_file": {
                              "description": "Path to the credentials file.",
                              "type": "string",
                              "_metadata": {
                                "docs::examples": "/my/aws/credentials",
                                "docs::human_name": "Credentials File"
                              }
                            },
                            "profile": {
                              "title": "The credentials profile to use.",
                              "description": "Used to select AWS credentials from a provided credentials file.",
                              "default": "default",
                              "type": "string",
                              "_metadata": {
                                "docs::examples": "develop",
                                "docs::human_name": "Profile"
                              }
                            }
                          },
                          "_metadata": {
                            "logical_name": "File",
                            "docs::human_name": "File"
                          }
                        },
                        {
                          "description": "Assume the given role ARN.",
                          "type": "object",
                          "required": [
                            "assume_role"
                          ],
                          "properties": {
                            "assume_role": {
                              "title": "The ARN of an [IAM role][iam_role] to assume.",
                              "description": "[iam_role]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html",
                              "type": "string",
                              "_metadata": {
                                "docs::examples": "arn:aws:iam::123456789098:role/my_role",
                                "docs::human_name": "Assume Role"
                              }
                            },
                            "external_id": {
                              "title": "The optional unique external ID in conjunction with role to assume.",
                              "description": "[external_id]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html",
                              "type": [
                                "string",
                                "null"
                              ],
                              "_metadata": {
                                "docs::optional": true,
                                "docs::examples": "randomEXAMPLEidString",
                                "docs::human_name": "External ID"
                              }
                            },
                            "imds": {
                              "description": "Configuration for authenticating with AWS through IMDS.",
                              "default": {
                                "max_attempts": 4,
                                "connect_timeout_seconds": 1,
                                "read_timeout_seconds": 1
                              },
                              "type": "object",
                              "properties": {
                                "connect_timeout_seconds": {
                                  "description": "Connect timeout for IMDS.",
                                  "default": 1,
                                  "$ref": "#/definitions/serde_with::DurationSeconds",
                                  "_metadata": {
                                    "docs::human_name": "Connect Timeout Seconds"
                                  }
                                },
                                "max_attempts": {
                                  "description": "Number of IMDS retries for fetching tokens and metadata.",
                                  "default": 4,
                                  "type": "integer",
                                  "maximum": 4294967295.0,
                                  "minimum": 0.0,
                                  "_metadata": {
                                    "docs::numeric_type": "uint",
                                    "docs::human_name": "Max Attempts"
                                  }
                                },
                                "read_timeout_seconds": {
                                  "description": "Read timeout for IMDS.",
                                  "default": 1,
                                  "$ref": "#/definitions/serde_with::DurationSeconds",
                                  "_metadata": {
                                    "docs::human_name": "Read Timeout Seconds"
                                  }
                                }
                              },
                              "unevaluatedProperties": false,
                              "_metadata": {
                                "docs::human_name": "IMDS"
                              }
                            },
                            "load_timeout_secs": {
                              "title": "Timeout for assuming the role, in seconds.",
                              "description": "Relevant when the default credentials chain or `assume_role` is used.",
                              "type": [
                                "integer",
                                "null"
                              ],
                              "maximum": 9007199254740991.0,
                              "minimum": 0.0,
                              "_metadata": {
                                "docs::numeric_type": "uint",
                                "docs::optional": true,
                                "docs::type_unit": "seconds",
                                "docs::examples": 30,
                                "docs::human_name": "Load Timeout"
                              }
                            },
                            "region": {
                              "title": "The [AWS region][aws_region] to send STS requests to.",
                              "description": "If not set, this defaults to the configured region\nfor the service itself.\n\n[aws_region]: https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints",
                              "type": [
                                "string",
                                "null"
                              ],
                              "_metadata": {
                                "docs::optional": true,
                                "docs::examples": "us-west-2",
                                "docs::human_name": "Region"
                              }
                            }
                          },
                          "_metadata": {
                            "logical_name": "Role",
                            "docs::human_name": "Role"
                          }
                        },
                        {
                          "description": "Default authentication strategy which tries a variety of substrategies in sequential order.",
                          "type": "object",
                          "properties": {
                            "imds": {
                              "description": "Configuration for authenticating with AWS through IMDS.",
                              "default": {
                                "max_attempts": 4,
                                "connect_timeout_seconds": 1,
                                "read_timeout_seconds": 1
                              },
                              "type": "object",
                              "properties": {
                                "connect_timeout_seconds": {
                                  "description": "Connect timeout for IMDS.",
                                  "default": 1,
                                  "$ref": "#/definitions/serde_with::DurationSeconds",
                                  "_metadata": {
                                    "docs::human_name": "Connect Timeout Seconds"
                                  }
                                },
                                "max_attempts": {
                                  "description": "Number of IMDS retries for fetching tokens and metadata.",
                                  "default": 4,
                                  "type": "integer",
                                  "maximum": 4294967295.0,
                                  "minimum": 0.0,
                                  "_metadata": {
                                    "docs::numeric_type": "uint",
                                    "docs::human_name": "Max Attempts"
                                  }
                                },
                                "read_timeout_seconds": {
                                  "description": "Read timeout for IMDS.",
                                  "default": 1,
                                  "$ref": "#/definitions/serde_with::DurationSeconds",
                                  "_metadata": {
                                    "docs::human_name": "Read Timeout Seconds"
                                  }
                                }
                              },
                              "unevaluatedProperties": false,
                              "_metadata": {
                                "docs::human_name": "IMDS"
                              }
                            },
                            "load_timeout_secs": {
                              "title": "Timeout for successfully loading any credentials, in seconds.",
                              "description": "Relevant when the default credentials chain or `assume_role` is used.",
                              "type": [
                                "integer",
                                "null"
                              ],
                              "maximum": 9007199254740991.0,
                              "minimum": 0.0,
                              "_metadata": {
                                "docs::numeric_type": "uint",
                                "docs::optional": true,
                                "docs::type_unit": "seconds",
                                "docs::examples": 30,
                                "docs::human_name": "Load Timeout"
                              }
                            },
                            "region": {
                              "title": "The [AWS region][aws_region] to send STS requests to.",
                              "description": "If not set, this defaults to the configured region\nfor the service itself.\n\n[aws_region]: https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints",
                              "type": [
                                "string",
                                "null"
                              ],
                              "_metadata": {
                                "docs::optional": true,
                                "docs::examples": "us-west-2",
                                "docs::human_name": "Region"
                              }
                            }
                          },
                          "_metadata": {
                            "logical_name": "Default",
                            "docs::human_name": "Default"
                          }
                        }
                      ],
                      "_metadata": {
                        "docs::enum_tagging": "untagged"
                      }
                    },
                    {
                      "type": "object",
                      "required": [
                        "strategy"
                      ],
                      "properties": {
                        "strategy": {
                          "description": "Amazon Prometheus Service-specific authentication.",
                          "const": "aws",
                          "_metadata": {
                            "docs::human_name": "Strategy"
                          }
                        }
                      }
                    }
                  ],
                  "_metadata": {
                    "logical_name": "Aws",
                    "docs::human_name": "AWS"
                  }
                }
              ],
              "_metadata": {
                "docs::enum_tag_description": "The authentication strategy to use.",
                "docs::enum_tagging": "internal",
                "docs::enum_tag_field": "strategy"
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Auth"
          }
        },
        "aws": {
          "$ref": "#/definitions/core::option::Option<vector::aws::region::RegionOrEndpoint>",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "AWS"
          }
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "type": "object",
          "properties": {
            "max_bytes": {
              "title": "The maximum size of a batch that is processed by a sink.",
              "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
              "default": null,
              "type": [
                "integer",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "bytes",
                "docs::human_name": "Max Bytes"
              }
            },
            "max_events": {
              "description": "The maximum size of a batch before it is flushed.",
              "default": 1000,
              "type": [
                "integer",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "events",
                "docs::human_name": "Max Events"
              }
            },
            "timeout_secs": {
              "description": "The maximum age of a batch before it is flushed.",
              "default": 1.0,
              "type": [
                "number",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": -9007199254740991.0,
              "_metadata": {
                "docs::numeric_type": "float",
                "docs::optional": true,
                "docs::type_unit": "seconds",
                "docs::human_name": "Timeout"
              }
            }
          },
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Batch"
          }
        },
        "buckets": {
          "title": "Default buckets to use for aggregating [distribution][dist_metric_docs] metrics into histograms.",
          "description": "[dist_metric_docs]: https://vector.dev/docs/about/under-the-hood/architecture/data-model/metric/#distribution",
          "default": [
            0.005,
            0.01,
            0.025,
            0.05,
            0.1,
            0.25,
            0.5,
            1.0,
            2.5,
            5.0,
            10.0
          ],
          "type": "array",
          "items": {
            "type": "number",
            "maximum": 9007199254740991.0,
            "minimum": -9007199254740991.0,
            "_metadata": {
              "docs::numeric_type": "float"
            }
          },
          "_metadata": {
            "docs::numeric_type": "float",
            "docs::advanced": true,
            "docs::human_name": "Buckets"
          }
        },
        "compression": {
          "description": "Supported compression types for Prometheus Remote Write.",
          "default": "snappy",
          "oneOf": [
            {
              "description": "Snappy.",
              "const": "snappy",
              "_metadata": {
                "logical_name": "Snappy",
                "docs::human_name": "Snappy"
              }
            },
            {
              "description": "Gzip.",
              "const": "gzip",
              "_metadata": {
                "logical_name": "Gzip",
                "docs::human_name": "Gzip"
              }
            },
            {
              "description": "Zstandard.",
              "const": "zstd",
              "_metadata": {
                "logical_name": "Zstd",
                "docs::human_name": "Zstd"
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::advanced": true,
            "docs::enum_tagging": "external",
            "docs::human_name": "Compression"
          }
        },
        "default_namespace": {
          "title": "The default namespace for any metrics sent.",
          "description": "This namespace is only used if a metric has no existing namespace. When a namespace is\npresent, it is used as a prefix to the metric name, and separated with an underscore (`_`).\n\nIt should follow the Prometheus [naming conventions][prom_naming_docs].\n\n[prom_naming_docs]: https://prometheus.io/docs/practices/naming/#metric-names",
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::examples": "service",
            "docs::advanced": true,
            "docs::human_name": "Default Namespace"
          }
        },
        "endpoint": {
          "title": "The endpoint to send data to.",
          "description": "The endpoint should include the scheme and the path to write to.",
          "type": "string",
          "_metadata": {
            "docs::examples": "https://localhost:8087/api/v1/write",
            "docs::human_name": "Endpoint"
          }
        },
        "quantiles": {
          "title": "Quantiles to use for aggregating [distribution][dist_metric_docs] metrics into a summary.",
          "description": "[dist_metric_docs]: https://vector.dev/docs/about/under-the-hood/architecture/data-model/metric/#distribution",
          "default": [
            0.5,
            0.75,
            0.9,
            0.95,
            0.99
          ],
          "type": "array",
          "items": {
            "type": "number",
            "maximum": 9007199254740991.0,
            "minimum": -9007199254740991.0,
            "_metadata": {
              "docs::numeric_type": "float"
            }
          },
          "_metadata": {
            "docs::numeric_type": "float",
            "docs::advanced": true,
            "docs::human_name": "Quantiles"
          }
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "initial_concurrency": 1,
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          }
        },
        "tenant_id": {
          "title": "The tenant ID to send.",
          "description": "If set, a header named `X-Scope-OrgID` is added to outgoing requests with the value of this setting.\n\nThis may be used by Cortex or other remote services to identify the tenant making the request.",
          "default": null,
          "$ref": "#/definitions/core::option::Option<vector::template::Template>",
          "_metadata": {
            "docs::examples": "my-domain",
            "docs::advanced": true,
            "docs::human_name": "Tenant ID"
          }
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "prometheus_remote_write"
      }
    },
    "vector::sinks::pulsar::config::PulsarSinkConfig": {
      "description": "Configuration for the `pulsar` sink.",
      "type": "object",
      "required": [
        "encoding",
        "endpoint",
        "topic"
      ],
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled for this sink.",
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "auth": {
          "description": "Authentication configuration.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "description": "Authentication configuration.",
              "type": "object",
              "properties": {
                "name": {
                  "title": "Basic authentication name/username.",
                  "description": "This can be used either for basic authentication (username/password) or JWT authentication.\nWhen used for JWT, the value should be `token`.",
                  "type": [
                    "string",
                    "null"
                  ],
                  "_metadata": {
                    "docs::optional": true,
                    "docs::examples": [
                      "${PULSAR_NAME}",
                      "name123"
                    ],
                    "docs::human_name": "Name"
                  }
                },
                "oauth2": {
                  "description": "OAuth2-specific authentication configuration.",
                  "oneOf": [
                    {
                      "type": "null"
                    },
                    {
                      "description": "OAuth2-specific authentication configuration.",
                      "type": "object",
                      "required": [
                        "credentials_url",
                        "issuer_url"
                      ],
                      "properties": {
                        "audience": {
                          "description": "The OAuth2 audience.",
                          "type": [
                            "string",
                            "null"
                          ],
                          "_metadata": {
                            "docs::optional": true,
                            "docs::examples": [
                              "${OAUTH2_AUDIENCE}",
                              "pulsar"
                            ],
                            "docs::human_name": "Audience"
                          }
                        },
                        "credentials_url": {
                          "title": "The credentials URL.",
                          "description": "A data URL is also supported.",
                          "type": "string",
                          "_metadata": {
                            "docs::examples": [
                              "{OAUTH2_CREDENTIALS_URL}",
                              "file:///oauth2_credentials",
                              "data:application/json;base64,cHVsc2FyCg=="
                            ],
                            "docs::human_name": "Credentials URL"
                          }
                        },
                        "issuer_url": {
                          "description": "The issuer URL.",
                          "type": "string",
                          "_metadata": {
                            "docs::examples": [
                              "${OAUTH2_ISSUER_URL}",
                              "https://oauth2.issuer"
                            ],
                            "docs::human_name": "Issuer URL"
                          }
                        },
                        "scope": {
                          "description": "The OAuth2 scope.",
                          "type": [
                            "string",
                            "null"
                          ],
                          "_metadata": {
                            "docs::optional": true,
                            "docs::examples": [
                              "${OAUTH2_SCOPE}",
                              "admin"
                            ],
                            "docs::human_name": "Scope"
                          }
                        }
                      }
                    }
                  ],
                  "unevaluatedProperties": false,
                  "_metadata": {
                    "docs::optional": true,
                    "docs::human_name": "OAuth2"
                  }
                },
                "token": {
                  "title": "Basic authentication password/token.",
                  "description": "This can be used either for basic authentication (username/password) or JWT authentication.\nWhen used for JWT, the value should be the signed JWT, in the compact representation.",
                  "$ref": "#/definitions/core::option::Option<vector_common::sensitive_string::SensitiveString>",
                  "_metadata": {
                    "docs::examples": [
                      "${PULSAR_TOKEN}",
                      "123456789"
                    ],
                    "docs::human_name": "Token"
                  }
                }
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Auth"
          }
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_events": null,
            "max_bytes": null
          },
          "type": "object",
          "properties": {
            "max_bytes": {
              "description": "The maximum size of a batch before it is flushed.",
              "type": [
                "integer",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "bytes",
                "docs::human_name": "Max Bytes"
              }
            },
            "max_events": {
              "title": "The maximum amount of events in a batch before it is flushed.",
              "description": "Note this is an unsigned 32 bit integer which is a smaller capacity than\nmany of the other sink batch settings.",
              "type": [
                "integer",
                "null"
              ],
              "maximum": 4294967295.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "events",
                "docs::examples": 1000,
                "docs::human_name": "Max Events"
              }
            }
          },
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::human_name": "Batch"
          }
        },
        "compression": {
          "description": "Supported compression types for Pulsar.",
          "default": "none",
          "oneOf": [
            {
              "description": "No compression.",
              "const": "none",
              "_metadata": {
                "logical_name": "None",
                "docs::human_name": "None"
              }
            },
            {
              "description": "LZ4.",
              "const": "lz4",
              "_metadata": {
                "logical_name": "Lz4",
                "docs::human_name": "LZ4"
              }
            },
            {
              "description": "Zlib.",
              "const": "zlib",
              "_metadata": {
                "logical_name": "Zlib",
                "docs::human_name": "Zlib"
              }
            },
            {
              "description": "Zstandard.",
              "const": "zstd",
              "_metadata": {
                "logical_name": "Zstd",
                "docs::human_name": "Zstd"
              }
            },
            {
              "description": "Snappy.",
              "const": "snappy",
              "_metadata": {
                "logical_name": "Snappy",
                "docs::human_name": "Snappy"
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::enum_tagging": "external",
            "docs::human_name": "Compression"
          }
        },
        "encoding": {
          "description": "Configures how events are encoded into raw bytes.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
          "_metadata": {
            "docs::human_name": "Encoding"
          }
        },
        "endpoint": {
          "title": "The endpoint to which the Pulsar client should connect to.",
          "description": "The endpoint should specify the pulsar protocol and port.",
          "type": "string",
          "_metadata": {
            "docs::examples": "pulsar://127.0.0.1:6650",
            "docs::human_name": "Endpoint"
          }
        },
        "partition_key_field": {
          "title": "The log field name or tags key to use for the partition key.",
          "description": "If the field does not exist in the log event or metric tags, a blank value will be used.\n\nIf omitted, the key is not sent.\n\nPulsar uses a hash of the key to choose the topic-partition or uses round-robin if the record has no key.",
          "$ref": "#/definitions/core::option::Option<vector_lookup::lookup_v2::optional_path::OptionalTargetPath>",
          "_metadata": {
            "docs::examples": [
              "message",
              "my_field"
            ],
            "docs::human_name": "Partition Key Field"
          }
        },
        "producer_name": {
          "description": "The name of the producer. If not specified, the default name assigned by Pulsar is used.",
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::examples": "producer-name",
            "docs::human_name": "Producer Name"
          }
        },
        "properties_key": {
          "title": "The log field name to use for the Pulsar properties key.",
          "description": "If omitted, no properties will be written.",
          "$ref": "#/definitions/core::option::Option<vector_lookup::lookup_v2::optional_path::OptionalTargetPath>",
          "_metadata": {
            "docs::human_name": "Properties Key"
          }
        },
        "topic": {
          "description": "The Pulsar topic name to write events to.",
          "$ref": "#/definitions/vector::template::Template",
          "_metadata": {
            "docs::examples": "topic-1234",
            "docs::human_name": "Topic"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "pulsar"
      }
    },
    "vector::sinks::redis::config::RedisSinkConfig": {
      "description": "Configuration for the `redis` sink.",
      "type": "object",
      "required": [
        "encoding",
        "endpoint",
        "key"
      ],
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled for this sink.",
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "type": "object",
          "properties": {
            "max_bytes": {
              "title": "The maximum size of a batch that is processed by a sink.",
              "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
              "default": null,
              "type": [
                "integer",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "bytes",
                "docs::human_name": "Max Bytes"
              }
            },
            "max_events": {
              "description": "The maximum size of a batch before it is flushed.",
              "default": 1,
              "type": [
                "integer",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "events",
                "docs::human_name": "Max Events"
              }
            },
            "timeout_secs": {
              "description": "The maximum age of a batch before it is flushed.",
              "default": 1.0,
              "type": [
                "number",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": -9007199254740991.0,
              "_metadata": {
                "docs::numeric_type": "float",
                "docs::optional": true,
                "docs::type_unit": "seconds",
                "docs::human_name": "Timeout"
              }
            }
          },
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Batch"
          }
        },
        "data_type": {
          "description": "Redis data type to store messages in.",
          "default": "list",
          "oneOf": [
            {
              "title": "The Redis `list` type.",
              "description": "This resembles a deque, where messages can be popped and pushed from either end.\n\nThis is the default.",
              "const": "list",
              "_metadata": {
                "logical_name": "List",
                "docs::human_name": "List"
              }
            },
            {
              "title": "The Redis `channel` type.",
              "description": "Redis channels function in a pub/sub fashion, allowing many-to-many broadcasting and receiving.",
              "const": "channel",
              "_metadata": {
                "logical_name": "Channel",
                "docs::human_name": "Channel"
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::enum_tagging": "external",
            "docs::human_name": "Data Type"
          }
        },
        "encoding": {
          "description": "Configures how events are encoded into raw bytes.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
          "_metadata": {
            "docs::human_name": "Encoding"
          }
        },
        "endpoint": {
          "title": "The URL of the Redis endpoint to connect to.",
          "description": "The URL _must_ take the form of `protocol://server:port/db` where the protocol can either be\n`redis` or `rediss` for connections secured via TLS.",
          "type": "string",
          "_metadata": {
            "docs::examples": "redis://127.0.0.1:6379/0",
            "docs::human_name": "Endpoint"
          }
        },
        "key": {
          "description": "The Redis key to publish messages to.",
          "$ref": "#/definitions/vector::template::Template",
          "_metadata": {
            "docs::examples": [
              "syslog:{{ app }}",
              "vector"
            ],
            "docs::human_name": "Key"
          }
        },
        "list_option": {
          "description": "List-specific options.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "description": "List-specific options.",
              "type": "object",
              "required": [
                "method"
              ],
              "properties": {
                "method": {
                  "description": "The method to use for pushing messages into a `list`.",
                  "oneOf": [
                    {
                      "title": "Use the `rpush` method.",
                      "description": "This pushes messages onto the tail of the list.\n\nThis is the default.",
                      "const": "rpush",
                      "_metadata": {
                        "logical_name": "RPush",
                        "docs::human_name": "R Push"
                      }
                    },
                    {
                      "title": "Use the `lpush` method.",
                      "description": "This pushes messages onto the head of the list.",
                      "const": "lpush",
                      "_metadata": {
                        "logical_name": "LPush",
                        "docs::human_name": "L Push"
                      }
                    }
                  ],
                  "unevaluatedProperties": false,
                  "_metadata": {
                    "docs::enum_tagging": "external",
                    "docs::human_name": "Method"
                  }
                }
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "List Option"
          }
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "initial_concurrency": 1,
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "redis"
      }
    },
    "vector::sinks::sematext::Region": {
      "description": "The Sematext region to send data to.",
      "oneOf": [
        {
          "description": "United States",
          "const": "us",
          "_metadata": {
            "logical_name": "Us",
            "docs::human_name": "US"
          }
        },
        {
          "description": "Europe",
          "const": "eu",
          "_metadata": {
            "logical_name": "Eu",
            "docs::human_name": "EU"
          }
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::enum_tagging": "external"
      }
    },
    "vector::sinks::sematext::logs::SematextLogsConfig": {
      "description": "Configuration for the `sematext_logs` sink.",
      "type": "object",
      "required": [
        "token"
      ],
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled for this sink.",
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::RealtimeSizeBasedDefaultBatchSettings>",
          "_metadata": {
            "docs::human_name": "Batch"
          }
        },
        "encoding": {
          "description": "Transformations to prepare an event for serialization.",
          "default": {},
          "$ref": "#/definitions/vector::codecs::encoding::transformer::Transformer",
          "_metadata": {
            "docs::human_name": "Encoding"
          }
        },
        "endpoint": {
          "title": "The endpoint to send data to.",
          "description": "Setting this option overrides the `region` option.",
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::examples": [
              "http://127.0.0.1",
              "https://example.com"
            ],
            "docs::human_name": "Endpoint"
          }
        },
        "region": {
          "description": "The Sematext region to send data to.",
          "default": "us",
          "$ref": "#/definitions/vector::sinks::sematext::Region",
          "_metadata": {
            "docs::human_name": "Region"
          }
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "initial_concurrency": 1,
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          }
        },
        "token": {
          "description": "The token that is used to write to Sematext.",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "docs::examples": [
              "${SEMATEXT_TOKEN}",
              "some-sematext-token"
            ],
            "docs::human_name": "Token"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "sematext_logs"
      }
    },
    "vector::sinks::sematext::metrics::SematextMetricsConfig": {
      "description": "Configuration for the `sematext_metrics` sink.",
      "type": "object",
      "required": [
        "default_namespace",
        "token"
      ],
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled for this sink.",
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "type": "object",
          "properties": {
            "max_bytes": {
              "title": "The maximum size of a batch that is processed by a sink.",
              "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
              "default": null,
              "type": [
                "integer",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "bytes",
                "docs::human_name": "Max Bytes"
              }
            },
            "max_events": {
              "description": "The maximum size of a batch before it is flushed.",
              "default": 20,
              "type": [
                "integer",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "events",
                "docs::human_name": "Max Events"
              }
            },
            "timeout_secs": {
              "description": "The maximum age of a batch before it is flushed.",
              "default": 1.0,
              "type": [
                "number",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": -9007199254740991.0,
              "_metadata": {
                "docs::numeric_type": "float",
                "docs::optional": true,
                "docs::type_unit": "seconds",
                "docs::human_name": "Timeout"
              }
            }
          },
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Batch"
          }
        },
        "default_namespace": {
          "title": "Sets the default namespace for any metrics sent.",
          "description": "This namespace is only used if a metric has no existing namespace. When a namespace is\npresent, it is used as a prefix to the metric name, and separated with a period (`.`).",
          "type": "string",
          "_metadata": {
            "docs::examples": "service",
            "docs::human_name": "Default Namespace"
          }
        },
        "endpoint": {
          "title": "The endpoint to send data to.",
          "description": "Setting this option overrides the `region` option.",
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::examples": [
              "http://127.0.0.1",
              "https://example.com"
            ],
            "docs::human_name": "Endpoint"
          }
        },
        "region": {
          "description": "The Sematext region to send data to.",
          "default": "us",
          "$ref": "#/definitions/vector::sinks::sematext::Region",
          "_metadata": {
            "docs::human_name": "Region"
          }
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "initial_concurrency": 1,
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          }
        },
        "token": {
          "description": "The token that is used to write to Sematext.",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "docs::examples": [
              "${SEMATEXT_TOKEN}",
              "some-sematext-token"
            ],
            "docs::human_name": "Token"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "sematext_metrics"
      }
    },
    "vector::sinks::socket::SocketSinkConfig": {
      "description": "Configuration for the `socket` sink.",
      "allOf": [
        {
          "type": "object",
          "properties": {
            "acknowledgements": {
              "title": "Controls how acknowledgements are handled for this sink.",
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              }
            }
          }
        },
        {
          "description": "Socket mode.",
          "oneOf": [
            {
              "description": "Send over TCP.",
              "allOf": [
                {
                  "description": "TCP configuration.",
                  "allOf": [
                    {
                      "description": "A TCP sink.",
                      "type": "object",
                      "required": [
                        "address"
                      ],
                      "properties": {
                        "address": {
                          "title": "The address to connect to.",
                          "description": "Both IP address and hostname are accepted formats.\n\nThe address _must_ include a port.",
                          "type": "string",
                          "_metadata": {
                            "docs::examples": [
                              "92.12.333.224:5000",
                              "https://somehost:5000"
                            ],
                            "docs::human_name": "Address"
                          }
                        },
                        "keepalive": {
                          "$ref": "#/definitions/core::option::Option<vector_core::tcp::TcpKeepaliveConfig>",
                          "_metadata": {
                            "docs::human_name": "Keepalive"
                          }
                        },
                        "send_buffer_bytes": {
                          "title": "The size of the socket's send buffer.",
                          "description": "If set, the value of the setting is passed via the `SO_SNDBUF` option.",
                          "type": [
                            "integer",
                            "null"
                          ],
                          "maximum": 9007199254740991.0,
                          "minimum": 0.0,
                          "_metadata": {
                            "docs::numeric_type": "uint",
                            "docs::optional": true,
                            "docs::type_unit": "bytes",
                            "docs::examples": 65536,
                            "docs::human_name": "Send Buffer Bytes"
                          }
                        },
                        "tls": {
                          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
                          "_metadata": {
                            "docs::human_name": "TLS"
                          }
                        }
                      }
                    },
                    {
                      "description": "Encoding configuration.",
                      "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfigWithFraming"
                    }
                  ]
                },
                {
                  "type": "object",
                  "required": [
                    "mode"
                  ],
                  "properties": {
                    "mode": {
                      "description": "Send over TCP.",
                      "const": "tcp",
                      "_metadata": {
                        "docs::human_name": "Mode"
                      }
                    }
                  }
                }
              ],
              "_metadata": {
                "logical_name": "Tcp",
                "docs::human_name": "TCP"
              }
            },
            {
              "description": "Send over UDP.",
              "allOf": [
                {
                  "description": "UDP configuration.",
                  "allOf": [
                    {
                      "type": "object",
                      "required": [
                        "encoding"
                      ],
                      "properties": {
                        "encoding": {
                          "description": "Configures how events are encoded into raw bytes.",
                          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
                          "_metadata": {
                            "docs::human_name": "Encoding"
                          }
                        }
                      }
                    },
                    {
                      "description": "A UDP sink.",
                      "type": "object",
                      "required": [
                        "address"
                      ],
                      "properties": {
                        "address": {
                          "title": "The address to connect to.",
                          "description": "Both IP address and hostname are accepted formats.\n\nThe address _must_ include a port.",
                          "type": "string",
                          "_metadata": {
                            "docs::examples": [
                              "92.12.333.224:5000",
                              "https://somehost:5000"
                            ],
                            "docs::human_name": "Address"
                          }
                        },
                        "send_buffer_bytes": {
                          "title": "The size of the socket's send buffer.",
                          "description": "If set, the value of the setting is passed via the `SO_SNDBUF` option.",
                          "type": [
                            "integer",
                            "null"
                          ],
                          "maximum": 9007199254740991.0,
                          "minimum": 0.0,
                          "_metadata": {
                            "docs::numeric_type": "uint",
                            "docs::optional": true,
                            "docs::type_unit": "bytes",
                            "docs::examples": 65536,
                            "docs::human_name": "Send Buffer Bytes"
                          }
                        }
                      }
                    }
                  ]
                },
                {
                  "type": "object",
                  "required": [
                    "mode"
                  ],
                  "properties": {
                    "mode": {
                      "description": "Send over UDP.",
                      "const": "udp",
                      "_metadata": {
                        "docs::human_name": "Mode"
                      }
                    }
                  }
                }
              ],
              "_metadata": {
                "logical_name": "Udp",
                "docs::human_name": "UDP"
              }
            },
            {
              "description": "Send over a Unix domain socket (UDS).",
              "allOf": [
                {
                  "description": "Unix Domain Socket configuration.",
                  "allOf": [
                    {
                      "description": "A Unix Domain Socket sink.",
                      "type": "object",
                      "required": [
                        "path"
                      ],
                      "properties": {
                        "path": {
                          "title": "The Unix socket path.",
                          "description": "This should be an absolute path.",
                          "$ref": "#/definitions/stdlib::PathBuf",
                          "_metadata": {
                            "docs::examples": "/path/to/socket",
                            "docs::human_name": "Path"
                          }
                        }
                      }
                    },
                    {
                      "description": "Encoding configuration.",
                      "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfigWithFraming"
                    }
                  ]
                },
                {
                  "type": "object",
                  "required": [
                    "mode"
                  ],
                  "properties": {
                    "mode": {
                      "description": "Send over a Unix domain socket (UDS).",
                      "const": "unix",
                      "_metadata": {
                        "docs::human_name": "Mode"
                      }
                    }
                  }
                }
              ],
              "_metadata": {
                "logical_name": "Unix",
                "docs::human_name": "Unix"
              }
            }
          ],
          "_metadata": {
            "docs::enum_tag_description": "The type of socket to use.",
            "docs::enum_tagging": "internal",
            "docs::enum_tag_field": "mode"
          }
        }
      ],
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "socket"
      }
    },
    "vector::sinks::splunk_hec::common::acknowledgements::HecClientAcknowledgementsConfig": {
      "description": "Splunk HEC acknowledgement configuration.",
      "default": {
        "indexer_acknowledgements_enabled": true,
        "query_interval": 10,
        "retry_limit": 30,
        "max_pending_acks": 1000000
      },
      "allOf": [
        {
          "type": "object",
          "properties": {
            "indexer_acknowledgements_enabled": {
              "title": "Controls if the sink integrates with [Splunk HEC indexer acknowledgements][splunk_indexer_ack_docs] for end-to-end acknowledgements.",
              "description": "[splunk_indexer_ack_docs]: https://docs.splunk.com/Documentation/Splunk/8.2.3/Data/AboutHECIDXAck",
              "type": "boolean",
              "_metadata": {
                "docs::human_name": "Indexer Acknowledgements Enabled"
              }
            },
            "max_pending_acks": {
              "title": "The maximum number of pending acknowledgements from events sent to the Splunk HEC collector.",
              "description": "Once reached, the sink begins applying backpressure.",
              "type": "integer",
              "maximum": 9007199254740991.0,
              "minimum": 1.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::human_name": "Max Pending Acks"
              }
            },
            "query_interval": {
              "description": "The amount of time to wait between queries to the Splunk HEC indexer acknowledgement endpoint.",
              "type": "integer",
              "maximum": 255.0,
              "minimum": 1.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::type_unit": "seconds",
                "docs::human_name": "Query Interval"
              }
            },
            "retry_limit": {
              "description": "The maximum number of times an acknowledgement ID is queried for its status.",
              "type": "integer",
              "maximum": 255.0,
              "minimum": 1.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::human_name": "Retry Limit"
              }
            }
          }
        },
        {
          "title": "Controls how acknowledgements are handled for this sink.",
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "type": "object",
          "properties": {
            "enabled": {
              "title": "Whether or not end-to-end acknowledgements are enabled.",
              "description": "When enabled for a sink, any source connected to that sink, where the source supports\nend-to-end acknowledgements as well, waits for events to be acknowledged by the sink\nbefore acknowledging them at the source.\n\nEnabling or disabling acknowledgements at the sink level takes precedence over any global\n[`acknowledgements`][global_acks] configuration.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements",
              "type": [
                "boolean",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::human_name": "Enabled"
              }
            }
          }
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::advanced": true
      }
    },
    "vector::sinks::splunk_hec::logs::config::HecLogsSinkConfig": {
      "description": "Configuration for the `splunk_hec_logs` sink.",
      "type": "object",
      "required": [
        "default_token",
        "encoding",
        "endpoint"
      ],
      "properties": {
        "acknowledgements": {
          "description": "Splunk HEC acknowledgement configuration.",
          "default": {
            "indexer_acknowledgements_enabled": true,
            "query_interval": 10,
            "retry_limit": 30,
            "max_pending_acks": 1000000
          },
          "$ref": "#/definitions/vector::sinks::splunk_hec::common::acknowledgements::HecClientAcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "auto_extract_timestamp": {
          "title": "Passes the `auto_extract_timestamp` option to Splunk.",
          "description": "This option is only relevant to Splunk v8.x and above, and is only applied when\n`endpoint_target` is set to `event`.\n\nSetting this to `true` causes Splunk to extract the timestamp from the message text\nrather than use the timestamp embedded in the event. The timestamp must be in the format\n`yyyy-mm-dd hh:mm:ss`.",
          "default": null,
          "type": [
            "boolean",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Auto Extract Timestamp"
          }
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::splunk_hec::common::util::SplunkHecDefaultBatchSettings>",
          "_metadata": {
            "docs::human_name": "Batch"
          }
        },
        "compression": {
          "title": "Compression configuration.",
          "description": "All compression algorithms use the default compression level unless otherwise specified.",
          "default": "none",
          "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
          "_metadata": {
            "docs::human_name": "Compression"
          }
        },
        "default_token": {
          "title": "Default Splunk HEC token.",
          "description": "If an event has a token set in its secrets (`splunk_hec_token`), it prevails over the one set here.",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "docs::human_name": "Default Token"
          }
        },
        "encoding": {
          "description": "Configures how events are encoded into raw bytes.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
          "_metadata": {
            "docs::human_name": "Encoding"
          }
        },
        "endpoint": {
          "title": "The base URL of the Splunk instance.",
          "description": "The scheme (`http` or `https`) must be specified. No path should be included since the paths defined\nby the [`Splunk`][splunk] API are used.\n\n[splunk]: https://docs.splunk.com/Documentation/Splunk/8.0.0/Data/HECRESTendpoints",
          "type": "string",
          "format": "uri",
          "_metadata": {
            "docs::examples": [
              "https://http-inputs-hec.splunkcloud.com",
              "https://hec.splunk.com:8088",
              "http://example.com"
            ],
            "docs::human_name": "Endpoint"
          }
        },
        "endpoint_target": {
          "description": "Splunk HEC endpoint configuration.",
          "default": "event",
          "oneOf": [
            {
              "title": "Events are sent to the [raw endpoint][raw_endpoint_docs].",
              "description": "When the raw endpoint is used, configured [event metadata][event_metadata_docs] is sent as\nquery parameters on the request, except for the `timestamp` field.\n\n[raw_endpoint_docs]: https://docs.splunk.com/Documentation/Splunk/8.0.0/RESTREF/RESTinput#services.2Fcollector.2Fraw\n[event_metadata_docs]: https://docs.splunk.com/Documentation/Splunk/latest/Data/FormateventsforHTTPEventCollector#Event_metadata",
              "const": "raw",
              "_metadata": {
                "logical_name": "Raw",
                "docs::human_name": "Raw"
              }
            },
            {
              "title": "Events are sent to the [event endpoint][event_endpoint_docs].",
              "description": "When the event endpoint is used, configured [event metadata][event_metadata_docs] is sent\ndirectly with each event.\n\n[event_endpoint_docs]: https://docs.splunk.com/Documentation/Splunk/8.0.0/RESTREF/RESTinput#services.2Fcollector.2Fevent\n[event_metadata_docs]: https://docs.splunk.com/Documentation/Splunk/latest/Data/FormateventsforHTTPEventCollector#Event_metadata",
              "const": "event",
              "_metadata": {
                "logical_name": "Event",
                "docs::human_name": "Event"
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::advanced": true,
            "docs::enum_tagging": "external",
            "docs::human_name": "Endpoint Target"
          }
        },
        "host_key": {
          "title": "Overrides the name of the log field used to retrieve the hostname to send to Splunk HEC.",
          "description": "By default, the [global `log_schema.host_key` option][global_host_key] is used.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
          "default": "host",
          "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Host Key"
          }
        },
        "index": {
          "title": "The name of the index to send events to.",
          "description": "If not specified, the default index defined within Splunk is used.",
          "$ref": "#/definitions/core::option::Option<vector::template::Template>",
          "_metadata": {
            "docs::examples": [
              "{{ host }}",
              "custom_index"
            ],
            "docs::human_name": "Index"
          }
        },
        "indexed_fields": {
          "title": "Fields to be [added to Splunk index][splunk_field_index_docs].",
          "description": "[splunk_field_index_docs]: https://docs.splunk.com/Documentation/Splunk/8.0.0/Data/IFXandHEC",
          "default": [],
          "type": "array",
          "items": {
            "$ref": "#/definitions/vector_lookup::lookup_v2::ConfigValuePath"
          },
          "_metadata": {
            "docs::advanced": true,
            "docs::examples": [
              "field1",
              "field2"
            ],
            "docs::human_name": "Indexed Fields"
          }
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "initial_concurrency": 1,
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          }
        },
        "source": {
          "title": "The source of events sent to this sink.",
          "description": "This is typically the filename the logs originated from.\n\nIf unset, the Splunk collector sets it.",
          "$ref": "#/definitions/core::option::Option<vector::template::Template>",
          "_metadata": {
            "docs::advanced": true,
            "docs::examples": [
              "{{ file }}",
              "/var/log/syslog",
              "UDP:514"
            ],
            "docs::human_name": "Source"
          }
        },
        "sourcetype": {
          "title": "The sourcetype of events sent to this sink.",
          "description": "If unset, Splunk defaults to `httpevent`.",
          "$ref": "#/definitions/core::option::Option<vector::template::Template>",
          "_metadata": {
            "docs::advanced": true,
            "docs::examples": [
              "{{ sourcetype }}",
              "_json"
            ],
            "docs::human_name": "Sourcetype"
          }
        },
        "timestamp_key": {
          "title": "Overrides the name of the log field used to retrieve the timestamp to send to Splunk HEC.\nWhen set to `“”`, a timestamp is not set in the events sent to Splunk HEC.",
          "description": "By default, the [global `log_schema.timestamp_key` option][global_timestamp_key] is used.\n\n[global_timestamp_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.timestamp_key",
          "default": "timestamp",
          "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
          "_metadata": {
            "docs::advanced": true,
            "docs::examples": [
              "timestamp",
              ""
            ],
            "docs::human_name": "Timestamp Key"
          }
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "splunk_hec_logs"
      }
    },
    "vector::sinks::splunk_hec::metrics::config::HecMetricsSinkConfig": {
      "description": "Configuration of the `splunk_hec_metrics` sink.",
      "type": "object",
      "required": [
        "default_token",
        "endpoint"
      ],
      "properties": {
        "acknowledgements": {
          "description": "Splunk HEC acknowledgement configuration.",
          "default": {
            "indexer_acknowledgements_enabled": true,
            "query_interval": 10,
            "retry_limit": 30,
            "max_pending_acks": 1000000
          },
          "$ref": "#/definitions/vector::sinks::splunk_hec::common::acknowledgements::HecClientAcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::splunk_hec::common::util::SplunkHecDefaultBatchSettings>",
          "_metadata": {
            "docs::human_name": "Batch"
          }
        },
        "compression": {
          "title": "Compression configuration.",
          "description": "All compression algorithms use the default compression level unless otherwise specified.",
          "default": "none",
          "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
          "_metadata": {
            "docs::human_name": "Compression"
          }
        },
        "default_namespace": {
          "title": "Sets the default namespace for any metrics sent.",
          "description": "This namespace is only used if a metric has no existing namespace. When a namespace is\npresent, it is used as a prefix to the metric name, and separated with a period (`.`).",
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::examples": "service",
            "docs::human_name": "Default Namespace"
          }
        },
        "default_token": {
          "title": "Default Splunk HEC token.",
          "description": "If an event has a token set in its metadata, it prevails over the one set here.",
          "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString",
          "_metadata": {
            "docs::examples": [
              "${SPLUNK_HEC_TOKEN}",
              "A94A8FE5CCB19BA61C4C08"
            ],
            "docs::human_name": "Default Token"
          }
        },
        "endpoint": {
          "title": "The base URL of the Splunk instance.",
          "description": "The scheme (`http` or `https`) must be specified. No path should be included since the paths defined\nby the [`Splunk`][splunk] API are used.\n\n[splunk]: https://docs.splunk.com/Documentation/Splunk/8.0.0/Data/HECRESTendpoints",
          "type": "string",
          "format": "uri",
          "_metadata": {
            "docs::examples": [
              "https://http-inputs-hec.splunkcloud.com",
              "https://hec.splunk.com:8088",
              "http://example.com"
            ],
            "docs::human_name": "Endpoint"
          }
        },
        "host_key": {
          "title": "Overrides the name of the log field used to retrieve the hostname to send to Splunk HEC.",
          "description": "By default, the [global `log_schema.host_key` option][global_host_key] is used.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
          "default": "host",
          "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Host Key"
          }
        },
        "index": {
          "title": "The name of the index where to send the events to.",
          "description": "If not specified, the default index defined within Splunk is used.",
          "$ref": "#/definitions/core::option::Option<vector::template::Template>",
          "_metadata": {
            "docs::examples": [
              "{{ host }}",
              "custom_index"
            ],
            "docs::human_name": "Index"
          }
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "initial_concurrency": 1,
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          }
        },
        "source": {
          "title": "The source of events sent to this sink.",
          "description": "This is typically the filename the logs originated from.\n\nIf unset, the Splunk collector sets it.",
          "$ref": "#/definitions/core::option::Option<vector::template::Template>",
          "_metadata": {
            "docs::advanced": true,
            "docs::examples": [
              "{{ file }}",
              "/var/log/syslog",
              "UDP:514"
            ],
            "docs::human_name": "Source"
          }
        },
        "sourcetype": {
          "title": "The sourcetype of events sent to this sink.",
          "description": "If unset, Splunk defaults to `httpevent`.",
          "$ref": "#/definitions/core::option::Option<vector::template::Template>",
          "_metadata": {
            "docs::advanced": true,
            "docs::examples": [
              "{{ sourcetype }}",
              "_json"
            ],
            "docs::human_name": "Sourcetype"
          }
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "splunk_hec_metrics"
      }
    },
    "vector::sinks::statsd::config::StatsdSinkConfig": {
      "description": "Configuration for the `statsd` sink.",
      "allOf": [
        {
          "type": "object",
          "properties": {
            "acknowledgements": {
              "title": "Controls how acknowledgements are handled for this sink.",
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              }
            },
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "type": "object",
              "properties": {
                "max_bytes": {
                  "title": "The maximum size of a batch that is processed by a sink.",
                  "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
                  "default": 1300,
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes",
                    "docs::human_name": "Max Bytes"
                  }
                },
                "max_events": {
                  "description": "The maximum size of a batch before it is flushed.",
                  "default": 1000,
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "events",
                    "docs::human_name": "Max Events"
                  }
                },
                "timeout_secs": {
                  "description": "The maximum age of a batch before it is flushed.",
                  "default": 1.0,
                  "type": [
                    "number",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": -9007199254740991.0,
                  "_metadata": {
                    "docs::numeric_type": "float",
                    "docs::optional": true,
                    "docs::type_unit": "seconds",
                    "docs::human_name": "Timeout"
                  }
                }
              },
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Batch"
              }
            },
            "default_namespace": {
              "title": "Sets the default namespace for any metrics sent.",
              "description": "This namespace is only used if a metric has no existing namespace. When a namespace is\npresent, it is used as a prefix to the metric name, and separated with a period (`.`).",
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::examples": "service",
                "docs::human_name": "Default Namespace"
              }
            }
          }
        },
        {
          "description": "Socket mode.",
          "oneOf": [
            {
              "description": "Send over TCP.",
              "allOf": [
                {
                  "description": "TCP configuration.",
                  "type": "object",
                  "required": [
                    "address"
                  ],
                  "properties": {
                    "address": {
                      "title": "The address to connect to.",
                      "description": "Both IP addresses and hostnames/fully qualified domain names (FQDNs) are accepted formats.\n\nThe address _must_ include a port.",
                      "$ref": "#/definitions/vector::sinks::util::service::net::HostAndPort",
                      "_metadata": {
                        "docs::human_name": "Address"
                      }
                    },
                    "keepalive": {
                      "$ref": "#/definitions/core::option::Option<vector_core::tcp::TcpKeepaliveConfig>",
                      "_metadata": {
                        "docs::human_name": "Keepalive"
                      }
                    },
                    "send_buffer_size": {
                      "title": "The size of the socket's send buffer.",
                      "description": "If set, the value of the setting is passed via the `SO_SNDBUF` option.",
                      "type": [
                        "integer",
                        "null"
                      ],
                      "maximum": 9007199254740991.0,
                      "minimum": 0.0,
                      "_metadata": {
                        "docs::numeric_type": "uint",
                        "docs::optional": true,
                        "docs::type_unit": "bytes",
                        "docs::examples": 65536,
                        "docs::human_name": "Send Buffer Size"
                      }
                    },
                    "tls": {
                      "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
                      "_metadata": {
                        "docs::human_name": "TLS"
                      }
                    }
                  }
                },
                {
                  "type": "object",
                  "required": [
                    "mode"
                  ],
                  "properties": {
                    "mode": {
                      "description": "Send over TCP.",
                      "const": "tcp",
                      "_metadata": {
                        "docs::human_name": "Mode"
                      }
                    }
                  }
                }
              ],
              "_metadata": {
                "logical_name": "Tcp",
                "docs::human_name": "TCP"
              }
            },
            {
              "description": "Send over UDP.",
              "allOf": [
                {
                  "description": "UDP configuration.",
                  "type": "object",
                  "required": [
                    "address"
                  ],
                  "properties": {
                    "address": {
                      "title": "The address to connect to.",
                      "description": "Both IP addresses and hostnames/fully qualified domain names (FQDNs) are accepted formats.\n\nThe address _must_ include a port.",
                      "$ref": "#/definitions/vector::sinks::util::service::net::HostAndPort",
                      "_metadata": {
                        "docs::human_name": "Address"
                      }
                    },
                    "send_buffer_size": {
                      "title": "The size of the socket's send buffer.",
                      "description": "If set, the value of the setting is passed via the `SO_SNDBUF` option.",
                      "type": [
                        "integer",
                        "null"
                      ],
                      "maximum": 9007199254740991.0,
                      "minimum": 0.0,
                      "_metadata": {
                        "docs::numeric_type": "uint",
                        "docs::optional": true,
                        "docs::type_unit": "bytes",
                        "docs::examples": 65536,
                        "docs::human_name": "Send Buffer Size"
                      }
                    }
                  }
                },
                {
                  "type": "object",
                  "required": [
                    "mode"
                  ],
                  "properties": {
                    "mode": {
                      "description": "Send over UDP.",
                      "const": "udp",
                      "_metadata": {
                        "docs::human_name": "Mode"
                      }
                    }
                  }
                }
              ],
              "_metadata": {
                "logical_name": "Udp",
                "docs::human_name": "UDP"
              }
            },
            {
              "description": "Send over a Unix domain socket (UDS).",
              "allOf": [
                {
                  "description": "Unix Domain Socket configuration.",
                  "type": "object",
                  "required": [
                    "path"
                  ],
                  "properties": {
                    "path": {
                      "title": "The Unix socket path.",
                      "description": "This should be an absolute path.",
                      "$ref": "#/definitions/stdlib::PathBuf",
                      "_metadata": {
                        "docs::examples": "/path/to/socket",
                        "docs::human_name": "Path"
                      }
                    },
                    "send_buffer_size": {
                      "title": "The size of the socket's send buffer.",
                      "description": "If set, the value of the setting is passed via the `SO_SNDBUF` option.",
                      "type": [
                        "integer",
                        "null"
                      ],
                      "maximum": 9007199254740991.0,
                      "minimum": 0.0,
                      "_metadata": {
                        "docs::numeric_type": "uint",
                        "docs::optional": true,
                        "docs::type_unit": "bytes",
                        "docs::examples": 65536,
                        "docs::human_name": "Send Buffer Size"
                      }
                    },
                    "unix_mode": {
                      "description": "The Unix socket mode to use.",
                      "default": "Stream",
                      "oneOf": [
                        {
                          "description": "Datagram-oriented (`SOCK_DGRAM`).",
                          "const": "Datagram",
                          "_metadata": {
                            "logical_name": "Datagram",
                            "docs::human_name": "Datagram"
                          }
                        },
                        {
                          "description": "Stream-oriented (`SOCK_STREAM`).",
                          "const": "Stream",
                          "_metadata": {
                            "logical_name": "Stream",
                            "docs::human_name": "Stream"
                          }
                        }
                      ],
                      "unevaluatedProperties": false,
                      "_metadata": {
                        "docs::enum_tagging": "external",
                        "docs::human_name": "Unix Mode"
                      }
                    }
                  }
                },
                {
                  "type": "object",
                  "required": [
                    "mode"
                  ],
                  "properties": {
                    "mode": {
                      "description": "Send over a Unix domain socket (UDS).",
                      "const": "unix",
                      "_metadata": {
                        "docs::human_name": "Mode"
                      }
                    }
                  }
                }
              ],
              "_metadata": {
                "logical_name": "Unix",
                "docs::human_name": "Unix"
              }
            }
          ],
          "_metadata": {
            "docs::enum_tag_description": "The type of socket to use.",
            "docs::enum_tagging": "internal",
            "docs::enum_tag_field": "mode"
          }
        }
      ],
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "statsd"
      }
    },
    "vector::sinks::util::batch::BatchConfig<vector::sinks::splunk_hec::common::util::SplunkHecDefaultBatchSettings>": {
      "description": "Event batching behavior.",
      "type": "object",
      "properties": {
        "max_bytes": {
          "title": "The maximum size of a batch that is processed by a sink.",
          "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
          "default": 1000000,
          "type": [
            "integer",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "bytes",
            "docs::human_name": "Max Bytes"
          }
        },
        "max_events": {
          "description": "The maximum size of a batch before it is flushed.",
          "default": null,
          "type": [
            "integer",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "events",
            "docs::human_name": "Max Events"
          }
        },
        "timeout_secs": {
          "description": "The maximum age of a batch before it is flushed.",
          "default": 1.0,
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0,
          "_metadata": {
            "docs::numeric_type": "float",
            "docs::optional": true,
            "docs::type_unit": "seconds",
            "docs::human_name": "Timeout"
          }
        }
      },
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::advanced": true
      }
    },
    "vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::BulkSizeBasedDefaultBatchSettings>": {
      "description": "Event batching behavior.",
      "type": "object",
      "properties": {
        "max_bytes": {
          "title": "The maximum size of a batch that is processed by a sink.",
          "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
          "default": 10000000,
          "type": [
            "integer",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "bytes",
            "docs::human_name": "Max Bytes"
          }
        },
        "max_events": {
          "description": "The maximum size of a batch before it is flushed.",
          "default": null,
          "type": [
            "integer",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "events",
            "docs::human_name": "Max Events"
          }
        },
        "timeout_secs": {
          "description": "The maximum age of a batch before it is flushed.",
          "default": 300.0,
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0,
          "_metadata": {
            "docs::numeric_type": "float",
            "docs::optional": true,
            "docs::type_unit": "seconds",
            "docs::human_name": "Timeout"
          }
        }
      },
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::advanced": true
      }
    },
    "vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::RealtimeSizeBasedDefaultBatchSettings>": {
      "description": "Event batching behavior.",
      "type": "object",
      "properties": {
        "max_bytes": {
          "title": "The maximum size of a batch that is processed by a sink.",
          "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
          "default": 10000000,
          "type": [
            "integer",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "bytes",
            "docs::human_name": "Max Bytes"
          }
        },
        "max_events": {
          "description": "The maximum size of a batch before it is flushed.",
          "default": null,
          "type": [
            "integer",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "events",
            "docs::human_name": "Max Events"
          }
        },
        "timeout_secs": {
          "description": "The maximum age of a batch before it is flushed.",
          "default": 1.0,
          "type": [
            "number",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": -9007199254740991.0,
          "_metadata": {
            "docs::numeric_type": "float",
            "docs::optional": true,
            "docs::type_unit": "seconds",
            "docs::human_name": "Timeout"
          }
        }
      },
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::advanced": true
      }
    },
    "vector::sinks::util::buffer::compression::Compression": {
      "title": "Compression configuration.",
      "description": "All compression algorithms use the default compression level unless otherwise specified.",
      "oneOf": [
        {
          "description": "Compression algorithm.",
          "oneOf": [
            {
              "description": "No compression.",
              "const": "none",
              "_metadata": {
                "logical_name": "None",
                "docs::human_name": "None"
              }
            },
            {
              "title": "[Gzip][gzip] compression.",
              "description": "[gzip]: https://www.gzip.org/",
              "const": "gzip",
              "_metadata": {
                "logical_name": "Gzip",
                "docs::human_name": "Gzip"
              }
            },
            {
              "title": "[Zlib][zlib] compression.",
              "description": "[zlib]: https://zlib.net/",
              "const": "zlib",
              "_metadata": {
                "logical_name": "Zlib",
                "docs::human_name": "Zlib"
              }
            },
            {
              "title": "[Zstandard][zstd] compression.",
              "description": "[zstd]: https://facebook.github.io/zstd/",
              "const": "zstd",
              "_metadata": {
                "logical_name": "Zstd",
                "docs::human_name": "Zstd"
              }
            }
          ],
          "_metadata": {
            "docs::enum_tagging": "external"
          }
        },
        {
          "description": "Compression algorithm and compression level.",
          "type": "object",
          "required": [
            "algorithm"
          ],
          "properties": {
            "algorithm": {
              "description": "Compression algorithm.",
              "oneOf": [
                {
                  "description": "No compression.",
                  "const": "none",
                  "_metadata": {
                    "logical_name": "None",
                    "docs::human_name": "None"
                  }
                },
                {
                  "title": "[Gzip][gzip] compression.",
                  "description": "[gzip]: https://www.gzip.org/",
                  "const": "gzip",
                  "_metadata": {
                    "logical_name": "Gzip",
                    "docs::human_name": "Gzip"
                  }
                },
                {
                  "title": "[Zlib][zlib] compression.",
                  "description": "[zlib]: https://zlib.net/",
                  "const": "zlib",
                  "_metadata": {
                    "logical_name": "Zlib",
                    "docs::human_name": "Zlib"
                  }
                },
                {
                  "title": "[Zstandard][zstd] compression.",
                  "description": "[zstd]: https://facebook.github.io/zstd/",
                  "const": "zstd",
                  "_metadata": {
                    "logical_name": "Zstd",
                    "docs::human_name": "Zstd"
                  }
                }
              ],
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::enum_tagging": "external",
                "docs::human_name": "Algorithm"
              }
            },
            "level": {
              "description": "Compression level.",
              "enum": [
                "none",
                "fast",
                "best",
                "default",
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21
              ],
              "_metadata": {
                "docs::human_name": "Level"
              }
            }
          },
          "_metadata": {
            "docs::hidden": true
          }
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::enum_tagging": "external",
        "docs::advanced": true
      }
    },
    "vector::sinks::util::http::RequestConfig": {
      "description": "Outbound HTTP request settings.",
      "allOf": [
        {
          "type": "object",
          "properties": {
            "headers": {
              "description": "Additional HTTP headers to add to every HTTP request.",
              "default": {},
              "type": "object",
              "additionalProperties": {
                "type": "string"
              },
              "_metadata": {
                "docs::additional_props_description": "An HTTP request header and it's value.",
                "docs::examples": {
                  "Accept": "text/plain",
                  "X-My-Custom-Header": "A-Value"
                },
                "docs::human_name": "Headers"
              }
            }
          }
        },
        {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "type": "object",
          "properties": {
            "adaptive_concurrency": {
              "title": "Configuration of adaptive concurrency parameters.",
              "description": "These parameters typically do not require changes from the default, and incorrect values can lead to meta-stable or\nunstable performance and sink behavior. Proceed with caution.",
              "default": {
                "initial_concurrency": 1,
                "decrease_ratio": 0.9,
                "ewma_alpha": 0.4,
                "rtt_deviation_scale": 2.5
              },
              "type": "object",
              "properties": {
                "decrease_ratio": {
                  "title": "The fraction of the current value to set the new concurrency limit when decreasing the limit.",
                  "description": "Valid values are greater than `0` and less than `1`. Smaller values cause the algorithm to scale back rapidly\nwhen latency increases.\n\nNote that the new limit is rounded down after applying this ratio.",
                  "default": 0.9,
                  "type": "number",
                  "maximum": 1.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "float",
                    "docs::human_name": "Decrease Ratio"
                  }
                },
                "ewma_alpha": {
                  "title": "The weighting of new measurements compared to older measurements.",
                  "description": "Valid values are greater than `0` and less than `1`.\n\nARC uses an exponentially weighted moving average (EWMA) of past RTT measurements as a reference to compare with\nthe current RTT. Smaller values cause this reference to adjust more slowly, which may be useful if a service has\nunusually high response variability.",
                  "default": 0.4,
                  "type": "number",
                  "maximum": 1.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "float",
                    "docs::human_name": "EWMA Alpha"
                  }
                },
                "initial_concurrency": {
                  "title": "The initial concurrency limit to use. If not specified, the initial limit will be 1 (no concurrency).",
                  "description": "It is recommended to set this value to your service's average limit if you're seeing that it takes a\nlong time to ramp up adaptive concurrency after a restart. You can find this value by looking at the\n`adaptive_concurrency_limit` metric.",
                  "default": 1,
                  "type": "integer",
                  "maximum": 200.0,
                  "minimum": 1.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::human_name": "Initial Concurrency"
                  }
                },
                "rtt_deviation_scale": {
                  "title": "Scale of RTT deviations which are not considered anomalous.",
                  "description": "Valid values are greater than or equal to `0`, and we expect reasonable values to range from `1.0` to `3.0`.\n\nWhen calculating the past RTT average, we also compute a secondary “deviation” value that indicates how variable\nthose values are. We use that deviation when comparing the past RTT average to the current measurements, so we\ncan ignore increases in RTT that are within an expected range. This factor is used to scale up the deviation to\nan appropriate range.  Larger values cause the algorithm to ignore larger increases in the RTT.",
                  "default": 2.5,
                  "type": "number",
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "float",
                    "docs::human_name": "RTT Deviation Scale"
                  }
                }
              },
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::human_name": "Adaptive Concurrency"
              }
            },
            "concurrency": {
              "description": "Configuration for outbound request concurrency.",
              "default": "none",
              "oneOf": [
                {
                  "title": "A fixed concurrency of 1.",
                  "description": "Only one request can be outstanding at any given time.",
                  "const": "none",
                  "_metadata": {
                    "logical_name": "None",
                    "docs::human_name": "None"
                  }
                },
                {
                  "title": "Concurrency will be managed by Vector's [Adaptive Request Concurrency][arc] feature.",
                  "description": "[arc]: https://vector.dev/docs/about/under-the-hood/networking/arc/",
                  "const": "adaptive",
                  "_metadata": {
                    "logical_name": "Adaptive",
                    "docs::human_name": "Adaptive"
                  }
                },
                {
                  "description": "A fixed amount of concurrency will be allowed.",
                  "type": "integer",
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "logical_name": "Fixed",
                    "docs::human_name": "Fixed"
                  }
                }
              ],
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::enum_tagging": "external",
                "docs::human_name": "Concurrency"
              }
            },
            "rate_limit_duration_secs": {
              "description": "The time window used for the `rate_limit_num` option.",
              "default": 1,
              "type": [
                "integer",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "seconds",
                "docs::human_name": "Rate Limit Duration"
              }
            },
            "rate_limit_num": {
              "description": "The maximum number of requests allowed within the `rate_limit_duration_secs` time window.",
              "default": 9223372036854775807,
              "type": [
                "integer",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "requests",
                "docs::human_name": "Rate Limit Number"
              }
            },
            "retry_attempts": {
              "title": "The maximum number of retries to make for failed requests.",
              "description": "The default, for all intents and purposes, represents an infinite number of retries.",
              "default": 9223372036854775807,
              "type": [
                "integer",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "retries",
                "docs::human_name": "Retry Attempts"
              }
            },
            "retry_initial_backoff_secs": {
              "title": "The amount of time to wait before attempting the first retry for a failed request.",
              "description": "After the first retry has failed, the fibonacci sequence is used to select future backoffs.",
              "default": 1,
              "type": [
                "integer",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "seconds",
                "docs::human_name": "Retry Initial Backoff"
              }
            },
            "retry_max_duration_secs": {
              "description": "The maximum amount of time to wait between retries.",
              "default": 3600,
              "type": [
                "integer",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "seconds",
                "docs::human_name": "Max Retry Duration"
              }
            },
            "timeout_secs": {
              "title": "The time a request can take before being aborted.",
              "description": "Datadog highly recommends that you do not lower this value below the service's internal timeout, as this could\ncreate orphaned requests, pile on retries, and result in duplicate data downstream.",
              "default": 60,
              "type": [
                "integer",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "seconds",
                "docs::human_name": "Timeout"
              }
            }
          },
          "_metadata": {
            "docs::advanced": true
          }
        }
      ],
      "unevaluatedProperties": false
    },
    "vector::sinks::util::service::TowerRequestConfig": {
      "title": "Middleware settings for outbound requests.",
      "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
      "type": "object",
      "properties": {
        "adaptive_concurrency": {
          "title": "Configuration of adaptive concurrency parameters.",
          "description": "These parameters typically do not require changes from the default, and incorrect values can lead to meta-stable or\nunstable performance and sink behavior. Proceed with caution.",
          "default": {
            "initial_concurrency": 1,
            "decrease_ratio": 0.9,
            "ewma_alpha": 0.4,
            "rtt_deviation_scale": 2.5
          },
          "type": "object",
          "properties": {
            "decrease_ratio": {
              "title": "The fraction of the current value to set the new concurrency limit when decreasing the limit.",
              "description": "Valid values are greater than `0` and less than `1`. Smaller values cause the algorithm to scale back rapidly\nwhen latency increases.\n\nNote that the new limit is rounded down after applying this ratio.",
              "default": 0.9,
              "type": "number",
              "maximum": 1.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "float",
                "docs::human_name": "Decrease Ratio"
              }
            },
            "ewma_alpha": {
              "title": "The weighting of new measurements compared to older measurements.",
              "description": "Valid values are greater than `0` and less than `1`.\n\nARC uses an exponentially weighted moving average (EWMA) of past RTT measurements as a reference to compare with\nthe current RTT. Smaller values cause this reference to adjust more slowly, which may be useful if a service has\nunusually high response variability.",
              "default": 0.4,
              "type": "number",
              "maximum": 1.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "float",
                "docs::human_name": "EWMA Alpha"
              }
            },
            "initial_concurrency": {
              "title": "The initial concurrency limit to use. If not specified, the initial limit will be 1 (no concurrency).",
              "description": "It is recommended to set this value to your service's average limit if you're seeing that it takes a\nlong time to ramp up adaptive concurrency after a restart. You can find this value by looking at the\n`adaptive_concurrency_limit` metric.",
              "default": 1,
              "type": "integer",
              "maximum": 200.0,
              "minimum": 1.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::human_name": "Initial Concurrency"
              }
            },
            "rtt_deviation_scale": {
              "title": "Scale of RTT deviations which are not considered anomalous.",
              "description": "Valid values are greater than or equal to `0`, and we expect reasonable values to range from `1.0` to `3.0`.\n\nWhen calculating the past RTT average, we also compute a secondary “deviation” value that indicates how variable\nthose values are. We use that deviation when comparing the past RTT average to the current measurements, so we\ncan ignore increases in RTT that are within an expected range. This factor is used to scale up the deviation to\nan appropriate range.  Larger values cause the algorithm to ignore larger increases in the RTT.",
              "default": 2.5,
              "type": "number",
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "float",
                "docs::human_name": "RTT Deviation Scale"
              }
            }
          },
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::human_name": "Adaptive Concurrency"
          }
        },
        "concurrency": {
          "description": "Configuration for outbound request concurrency.",
          "default": "none",
          "oneOf": [
            {
              "title": "A fixed concurrency of 1.",
              "description": "Only one request can be outstanding at any given time.",
              "const": "none",
              "_metadata": {
                "logical_name": "None",
                "docs::human_name": "None"
              }
            },
            {
              "title": "Concurrency will be managed by Vector's [Adaptive Request Concurrency][arc] feature.",
              "description": "[arc]: https://vector.dev/docs/about/under-the-hood/networking/arc/",
              "const": "adaptive",
              "_metadata": {
                "logical_name": "Adaptive",
                "docs::human_name": "Adaptive"
              }
            },
            {
              "description": "A fixed amount of concurrency will be allowed.",
              "type": "integer",
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "logical_name": "Fixed",
                "docs::human_name": "Fixed"
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::enum_tagging": "external",
            "docs::human_name": "Concurrency"
          }
        },
        "rate_limit_duration_secs": {
          "description": "The time window used for the `rate_limit_num` option.",
          "default": 1,
          "type": [
            "integer",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "seconds",
            "docs::human_name": "Rate Limit Duration"
          }
        },
        "rate_limit_num": {
          "description": "The maximum number of requests allowed within the `rate_limit_duration_secs` time window.",
          "default": 9223372036854775807,
          "type": [
            "integer",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "requests",
            "docs::human_name": "Rate Limit Number"
          }
        },
        "retry_attempts": {
          "title": "The maximum number of retries to make for failed requests.",
          "description": "The default, for all intents and purposes, represents an infinite number of retries.",
          "default": 9223372036854775807,
          "type": [
            "integer",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "retries",
            "docs::human_name": "Retry Attempts"
          }
        },
        "retry_initial_backoff_secs": {
          "title": "The amount of time to wait before attempting the first retry for a failed request.",
          "description": "After the first retry has failed, the fibonacci sequence is used to select future backoffs.",
          "default": 1,
          "type": [
            "integer",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "seconds",
            "docs::human_name": "Retry Initial Backoff"
          }
        },
        "retry_max_duration_secs": {
          "description": "The maximum amount of time to wait between retries.",
          "default": 3600,
          "type": [
            "integer",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "seconds",
            "docs::human_name": "Max Retry Duration"
          }
        },
        "timeout_secs": {
          "title": "The time a request can take before being aborted.",
          "description": "Datadog highly recommends that you do not lower this value below the service's internal timeout, as this could\ncreate orphaned requests, pile on retries, and result in duplicate data downstream.",
          "default": 60,
          "type": [
            "integer",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "seconds",
            "docs::human_name": "Timeout"
          }
        }
      },
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::advanced": true
      }
    },
    "vector::sinks::util::service::net::HostAndPort": {
      "title": "The address to connect to.",
      "description": "Both IP addresses and hostnames/fully qualified domain names (FQDNs) are accepted formats.\n\nThe address _must_ include a port.",
      "type": "string",
      "_metadata": {
        "docs::examples": [
          "92.12.333.224:5000",
          "somehost:5000"
        ]
      }
    },
    "vector::sinks::util::uri::UriSerde": {
      "title": "The URI component of a request.",
      "description": "",
      "type": "string"
    },
    "vector::sinks::vector::config::VectorConfig": {
      "description": "Configuration for the `vector` sink.",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled for this sink.",
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "address": {
          "title": "The downstream Vector address to which to connect.",
          "description": "Both IP address and hostname are accepted formats.\n\nThe address _must_ include a port.",
          "type": "string",
          "format": "uri",
          "_metadata": {
            "docs::examples": [
              "92.12.333.224:6000",
              "https://somehost:6000"
            ],
            "docs::human_name": "Address"
          }
        },
        "batch": {
          "description": "Event batching behavior.",
          "default": {
            "max_bytes": null,
            "max_events": null,
            "timeout_secs": null
          },
          "type": "object",
          "properties": {
            "max_bytes": {
              "title": "The maximum size of a batch that is processed by a sink.",
              "description": "This is based on the uncompressed size of the batched events, before they are\nserialized/compressed.",
              "default": null,
              "type": [
                "integer",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "bytes",
                "docs::human_name": "Max Bytes"
              }
            },
            "max_events": {
              "description": "The maximum size of a batch before it is flushed.",
              "default": 1000,
              "type": [
                "integer",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::type_unit": "events",
                "docs::human_name": "Max Events"
              }
            },
            "timeout_secs": {
              "description": "The maximum age of a batch before it is flushed.",
              "default": 1.0,
              "type": [
                "number",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": -9007199254740991.0,
              "_metadata": {
                "docs::numeric_type": "float",
                "docs::optional": true,
                "docs::type_unit": "seconds",
                "docs::human_name": "Timeout"
              }
            }
          },
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Batch"
          }
        },
        "compression": {
          "title": "Whether or not to compress requests.",
          "description": "If set to `true`, requests are compressed with [`gzip`][gzip_docs].\n\n[gzip_docs]: https://www.gzip.org/",
          "default": false,
          "type": "boolean",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Compression"
          }
        },
        "request": {
          "title": "Middleware settings for outbound requests.",
          "description": "Various settings can be configured, such as concurrency and rate limits, timeouts, etc.",
          "default": {
            "timeout_secs": 60,
            "rate_limit_duration_secs": 1,
            "rate_limit_num": 9223372036854775807,
            "retry_attempts": 9223372036854775807,
            "retry_max_duration_secs": 3600,
            "retry_initial_backoff_secs": 1,
            "adaptive_concurrency": {
              "initial_concurrency": 1,
              "decrease_ratio": 0.9,
              "ewma_alpha": 0.4,
              "rtt_deviation_scale": 2.5
            }
          },
          "$ref": "#/definitions/vector::sinks::util::service::TowerRequestConfig",
          "_metadata": {
            "docs::human_name": "Request"
          }
        },
        "tls": {
          "default": null,
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        },
        "version": {
          "description": "Version of the configuration.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "description": "Marker type for the version two of the configuration for the `vector` sink.",
              "oneOf": [
                {
                  "description": "Marker value for version two.",
                  "const": "2",
                  "_metadata": {
                    "logical_name": "V2",
                    "docs::human_name": "V2"
                  }
                }
              ],
              "_metadata": {
                "docs::enum_tagging": "external"
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::hidden": true,
            "docs::optional": true,
            "docs::human_name": "Version"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "vector"
      }
    },
    "vector::sinks::webhdfs::config::WebHdfsConfig": {
      "description": "Configuration for the `webhdfs` sink.",
      "allOf": [
        {
          "type": "object",
          "properties": {
            "acknowledgements": {
              "title": "Controls how acknowledgements are handled for this sink.",
              "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              }
            },
            "batch": {
              "description": "Event batching behavior.",
              "default": {
                "max_bytes": null,
                "max_events": null,
                "timeout_secs": null
              },
              "$ref": "#/definitions/vector::sinks::util::batch::BatchConfig<vector::sinks::util::batch::BulkSizeBasedDefaultBatchSettings>",
              "_metadata": {
                "docs::human_name": "Batch"
              }
            },
            "compression": {
              "title": "Compression configuration.",
              "description": "All compression algorithms use the default compression level unless otherwise specified.",
              "default": "gzip",
              "$ref": "#/definitions/vector::sinks::util::buffer::compression::Compression",
              "_metadata": {
                "docs::human_name": "Compression"
              }
            },
            "endpoint": {
              "title": "An HDFS cluster consists of a single NameNode, a master server that manages the file system namespace and regulates access to files by clients.",
              "description": "The endpoint is the HDFS's web restful HTTP API endpoint.\n\nFor more information, see the [HDFS Architecture][hdfs_arch] documentation.\n\n[hdfs_arch]: https://hadoop.apache.org/docs/r3.3.4/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html#NameNode_and_DataNodes",
              "default": "",
              "type": "string",
              "_metadata": {
                "docs::examples": "http://127.0.0.1:9870",
                "docs::human_name": "Endpoint"
              }
            },
            "prefix": {
              "title": "A prefix to apply to all keys.",
              "description": "Prefixes are useful for partitioning objects, such as by creating a blob key that\nstores blobs under a particular directory. If using a prefix for this purpose, it must end\nin `/` to act as a directory path. A trailing `/` is **not** automatically added.\n\nThe final file path is in the format of `{root}/{prefix}{suffix}`.",
              "default": "",
              "type": "string",
              "_metadata": {
                "docs::templateable": true,
                "docs::human_name": "Prefix"
              }
            },
            "root": {
              "title": "The root path for WebHDFS.",
              "description": "Must be a valid directory.\n\nThe final file path is in the format of `{root}/{prefix}{suffix}`.",
              "default": "",
              "type": "string",
              "_metadata": {
                "docs::human_name": "Root"
              }
            }
          }
        },
        {
          "description": "Encoding configuration.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfigWithFraming"
        }
      ],
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "webhdfs"
      }
    },
    "vector::sinks::websocket::config::WebSocketSinkConfig": {
      "description": "Configuration for the `websocket` sink.",
      "type": "object",
      "required": [
        "encoding",
        "uri"
      ],
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled for this sink.",
          "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::AcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "auth": {
          "$ref": "#/definitions/core::option::Option<vector::http::Auth>",
          "_metadata": {
            "docs::human_name": "Auth"
          }
        },
        "encoding": {
          "description": "Configures how events are encoded into raw bytes.",
          "$ref": "#/definitions/vector::codecs::encoding::config::EncodingConfig",
          "_metadata": {
            "docs::human_name": "Encoding"
          }
        },
        "ping_interval": {
          "title": "The interval, in seconds, between sending [Ping][ping]s to the remote peer.",
          "description": "If this option is not configured, pings are not sent on an interval.\n\nIf the `ping_timeout` is not set, pings are still sent but there is no expectation of pong\nresponse times.\n\n[ping]: https://www.rfc-editor.org/rfc/rfc6455#section-5.5.2",
          "type": [
            "integer",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 1.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "seconds",
            "docs::human_name": "Ping Interval"
          }
        },
        "ping_timeout": {
          "title": "The number of seconds to wait for a [Pong][pong] response from the remote peer.",
          "description": "If a response is not received within this time, the connection is re-established.\n\n[pong]: https://www.rfc-editor.org/rfc/rfc6455#section-5.5.3",
          "type": [
            "integer",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 1.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "seconds",
            "docs::human_name": "Ping Timeout"
          }
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        },
        "uri": {
          "title": "The WebSocket URI to connect to.",
          "description": "This should include the protocol and host, but can also include the port, path, and any other valid part of a URI.",
          "type": "string",
          "_metadata": {
            "docs::human_name": "URI"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "sink",
        "docs::component_name": "websocket"
      }
    },
    "vector::sources::Sources": {
      "description": "Configurable sources in Vector.",
      "oneOf": [
        {
          "description": "Collect events from AMQP 0.9.1 compatible brokers like RabbitMQ.",
          "allOf": [
            {
              "title": "Configuration for the `amqp` source.",
              "description": "Supports AMQP version 0.9.1",
              "$ref": "#/definitions/vector::sources::amqp::AmqpSourceConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Collect events from AMQP 0.9.1 compatible brokers like RabbitMQ.",
                  "const": "amqp",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "AMQP",
            "logical_name": "AmqpSource"
          }
        },
        {
          "description": "Collect metrics from Apache's HTTPD server.",
          "allOf": [
            {
              "description": "Configuration for the `apache_metrics` source.",
              "$ref": "#/definitions/vector::sources::apache_metrics::ApacheMetricsConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Collect metrics from Apache's HTTPD server.",
                  "const": "apache_metrics",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Apache Metrics",
            "logical_name": "ApacheMetrics"
          }
        },
        {
          "description": "Collect Docker container stats for tasks running in AWS ECS and AWS Fargate.",
          "allOf": [
            {
              "description": "Configuration for the `aws_ecs_metrics` source.",
              "$ref": "#/definitions/vector::sources::aws_ecs_metrics::AwsEcsMetricsSourceConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Collect Docker container stats for tasks running in AWS ECS and AWS Fargate.",
                  "const": "aws_ecs_metrics",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "AWS ECS Metrics",
            "logical_name": "AwsEcsMetricsSource"
          }
        },
        {
          "description": "Collect logs from AWS Kinesis Firehose.",
          "allOf": [
            {
              "description": "Configuration for the `aws_kinesis_firehose` source.",
              "$ref": "#/definitions/vector::sources::aws_kinesis_firehose::AwsKinesisFirehoseConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Collect logs from AWS Kinesis Firehose.",
                  "const": "aws_kinesis_firehose",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "AWS Kinesis Firehose",
            "logical_name": "AwsKinesisFirehose"
          }
        },
        {
          "description": "Collect logs from AWS S3.",
          "allOf": [
            {
              "description": "Configuration for the `aws_s3` source.",
              "$ref": "#/definitions/vector::sources::aws_s3::AwsS3Config"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Collect logs from AWS S3.",
                  "const": "aws_s3",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "AWS S3",
            "logical_name": "AwsS3"
          }
        },
        {
          "description": "Collect logs from AWS SQS.",
          "allOf": [
            {
              "description": "Configuration for the `aws_sqs` source.",
              "$ref": "#/definitions/vector::sources::aws_sqs::config::AwsSqsConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Collect logs from AWS SQS.",
                  "const": "aws_sqs",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "AWS SQS",
            "logical_name": "AwsSqs"
          }
        },
        {
          "description": "Receive logs, metrics, and traces collected by a Datadog Agent.",
          "allOf": [
            {
              "description": "Configuration for the `datadog_agent` source.",
              "$ref": "#/definitions/vector::sources::datadog_agent::DatadogAgentConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Receive logs, metrics, and traces collected by a Datadog Agent.",
                  "const": "datadog_agent",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Datadog Agent",
            "logical_name": "DatadogAgent"
          }
        },
        {
          "description": "Generate fake log events, which can be useful for testing and demos.",
          "allOf": [
            {
              "description": "Configuration for the `demo_logs` source.",
              "$ref": "#/definitions/vector::sources::demo_logs::DemoLogsConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Generate fake log events, which can be useful for testing and demos.",
                  "const": "demo_logs",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Demo Logs",
            "logical_name": "DemoLogs"
          }
        },
        {
          "description": "Collect DNS logs from a dnstap-compatible server.",
          "allOf": [
            {
              "description": "Configuration for the `dnstap` source.",
              "$ref": "#/definitions/vector::sources::dnstap::DnstapConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Collect DNS logs from a dnstap-compatible server.",
                  "const": "dnstap",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Dnstap",
            "logical_name": "Dnstap"
          }
        },
        {
          "description": "Collect container logs from a Docker Daemon.",
          "allOf": [
            {
              "description": "Configuration for the `docker_logs` source.",
              "$ref": "#/definitions/vector::sources::docker_logs::DockerLogsConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Collect container logs from a Docker Daemon.",
                  "const": "docker_logs",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Docker Logs",
            "logical_name": "DockerLogs"
          }
        },
        {
          "description": "Receive metrics from collected by a EventStoreDB.",
          "allOf": [
            {
              "description": "Configuration for the `eventstoredb_metrics` source.",
              "$ref": "#/definitions/vector::sources::eventstoredb_metrics::EventStoreDbConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Receive metrics from collected by a EventStoreDB.",
                  "const": "eventstoredb_metrics",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "EventStoreDB Metrics",
            "logical_name": "EventStoreDb"
          }
        },
        {
          "description": "Collect output from a process running on the host.",
          "allOf": [
            {
              "description": "Configuration for the `exec` source.",
              "$ref": "#/definitions/vector::sources::exec::ExecConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Collect output from a process running on the host.",
                  "const": "exec",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Exec",
            "logical_name": "Exec"
          }
        },
        {
          "description": "Collect logs from files.",
          "allOf": [
            {
              "description": "Configuration for the `file` source.",
              "$ref": "#/definitions/vector::sources::file::FileConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Collect logs from files.",
                  "const": "file",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "File",
            "logical_name": "File"
          }
        },
        {
          "description": "Collect logs from a file descriptor.",
          "allOf": [
            {
              "description": "Configuration for the `file_descriptor` source.",
              "$ref": "#/definitions/vector::sources::file_descriptors::file_descriptor::FileDescriptorSourceConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Collect logs from a file descriptor.",
                  "const": "file_descriptor",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "File Descriptor",
            "logical_name": "FileDescriptorSource"
          }
        },
        {
          "description": "Collect logs from a Fluentd or Fluent Bit agent.",
          "allOf": [
            {
              "description": "Configuration for the `fluent` source.",
              "$ref": "#/definitions/vector::sources::fluent::FluentConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Collect logs from a Fluentd or Fluent Bit agent.",
                  "const": "fluent",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Fluent",
            "logical_name": "Fluent"
          }
        },
        {
          "description": "Fetch observability events from GCP's Pub/Sub messaging system.",
          "allOf": [
            {
              "description": "Configuration for the `gcp_pubsub` source.",
              "$ref": "#/definitions/vector::sources::gcp_pubsub::PubsubConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Fetch observability events from GCP's Pub/Sub messaging system.",
                  "const": "gcp_pubsub",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "GCP Pub/Sub",
            "logical_name": "Pubsub"
          }
        },
        {
          "description": "Collect logs from Heroku's Logplex, the router responsible for receiving logs from your Heroku apps.",
          "allOf": [
            {
              "description": "Configuration for `heroku_logs` source.",
              "$ref": "#/definitions/vector::sources::heroku_logs::LogplexConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Collect logs from Heroku's Logplex, the router responsible for receiving logs from your Heroku apps.",
                  "const": "heroku_logs",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Heroku Logs",
            "logical_name": "Logplex"
          }
        },
        {
          "description": "Collect metric data from the local system.",
          "allOf": [
            {
              "description": "Configuration for the `host_metrics` source.",
              "$ref": "#/definitions/vector::sources::host_metrics::HostMetricsConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Collect metric data from the local system.",
                  "const": "host_metrics",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Host Metrics",
            "logical_name": "HostMetrics"
          }
        },
        {
          "description": "Host an HTTP endpoint to receive logs.",
          "allOf": [
            {
              "description": "Configuration for the `http` source.",
              "$ref": "#/definitions/vector::sources::http_server::HttpConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Host an HTTP endpoint to receive logs.",
                  "const": "http",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "HTTP",
            "logical_name": "Http"
          }
        },
        {
          "description": "Pull observability data from an HTTP server at a configured interval.",
          "allOf": [
            {
              "description": "Configuration for the `http_client` source.",
              "$ref": "#/definitions/vector::sources::http_client::client::HttpClientConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Pull observability data from an HTTP server at a configured interval.",
                  "const": "http_client",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "HTTP Client",
            "logical_name": "HttpClient"
          }
        },
        {
          "description": "Host an HTTP endpoint to receive logs.",
          "allOf": [
            {
              "description": "Configuration for the `http_server` source.",
              "$ref": "#/definitions/vector::sources::http_server::SimpleHttpConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Host an HTTP endpoint to receive logs.",
                  "const": "http_server",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "HTTP Server",
            "logical_name": "SimpleHttp"
          }
        },
        {
          "description": "Expose internal log messages emitted by the running Vector instance.",
          "allOf": [
            {
              "description": "Configuration for the `internal_logs` source.",
              "$ref": "#/definitions/vector::sources::internal_logs::InternalLogsConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Expose internal log messages emitted by the running Vector instance.",
                  "const": "internal_logs",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Internal Logs",
            "logical_name": "InternalLogs"
          }
        },
        {
          "description": "Expose internal metrics emitted by the running Vector instance.",
          "allOf": [
            {
              "description": "Configuration for the `internal_metrics` source.",
              "$ref": "#/definitions/vector::sources::internal_metrics::InternalMetricsConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Expose internal metrics emitted by the running Vector instance.",
                  "const": "internal_metrics",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Internal Metrics",
            "logical_name": "InternalMetrics"
          }
        },
        {
          "description": "Collect logs from JournalD.",
          "allOf": [
            {
              "description": "Configuration for the `journald` source.",
              "$ref": "#/definitions/vector::sources::journald::JournaldConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Collect logs from JournalD.",
                  "const": "journald",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "JournalD",
            "logical_name": "Journald"
          }
        },
        {
          "description": "Collect logs from Apache Kafka.",
          "allOf": [
            {
              "description": "Configuration for the `kafka` source.",
              "$ref": "#/definitions/vector::sources::kafka::KafkaSourceConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Collect logs from Apache Kafka.",
                  "const": "kafka",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Kafka",
            "logical_name": "KafkaSource"
          }
        },
        {
          "description": "Collect Pod logs from Kubernetes Nodes.",
          "allOf": [
            {
              "description": "Configuration for the `kubernetes_logs` source.",
              "$ref": "#/definitions/vector::sources::kubernetes_logs::Config"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Collect Pod logs from Kubernetes Nodes.",
                  "const": "kubernetes_logs",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Kubernetes Logs",
            "logical_name": ""
          }
        },
        {
          "description": "Collect logs from a Logstash agent.",
          "allOf": [
            {
              "description": "Configuration for the `logstash` source.",
              "$ref": "#/definitions/vector::sources::logstash::LogstashConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Collect logs from a Logstash agent.",
                  "const": "logstash",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Logstash",
            "logical_name": "Logstash"
          }
        },
        {
          "description": "Collect metrics from the MongoDB database.",
          "allOf": [
            {
              "description": "Configuration for the `mongodb_metrics` source.",
              "$ref": "#/definitions/vector::sources::mongodb_metrics::MongoDbMetricsConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Collect metrics from the MongoDB database.",
                  "const": "mongodb_metrics",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "MongoDB Metrics",
            "logical_name": "MongoDbMetrics"
          }
        },
        {
          "description": "Read observability data from subjects on the NATS messaging system.",
          "allOf": [
            {
              "description": "Configuration for the `nats` source.",
              "$ref": "#/definitions/vector::sources::nats::NatsSourceConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Read observability data from subjects on the NATS messaging system.",
                  "const": "nats",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "NATS",
            "logical_name": "NatsSource"
          }
        },
        {
          "description": "Collect metrics from NGINX.",
          "allOf": [
            {
              "description": "Configuration for the `nginx_metrics` source.",
              "$ref": "#/definitions/vector::sources::nginx_metrics::NginxMetricsConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Collect metrics from NGINX.",
                  "const": "nginx_metrics",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "NGINX Metrics",
            "logical_name": "NginxMetrics"
          }
        },
        {
          "description": "Receive OTLP data through gRPC or HTTP.",
          "allOf": [
            {
              "description": "Configuration for the `opentelemetry` source.",
              "$ref": "#/definitions/vector::sources::opentelemetry::OpentelemetryConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Receive OTLP data through gRPC or HTTP.",
                  "const": "opentelemetry",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "OpenTelemetry",
            "logical_name": "Opentelemetry"
          }
        },
        {
          "description": "Collect metrics from the PostgreSQL database.",
          "allOf": [
            {
              "description": "Configuration for the `postgresql_metrics` source.",
              "$ref": "#/definitions/vector::sources::postgresql_metrics::PostgresqlMetricsConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Collect metrics from the PostgreSQL database.",
                  "const": "postgresql_metrics",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "PostgreSQL Metrics",
            "logical_name": "PostgresqlMetrics"
          }
        },
        {
          "description": "Receive metric via the Prometheus Remote Write protocol.",
          "allOf": [
            {
              "description": "Configuration for the `prometheus_remote_write` source.",
              "$ref": "#/definitions/vector::sources::prometheus::remote_write::PrometheusRemoteWriteConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Receive metric via the Prometheus Remote Write protocol.",
                  "const": "prometheus_remote_write",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Prometheus Remote Write",
            "logical_name": "PrometheusRemoteWrite"
          }
        },
        {
          "description": "Collect metrics from Prometheus exporters.",
          "allOf": [
            {
              "description": "Configuration for the `prometheus_scrape` source.",
              "$ref": "#/definitions/vector::sources::prometheus::scrape::PrometheusScrapeConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Collect metrics from Prometheus exporters.",
                  "const": "prometheus_scrape",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Prometheus Scrape",
            "logical_name": "PrometheusScrape"
          }
        },
        {
          "description": "Collect observability data from Redis.",
          "allOf": [
            {
              "description": "Configuration for the `redis` source.",
              "$ref": "#/definitions/vector::sources::redis::RedisSourceConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Collect observability data from Redis.",
                  "const": "redis",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Redis",
            "logical_name": "RedisSource"
          }
        },
        {
          "description": "Collect logs over a socket.",
          "allOf": [
            {
              "description": "Configuration for the `socket` source.",
              "$ref": "#/definitions/vector::sources::socket::SocketConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Collect logs over a socket.",
                  "const": "socket",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Socket",
            "logical_name": "Socket"
          }
        },
        {
          "description": "Receive logs from Splunk.",
          "allOf": [
            {
              "description": "Configuration for the `splunk_hec` source.",
              "$ref": "#/definitions/vector::sources::splunk_hec::SplunkConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Receive logs from Splunk.",
                  "const": "splunk_hec",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Splunk HEC",
            "logical_name": "Splunk"
          }
        },
        {
          "description": "Collect metrics emitted by the StatsD aggregator.",
          "allOf": [
            {
              "description": "Configuration for the `statsd` source.",
              "$ref": "#/definitions/vector::sources::statsd::StatsdConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Collect metrics emitted by the StatsD aggregator.",
                  "const": "statsd",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "StatsD",
            "logical_name": "Statsd"
          }
        },
        {
          "description": "Collect logs sent via stdin.",
          "allOf": [
            {
              "description": "Configuration for the `stdin` source.",
              "$ref": "#/definitions/vector::sources::file_descriptors::stdin::StdinConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Collect logs sent via stdin.",
                  "const": "stdin",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Stdin",
            "logical_name": "Stdin"
          }
        },
        {
          "description": "Collect logs sent via Syslog.",
          "allOf": [
            {
              "description": "Configuration for the `syslog` source.",
              "$ref": "#/definitions/vector::sources::syslog::SyslogConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Collect logs sent via Syslog.",
                  "const": "syslog",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Syslog",
            "logical_name": "Syslog"
          }
        },
        {
          "description": "Unit test.",
          "allOf": [
            {
              "description": "Configuration for the `unit_test` source.",
              "$ref": "#/definitions/vector::config::unit_test::unit_test_components::UnitTestSourceConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Unit test.",
                  "const": "unit_test",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Unit Test",
            "logical_name": "UnitTestSource"
          }
        },
        {
          "description": "Unit test stream.",
          "allOf": [
            {
              "description": "Configuration for the `unit_test_stream` source.",
              "$ref": "#/definitions/vector::config::unit_test::unit_test_components::UnitTestStreamSourceConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Unit test stream.",
                  "const": "unit_test_stream",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Unit Test Stream",
            "logical_name": "UnitTestStreamSource"
          }
        },
        {
          "description": "Collect observability data from a Vector instance.",
          "allOf": [
            {
              "description": "Configuration for the `vector` source.",
              "$ref": "#/definitions/vector::sources::vector::VectorConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Collect observability data from a Vector instance.",
                  "const": "vector",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Vector",
            "logical_name": "Vector"
          }
        }
      ],
      "_metadata": {
        "docs::enum_tagging": "internal",
        "docs::enum_tag_field": "type"
      }
    },
    "vector::sources::amqp::AmqpSourceConfig": {
      "title": "Configuration for the `amqp` source.",
      "description": "Supports AMQP version 0.9.1",
      "allOf": [
        {
          "type": "object",
          "properties": {
            "acknowledgements": {
              "title": "Controls how acknowledgements are handled by this source.",
              "description": "This setting is **deprecated** in favor of enabling `acknowledgements` at the [global][global_acks] or sink level.\n\nEnabling or disabling acknowledgements at the source level has **no effect** on acknowledgement behavior.\n\nSee [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::SourceAcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              }
            },
            "consumer": {
              "description": "The identifier for the consumer.",
              "default": "vector",
              "type": "string",
              "_metadata": {
                "docs::examples": "consumer-group-name",
                "docs::human_name": "Consumer"
              }
            },
            "decoding": {
              "description": "Configures how events are decoded from raw bytes.",
              "default": {
                "codec": "bytes"
              },
              "$ref": "#/definitions/codecs::decoding::DeserializerConfig",
              "_metadata": {
                "docs::human_name": "Decoding"
              }
            },
            "exchange_key": {
              "description": "The `AMQP` exchange key.",
              "default": "exchange",
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
              "_metadata": {
                "docs::human_name": "Exchange Key"
              }
            },
            "framing": {
              "title": "Framing configuration.",
              "description": "Framing handles how events are separated when encoded in a raw byte form, where each event is\na frame that must be prefixed, or delimited, in a way that marks where an event begins and\nends within the byte stream.",
              "default": {
                "method": "bytes"
              },
              "$ref": "#/definitions/codecs::decoding::FramingConfig",
              "_metadata": {
                "docs::human_name": "Framing"
              }
            },
            "log_namespace": {
              "description": "The namespace to use for logs. This overrides the global setting.",
              "default": null,
              "type": [
                "boolean",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::hidden": true,
                "docs::human_name": "Log Namespace"
              }
            },
            "offset_key": {
              "description": "The `AMQP` offset key.",
              "default": "offset",
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
              "_metadata": {
                "docs::human_name": "Offset Key"
              }
            },
            "queue": {
              "description": "The name of the queue to consume.",
              "default": "vector",
              "type": "string",
              "_metadata": {
                "docs::human_name": "Queue"
              }
            },
            "routing_key_field": {
              "description": "The `AMQP` routing key.",
              "default": "routing",
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
              "_metadata": {
                "docs::human_name": "Routing Key Field"
              }
            }
          }
        },
        {
          "description": "AMQP connection options.",
          "$ref": "#/definitions/vector::amqp::AmqpConfig"
        }
      ],
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "amqp"
      }
    },
    "vector::sources::apache_metrics::ApacheMetricsConfig": {
      "description": "Configuration for the `apache_metrics` source.",
      "type": "object",
      "required": [
        "endpoints"
      ],
      "properties": {
        "endpoints": {
          "description": "The list of `mod_status` endpoints to scrape metrics from.",
          "type": "array",
          "items": {
            "type": "string"
          },
          "_metadata": {
            "docs::examples": "http://localhost:8080/server-status/?auto",
            "docs::human_name": "Endpoints"
          }
        },
        "namespace": {
          "title": "The namespace of the metric.",
          "description": "Disabled if empty.",
          "default": "apache",
          "type": "string",
          "_metadata": {
            "docs::human_name": "Namespace"
          }
        },
        "scrape_interval_secs": {
          "description": "The interval between scrapes.",
          "default": 15,
          "$ref": "#/definitions/serde_with::DurationSeconds",
          "_metadata": {
            "docs::human_name": "Scrape Interval"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "apache_metrics"
      }
    },
    "vector::sources::aws_ecs_metrics::AwsEcsMetricsSourceConfig": {
      "description": "Configuration for the `aws_ecs_metrics` source.",
      "type": "object",
      "properties": {
        "endpoint": {
          "title": "Base URI of the task metadata endpoint.",
          "description": "If empty, the URI is automatically discovered based on the latest version detected.\n\nBy default:\n- The version 4 endpoint base URI is stored in the environment variable `ECS_CONTAINER_METADATA_URI_V4`.\n- The version 3 endpoint base URI is stored in the environment variable `ECS_CONTAINER_METADATA_URI`.\n- The version 2 endpoint base URI is `169.254.170.2/v2/`.",
          "default": "http://169.254.170.2/v2",
          "type": "string",
          "_metadata": {
            "docs::human_name": "Endpoint"
          }
        },
        "namespace": {
          "title": "The namespace of the metric.",
          "description": "Disabled if empty.",
          "default": "awsecs",
          "type": "string",
          "_metadata": {
            "docs::human_name": "Namespace"
          }
        },
        "scrape_interval_secs": {
          "description": "The interval between scrapes, in seconds.",
          "default": 15,
          "$ref": "#/definitions/serde_with::DurationSeconds",
          "_metadata": {
            "docs::human_name": "Scrape Interval"
          }
        },
        "version": {
          "title": "The version of the task metadata endpoint to use.",
          "description": "If empty, the version is automatically discovered based on environment variables.\n\nBy default:\n- Version 4 is used if the environment variable `ECS_CONTAINER_METADATA_URI_V4` is defined.\n- Version 3 is used if the environment variable `ECS_CONTAINER_METADATA_URI_V4` is not defined, but the\n  environment variable `ECS_CONTAINER_METADATA_URI` _is_ defined.\n- Version 2 is used if neither of the environment variables `ECS_CONTAINER_METADATA_URI_V4` or\n  `ECS_CONTAINER_METADATA_URI` are defined.",
          "default": "v2",
          "oneOf": [
            {
              "title": "Version 2.",
              "description": "More information about version 2 of the task metadata endpoint can be found [here][endpoint_v2].\n\n[endpoint_v2]: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-metadata-endpoint-v2.html",
              "const": "v2",
              "_metadata": {
                "logical_name": "V2",
                "docs::human_name": "V2"
              }
            },
            {
              "title": "Version 3.",
              "description": "More information about version 3 of the task metadata endpoint can be found [here][endpoint_v3].\n\n[endpoint_v3]: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-metadata-endpoint-v3.html",
              "const": "v3",
              "_metadata": {
                "logical_name": "V3",
                "docs::human_name": "V3"
              }
            },
            {
              "title": "Version 4.",
              "description": "More information about version 4 of the task metadata endpoint can be found [here][endpoint_v4].\n\n[endpoint_v4]: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-metadata-endpoint-v4.html",
              "const": "v4",
              "_metadata": {
                "logical_name": "V4",
                "docs::human_name": "V4"
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::enum_tagging": "external",
            "docs::human_name": "Version"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "aws_ecs_metrics"
      }
    },
    "vector::sources::aws_kinesis_firehose::AwsKinesisFirehoseConfig": {
      "description": "Configuration for the `aws_kinesis_firehose` source.",
      "type": "object",
      "required": [
        "address",
        "store_access_key"
      ],
      "properties": {
        "access_key": {
          "title": "An access key to authenticate requests against.",
          "description": "AWS Kinesis Firehose can be configured to pass along a user-configurable access key with each request. If\nconfigured, `access_key` should be set to the same value. Otherwise, all requests are allowed.",
          "deprecated": true,
          "$ref": "#/definitions/core::option::Option<vector_common::sensitive_string::SensitiveString>",
          "_metadata": {
            "deprecated_message": "This option has been deprecated, use `access_keys` instead.",
            "docs::examples": "A94A8FE5CCB19BA61C4C08",
            "docs::human_name": "Access Key"
          }
        },
        "access_keys": {
          "title": "A list of access keys to authenticate requests against.",
          "description": "AWS Kinesis Firehose can be configured to pass along a user-configurable access key with each request. If\nconfigured, `access_keys` should be set to the same value. Otherwise, all requests are allowed.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString"
          },
          "_metadata": {
            "sensitive": true,
            "docs::optional": true,
            "docs::examples": [
              "A94A8FE5CCB19BA61C4C08",
              "B94B8FE5CCB19BA61C4C12"
            ],
            "docs::human_name": "Access Keys"
          }
        },
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled by this source.",
          "description": "This setting is **deprecated** in favor of enabling `acknowledgements` at the [global][global_acks] or sink level.\n\nEnabling or disabling acknowledgements at the source level has **no effect** on acknowledgement behavior.\n\nSee [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::SourceAcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "address": {
          "description": "The socket address to listen for connections on.",
          "$ref": "#/definitions/stdlib::SocketAddr",
          "_metadata": {
            "docs::examples": [
              "0.0.0.0:443",
              "localhost:443"
            ],
            "docs::human_name": "Address"
          }
        },
        "decoding": {
          "description": "Configures how events are decoded from raw bytes.",
          "default": {
            "codec": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::DeserializerConfig",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Decoding"
          }
        },
        "framing": {
          "title": "Framing configuration.",
          "description": "Framing handles how events are separated when encoded in a raw byte form, where each event is\na frame that must be prefixed, or delimited, in a way that marks where an event begins and\nends within the byte stream.",
          "default": {
            "method": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::FramingConfig",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Framing"
          }
        },
        "log_namespace": {
          "description": "The namespace to use for logs. This overrides the global setting.",
          "default": null,
          "type": [
            "boolean",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::hidden": true,
            "docs::human_name": "Log Namespace"
          }
        },
        "record_compression": {
          "title": "The compression scheme to use for decompressing records within the Firehose message.",
          "description": "Some services, like AWS CloudWatch Logs, [compresses the events with gzip][events_with_gzip],\nbefore sending them AWS Kinesis Firehose. This option can be used to automatically decompress\nthem before forwarding them to the next component.\n\nNote that this is different from [Content encoding option][encoding_option] of the\nFirehose HTTP endpoint destination. That option controls the content encoding of the entire HTTP request.\n\n[events_with_gzip]: https://docs.aws.amazon.com/firehose/latest/dev/writing-with-cloudwatch-logs.html\n[encoding_option]: https://docs.aws.amazon.com/firehose/latest/dev/create-destination.html#create-destination-http",
          "default": "auto",
          "oneOf": [
            {
              "title": "Automatically attempt to determine the compression scheme.",
              "description": "The compression scheme of the object is determined by looking at its file signature, also known\nas [magic bytes][magic_bytes].\n\nIf the record fails to decompress with the discovered format, the record is forwarded as is.\nThus, if you know the records are always gzip encoded (for example, if they are coming from AWS CloudWatch Logs),\nset `gzip` in this field so that any records that are not-gzipped are rejected.\n\n[magic_bytes]: https://en.wikipedia.org/wiki/List_of_file_signatures",
              "const": "auto",
              "_metadata": {
                "logical_name": "Auto",
                "docs::human_name": "Auto"
              }
            },
            {
              "description": "Uncompressed.",
              "const": "none",
              "_metadata": {
                "logical_name": "None",
                "docs::human_name": "None"
              }
            },
            {
              "description": "GZIP.",
              "const": "gzip",
              "_metadata": {
                "logical_name": "Gzip",
                "docs::human_name": "Gzip"
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::advanced": true,
            "docs::enum_tagging": "external",
            "docs::human_name": "Record Compression"
          }
        },
        "store_access_key": {
          "title": "Whether or not to store the AWS Firehose Access Key in event secrets.",
          "description": "If set to `true`, when incoming requests contains an access key sent by AWS Firehose, it is kept in the\nevent secrets as \"aws_kinesis_firehose_access_key\".",
          "type": "boolean",
          "_metadata": {
            "docs::human_name": "Store Access Key"
          }
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "aws_kinesis_firehose"
      }
    },
    "vector::sources::aws_s3::AwsS3Config": {
      "description": "Configuration for the `aws_s3` source.",
      "default": {
        "region": null,
        "endpoint": null,
        "compression": "auto",
        "strategy": "sqs",
        "sqs": null,
        "assume_role": null,
        "auth": {
          "load_timeout_secs": null,
          "imds": {
            "max_attempts": 4,
            "connect_timeout_seconds": 1,
            "read_timeout_seconds": 1
          },
          "region": null
        },
        "multiline": null,
        "acknowledgements": {
          "enabled": null
        },
        "tls_options": null,
        "log_namespace": null,
        "framing": {
          "method": "newline_delimited"
        },
        "decoding": {
          "codec": "bytes"
        }
      },
      "allOf": [
        {
          "type": "object",
          "properties": {
            "acknowledgements": {
              "title": "Controls how acknowledgements are handled by this source.",
              "description": "This setting is **deprecated** in favor of enabling `acknowledgements` at the [global][global_acks] or sink level.\n\nEnabling or disabling acknowledgements at the source level has **no effect** on acknowledgement behavior.\n\nSee [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::SourceAcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              }
            },
            "assume_role": {
              "title": "The ARN of an [IAM role][iam_role] to assume at startup.",
              "description": "[iam_role]: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html",
              "deprecated": true,
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::hidden": true,
                "docs::human_name": "Assume Role"
              }
            },
            "auth": {
              "description": "Configuration of the authentication strategy for interacting with AWS services.",
              "default": {
                "load_timeout_secs": null,
                "imds": {
                  "max_attempts": 4,
                  "connect_timeout_seconds": 1,
                  "read_timeout_seconds": 1
                },
                "region": null
              },
              "$ref": "#/definitions/vector::aws::auth::AwsAuthentication",
              "_metadata": {
                "docs::human_name": "Auth"
              }
            },
            "compression": {
              "description": "The compression scheme used for decompressing objects retrieved from S3.",
              "oneOf": [
                {
                  "title": "Automatically attempt to determine the compression scheme.",
                  "description": "The compression scheme of the object is determined from its `Content-Encoding` and\n`Content-Type` metadata, as well as the key suffix (for example, `.gz`).\n\nIt is set to `none` if the compression scheme cannot be determined.",
                  "const": "auto",
                  "_metadata": {
                    "logical_name": "Auto",
                    "docs::human_name": "Auto"
                  }
                },
                {
                  "description": "Uncompressed.",
                  "const": "none",
                  "_metadata": {
                    "logical_name": "None",
                    "docs::human_name": "None"
                  }
                },
                {
                  "description": "GZIP.",
                  "const": "gzip",
                  "_metadata": {
                    "logical_name": "Gzip",
                    "docs::human_name": "Gzip"
                  }
                },
                {
                  "description": "ZSTD.",
                  "const": "zstd",
                  "_metadata": {
                    "logical_name": "Zstd",
                    "docs::human_name": "Zstd"
                  }
                }
              ],
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::advanced": true,
                "docs::enum_tagging": "external",
                "docs::human_name": "Compression"
              }
            },
            "decoding": {
              "description": "Configures how events are decoded from raw bytes.",
              "default": {
                "codec": "bytes"
              },
              "$ref": "#/definitions/codecs::decoding::DeserializerConfig",
              "_metadata": {
                "docs::human_name": "Decoding"
              }
            },
            "framing": {
              "title": "Framing configuration.",
              "description": "Framing handles how events are separated when encoded in a raw byte form, where each event is\na frame that must be prefixed, or delimited, in a way that marks where an event begins and\nends within the byte stream.",
              "default": {
                "method": "newline_delimited"
              },
              "$ref": "#/definitions/codecs::decoding::FramingConfig",
              "_metadata": {
                "docs::human_name": "Framing"
              }
            },
            "log_namespace": {
              "description": "The namespace to use for logs. This overrides the global setting.",
              "default": null,
              "type": [
                "boolean",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::hidden": true,
                "docs::human_name": "Log Namespace"
              }
            },
            "multiline": {
              "title": "Multiline aggregation configuration.",
              "description": "If not specified, multiline aggregation is disabled.",
              "$ref": "#/definitions/core::option::Option<vector::sources::util::multiline_config::MultilineConfig>",
              "_metadata": {
                "docs::human_name": "Multiline"
              }
            },
            "sqs": {
              "description": "Configuration options for SQS.",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "description": "SQS configuration options.",
                  "type": "object",
                  "required": [
                    "queue_url"
                  ],
                  "properties": {
                    "client_concurrency": {
                      "title": "Number of concurrent tasks to create for polling the queue for messages.",
                      "description": "Defaults to the number of available CPUs on the system.\n\nShould not typically need to be changed, but it can sometimes be beneficial to raise this\nvalue when there is a high rate of messages being pushed into the queue and the objects\nbeing fetched are small. In these cases, system resources may not be fully utilized without\nfetching more messages per second, as the SQS message consumption rate affects the S3 object\nretrieval rate.",
                      "type": [
                        "integer",
                        "null"
                      ],
                      "maximum": 9007199254740991.0,
                      "minimum": 1.0,
                      "_metadata": {
                        "docs::numeric_type": "uint",
                        "docs::optional": true,
                        "docs::type_unit": "tasks",
                        "docs::examples": 5,
                        "docs::human_name": "Client Concurrency"
                      }
                    },
                    "delete_message": {
                      "title": "Whether to delete the message once it is processed.",
                      "description": "It can be useful to set this to `false` for debugging or during the initial setup.",
                      "default": true,
                      "type": "boolean",
                      "_metadata": {
                        "docs::human_name": "Delete Message"
                      }
                    },
                    "poll_secs": {
                      "title": "How long to wait while polling the queue for new messages, in seconds.",
                      "description": "Generally, this should not be changed unless instructed to do so, as if messages are available,\nthey are always consumed, regardless of the value of `poll_secs`.",
                      "default": 15,
                      "type": "integer",
                      "maximum": 4294967295.0,
                      "minimum": 0.0,
                      "_metadata": {
                        "docs::numeric_type": "uint",
                        "docs::type_unit": "seconds",
                        "docs::human_name": "Poll Secs"
                      }
                    },
                    "queue_url": {
                      "description": "The URL of the SQS queue to poll for bucket notifications.",
                      "type": "string",
                      "format": "uri",
                      "_metadata": {
                        "docs::examples": "https://sqs.us-east-2.amazonaws.com/123456789012/MyQueue",
                        "docs::human_name": "Queue URL"
                      }
                    },
                    "tls_options": {
                      "default": null,
                      "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
                      "_metadata": {
                        "docs::human_name": "TLS Options"
                      }
                    },
                    "visibility_timeout_secs": {
                      "title": "The visibility timeout to use for messages, in seconds.",
                      "description": "This controls how long a message is left unavailable after it is received. If a message is received, and\ntakes longer than `visibility_timeout_secs` to process and delete the message from the queue, it is made available again for another consumer.\n\nThis can happen if there is an issue between consuming a message and deleting it.",
                      "default": 300,
                      "type": "integer",
                      "maximum": 4294967295.0,
                      "minimum": 0.0,
                      "_metadata": {
                        "docs::numeric_type": "uint",
                        "docs::type_unit": "seconds",
                        "docs::human_name": "Visibility Timeout"
                      }
                    }
                  }
                }
              ],
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::optional": true,
                "docs::human_name": "SQS"
              }
            },
            "strategy": {
              "description": "The strategy to use to consume objects from S3.",
              "oneOf": [
                {
                  "title": "Consumes objects by processing bucket notification events sent to an [AWS SQS queue][aws_sqs].",
                  "description": "[aws_sqs]: https://aws.amazon.com/sqs/",
                  "const": "sqs",
                  "_metadata": {
                    "logical_name": "Sqs",
                    "docs::human_name": "SQS"
                  }
                }
              ],
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::hidden": true,
                "docs::enum_tagging": "external",
                "docs::human_name": "Strategy"
              }
            },
            "tls_options": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS Options"
              }
            }
          }
        },
        {
          "description": "Configuration of the region/endpoint to use when interacting with an AWS service.",
          "$ref": "#/definitions/vector::aws::region::RegionOrEndpoint"
        }
      ],
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "aws_s3"
      }
    },
    "vector::sources::aws_sqs::config::AwsSqsConfig": {
      "description": "Configuration for the `aws_sqs` source.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "queue_url"
          ],
          "properties": {
            "acknowledgements": {
              "title": "Controls how acknowledgements are handled by this source.",
              "description": "This setting is **deprecated** in favor of enabling `acknowledgements` at the [global][global_acks] or sink level.\n\nEnabling or disabling acknowledgements at the source level has **no effect** on acknowledgement behavior.\n\nSee [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::SourceAcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              }
            },
            "auth": {
              "description": "Configuration of the authentication strategy for interacting with AWS services.",
              "default": {
                "load_timeout_secs": null,
                "imds": {
                  "max_attempts": 4,
                  "connect_timeout_seconds": 1,
                  "read_timeout_seconds": 1
                },
                "region": null
              },
              "$ref": "#/definitions/vector::aws::auth::AwsAuthentication",
              "_metadata": {
                "docs::human_name": "Auth"
              }
            },
            "client_concurrency": {
              "title": "Number of concurrent tasks to create for polling the queue for messages.",
              "description": "Defaults to the number of available CPUs on the system.\n\nShould not typically need to be changed, but it can sometimes be beneficial to raise this\nvalue when there is a high rate of messages being pushed into the queue and the messages\nbeing fetched are small. In these cases, system resources may not be fully utilized without\nfetching more messages per second, as it spends more time fetching the messages than\nprocessing them.",
              "type": [
                "integer",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": 1.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "docs::human_name": "Client Concurrency"
              }
            },
            "decoding": {
              "description": "Configures how events are decoded from raw bytes.",
              "default": {
                "codec": "bytes"
              },
              "$ref": "#/definitions/codecs::decoding::DeserializerConfig",
              "_metadata": {
                "docs::human_name": "Decoding"
              }
            },
            "delete_message": {
              "title": "Whether to delete the message once it is processed.",
              "description": "It can be useful to set this to `false` for debugging or during the initial setup.",
              "default": true,
              "type": "boolean",
              "_metadata": {
                "docs::human_name": "Delete Message"
              }
            },
            "framing": {
              "title": "Framing configuration.",
              "description": "Framing handles how events are separated when encoded in a raw byte form, where each event is\na frame that must be prefixed, or delimited, in a way that marks where an event begins and\nends within the byte stream.",
              "default": {
                "method": "bytes"
              },
              "$ref": "#/definitions/codecs::decoding::FramingConfig",
              "_metadata": {
                "docs::human_name": "Framing"
              }
            },
            "log_namespace": {
              "description": "The namespace to use for logs. This overrides the global setting.",
              "default": null,
              "type": [
                "boolean",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::hidden": true,
                "docs::human_name": "Log Namespace"
              }
            },
            "poll_secs": {
              "title": "How long to wait while polling the queue for new messages, in seconds.",
              "description": "Generally, this should not be changed unless instructed to do so, as if messages are available,\nthey are always consumed, regardless of the value of `poll_secs`.",
              "default": 15,
              "type": "integer",
              "maximum": 4294967295.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::type_unit": "seconds",
                "docs::human_name": "Poll Wait Time"
              }
            },
            "queue_url": {
              "description": "The URL of the SQS queue to poll for messages.",
              "type": "string",
              "_metadata": {
                "docs::examples": "https://sqs.us-east-2.amazonaws.com/123456789012/MyQueue",
                "docs::human_name": "Queue URL"
              }
            },
            "tls": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              }
            },
            "visibility_timeout_secs": {
              "title": "The visibility timeout to use for messages, in seconds.",
              "description": "This controls how long a message is left unavailable after it is received. If a message is received, and\ntakes longer than `visibility_timeout_secs` to process and delete the message from the queue, it is made available again for another consumer.\n\nThis can happen if there is an issue between consuming a message and deleting it.",
              "default": 300,
              "type": "integer",
              "maximum": 4294967295.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::type_unit": "seconds",
                "docs::human_name": "Visibility Timeout"
              }
            }
          }
        },
        {
          "description": "Configuration of the region/endpoint to use when interacting with an AWS service.",
          "$ref": "#/definitions/vector::aws::region::RegionOrEndpoint"
        }
      ],
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "aws_sqs"
      }
    },
    "vector::sources::datadog_agent::DatadogAgentConfig": {
      "description": "Configuration for the `datadog_agent` source.",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled by this source.",
          "description": "This setting is **deprecated** in favor of enabling `acknowledgements` at the [global][global_acks] or sink level.\n\nEnabling or disabling acknowledgements at the source level has **no effect** on acknowledgement behavior.\n\nSee [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::SourceAcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "address": {
          "title": "The socket address to accept connections on.",
          "description": "It _must_ include a port.",
          "$ref": "#/definitions/stdlib::SocketAddr",
          "_metadata": {
            "docs::examples": [
              "0.0.0.0:80",
              "localhost:80"
            ],
            "docs::human_name": "Address"
          }
        },
        "decoding": {
          "description": "Configures how events are decoded from raw bytes.",
          "default": {
            "codec": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::DeserializerConfig",
          "_metadata": {
            "docs::human_name": "Decoding"
          }
        },
        "disable_logs": {
          "description": "If this is set to `true`, logs are not accepted by the component.",
          "default": false,
          "type": "boolean",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Disable Logs"
          }
        },
        "disable_metrics": {
          "description": "If this is set to `true`, metrics are not accepted by the component.",
          "default": false,
          "type": "boolean",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Disable Metrics"
          }
        },
        "disable_traces": {
          "description": "If this is set to `true`, traces are not accepted by the component.",
          "default": false,
          "type": "boolean",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Disable Traces"
          }
        },
        "framing": {
          "title": "Framing configuration.",
          "description": "Framing handles how events are separated when encoded in a raw byte form, where each event is\na frame that must be prefixed, or delimited, in a way that marks where an event begins and\nends within the byte stream.",
          "default": {
            "method": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::FramingConfig",
          "_metadata": {
            "docs::human_name": "Framing"
          }
        },
        "log_namespace": {
          "description": "The namespace to use for logs. This overrides the global setting.",
          "default": null,
          "type": [
            "boolean",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::hidden": true,
            "docs::human_name": "Log Namespace"
          }
        },
        "multiple_outputs": {
          "title": "If this is set to `true` logs, metrics, and traces are sent to different outputs.",
          "description": "For a source component named `agent`, the received logs, metrics, and traces can then be\nconfigured as input to other components by specifying `agent.logs`, `agent.metrics`, and\n`agent.traces`, respectively.",
          "default": false,
          "type": "boolean",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Multiple Outputs"
          }
        },
        "store_api_key": {
          "description": "If this is set to `true`, when incoming events contain a Datadog API key, it is\nstored in the event metadata and used if the event is sent to a Datadog sink.",
          "default": true,
          "type": "boolean",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Store API Key"
          }
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "datadog_agent"
      }
    },
    "vector::sources::demo_logs::DemoLogsConfig": {
      "description": "Configuration for the `demo_logs` source.",
      "allOf": [
        {
          "type": "object",
          "properties": {
            "count": {
              "title": "The total number of lines to output.",
              "description": "By default, the source continuously prints logs (infinitely).",
              "default": 9223372036854775807,
              "type": "integer",
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::human_name": "Count"
              }
            },
            "decoding": {
              "description": "Configures how events are decoded from raw bytes.",
              "default": {
                "codec": "bytes"
              },
              "$ref": "#/definitions/codecs::decoding::DeserializerConfig",
              "_metadata": {
                "docs::human_name": "Decoding"
              }
            },
            "framing": {
              "title": "Framing configuration.",
              "description": "Framing handles how events are separated when encoded in a raw byte form, where each event is\na frame that must be prefixed, or delimited, in a way that marks where an event begins and\nends within the byte stream.",
              "default": {
                "method": "bytes"
              },
              "$ref": "#/definitions/codecs::decoding::FramingConfig",
              "_metadata": {
                "docs::human_name": "Framing"
              }
            },
            "interval": {
              "title": "The amount of time, in seconds, to pause between each batch of output lines.",
              "description": "The default is one batch per second. To remove the delay and output batches as quickly as possible, set\n`interval` to `0.0`.",
              "default": 1.0,
              "$ref": "#/definitions/serde_with::DurationFractionalSeconds",
              "_metadata": {
                "docs::examples": [
                  1.0,
                  0.1,
                  0.01
                ],
                "docs::human_name": "Interval"
              }
            },
            "log_namespace": {
              "description": "The namespace to use for logs. This overrides the global setting.",
              "default": null,
              "type": [
                "boolean",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::hidden": true,
                "docs::human_name": "Log Namespace"
              }
            }
          }
        },
        {
          "description": "Output format configuration.",
          "oneOf": [
            {
              "description": "Lines are chosen at random from the list specified using `lines`.",
              "type": "object",
              "required": [
                "format",
                "lines"
              ],
              "properties": {
                "format": {
                  "description": "Lines are chosen at random from the list specified using `lines`.",
                  "const": "shuffle",
                  "_metadata": {
                    "docs::human_name": "Format"
                  }
                },
                "lines": {
                  "description": "The list of lines to output.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "_metadata": {
                    "docs::examples": [
                      "line1",
                      "line2"
                    ],
                    "docs::human_name": "Lines"
                  }
                },
                "sequence": {
                  "description": "If `true`, each output line starts with an increasing sequence number, beginning with 0.",
                  "default": false,
                  "type": "boolean",
                  "_metadata": {
                    "docs::human_name": "Sequence"
                  }
                }
              },
              "_metadata": {
                "logical_name": "Shuffle",
                "docs::human_name": "Shuffle"
              }
            },
            {
              "title": "Randomly generated logs in [Apache common][apache_common] format.",
              "description": "[apache_common]: https://httpd.apache.org/docs/current/logs.html#common",
              "type": "object",
              "required": [
                "format"
              ],
              "properties": {
                "format": {
                  "title": "Randomly generated logs in [Apache common][apache_common] format.",
                  "description": "[apache_common]: https://httpd.apache.org/docs/current/logs.html#common",
                  "const": "apache_common",
                  "_metadata": {
                    "docs::human_name": "Format"
                  }
                }
              },
              "_metadata": {
                "logical_name": "ApacheCommon",
                "docs::human_name": "Apache Common"
              }
            },
            {
              "title": "Randomly generated logs in [Apache error][apache_error] format.",
              "description": "[apache_error]: https://httpd.apache.org/docs/current/logs.html#errorlog",
              "type": "object",
              "required": [
                "format"
              ],
              "properties": {
                "format": {
                  "title": "Randomly generated logs in [Apache error][apache_error] format.",
                  "description": "[apache_error]: https://httpd.apache.org/docs/current/logs.html#errorlog",
                  "const": "apache_error",
                  "_metadata": {
                    "docs::human_name": "Format"
                  }
                }
              },
              "_metadata": {
                "logical_name": "ApacheError",
                "docs::human_name": "Apache Error"
              }
            },
            {
              "title": "Randomly generated logs in Syslog format ([RFC 5424][syslog_5424]).",
              "description": "[syslog_5424]: https://tools.ietf.org/html/rfc5424",
              "type": "object",
              "required": [
                "format"
              ],
              "properties": {
                "format": {
                  "title": "Randomly generated logs in Syslog format ([RFC 5424][syslog_5424]).",
                  "description": "[syslog_5424]: https://tools.ietf.org/html/rfc5424",
                  "const": "syslog",
                  "_metadata": {
                    "docs::human_name": "Format"
                  }
                }
              },
              "_metadata": {
                "logical_name": "Syslog",
                "docs::human_name": "Syslog"
              }
            },
            {
              "title": "Randomly generated logs in Syslog format ([RFC 3164][syslog_3164]).",
              "description": "[syslog_3164]: https://tools.ietf.org/html/rfc3164",
              "type": "object",
              "required": [
                "format"
              ],
              "properties": {
                "format": {
                  "title": "Randomly generated logs in Syslog format ([RFC 3164][syslog_3164]).",
                  "description": "[syslog_3164]: https://tools.ietf.org/html/rfc3164",
                  "const": "bsd_syslog",
                  "_metadata": {
                    "docs::human_name": "Format"
                  }
                }
              },
              "_metadata": {
                "logical_name": "BsdSyslog",
                "docs::human_name": "BSD Syslog"
              }
            },
            {
              "title": "Randomly generated HTTP server logs in [JSON][json] format.",
              "description": "[json]: https://en.wikipedia.org/wiki/JSON",
              "type": "object",
              "required": [
                "format"
              ],
              "properties": {
                "format": {
                  "title": "Randomly generated HTTP server logs in [JSON][json] format.",
                  "description": "[json]: https://en.wikipedia.org/wiki/JSON",
                  "const": "json",
                  "_metadata": {
                    "docs::human_name": "Format"
                  }
                }
              },
              "_metadata": {
                "logical_name": "Json",
                "docs::human_name": "JSON"
              }
            }
          ],
          "_metadata": {
            "docs::enum_tag_description": "The format of the randomly generated output.",
            "docs::enum_tagging": "internal",
            "docs::enum_tag_field": "format"
          }
        }
      ],
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "demo_logs"
      }
    },
    "vector::sources::dnstap::DnstapConfig": {
      "description": "Configuration for the `dnstap` source.",
      "type": "object",
      "required": [
        "socket_path"
      ],
      "properties": {
        "host_key": {
          "title": "Overrides the name of the log field used to add the source path to each event.",
          "description": "The value is the socket path itself.\n\nBy default, the [global `log_schema.host_key` option][global_host_key] is used.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
          "$ref": "#/definitions/core::option::Option<vector_lookup::lookup_v2::optional_path::OptionalValuePath>",
          "_metadata": {
            "docs::human_name": "Host Key"
          }
        },
        "log_namespace": {
          "description": "The namespace to use for logs. This overrides the global settings.",
          "default": null,
          "type": [
            "boolean",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::hidden": true,
            "docs::human_name": "Log Namespace"
          }
        },
        "max_frame_handling_tasks": {
          "description": "Maximum number of frames that can be processed concurrently.",
          "type": [
            "integer",
            "null"
          ],
          "maximum": 4294967295.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::human_name": "Max Frame Handling Tasks"
          }
        },
        "max_frame_length": {
          "title": "Maximum DNSTAP frame length that the source accepts.",
          "description": "If any frame is longer than this, it is discarded.",
          "default": 102400,
          "type": "integer",
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::type_unit": "bytes",
            "docs::human_name": "Max Frame Length"
          }
        },
        "multithreaded": {
          "description": "Whether or not to concurrently process DNSTAP frames.",
          "type": [
            "boolean",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Multithreaded"
          }
        },
        "raw_data_only": {
          "title": "Whether or not to skip parsing or decoding of DNSTAP frames.",
          "description": "If set to `true`, frames are not parsed or decoded. The raw frame data is set as a field on the event\n(called `rawData`) and encoded as a base64 string.",
          "type": [
            "boolean",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Raw Data Only"
          }
        },
        "socket_file_mode": {
          "title": "Unix file mode bits to be applied to the unix socket file as its designated file permissions.",
          "description": "Note: The file mode value can be specified in any numeric format supported by your configuration\nlanguage, but it is most intuitive to use an octal number.",
          "type": [
            "integer",
            "null"
          ],
          "maximum": 4294967295.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::human_name": "Socket File Mode"
          }
        },
        "socket_path": {
          "title": "Absolute path to the socket file to read DNSTAP data from.",
          "description": "The DNS server must be configured to send its DNSTAP data to this socket file. The socket file is created\nif it doesn't already exist when the source first starts.",
          "$ref": "#/definitions/stdlib::PathBuf",
          "_metadata": {
            "docs::human_name": "Socket Path"
          }
        },
        "socket_receive_buffer_size": {
          "title": "The size, in bytes, of the receive buffer used for the socket.",
          "description": "This should not typically needed to be changed.",
          "type": [
            "integer",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "bytes",
            "docs::human_name": "Socket Receive Buffer Size"
          }
        },
        "socket_send_buffer_size": {
          "title": "The size, in bytes, of the send buffer used for the socket.",
          "description": "This should not typically needed to be changed.",
          "type": [
            "integer",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "bytes",
            "docs::human_name": "Socket Send Buffer Size"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "dnstap"
      }
    },
    "vector::sources::docker_logs::DockerLogsConfig": {
      "description": "Configuration for the `docker_logs` source.",
      "default": {
        "host_key": "host",
        "docker_host": null,
        "exclude_containers": null,
        "include_containers": null,
        "include_labels": null,
        "include_images": null,
        "partial_event_marker_field": "_partial",
        "auto_partial_merge": true,
        "retry_backoff_secs": 2,
        "multiline": null,
        "tls": null,
        "log_namespace": null
      },
      "type": "object",
      "properties": {
        "auto_partial_merge": {
          "description": "Enables automatic merging of partial events.",
          "type": "boolean",
          "_metadata": {
            "docs::human_name": "Auto Partial Merge"
          }
        },
        "docker_host": {
          "title": "Docker host to connect to.",
          "description": "Use an HTTPS URL to enable TLS encryption.\n\nIf absent, the `DOCKER_HOST` environment variable is used. If `DOCKER_HOST` is also absent,\nthe default Docker local socket (`/var/run/docker.sock` on Unix platforms,\n`//./pipe/docker_engine` on Windows) is used.",
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::examples": [
              "http://localhost:2375",
              "https://localhost:2376",
              "unix:///var/run/docker.sock",
              "npipe:////./pipe/docker_engine",
              "/var/run/docker.sock",
              "//./pipe/docker_engine"
            ],
            "docs::human_name": "Docker Host"
          }
        },
        "exclude_containers": {
          "title": "A list of container IDs or names of containers to exclude from log collection.",
          "description": "Matching is prefix first, so specifying a value of `foo` would match any container named `foo` as well as any\ncontainer whose name started with `foo`. This applies equally whether matching container IDs or names.\n\nBy default, the source collects logs for all containers. If `exclude_containers` is configured, any\ncontainer that matches a configured exclusion is excluded even if it is also included with\n`include_containers`, so care should be taken when using prefix matches as they cannot be overridden by a\ncorresponding entry in `include_containers`, for example, excluding `foo` by attempting to include `foo-specific-id`.\n\nThis can be used in conjunction with `include_containers`.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          },
          "_metadata": {
            "docs::optional": true,
            "docs::examples": [
              "exclude_",
              "exclude_me_0",
              "ad08cc418cf9"
            ],
            "docs::human_name": "Exclude Containers"
          }
        },
        "host_key": {
          "title": "Overrides the name of the log field used to add the current hostname to each event.",
          "description": "By default, the [global `log_schema.host_key` option][global_host_key] is used.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
          "default": "host",
          "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
          "_metadata": {
            "docs::human_name": "Host Key"
          }
        },
        "include_containers": {
          "title": "A list of container IDs or names of containers to include in log collection.",
          "description": "Matching is prefix first, so specifying a value of `foo` would match any container named `foo` as well as any\ncontainer whose name started with `foo`. This applies equally whether matching container IDs or names.\n\nBy default, the source collects logs for all containers. If `include_containers` is configured, only\ncontainers that match a configured inclusion and are also not excluded get matched.\n\nThis can be used in conjunction with `exclude_containers`.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          },
          "_metadata": {
            "docs::optional": true,
            "docs::examples": [
              "include_",
              "include_me_0",
              "ad08cc418cf9"
            ],
            "docs::human_name": "Include Containers"
          }
        },
        "include_images": {
          "title": "A list of image names to match against.",
          "description": "If not provided, all images are included.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          },
          "_metadata": {
            "docs::optional": true,
            "docs::examples": [
              "httpd",
              "redis"
            ],
            "docs::human_name": "Include Images"
          }
        },
        "include_labels": {
          "title": "A list of container object labels to match against when filtering running containers.",
          "description": "Labels should follow the syntax described in the [Docker object labels](https://docs.docker.com/config/labels-custom-metadata/) documentation.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          },
          "_metadata": {
            "docs::optional": true,
            "docs::examples": [
              "org.opencontainers.image.vendor=Vector",
              "com.mycorp.internal.animal=fish"
            ],
            "docs::human_name": "Include Labels"
          }
        },
        "log_namespace": {
          "description": "The namespace to use for logs. This overrides the global setting.",
          "default": null,
          "type": [
            "boolean",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::hidden": true,
            "docs::human_name": "Log Namespace"
          }
        },
        "multiline": {
          "title": "Multiline aggregation configuration.",
          "description": "If not specified, multiline aggregation is disabled.",
          "$ref": "#/definitions/core::option::Option<vector::sources::util::multiline_config::MultilineConfig>",
          "_metadata": {
            "docs::human_name": "Multiline"
          }
        },
        "partial_event_marker_field": {
          "title": "Overrides the name of the log field used to mark an event as partial.",
          "description": "If `auto_partial_merge` is disabled, partial events are emitted with a log field, set by this\nconfiguration value, indicating that the event is not complete.",
          "default": "_partial",
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Partial Event Marker Field"
          }
        },
        "retry_backoff_secs": {
          "description": "The amount of time to wait before retrying after an error.",
          "default": 2,
          "$ref": "#/definitions/serde_with::DurationSeconds",
          "_metadata": {
            "docs::human_name": "Retry Backoff"
          }
        },
        "tls": {
          "title": "Configuration of TLS when connecting to the Docker daemon.",
          "description": "Only relevant when connecting to Docker with an HTTPS URL.\n\nIf not configured, the environment variable `DOCKER_CERT_PATH` is used. If `DOCKER_CERT_PATH` is absent, then` DOCKER_CONFIG` is used. If both environment variables are absent, the certificates in `~/.docker/` are read.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "Configuration of TLS when connecting to the Docker daemon.",
              "description": "Only relevant when connecting to Docker with an HTTPS URL.\n\nIf not configured, the environment variable `DOCKER_CERT_PATH` is used. If `DOCKER_CERT_PATH` is absent, then` DOCKER_CONFIG` is used. If both environment variables are absent, the certificates in `~/.docker/` are read.",
              "type": "object",
              "required": [
                "ca_file",
                "crt_file",
                "key_file"
              ],
              "properties": {
                "ca_file": {
                  "description": "Path to the CA certificate file.",
                  "$ref": "#/definitions/stdlib::PathBuf",
                  "_metadata": {
                    "docs::human_name": "Ca File"
                  }
                },
                "crt_file": {
                  "description": "Path to the TLS certificate file.",
                  "$ref": "#/definitions/stdlib::PathBuf",
                  "_metadata": {
                    "docs::human_name": "Crt File"
                  }
                },
                "key_file": {
                  "description": "Path to the TLS key file.",
                  "$ref": "#/definitions/stdlib::PathBuf",
                  "_metadata": {
                    "docs::human_name": "Key File"
                  }
                }
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "TLS"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "docker_logs"
      }
    },
    "vector::sources::eventstoredb_metrics::EventStoreDbConfig": {
      "description": "Configuration for the `eventstoredb_metrics` source.",
      "type": "object",
      "properties": {
        "default_namespace": {
          "title": "Overrides the default namespace for the metrics emitted by the source.",
          "description": "By default, `eventstoredb` is used.",
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::examples": "eventstoredb",
            "docs::human_name": "Default Namespace"
          }
        },
        "endpoint": {
          "description": "Endpoint to scrape stats from.",
          "default": "https://localhost:2113/stats",
          "type": "string",
          "_metadata": {
            "docs::examples": "https://localhost:2113/stats",
            "docs::human_name": "Endpoint"
          }
        },
        "scrape_interval_secs": {
          "description": "The interval between scrapes, in seconds.",
          "default": 15,
          "$ref": "#/definitions/serde_with::DurationSeconds",
          "_metadata": {
            "docs::human_name": "Scrape Interval"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "eventstoredb_metrics"
      }
    },
    "vector::sources::exec::ExecConfig": {
      "description": "Configuration for the `exec` source.",
      "type": "object",
      "required": [
        "command",
        "mode"
      ],
      "properties": {
        "clear_environment": {
          "description": "Whether or not to clear the environment before setting custom environment variables.",
          "default": false,
          "type": "boolean",
          "_metadata": {
            "docs::human_name": "Clear Environment"
          }
        },
        "command": {
          "description": "The command to run, plus any arguments required.",
          "type": "array",
          "items": {
            "type": "string"
          },
          "_metadata": {
            "docs::examples": [
              "echo",
              "Hello World!"
            ],
            "docs::human_name": "Command"
          }
        },
        "decoding": {
          "description": "Configures how events are decoded from raw bytes.",
          "default": {
            "codec": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::DeserializerConfig",
          "_metadata": {
            "docs::human_name": "Decoding"
          }
        },
        "environment": {
          "description": "Custom environment variables to set or update when running the command.\nIf a variable name already exists in the environment, its value is replaced.",
          "default": null,
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "type": "string"
          },
          "_metadata": {
            "docs::optional": true,
            "docs::additional_props_description": "An environment variable.",
            "docs::examples": {
              "TZ": "Etc/UTC",
              "LANG": "es_ES.UTF-8",
              "PATH": "/bin:/usr/bin:/usr/local/bin"
            },
            "docs::human_name": "Environment"
          }
        },
        "framing": {
          "$ref": "#/definitions/core::option::Option<codecs::decoding::FramingConfig>",
          "_metadata": {
            "docs::human_name": "Framing"
          }
        },
        "include_stderr": {
          "description": "Whether or not the output from stderr should be included when generating events.",
          "default": true,
          "type": "boolean",
          "_metadata": {
            "docs::human_name": "Include Stderr"
          }
        },
        "log_namespace": {
          "description": "The namespace to use for logs. This overrides the global setting.",
          "default": null,
          "type": [
            "boolean",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::hidden": true,
            "docs::human_name": "Log Namespace"
          }
        },
        "maximum_buffer_size_bytes": {
          "description": "The maximum buffer size allowed before a log event is generated.",
          "default": 1000000,
          "type": "integer",
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::human_name": "Maximum Buffer Size Bytes"
          }
        },
        "mode": {
          "description": "Mode of operation for running the command.",
          "oneOf": [
            {
              "description": "The command is run on a schedule.",
              "const": "scheduled",
              "_metadata": {
                "logical_name": "Scheduled",
                "docs::human_name": "Scheduled"
              }
            },
            {
              "description": "The command is run until it exits, potentially being restarted.",
              "const": "streaming",
              "_metadata": {
                "logical_name": "Streaming",
                "docs::human_name": "Streaming"
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::enum_tagging": "external",
            "docs::human_name": "Mode"
          }
        },
        "scheduled": {
          "description": "Configuration options for scheduled commands.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "description": "Configuration options for scheduled commands.",
              "type": "object",
              "properties": {
                "exec_interval_secs": {
                  "title": "The interval, in seconds, between scheduled command runs.",
                  "description": "If the command takes longer than `exec_interval_secs` to run, it is killed.",
                  "default": 60,
                  "type": "integer",
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::human_name": "Exec Interval Secs"
                  }
                }
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Scheduled"
          }
        },
        "streaming": {
          "description": "Configuration options for streaming commands.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "description": "Configuration options for streaming commands.",
              "type": "object",
              "properties": {
                "respawn_interval_secs": {
                  "description": "The amount of time, in seconds, before rerunning a streaming command that exited.",
                  "default": 5,
                  "type": "integer",
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::human_name": "Respawn Interval"
                  }
                },
                "respawn_on_exit": {
                  "description": "Whether or not the command should be rerun if the command exits.",
                  "default": true,
                  "type": "boolean",
                  "_metadata": {
                    "docs::human_name": "Respawn On Exit"
                  }
                }
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Streaming"
          }
        },
        "working_directory": {
          "description": "The directory in which to run the command.",
          "$ref": "#/definitions/core::option::Option<std::path::PathBuf>",
          "_metadata": {
            "docs::human_name": "Working Directory"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "exec"
      }
    },
    "vector::sources::file::FileConfig": {
      "description": "Configuration for the `file` source.",
      "type": "object",
      "required": [
        "include"
      ],
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled by this source.",
          "description": "This setting is **deprecated** in favor of enabling `acknowledgements` at the [global][global_acks] or sink level.\n\nEnabling or disabling acknowledgements at the source level has **no effect** on acknowledgement behavior.\n\nSee [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::SourceAcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "data_dir": {
          "title": "The directory used to persist file checkpoint positions.",
          "description": "By default, the [global `data_dir` option][global_data_dir] is used. Make sure the running user has write\npermissions to this directory.\n\n[global_data_dir]: https://vector.dev/docs/reference/configuration/global-options/#data_dir",
          "default": null,
          "$ref": "#/definitions/core::option::Option<std::path::PathBuf>",
          "_metadata": {
            "docs::examples": "/var/local/lib/vector/",
            "docs::human_name": "Data Directory"
          }
        },
        "encoding": {
          "description": "Character set encoding.",
          "default": null,
          "oneOf": [
            {
              "type": "null"
            },
            {
              "description": "Character set encoding.",
              "type": "object",
              "required": [
                "charset"
              ],
              "properties": {
                "charset": {
                  "title": "Encoding of the source messages.",
                  "description": "Takes one of the encoding [label strings](https://encoding.spec.whatwg.org/#concept-encoding-get) defined as\npart of the [Encoding Standard](https://encoding.spec.whatwg.org/).\n\nWhen set, the messages are transcoded from the specified encoding to UTF-8, which is the encoding that is\nassumed internally for string-like data. Enable this transcoding operation if you need your data to\nbe in UTF-8 for further processing. At the time of transcoding, any malformed sequences (that can't be mapped to\nUTF-8) is replaced with the Unicode [REPLACEMENT\nCHARACTER](https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character) and warnings are\nlogged.",
                  "type": "string",
                  "_metadata": {
                    "docs::examples": [
                      "utf-16le",
                      "utf-16be"
                    ],
                    "docs::human_name": "Charset"
                  }
                }
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Encoding"
          }
        },
        "exclude": {
          "title": "Array of file patterns to exclude. [Globbing](https://vector.dev/docs/reference/configuration/sources/file/#globbing) is supported.",
          "description": "Takes precedence over the `include` option. Note: The `exclude` patterns are applied _after_ the attempt to glob everything\nin `include`. This means that all files are first matched by `include` and then filtered by the `exclude`\npatterns. This can be impactful if `include` contains directories with contents that are not accessible.",
          "default": [],
          "type": "array",
          "items": {
            "$ref": "#/definitions/stdlib::PathBuf"
          },
          "_metadata": {
            "docs::examples": "/var/log/binary-file.log",
            "docs::human_name": "Exclude"
          }
        },
        "file_key": {
          "title": "Overrides the name of the log field used to add the file path to each event.",
          "description": "The value is the full path to the file where the event was read message.\n\nSet to `\"\"` to suppress this key.",
          "default": "file",
          "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
          "_metadata": {
            "docs::examples": "path",
            "docs::human_name": "File Key"
          }
        },
        "fingerprint": {
          "title": "Configuration for how files should be identified.",
          "description": "This is important for `checkpointing` when file rotation is used.",
          "default": {
            "strategy": "checksum",
            "bytes": null,
            "ignored_header_bytes": 0,
            "lines": 1
          },
          "oneOf": [
            {
              "description": "Read lines from the beginning of the file and compute a checksum over them.",
              "type": "object",
              "required": [
                "ignored_header_bytes",
                "strategy"
              ],
              "properties": {
                "bytes": {
                  "description": "Maximum number of bytes to use, from the lines that are read, for generating the checksum.",
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::hidden": true,
                    "docs::type_unit": "bytes",
                    "docs::human_name": "Bytes"
                  }
                },
                "ignored_header_bytes": {
                  "title": "The number of bytes to skip ahead (or ignore) when reading the data used for generating the checksum.",
                  "description": "This can be helpful if all files share a common header that should be skipped.",
                  "type": "integer",
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::type_unit": "bytes",
                    "docs::human_name": "Ignored Header Bytes"
                  }
                },
                "lines": {
                  "title": "The number of lines to read for generating the checksum.",
                  "description": "If your files share a common header that is not always a fixed size,\n\nIf the file has less than this amount of lines, it won’t be read at all.",
                  "default": 1,
                  "type": "integer",
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::type_unit": "lines",
                    "docs::human_name": "Lines"
                  }
                },
                "strategy": {
                  "description": "Read lines from the beginning of the file and compute a checksum over them.",
                  "const": "checksum",
                  "_metadata": {
                    "docs::human_name": "Strategy"
                  }
                }
              },
              "_metadata": {
                "logical_name": "Checksum",
                "docs::human_name": "Checksum"
              }
            },
            {
              "title": "Use the [device and inode][inode] as the identifier.",
              "description": "[inode]: https://en.wikipedia.org/wiki/Inode",
              "type": "object",
              "required": [
                "strategy"
              ],
              "properties": {
                "strategy": {
                  "title": "Use the [device and inode][inode] as the identifier.",
                  "description": "[inode]: https://en.wikipedia.org/wiki/Inode",
                  "const": "device_and_inode",
                  "_metadata": {
                    "docs::human_name": "Strategy"
                  }
                }
              },
              "_metadata": {
                "logical_name": "DevInode",
                "docs::human_name": "Dev Inode"
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::enum_tag_description": "The strategy used to uniquely identify files.\n\nThis is important for checkpointing when file rotation is used.",
            "docs::enum_tagging": "internal",
            "docs::enum_tag_field": "strategy",
            "docs::human_name": "Fingerprint"
          }
        },
        "glob_minimum_cooldown_ms": {
          "title": "The delay between file discovery calls.",
          "description": "This controls the interval at which files are searched. A higher value results in greater\nchances of some short-lived files being missed between searches, but a lower value increases\nthe performance impact of file discovery.",
          "default": 1000,
          "$ref": "#/definitions/serde_with::DurationMilliSeconds",
          "_metadata": {
            "docs::type_unit": "milliseconds",
            "docs::human_name": "Glob Minimum Cooldown"
          }
        },
        "host_key": {
          "title": "Overrides the name of the log field used to add the current hostname to each event.",
          "description": "By default, the [global `log_schema.host_key` option][global_host_key] is used.\n\nSet to `\"\"` to suppress this key.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
          "default": "host",
          "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
          "_metadata": {
            "docs::examples": "hostname",
            "docs::human_name": "Host Key"
          }
        },
        "ignore_checkpoints": {
          "title": "Whether or not to ignore existing checkpoints when determining where to start reading a file.",
          "description": "Checkpoints are still written normally.",
          "default": null,
          "type": [
            "boolean",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Ignore Checkpoints"
          }
        },
        "ignore_not_found": {
          "title": "Ignore missing files when fingerprinting.",
          "description": "This may be useful when used with source directories containing dangling symlinks.",
          "default": false,
          "type": "boolean",
          "_metadata": {
            "docs::human_name": "Ignore Not Found"
          }
        },
        "ignore_older_secs": {
          "description": "Ignore files with a data modification date older than the specified number of seconds.",
          "default": null,
          "type": [
            "integer",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "seconds",
            "docs::examples": 600,
            "docs::human_name": "Ignore Older Files"
          }
        },
        "include": {
          "description": "Array of file patterns to include. [Globbing](https://vector.dev/docs/reference/configuration/sources/file/#globbing) is supported.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/stdlib::PathBuf"
          },
          "_metadata": {
            "docs::examples": "/var/log/**/*.log",
            "docs::human_name": "Include"
          }
        },
        "line_delimiter": {
          "description": "String sequence used to separate one file line from another.",
          "default": "\n",
          "type": "string",
          "_metadata": {
            "docs::examples": "\r\n",
            "docs::human_name": "Line Delimiter"
          }
        },
        "log_namespace": {
          "description": "The namespace to use for logs. This overrides the global setting.",
          "default": null,
          "type": [
            "boolean",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::hidden": true,
            "docs::human_name": "Log Namespace"
          }
        },
        "max_line_bytes": {
          "title": "The maximum size of a line before it is discarded.",
          "description": "This protects against malformed lines or tailing incorrect files.",
          "default": 102400,
          "type": "integer",
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::type_unit": "bytes",
            "docs::human_name": "Max Line Bytes"
          }
        },
        "max_read_bytes": {
          "description": "An approximate limit on the amount of data read from a single file at a given time.",
          "default": 2048,
          "type": "integer",
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::type_unit": "bytes",
            "docs::human_name": "Max Read Bytes"
          }
        },
        "message_start_indicator": {
          "description": "String value used to identify the start of a multi-line message.",
          "default": null,
          "deprecated": true,
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "deprecated_message": "This option has been deprecated, use `multiline` instead.",
            "docs::hidden": true,
            "docs::human_name": "Message Start Indicator"
          }
        },
        "multi_line_timeout": {
          "description": "How long to wait for more data when aggregating a multi-line message, in milliseconds.",
          "default": 1000,
          "deprecated": true,
          "type": "integer",
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "deprecated_message": "This option has been deprecated, use `multiline` instead.",
            "docs::numeric_type": "uint",
            "docs::hidden": true,
            "docs::human_name": "Multi Line Timeout"
          }
        },
        "multiline": {
          "title": "Multiline aggregation configuration.",
          "description": "If not specified, multiline aggregation is disabled.",
          "default": null,
          "$ref": "#/definitions/core::option::Option<vector::sources::util::multiline_config::MultilineConfig>",
          "_metadata": {
            "docs::human_name": "Multiline"
          }
        },
        "offset_key": {
          "title": "Enables adding the file offset to each event and sets the name of the log field used.",
          "description": "The value is the byte offset of the start of the line within the file.\n\nOff by default, the offset is only added to the event if this is set.",
          "default": null,
          "$ref": "#/definitions/core::option::Option<vector_lookup::lookup_v2::optional_path::OptionalValuePath>",
          "_metadata": {
            "docs::examples": "offset",
            "docs::human_name": "Offset Key"
          }
        },
        "oldest_first": {
          "description": "Instead of balancing read capacity fairly across all watched files, prioritize draining the oldest files before moving on to read data from younger files.",
          "default": false,
          "type": "boolean",
          "_metadata": {
            "docs::human_name": "Oldest First"
          }
        },
        "read_from": {
          "description": "File position to use when reading a new file.",
          "default": "beginning",
          "$ref": "#/definitions/file_source::ReadFromConfig",
          "_metadata": {
            "docs::human_name": "Read From"
          }
        },
        "remove_after_secs": {
          "title": "After reaching EOF, the number of seconds to wait before removing the file, unless new data is written.",
          "description": "If not specified, files are not removed.",
          "default": null,
          "type": [
            "integer",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "seconds",
            "docs::examples": [
              0,
              5,
              60
            ],
            "docs::human_name": "Wait Time Before Removing File"
          }
        },
        "start_at_beginning": {
          "description": "Whether or not to start reading from the beginning of a new file.",
          "default": null,
          "deprecated": true,
          "type": [
            "boolean",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "deprecated_message": "This option has been deprecated, use `ignore_checkpoints`/`read_from` instead.",
            "docs::hidden": true,
            "docs::human_name": "Start At Beginning"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "file"
      }
    },
    "vector::sources::file_descriptors::file_descriptor::FileDescriptorSourceConfig": {
      "description": "Configuration for the `file_descriptor` source.",
      "type": "object",
      "required": [
        "fd"
      ],
      "properties": {
        "decoding": {
          "description": "Configures how events are decoded from raw bytes.",
          "default": {
            "codec": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::DeserializerConfig",
          "_metadata": {
            "docs::human_name": "Decoding"
          }
        },
        "fd": {
          "description": "The file descriptor number to read from.",
          "type": "integer",
          "maximum": 4294967295.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::examples": 10,
            "docs::human_name": "File Descriptor Number"
          }
        },
        "framing": {
          "$ref": "#/definitions/core::option::Option<codecs::decoding::FramingConfig>",
          "_metadata": {
            "docs::human_name": "Framing"
          }
        },
        "host_key": {
          "title": "Overrides the name of the log field used to add the current hostname to each event.",
          "description": "By default, the [global `host_key` option](https://vector.dev/docs/reference/configuration//global-options#log_schema.host_key) is used.",
          "$ref": "#/definitions/core::option::Option<vector_lookup::lookup_v2::optional_path::OptionalValuePath>",
          "_metadata": {
            "docs::human_name": "Host Key"
          }
        },
        "log_namespace": {
          "description": "The namespace to use for logs. This overrides the global setting.",
          "default": null,
          "type": [
            "boolean",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::hidden": true,
            "docs::human_name": "Log Namespace"
          }
        },
        "max_length": {
          "title": "The maximum buffer size, in bytes, of incoming messages.",
          "description": "Messages larger than this are truncated.",
          "default": 102400,
          "type": "integer",
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::type_unit": "bytes",
            "docs::human_name": "Max Length"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "file_descriptor"
      }
    },
    "vector::sources::file_descriptors::stdin::StdinConfig": {
      "description": "Configuration for the `stdin` source.",
      "default": {
        "max_length": 102400,
        "host_key": null,
        "framing": null,
        "decoding": {
          "codec": "bytes"
        },
        "log_namespace": null
      },
      "type": "object",
      "properties": {
        "decoding": {
          "description": "Configures how events are decoded from raw bytes.",
          "default": {
            "codec": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::DeserializerConfig",
          "_metadata": {
            "docs::human_name": "Decoding"
          }
        },
        "framing": {
          "$ref": "#/definitions/core::option::Option<codecs::decoding::FramingConfig>",
          "_metadata": {
            "docs::human_name": "Framing"
          }
        },
        "host_key": {
          "title": "Overrides the name of the log field used to add the current hostname to each event.",
          "description": "By default, the [global `log_schema.host_key` option][global_host_key] is used.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
          "$ref": "#/definitions/core::option::Option<vector_lookup::lookup_v2::optional_path::OptionalValuePath>",
          "_metadata": {
            "docs::human_name": "Host Key"
          }
        },
        "log_namespace": {
          "description": "The namespace to use for logs. This overrides the global setting.",
          "default": null,
          "type": [
            "boolean",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::hidden": true,
            "docs::human_name": "Log Namespace"
          }
        },
        "max_length": {
          "title": "The maximum buffer size, in bytes, of incoming messages.",
          "description": "Messages larger than this are truncated.",
          "default": 102400,
          "type": "integer",
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::type_unit": "bytes",
            "docs::human_name": "Max Length"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "stdin"
      }
    },
    "vector::sources::fluent::FluentConfig": {
      "description": "Configuration for the `fluent` source.",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled by this source.",
          "description": "This setting is **deprecated** in favor of enabling `acknowledgements` at the [global][global_acks] or sink level.\n\nEnabling or disabling acknowledgements at the source level has **no effect** on acknowledgement behavior.\n\nSee [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::SourceAcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "address": {
          "title": "The socket address to listen for connections on, or `systemd{#N}` to use the Nth socket passed by\nsystemd socket activation.",
          "description": "If a socket address is used, it _must_ include a port.",
          "$ref": "#/definitions/vector::sources::util::net::SocketListenAddr",
          "_metadata": {
            "docs::human_name": "Address"
          }
        },
        "connection_limit": {
          "description": "The maximum number of TCP connections that are allowed at any given time.",
          "type": [
            "integer",
            "null"
          ],
          "maximum": 4294967295.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "connections",
            "docs::human_name": "Connection Limit"
          }
        },
        "keepalive": {
          "$ref": "#/definitions/core::option::Option<vector_core::tcp::TcpKeepaliveConfig>",
          "_metadata": {
            "docs::human_name": "Keepalive"
          }
        },
        "log_namespace": {
          "description": "The namespace to use for logs. This overrides the global setting.",
          "default": null,
          "type": [
            "boolean",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::hidden": true,
            "docs::human_name": "Log Namespace"
          }
        },
        "receive_buffer_bytes": {
          "title": "The size of the receive buffer used for each connection.",
          "description": "This generally should not need to be changed.",
          "type": [
            "integer",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "bytes",
            "docs::examples": 65536,
            "docs::human_name": "Receive Buffer Bytes"
          }
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsSourceConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "fluent"
      }
    },
    "vector::sources::gcp_pubsub::PubsubConfig": {
      "description": "Configuration for the `gcp_pubsub` source.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "project",
            "subscription"
          ],
          "properties": {
            "ack_deadline_seconds": {
              "title": "The acknowledgement deadline, in seconds, to use for this stream.",
              "description": "Messages that are not acknowledged when this deadline expires may be retransmitted.",
              "deprecated": true,
              "type": [
                "integer",
                "null"
              ],
              "maximum": 65535.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::optional": true,
                "deprecated_message": "This option has been deprecated, use `ack_deadline_secs` instead.",
                "docs::human_name": "Ack Deadline Seconds"
              }
            },
            "ack_deadline_secs": {
              "title": "The acknowledgement deadline, in seconds, to use for this stream.",
              "description": "Messages that are not acknowledged when this deadline expires may be retransmitted.",
              "default": 600,
              "$ref": "#/definitions/serde_with::DurationSeconds",
              "_metadata": {
                "docs::human_name": "Acknowledgement Deadline"
              }
            },
            "acknowledgements": {
              "title": "Controls how acknowledgements are handled by this source.",
              "description": "This setting is **deprecated** in favor of enabling `acknowledgements` at the [global][global_acks] or sink level.\n\nEnabling or disabling acknowledgements at the source level has **no effect** on acknowledgement behavior.\n\nSee [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::SourceAcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              }
            },
            "decoding": {
              "description": "Configures how events are decoded from raw bytes.",
              "default": {
                "codec": "bytes"
              },
              "$ref": "#/definitions/codecs::decoding::DeserializerConfig",
              "_metadata": {
                "docs::human_name": "Decoding"
              }
            },
            "endpoint": {
              "description": "The endpoint from which to pull data.",
              "default": "https://pubsub.googleapis.com",
              "type": "string",
              "_metadata": {
                "docs::examples": "https://us-central1-pubsub.googleapis.com",
                "docs::human_name": "Endpoint"
              }
            },
            "framing": {
              "title": "Framing configuration.",
              "description": "Framing handles how events are separated when encoded in a raw byte form, where each event is\na frame that must be prefixed, or delimited, in a way that marks where an event begins and\nends within the byte stream.",
              "default": {
                "method": "bytes"
              },
              "$ref": "#/definitions/codecs::decoding::FramingConfig",
              "_metadata": {
                "docs::human_name": "Framing"
              }
            },
            "full_response_size": {
              "title": "The number of messages in a response to mark a stream as\n\"busy\". This is used to determine if more streams should be\nstarted.",
              "description": "The GCP Pub/Sub servers send responses with 100 or more messages when\nthe subscription is busy.",
              "default": 100,
              "type": "integer",
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::human_name": "Full Response Size"
              }
            },
            "keepalive_secs": {
              "description": "The amount of time, in seconds, with no received activity\nbefore sending a keepalive request. If this is set larger than\n`60`, you may see periodic errors sent from the server.",
              "default": 60.0,
              "$ref": "#/definitions/serde_with::DurationFractionalSeconds",
              "_metadata": {
                "docs::human_name": "Keepalive"
              }
            },
            "log_namespace": {
              "description": "The namespace to use for logs. This overrides the global setting.",
              "default": null,
              "type": [
                "boolean",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::hidden": true,
                "docs::human_name": "Log Namespace"
              }
            },
            "max_concurrency": {
              "description": "The maximum number of concurrent stream connections to open at once.",
              "default": 10,
              "type": "integer",
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::human_name": "Max Concurrency"
              }
            },
            "poll_time_seconds": {
              "description": "How often to poll the currently active streams to see if they\nare all busy and so open a new stream.",
              "default": 2.0,
              "$ref": "#/definitions/serde_with::DurationFractionalSeconds",
              "_metadata": {
                "docs::human_name": "Poll Time"
              }
            },
            "project": {
              "description": "The project name from which to pull logs.",
              "type": "string",
              "_metadata": {
                "docs::human_name": "Project"
              }
            },
            "retry_delay_seconds": {
              "description": "The amount of time, in seconds, to wait between retry attempts after an error.",
              "deprecated": true,
              "type": [
                "number",
                "null"
              ],
              "maximum": 9007199254740991.0,
              "minimum": -9007199254740991.0,
              "_metadata": {
                "docs::numeric_type": "float",
                "docs::optional": true,
                "deprecated_message": "This option has been deprecated, use `retry_delay_secs` instead.",
                "docs::human_name": "Retry Delay Seconds"
              }
            },
            "retry_delay_secs": {
              "description": "The amount of time, in seconds, to wait between retry attempts after an error.",
              "default": 1.0,
              "$ref": "#/definitions/serde_with::DurationFractionalSeconds",
              "_metadata": {
                "docs::human_name": "Retry Delay"
              }
            },
            "subscription": {
              "description": "The subscription within the project which is configured to receive logs.",
              "type": "string",
              "_metadata": {
                "docs::human_name": "Subscription"
              }
            },
            "tls": {
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              }
            }
          }
        },
        {
          "description": "Configuration of the authentication strategy for interacting with GCP services.",
          "$ref": "#/definitions/vector::gcp::GcpAuthConfig"
        }
      ],
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "gcp_pubsub"
      }
    },
    "vector::sources::heroku_logs::LogplexConfig": {
      "description": "Configuration for `heroku_logs` source.",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled by this source.",
          "description": "This setting is **deprecated** in favor of enabling `acknowledgements` at the [global][global_acks] or sink level.\n\nEnabling or disabling acknowledgements at the source level has **no effect** on acknowledgement behavior.\n\nSee [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::SourceAcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "address": {
          "description": "The socket address to listen for connections on.",
          "$ref": "#/definitions/stdlib::SocketAddr",
          "_metadata": {
            "docs::examples": [
              "0.0.0.0:80",
              "localhost:80"
            ],
            "docs::human_name": "Address"
          }
        },
        "auth": {
          "$ref": "#/definitions/core::option::Option<vector::sources::util::http::auth::HttpSourceAuthConfig>",
          "_metadata": {
            "docs::human_name": "Auth"
          }
        },
        "decoding": {
          "description": "Configures how events are decoded from raw bytes.",
          "default": {
            "codec": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::DeserializerConfig",
          "_metadata": {
            "docs::human_name": "Decoding"
          }
        },
        "framing": {
          "title": "Framing configuration.",
          "description": "Framing handles how events are separated when encoded in a raw byte form, where each event is\na frame that must be prefixed, or delimited, in a way that marks where an event begins and\nends within the byte stream.",
          "default": {
            "method": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::FramingConfig",
          "_metadata": {
            "docs::human_name": "Framing"
          }
        },
        "log_namespace": {
          "description": "The namespace to use for logs. This overrides the global setting.",
          "default": null,
          "type": [
            "boolean",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::hidden": true,
            "docs::human_name": "Log Namespace"
          }
        },
        "query_parameters": {
          "title": "A list of URL query parameters to include in the log event.",
          "description": "These override any values included in the body with conflicting names.",
          "default": [],
          "type": "array",
          "items": {
            "type": "string"
          },
          "_metadata": {
            "docs::examples": [
              "application",
              "source"
            ],
            "docs::human_name": "Query Parameters"
          }
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "heroku_logs"
      }
    },
    "vector::sources::host_metrics::FilterList": {
      "description": "Filtering configuration.",
      "type": "object",
      "properties": {
        "excludes": {
          "title": "Any patterns which should be excluded.",
          "description": "The patterns are matched using globbing.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "title": "A compiled Unix shell-style pattern.",
            "description": "- `?` matches any single character.\n- `*` matches any (possibly empty) sequence of characters.\n- `**` matches the current directory and arbitrary subdirectories. This sequence must form a single path component,\n  so both `**a` and `b**` are invalid and will result in an error. A sequence of more than two consecutive `*`\n  characters is also invalid.\n- `[...]` matches any character inside the brackets. Character sequences can also specify ranges of characters, as\n  ordered by Unicode, so e.g. `[0-9]` specifies any character between 0 and 9 inclusive. An unclosed bracket is\n  invalid.\n- `[!...]` is the negation of `[...]`, i.e. it matches any characters not in the brackets.\n\nThe metacharacters `?`, `*`, `[`, `]` can be matched by using brackets (e.g. `[?]`). When a `]` occurs immediately\nfollowing `[` or `[!` then it is interpreted as being part of, rather then ending, the character set, so `]` and NOT\n`]` can be matched by `[]]` and `[!]]` respectively. The `-` character can be specified inside a character sequence\npattern by placing it at the start or the end, e.g. `[abc-]`.",
            "type": "string"
          },
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Excludes"
          }
        },
        "includes": {
          "title": "Any patterns which should be included.",
          "description": "The patterns are matched using globbing.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "title": "A compiled Unix shell-style pattern.",
            "description": "- `?` matches any single character.\n- `*` matches any (possibly empty) sequence of characters.\n- `**` matches the current directory and arbitrary subdirectories. This sequence must form a single path component,\n  so both `**a` and `b**` are invalid and will result in an error. A sequence of more than two consecutive `*`\n  characters is also invalid.\n- `[...]` matches any character inside the brackets. Character sequences can also specify ranges of characters, as\n  ordered by Unicode, so e.g. `[0-9]` specifies any character between 0 and 9 inclusive. An unclosed bracket is\n  invalid.\n- `[!...]` is the negation of `[...]`, i.e. it matches any characters not in the brackets.\n\nThe metacharacters `?`, `*`, `[`, `]` can be matched by using brackets (e.g. `[?]`). When a `]` occurs immediately\nfollowing `[` or `[!` then it is interpreted as being part of, rather then ending, the character set, so `]` and NOT\n`]` can be matched by `[]]` and `[!]]` respectively. The `-` character can be specified inside a character sequence\npattern by placing it at the start or the end, e.g. `[abc-]`.",
            "type": "string"
          },
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Includes"
          }
        }
      },
      "unevaluatedProperties": false
    },
    "vector::sources::host_metrics::HostMetricsConfig": {
      "description": "Configuration for the `host_metrics` source.",
      "type": "object",
      "properties": {
        "cgroups": {
          "title": "Options for the cgroups (controller groups) metrics collector.",
          "description": "This collector is only available on Linux systems, and only supports either version 2 or hybrid cgroups.",
          "default": {
            "levels": 100,
            "base": null,
            "groups": {
              "includes": null,
              "excludes": null
            }
          },
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "Options for the cgroups (controller groups) metrics collector.",
              "description": "This collector is only available on Linux systems, and only supports either version 2 or hybrid cgroups.",
              "default": {
                "levels": 100,
                "base": null,
                "groups": {
                  "includes": null,
                  "excludes": null
                }
              },
              "type": "object",
              "properties": {
                "base": {
                  "description": "The base cgroup name to provide metrics for.",
                  "$ref": "#/definitions/core::option::Option<std::path::PathBuf>",
                  "_metadata": {
                    "docs::examples": [
                      "/",
                      "system.slice/snapd.service"
                    ],
                    "docs::human_name": "Base"
                  }
                },
                "base_dir": {
                  "description": "Base cgroup directory, for testing use only",
                  "$ref": "#/definitions/core::option::Option<std::path::PathBuf>",
                  "_metadata": {
                    "docs::hidden": true,
                    "docs::human_name": "Base Directory"
                  }
                },
                "groups": {
                  "description": "Lists of cgroup name patterns to include or exclude in gathering\nusage metrics.",
                  "default": {
                    "includes": [
                      "*"
                    ],
                    "excludes": null
                  },
                  "$ref": "#/definitions/vector::sources::host_metrics::FilterList",
                  "_metadata": {
                    "docs::examples": {
                      "includes": [
                        "user.slice/*"
                      ],
                      "excludes": [
                        "*.service"
                      ]
                    },
                    "docs::human_name": "Groups"
                  }
                },
                "levels": {
                  "title": "The number of levels of the cgroups hierarchy for which to report metrics.",
                  "description": "A value of `1` means the root or named cgroup.",
                  "default": 100,
                  "type": "integer",
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::examples": [
                      1,
                      3
                    ],
                    "docs::human_name": "Levels"
                  }
                }
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Cgroups"
          }
        },
        "collectors": {
          "title": "The list of host metric collector services to use.",
          "description": "Defaults to all collectors.",
          "default": [
            "cpu",
            "disk",
            "filesystem",
            "load",
            "host",
            "memory",
            "network",
            "cgroups"
          ],
          "type": [
            "array",
            "null"
          ],
          "items": {
            "description": "Collector types.",
            "oneOf": [
              {
                "title": "Metrics related to Linux control groups.",
                "description": "Only available on Linux.",
                "const": "cgroups",
                "_metadata": {
                  "logical_name": "CGroups",
                  "docs::human_name": "C Groups"
                }
              },
              {
                "description": "Metrics related to CPU utilization.",
                "const": "cpu",
                "_metadata": {
                  "logical_name": "Cpu",
                  "docs::human_name": "CPU"
                }
              },
              {
                "description": "Metrics related to disk I/O utilization.",
                "const": "disk",
                "_metadata": {
                  "logical_name": "Disk",
                  "docs::human_name": "Disk"
                }
              },
              {
                "description": "Metrics related to filesystem space utilization.",
                "const": "filesystem",
                "_metadata": {
                  "logical_name": "Filesystem",
                  "docs::human_name": "Filesystem"
                }
              },
              {
                "description": "Metrics related to the system load average.",
                "const": "load",
                "_metadata": {
                  "logical_name": "Load",
                  "docs::human_name": "Load"
                }
              },
              {
                "description": "Metrics related to the host.",
                "const": "host",
                "_metadata": {
                  "logical_name": "Host",
                  "docs::human_name": "Host"
                }
              },
              {
                "description": "Metrics related to memory utilization.",
                "const": "memory",
                "_metadata": {
                  "logical_name": "Memory",
                  "docs::human_name": "Memory"
                }
              },
              {
                "description": "Metrics related to network utilization.",
                "const": "network",
                "_metadata": {
                  "logical_name": "Network",
                  "docs::human_name": "Network"
                }
              }
            ],
            "unevaluatedProperties": false,
            "_metadata": {
              "docs::enum_tagging": "external"
            }
          },
          "_metadata": {
            "docs::enum_tagging": "external",
            "docs::optional": true,
            "docs::examples": [
              "cgroups",
              "cpu",
              "disk",
              "filesystem",
              "load",
              "host",
              "memory",
              "network"
            ],
            "docs::human_name": "Collectors"
          }
        },
        "disk": {
          "description": "Options for the disk metrics collector.",
          "default": {
            "devices": {
              "includes": null,
              "excludes": null
            }
          },
          "type": "object",
          "properties": {
            "devices": {
              "description": "Lists of device name patterns to include or exclude in gathering\nI/O utilization metrics.",
              "default": {
                "includes": [
                  "*"
                ],
                "excludes": null
              },
              "$ref": "#/definitions/vector::sources::host_metrics::FilterList",
              "_metadata": {
                "docs::examples": {
                  "includes": [
                    "sda"
                  ],
                  "excludes": [
                    "dm-*"
                  ]
                },
                "docs::human_name": "Devices"
              }
            }
          },
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::human_name": "Disk"
          }
        },
        "filesystem": {
          "description": "Options for the filesystem metrics collector.",
          "default": {
            "devices": {
              "includes": null,
              "excludes": null
            },
            "filesystems": {
              "includes": null,
              "excludes": null
            },
            "mountpoints": {
              "includes": null,
              "excludes": null
            }
          },
          "type": "object",
          "properties": {
            "devices": {
              "description": "Lists of device name patterns to include or exclude in gathering\nusage metrics.",
              "default": {
                "includes": [
                  "*"
                ],
                "excludes": null
              },
              "$ref": "#/definitions/vector::sources::host_metrics::FilterList",
              "_metadata": {
                "docs::examples": {
                  "includes": [
                    "sda"
                  ],
                  "excludes": [
                    "dm-*"
                  ]
                },
                "docs::human_name": "Devices"
              }
            },
            "filesystems": {
              "description": "Lists of filesystem name patterns to include or exclude in gathering\nusage metrics.",
              "default": {
                "includes": [
                  "*"
                ],
                "excludes": null
              },
              "$ref": "#/definitions/vector::sources::host_metrics::FilterList",
              "_metadata": {
                "docs::examples": {
                  "includes": [
                    "ntfs"
                  ],
                  "excludes": [
                    "ext*"
                  ]
                },
                "docs::human_name": "Filesystems"
              }
            },
            "mountpoints": {
              "description": "Lists of mount point path patterns to include or exclude in gathering\nusage metrics.",
              "default": {
                "includes": [
                  "*"
                ],
                "excludes": null
              },
              "$ref": "#/definitions/vector::sources::host_metrics::FilterList",
              "_metadata": {
                "docs::examples": {
                  "includes": [
                    "/home"
                  ],
                  "excludes": [
                    "/raid*"
                  ]
                },
                "docs::human_name": "Mountpoints"
              }
            }
          },
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::human_name": "Filesystem"
          }
        },
        "namespace": {
          "description": "Overrides the default namespace for the metrics emitted by the source.",
          "default": "host",
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Namespace"
          }
        },
        "network": {
          "description": "Options for the network metrics collector.",
          "default": {
            "devices": {
              "includes": null,
              "excludes": null
            }
          },
          "type": "object",
          "properties": {
            "devices": {
              "description": "Lists of device name patterns to include or exclude in gathering\nnetwork utilization metrics.",
              "default": {
                "includes": [
                  "*"
                ],
                "excludes": null
              },
              "$ref": "#/definitions/vector::sources::host_metrics::FilterList",
              "_metadata": {
                "docs::examples": {
                  "includes": [
                    "sda"
                  ],
                  "excludes": [
                    "dm-*"
                  ]
                },
                "docs::human_name": "Devices"
              }
            }
          },
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::human_name": "Network"
          }
        },
        "scrape_interval_secs": {
          "description": "The interval between metric gathering, in seconds.",
          "default": 15,
          "$ref": "#/definitions/serde_with::DurationSeconds",
          "_metadata": {
            "docs::human_name": "Scrape Interval"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "host_metrics"
      }
    },
    "vector::sources::http_client::client::HttpClientConfig": {
      "description": "Configuration for the `http_client` source.",
      "type": "object",
      "required": [
        "endpoint"
      ],
      "properties": {
        "auth": {
          "description": "HTTP Authentication.",
          "$ref": "#/definitions/core::option::Option<vector::http::Auth>",
          "_metadata": {
            "docs::human_name": "Auth"
          }
        },
        "decoding": {
          "description": "Decoder to use on the HTTP responses.",
          "default": {
            "codec": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::DeserializerConfig",
          "_metadata": {
            "docs::human_name": "Decoding"
          }
        },
        "endpoint": {
          "title": "The HTTP endpoint to collect events from.",
          "description": "The full path must be specified.",
          "type": "string",
          "_metadata": {
            "docs::examples": "http://127.0.0.1:9898/logs",
            "docs::human_name": "Endpoint"
          }
        },
        "framing": {
          "description": "Framing to use in the decoding.",
          "default": {
            "method": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::FramingConfig",
          "_metadata": {
            "docs::human_name": "Framing"
          }
        },
        "headers": {
          "title": "Headers to apply to the HTTP requests.",
          "description": "One or more values for the same header can be provided.",
          "default": {},
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "_metadata": {
            "docs::additional_props_description": "An HTTP request header and it's value(s).",
            "docs::examples": {
              "X-My-Custom-Header": [
                "a",
                "vector",
                "of",
                "values"
              ],
              "Accept": [
                "text/plain",
                "text/html"
              ]
            },
            "docs::human_name": "Headers"
          }
        },
        "log_namespace": {
          "description": "The namespace to use for logs. This overrides the global setting.",
          "default": null,
          "type": [
            "boolean",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::hidden": true,
            "docs::human_name": "Log Namespace"
          }
        },
        "method": {
          "description": "Specifies the method of the HTTP request.",
          "default": "GET",
          "$ref": "#/definitions/vector::sources::util::http::method::HttpMethod",
          "_metadata": {
            "docs::human_name": "Method"
          }
        },
        "query": {
          "title": "Custom parameters for the HTTP request query string.",
          "description": "One or more values for the same parameter key can be provided.\n\nThe parameters provided in this option are appended to any parameters\nmanually provided in the `endpoint` option.",
          "default": {},
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "_metadata": {
            "docs::additional_props_description": "A query string parameter and it's value(s).",
            "docs::examples": {
              "field": [
                "value"
              ],
              "fruit": [
                "mango",
                "papaya",
                "kiwi"
              ]
            },
            "docs::human_name": "Query"
          }
        },
        "scrape_interval_secs": {
          "description": "The interval between scrapes. Requests are run concurrently so if a scrape takes longer\nthan the interval a new scrape will be started. This can take extra resources, set the timeout\nto a value lower than the scrape interval to prevent this from happening.",
          "default": 15,
          "$ref": "#/definitions/serde_with::DurationSeconds",
          "_metadata": {
            "docs::human_name": "Scrape Interval"
          }
        },
        "scrape_timeout_secs": {
          "description": "The timeout for each scrape request.",
          "default": 5.0,
          "$ref": "#/definitions/serde_with::DurationFractionalSeconds",
          "_metadata": {
            "docs::human_name": "Scrape Timeout"
          }
        },
        "tls": {
          "description": "TLS configuration.",
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "http_client"
      }
    },
    "vector::sources::http_server::HttpConfig": {
      "description": "Configuration for the `http` source.",
      "$ref": "#/definitions/vector::sources::http_server::SimpleHttpConfig",
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "http",
        "deprecated": true
      }
    },
    "vector::sources::http_server::SimpleHttpConfig": {
      "description": "Configuration for the `http_server` source.",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled by this source.",
          "description": "This setting is **deprecated** in favor of enabling `acknowledgements` at the [global][global_acks] or sink level.\n\nEnabling or disabling acknowledgements at the source level has **no effect** on acknowledgement behavior.\n\nSee [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::SourceAcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "address": {
          "title": "The socket address to listen for connections on.",
          "description": "It _must_ include a port.",
          "$ref": "#/definitions/stdlib::SocketAddr",
          "_metadata": {
            "docs::examples": [
              "0.0.0.0:80",
              "localhost:80"
            ],
            "docs::human_name": "Address"
          }
        },
        "auth": {
          "$ref": "#/definitions/core::option::Option<vector::sources::util::http::auth::HttpSourceAuthConfig>",
          "_metadata": {
            "docs::human_name": "Auth"
          }
        },
        "decoding": {
          "description": "Configures how events are decoded from raw bytes.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "description": "Configures how events are decoded from raw bytes.",
              "oneOf": [
                {
                  "description": "Uses the raw bytes as-is.",
                  "type": "object",
                  "required": [
                    "codec"
                  ],
                  "properties": {
                    "codec": {
                      "description": "Uses the raw bytes as-is.",
                      "const": "bytes",
                      "_metadata": {
                        "docs::human_name": "Codec"
                      }
                    }
                  },
                  "_metadata": {
                    "logical_name": "Bytes",
                    "docs::human_name": "Bytes"
                  }
                },
                {
                  "title": "Decodes the raw bytes as [JSON][json].",
                  "description": "[json]: https://www.json.org/",
                  "allOf": [
                    {
                      "description": "Config used to build a `JsonDeserializer`.",
                      "type": "object",
                      "properties": {
                        "json": {
                          "description": "JSON-specific decoding options.",
                          "default": {
                            "lossy": true
                          },
                          "type": "object",
                          "properties": {
                            "lossy": {
                              "title": "Determines whether or not to replace invalid UTF-8 sequences instead of failing.",
                              "description": "When true, invalid UTF-8 sequences are replaced with the [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD].\n\n[U+FFFD]: https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character",
                              "default": true,
                              "type": "boolean",
                              "_metadata": {
                                "docs::human_name": "Lossy"
                              }
                            }
                          },
                          "unevaluatedProperties": false,
                          "_metadata": {
                            "docs::human_name": "JSON"
                          }
                        }
                      }
                    },
                    {
                      "type": "object",
                      "required": [
                        "codec"
                      ],
                      "properties": {
                        "codec": {
                          "title": "Decodes the raw bytes as [JSON][json].",
                          "description": "[json]: https://www.json.org/",
                          "const": "json",
                          "_metadata": {
                            "docs::human_name": "Codec"
                          }
                        }
                      }
                    }
                  ],
                  "_metadata": {
                    "logical_name": "Json",
                    "docs::human_name": "JSON"
                  }
                },
                {
                  "title": "Decodes the raw bytes as [protobuf][protobuf].",
                  "description": "[protobuf]: https://protobuf.dev/",
                  "allOf": [
                    {
                      "description": "Config used to build a `ProtobufDeserializer`.",
                      "type": "object",
                      "properties": {
                        "protobuf": {
                          "description": "Protobuf-specific decoding options.",
                          "default": {
                            "desc_file": "",
                            "message_type": ""
                          },
                          "type": "object",
                          "required": [
                            "desc_file",
                            "message_type"
                          ],
                          "properties": {
                            "desc_file": {
                              "description": "Path to desc file",
                              "$ref": "#/definitions/stdlib::PathBuf",
                              "_metadata": {
                                "docs::human_name": "Desc File"
                              }
                            },
                            "message_type": {
                              "description": "message type. e.g package.message",
                              "type": "string",
                              "_metadata": {
                                "docs::human_name": "Message Type"
                              }
                            }
                          },
                          "unevaluatedProperties": false,
                          "_metadata": {
                            "docs::human_name": "Protobuf"
                          }
                        }
                      }
                    },
                    {
                      "type": "object",
                      "required": [
                        "codec"
                      ],
                      "properties": {
                        "codec": {
                          "title": "Decodes the raw bytes as [protobuf][protobuf].",
                          "description": "[protobuf]: https://protobuf.dev/",
                          "const": "protobuf",
                          "_metadata": {
                            "docs::human_name": "Codec"
                          }
                        }
                      }
                    }
                  ],
                  "_metadata": {
                    "logical_name": "Protobuf",
                    "docs::human_name": "Protobuf"
                  }
                },
                {
                  "title": "Decodes the raw bytes as a Syslog message.",
                  "description": "Decodes either as the [RFC 3164][rfc3164]-style format (\"old\" style) or the\n[RFC 5424][rfc5424]-style format (\"new\" style, includes structured data).\n\n[rfc3164]: https://www.ietf.org/rfc/rfc3164.txt\n[rfc5424]: https://www.ietf.org/rfc/rfc5424.txt",
                  "allOf": [
                    {
                      "description": "Config used to build a `SyslogDeserializer`.",
                      "type": "object",
                      "properties": {
                        "syslog": {
                          "description": "Syslog-specific decoding options.",
                          "default": {
                            "lossy": true
                          },
                          "type": "object",
                          "properties": {
                            "lossy": {
                              "title": "Determines whether or not to replace invalid UTF-8 sequences instead of failing.",
                              "description": "When true, invalid UTF-8 sequences are replaced with the [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD].\n\n[U+FFFD]: https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character",
                              "default": true,
                              "type": "boolean",
                              "_metadata": {
                                "docs::human_name": "Lossy"
                              }
                            }
                          },
                          "unevaluatedProperties": false,
                          "_metadata": {
                            "docs::human_name": "Syslog"
                          }
                        }
                      }
                    },
                    {
                      "type": "object",
                      "required": [
                        "codec"
                      ],
                      "properties": {
                        "codec": {
                          "title": "Decodes the raw bytes as a Syslog message.",
                          "description": "Decodes either as the [RFC 3164][rfc3164]-style format (\"old\" style) or the\n[RFC 5424][rfc5424]-style format (\"new\" style, includes structured data).\n\n[rfc3164]: https://www.ietf.org/rfc/rfc3164.txt\n[rfc5424]: https://www.ietf.org/rfc/rfc5424.txt",
                          "const": "syslog",
                          "_metadata": {
                            "docs::human_name": "Codec"
                          }
                        }
                      }
                    }
                  ],
                  "_metadata": {
                    "logical_name": "Syslog",
                    "docs::human_name": "Syslog"
                  }
                },
                {
                  "title": "Decodes the raw bytes as Vector’s [native Protocol Buffers format][vector_native_protobuf].",
                  "description": "This codec is **[experimental][experimental]**.\n\n[vector_native_protobuf]: https://github.com/vectordotdev/vector/blob/master/lib/vector-core/proto/event.proto\n[experimental]: https://vector.dev/highlights/2022-03-31-native-event-codecs",
                  "type": "object",
                  "required": [
                    "codec"
                  ],
                  "properties": {
                    "codec": {
                      "title": "Decodes the raw bytes as Vector’s [native Protocol Buffers format][vector_native_protobuf].",
                      "description": "This codec is **[experimental][experimental]**.\n\n[vector_native_protobuf]: https://github.com/vectordotdev/vector/blob/master/lib/vector-core/proto/event.proto\n[experimental]: https://vector.dev/highlights/2022-03-31-native-event-codecs",
                      "const": "native",
                      "_metadata": {
                        "docs::human_name": "Codec"
                      }
                    }
                  },
                  "_metadata": {
                    "logical_name": "Native",
                    "docs::human_name": "Native"
                  }
                },
                {
                  "title": "Decodes the raw bytes as Vector’s [native JSON format][vector_native_json].",
                  "description": "This codec is **[experimental][experimental]**.\n\n[vector_native_json]: https://github.com/vectordotdev/vector/blob/master/lib/codecs/tests/data/native_encoding/schema.cue\n[experimental]: https://vector.dev/highlights/2022-03-31-native-event-codecs",
                  "allOf": [
                    {
                      "description": "Config used to build a `NativeJsonDeserializer`.",
                      "type": "object",
                      "properties": {
                        "native_json": {
                          "description": "Vector's native JSON-specific decoding options.",
                          "default": {
                            "lossy": true
                          },
                          "type": "object",
                          "properties": {
                            "lossy": {
                              "title": "Determines whether or not to replace invalid UTF-8 sequences instead of failing.",
                              "description": "When true, invalid UTF-8 sequences are replaced with the [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD].\n\n[U+FFFD]: https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character",
                              "default": true,
                              "type": "boolean",
                              "_metadata": {
                                "docs::human_name": "Lossy"
                              }
                            }
                          },
                          "unevaluatedProperties": false,
                          "_metadata": {
                            "docs::human_name": "Native JSON"
                          }
                        }
                      }
                    },
                    {
                      "type": "object",
                      "required": [
                        "codec"
                      ],
                      "properties": {
                        "codec": {
                          "title": "Decodes the raw bytes as Vector’s [native JSON format][vector_native_json].",
                          "description": "This codec is **[experimental][experimental]**.\n\n[vector_native_json]: https://github.com/vectordotdev/vector/blob/master/lib/codecs/tests/data/native_encoding/schema.cue\n[experimental]: https://vector.dev/highlights/2022-03-31-native-event-codecs",
                          "const": "native_json",
                          "_metadata": {
                            "docs::human_name": "Codec"
                          }
                        }
                      }
                    }
                  ],
                  "_metadata": {
                    "logical_name": "NativeJson",
                    "docs::human_name": "Native JSON"
                  }
                },
                {
                  "title": "Decodes the raw bytes as a [GELF][gelf] message.",
                  "description": "[gelf]: https://docs.graylog.org/docs/gelf",
                  "allOf": [
                    {
                      "description": "On GELF decoding behavior:\n  Graylog has a relaxed decoding. They are much more lenient than the spec would\n  suggest. We've elected to take a more strict approach to maintain backwards compatability\n  in the event that we need to change the behavior to be more relaxed, so that prior versions\n  of vector will still work with the new relaxed decoding.\nConfig used to build a `GelfDeserializer`.",
                      "type": "object",
                      "properties": {
                        "gelf": {
                          "description": "GELF-specific decoding options.",
                          "default": {
                            "lossy": true
                          },
                          "type": "object",
                          "properties": {
                            "lossy": {
                              "title": "Determines whether or not to replace invalid UTF-8 sequences instead of failing.",
                              "description": "When true, invalid UTF-8 sequences are replaced with the [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD].\n\n[U+FFFD]: https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character",
                              "default": true,
                              "type": "boolean",
                              "_metadata": {
                                "docs::human_name": "Lossy"
                              }
                            }
                          },
                          "unevaluatedProperties": false,
                          "_metadata": {
                            "docs::human_name": "GELF"
                          }
                        }
                      }
                    },
                    {
                      "type": "object",
                      "required": [
                        "codec"
                      ],
                      "properties": {
                        "codec": {
                          "title": "Decodes the raw bytes as a [GELF][gelf] message.",
                          "description": "[gelf]: https://docs.graylog.org/docs/gelf",
                          "const": "gelf",
                          "_metadata": {
                            "docs::human_name": "Codec"
                          }
                        }
                      }
                    }
                  ],
                  "_metadata": {
                    "logical_name": "Gelf",
                    "docs::human_name": "GELF"
                  }
                }
              ],
              "_metadata": {
                "docs::enum_tag_description": "The codec to use for decoding events.",
                "docs::enum_tagging": "internal",
                "docs::enum_tag_field": "codec"
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Decoding"
          }
        },
        "encoding": {
          "title": "The expected encoding of received data.",
          "description": "For `json` and `ndjson` encodings, the fields of the JSON objects are output as separate fields.",
          "default": null,
          "oneOf": [
            {
              "type": "null"
            },
            {
              "description": "Content encoding.",
              "oneOf": [
                {
                  "description": "Plaintext.",
                  "const": "text",
                  "_metadata": {
                    "logical_name": "Text",
                    "docs::human_name": "Text"
                  }
                },
                {
                  "description": "Newline-delimited JSON.",
                  "const": "ndjson",
                  "_metadata": {
                    "logical_name": "Ndjson",
                    "docs::human_name": "NDJSON"
                  }
                },
                {
                  "description": "JSON.",
                  "const": "json",
                  "_metadata": {
                    "logical_name": "Json",
                    "docs::human_name": "JSON"
                  }
                },
                {
                  "description": "Binary.",
                  "const": "binary",
                  "_metadata": {
                    "logical_name": "Binary",
                    "docs::human_name": "Binary"
                  }
                }
              ],
              "_metadata": {
                "docs::enum_tagging": "external"
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Encoding"
          }
        },
        "framing": {
          "$ref": "#/definitions/core::option::Option<codecs::decoding::FramingConfig>",
          "_metadata": {
            "docs::human_name": "Framing"
          }
        },
        "headers": {
          "title": "A list of HTTP headers to include in the log event.",
          "description": "These override any values included in the JSON payload with conflicting names.",
          "default": [],
          "type": "array",
          "items": {
            "type": "string"
          },
          "_metadata": {
            "docs::examples": [
              "User-Agent",
              "X-My-Custom-Header"
            ],
            "docs::human_name": "Headers"
          }
        },
        "log_namespace": {
          "description": "The namespace to use for logs. This overrides the global setting.",
          "default": null,
          "type": [
            "boolean",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::hidden": true,
            "docs::human_name": "Log Namespace"
          }
        },
        "method": {
          "description": "Specifies the action of the HTTP request.",
          "default": "POST",
          "$ref": "#/definitions/vector::sources::util::http::method::HttpMethod",
          "_metadata": {
            "docs::human_name": "Method"
          }
        },
        "path": {
          "description": "The URL path on which log event POST requests are sent.",
          "default": "/",
          "type": "string",
          "_metadata": {
            "docs::examples": [
              "/event/path",
              "/logs"
            ],
            "docs::human_name": "Path"
          }
        },
        "path_key": {
          "description": "The event key in which the requested URL path used to send the request is stored.",
          "default": "path",
          "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
          "_metadata": {
            "docs::examples": "vector_http_path",
            "docs::human_name": "Path Key"
          }
        },
        "query_parameters": {
          "title": "A list of URL query parameters to include in the log event.",
          "description": "These override any values included in the body with conflicting names.",
          "default": [],
          "type": "array",
          "items": {
            "type": "string"
          },
          "_metadata": {
            "docs::examples": [
              "application",
              "source"
            ],
            "docs::human_name": "Query Parameters"
          }
        },
        "response_code": {
          "description": "Specifies the HTTP response status code that will be returned on successful requests.",
          "default": 200,
          "type": "integer",
          "maximum": 65535.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::examples": 202,
            "docs::numeric_type": "uint",
            "docs::human_name": "Response Code"
          }
        },
        "strict_path": {
          "title": "Whether or not to treat the configured `path` as an absolute path.",
          "description": "If set to `true`, only requests using the exact URL path specified in `path` are accepted. Otherwise,\nrequests sent to a URL path that starts with the value of `path` are accepted.\n\nWith `strict_path` set to `false` and `path` set to `\"\"`, the configured HTTP source accepts requests from\nany URL path.",
          "default": true,
          "type": "boolean",
          "_metadata": {
            "docs::human_name": "Strict Path"
          }
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "http_server"
      }
    },
    "vector::sources::internal_logs::InternalLogsConfig": {
      "description": "Configuration for the `internal_logs` source.",
      "type": "object",
      "properties": {
        "host_key": {
          "title": "Overrides the name of the log field used to add the current hostname to each event.",
          "description": "By default, the [global `log_schema.host_key` option][global_host_key] is used.\n\nSet to `\"\"` to suppress this key.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
          "default": "host",
          "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
          "_metadata": {
            "docs::human_name": "Host Key"
          }
        },
        "log_namespace": {
          "description": "The namespace to use for logs. This overrides the global setting.",
          "default": null,
          "type": [
            "boolean",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::hidden": true,
            "docs::human_name": "Log Namespace"
          }
        },
        "pid_key": {
          "title": "Overrides the name of the log field used to add the current process ID to each event.",
          "description": "By default, `\"pid\"` is used.\n\nSet to `\"\"` to suppress this key.",
          "default": "pid",
          "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
          "_metadata": {
            "docs::human_name": "PID Key"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "internal_logs"
      }
    },
    "vector::sources::internal_metrics::InternalMetricsConfig": {
      "description": "Configuration for the `internal_metrics` source.",
      "default": {
        "scrape_interval_secs": 1.0,
        "tags": {
          "host_key": "host",
          "pid_key": null
        },
        "namespace": "vector"
      },
      "type": "object",
      "properties": {
        "namespace": {
          "description": "Overrides the default namespace for the metrics emitted by the source.",
          "default": "vector",
          "type": "string",
          "_metadata": {
            "docs::human_name": "Namespace"
          }
        },
        "scrape_interval_secs": {
          "description": "The interval between metric gathering, in seconds.",
          "default": 1.0,
          "$ref": "#/definitions/serde_with::DurationFractionalSeconds",
          "_metadata": {
            "docs::human_name": "Scrape Interval"
          }
        },
        "tags": {
          "description": "Tag configuration for the `internal_metrics` source.",
          "default": {
            "host_key": "host",
            "pid_key": null
          },
          "type": "object",
          "properties": {
            "host_key": {
              "title": "Overrides the name of the tag used to add the peer host to each metric.",
              "description": "The value is the peer host's address, including the port. For example, `1.2.3.4:9000`.\n\nBy default, the [global `log_schema.host_key` option][global_host_key] is used.\n\nSet to `\"\"` to suppress this key.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
              "default": "host",
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
              "_metadata": {
                "docs::human_name": "Host Key"
              }
            },
            "pid_key": {
              "title": "Sets the name of the tag to use to add the current process ID to each metric.",
              "description": "By default, this is not set and the tag is not automatically added.",
              "type": [
                "string",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::examples": "pid",
                "docs::human_name": "PID Key"
              }
            }
          },
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::human_name": "Tags"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "internal_metrics"
      }
    },
    "vector::sources::journald::JournaldConfig": {
      "description": "Configuration for the `journald` source.",
      "type": "object",
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled by this source.",
          "description": "This setting is **deprecated** in favor of enabling `acknowledgements` at the [global][global_acks] or sink level.\n\nEnabling or disabling acknowledgements at the source level has **no effect** on acknowledgement behavior.\n\nSee [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::SourceAcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "batch_size": {
          "title": "The systemd journal is read in batches, and a checkpoint is set at the end of each batch.",
          "description": "This option limits the size of the batch.",
          "default": 16,
          "type": "integer",
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::type_unit": "events",
            "docs::human_name": "Batch Size"
          }
        },
        "current_boot_only": {
          "description": "Only include entries that occurred after the current boot of the system.",
          "default": true,
          "type": "boolean",
          "_metadata": {
            "docs::human_name": "Current Boot Only"
          }
        },
        "data_dir": {
          "title": "The directory used to persist file checkpoint positions.",
          "description": "By default, the global `data_dir` option is used. Make sure the running user has write\npermissions to this directory.",
          "default": null,
          "$ref": "#/definitions/core::option::Option<std::path::PathBuf>",
          "_metadata": {
            "docs::examples": "/var/lib/vector",
            "docs::human_name": "Data Directory"
          }
        },
        "exclude_matches": {
          "title": "A list of sets of field/value pairs that, if any are present in a journal entry,\nexcludes the entry from this source.",
          "description": "If `exclude_units` is specified, it is merged into this list.",
          "default": {},
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "uniqueItems": true
          },
          "_metadata": {
            "docs::additional_props_description": "The set of field values to match in journal entries that are to be excluded.",
            "docs::examples": {
              "_SYSTEMD_UNIT": [
                "sshd.service",
                "ntpd.service"
              ],
              "_TRANSPORT": [
                "kernel"
              ]
            },
            "docs::human_name": "Exclude Matches"
          }
        },
        "exclude_units": {
          "title": "A list of unit names to exclude from monitoring.",
          "description": "Unit names lacking a `.` have `.service` appended to make them a valid service unit\nname.",
          "default": [],
          "type": "array",
          "items": {
            "type": "string"
          },
          "_metadata": {
            "docs::examples": [
              "badservice",
              "sysinit.target"
            ],
            "docs::human_name": "Exclude Units"
          }
        },
        "include_matches": {
          "title": "A list of sets of field/value pairs to monitor.",
          "description": "If empty or not present, all journal fields are accepted.\n\nIf `include_units` is specified, it is merged into this list.",
          "default": {},
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "uniqueItems": true
          },
          "_metadata": {
            "docs::additional_props_description": "The set of field values to match in journal entries that are to be included.",
            "docs::examples": {
              "_SYSTEMD_UNIT": [
                "sshd.service",
                "ntpd.service"
              ],
              "_TRANSPORT": [
                "kernel"
              ]
            },
            "docs::human_name": "Include Matches"
          }
        },
        "include_units": {
          "title": "A list of unit names to monitor.",
          "description": "If empty or not present, all units are accepted.\n\nUnit names lacking a `.` have `.service` appended to make them a valid service unit name.",
          "default": [],
          "type": "array",
          "items": {
            "type": "string"
          },
          "_metadata": {
            "docs::examples": [
              "ntpd",
              "sysinit.target"
            ],
            "docs::human_name": "Include Units"
          }
        },
        "journal_directory": {
          "title": "The full path of the journal directory.",
          "description": "If not set, `journalctl` uses the default system journal path.",
          "default": null,
          "$ref": "#/definitions/core::option::Option<std::path::PathBuf>",
          "_metadata": {
            "docs::human_name": "Journal Directory"
          }
        },
        "journal_namespace": {
          "title": "The [journal namespace][journal-namespace].",
          "description": "This value is passed to `journalctl` through the [`--namespace` option][journalctl-namespace-option].\nIf not set, `journalctl` uses the default namespace.\n\n[journal-namespace]: https://www.freedesktop.org/software/systemd/man/systemd-journald.service.html#Journal%20Namespaces\n[journalctl-namespace-option]: https://www.freedesktop.org/software/systemd/man/journalctl.html#--namespace=NAMESPACE",
          "default": null,
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Journal Namespace"
          }
        },
        "journalctl_path": {
          "title": "The full path of the `journalctl` executable.",
          "description": "If not set, a search is done for the `journalctl` path.",
          "default": null,
          "$ref": "#/definitions/core::option::Option<std::path::PathBuf>",
          "_metadata": {
            "docs::human_name": "Journalctl Path"
          }
        },
        "log_namespace": {
          "description": "The namespace to use for logs. This overrides the global setting.",
          "default": null,
          "type": [
            "boolean",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::hidden": true,
            "docs::human_name": "Log Namespace"
          }
        },
        "remap_priority": {
          "title": "Enables remapping the `PRIORITY` field from an integer to string value.",
          "description": "Has no effect unless the value of the field is already an integer.",
          "default": false,
          "deprecated": true,
          "type": "boolean",
          "_metadata": {
            "deprecated_message": "This option has been deprecated, use the `remap` transform and `to_syslog_level` function instead.",
            "docs::human_name": "Remap Priority"
          }
        },
        "since_now": {
          "description": "Only include entries that appended to the journal after the entries have been read.",
          "default": false,
          "type": "boolean",
          "_metadata": {
            "docs::human_name": "Since Now"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "journald"
      }
    },
    "vector::sources::kafka::KafkaSourceConfig": {
      "description": "Configuration for the `kafka` source.",
      "allOf": [
        {
          "type": "object",
          "required": [
            "bootstrap_servers",
            "group_id",
            "topics"
          ],
          "properties": {
            "acknowledgements": {
              "title": "Controls how acknowledgements are handled by this source.",
              "description": "This setting is **deprecated** in favor of enabling `acknowledgements` at the [global][global_acks] or sink level.\n\nEnabling or disabling acknowledgements at the source level has **no effect** on acknowledgement behavior.\n\nSee [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
              "default": {
                "enabled": null
              },
              "$ref": "#/definitions/vector_core::config::SourceAcknowledgementsConfig",
              "_metadata": {
                "docs::human_name": "Acknowledgements"
              }
            },
            "auto_offset_reset": {
              "title": "If offsets for consumer group do not exist, set them using this strategy.",
              "description": "See the [librdkafka documentation](https://github.com/edenhill/librdkafka/blob/master/CONFIGURATION.md) for the `auto.offset.reset` option for further clarification.",
              "default": "largest",
              "type": "string",
              "_metadata": {
                "docs::examples": [
                  "smallest",
                  "earliest",
                  "beginning",
                  "largest",
                  "latest",
                  "end",
                  "error"
                ],
                "docs::human_name": "Auto Offset Reset"
              }
            },
            "bootstrap_servers": {
              "title": "A comma-separated list of Kafka bootstrap servers.",
              "description": "These are the servers in a Kafka cluster that a client should use to bootstrap its connection to the cluster,\nallowing discovery of all the other hosts in the cluster.\n\nMust be in the form of `host:port`, and comma-separated.",
              "type": "string",
              "_metadata": {
                "docs::examples": "10.14.22.123:9092,10.14.23.332:9092",
                "docs::human_name": "Bootstrap Servers"
              }
            },
            "commit_interval_ms": {
              "description": "The frequency that the consumer offsets are committed (written) to offset storage.",
              "default": 5000,
              "$ref": "#/definitions/serde_with::DurationMilliSeconds",
              "_metadata": {
                "docs::examples": [
                  5000,
                  10000
                ],
                "docs::human_name": "Commit Interval"
              }
            },
            "decoding": {
              "description": "Configures how events are decoded from raw bytes.",
              "default": {
                "codec": "bytes"
              },
              "$ref": "#/definitions/codecs::decoding::DeserializerConfig",
              "_metadata": {
                "docs::human_name": "Decoding"
              }
            },
            "fetch_wait_max_ms": {
              "description": "Maximum time the broker may wait to fill the response.",
              "default": 100,
              "$ref": "#/definitions/serde_with::DurationMilliSeconds",
              "_metadata": {
                "docs::examples": [
                  50,
                  100
                ],
                "docs::advanced": true,
                "docs::human_name": "Max Fetch Wait Time"
              }
            },
            "framing": {
              "title": "Framing configuration.",
              "description": "Framing handles how events are separated when encoded in a raw byte form, where each event is\na frame that must be prefixed, or delimited, in a way that marks where an event begins and\nends within the byte stream.",
              "default": {
                "method": "bytes"
              },
              "$ref": "#/definitions/codecs::decoding::FramingConfig",
              "_metadata": {
                "docs::advanced": true,
                "docs::human_name": "Framing"
              }
            },
            "group_id": {
              "description": "The consumer group name to be used to consume events from Kafka.",
              "type": "string",
              "_metadata": {
                "docs::examples": "consumer-group-name",
                "docs::human_name": "Group ID"
              }
            },
            "headers_key": {
              "title": "Overrides the name of the log field used to add the headers to each event.",
              "description": "The value is the headers of the Kafka message itself.\n\nBy default, `\"headers\"` is used.",
              "default": "headers",
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
              "_metadata": {
                "docs::examples": "headers",
                "docs::human_name": "Headers Key"
              }
            },
            "key_field": {
              "title": "Overrides the name of the log field used to add the message key to each event.",
              "description": "The value is the message key of the Kafka message itself.\n\nBy default, `\"message_key\"` is used.",
              "default": "message_key",
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
              "_metadata": {
                "docs::examples": "message_key",
                "docs::human_name": "Key Field"
              }
            },
            "librdkafka_options": {
              "title": "Advanced options set directly on the underlying `librdkafka` client.",
              "description": "See the [librdkafka documentation](https://github.com/edenhill/librdkafka/blob/master/CONFIGURATION.md) for details.",
              "type": [
                "object",
                "null"
              ],
              "additionalProperties": {
                "type": "string"
              },
              "_metadata": {
                "docs::optional": true,
                "docs::examples": {
                  "fetch.error.backoff.ms": "1000",
                  "socket.send.buffer.bytes": "100",
                  "client.id": "${ENV_VAR}"
                },
                "docs::advanced": true,
                "docs::additional_props_description": "A librdkafka configuration option.",
                "docs::human_name": "Librdkafka Options"
              }
            },
            "log_namespace": {
              "description": "The namespace to use for logs. This overrides the global setting.",
              "default": null,
              "type": [
                "boolean",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::hidden": true,
                "docs::human_name": "Log Namespace"
              }
            },
            "metrics": {
              "description": "Metrics configuration.",
              "default": {
                "topic_lag_metric": false
              },
              "type": "object",
              "required": [
                "topic_lag_metric"
              ],
              "properties": {
                "topic_lag_metric": {
                  "description": "Expose topic lag metrics for all topics and partitions. Metric names are `kafka_consumer_lag`.",
                  "type": "boolean",
                  "_metadata": {
                    "docs::human_name": "Topic Lag Metric"
                  }
                }
              },
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::human_name": "Metrics"
              }
            },
            "offset_key": {
              "title": "Overrides the name of the log field used to add the offset to each event.",
              "description": "The value is the offset of the Kafka message itself.\n\nBy default, `\"offset\"` is used.",
              "default": "offset",
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
              "_metadata": {
                "docs::examples": "offset",
                "docs::human_name": "Offset Key"
              }
            },
            "partition_key": {
              "title": "Overrides the name of the log field used to add the partition to each event.",
              "description": "The value is the partition from which the Kafka message was consumed from.\n\nBy default, `\"partition\"` is used.",
              "default": "partition",
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
              "_metadata": {
                "docs::examples": "partition",
                "docs::human_name": "Partition Key"
              }
            },
            "session_timeout_ms": {
              "description": "The Kafka session timeout.",
              "default": 10000,
              "$ref": "#/definitions/serde_with::DurationMilliSeconds",
              "_metadata": {
                "docs::examples": [
                  5000,
                  10000
                ],
                "docs::advanced": true,
                "docs::human_name": "Session Timeout"
              }
            },
            "socket_timeout_ms": {
              "description": "Timeout for network requests.",
              "default": 60000,
              "$ref": "#/definitions/serde_with::DurationMilliSeconds",
              "_metadata": {
                "docs::examples": [
                  30000,
                  60000
                ],
                "docs::advanced": true,
                "docs::human_name": "Socket Timeout"
              }
            },
            "topic_key": {
              "title": "Overrides the name of the log field used to add the topic to each event.",
              "description": "The value is the topic from which the Kafka message was consumed from.\n\nBy default, `\"topic\"` is used.",
              "default": "topic",
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
              "_metadata": {
                "docs::examples": "topic",
                "docs::human_name": "Topic Key"
              }
            },
            "topics": {
              "title": "The Kafka topics names to read events from.",
              "description": "Regular expression syntax is supported if the topic begins with `^`.",
              "type": "array",
              "items": {
                "type": "string"
              },
              "_metadata": {
                "docs::examples": [
                  "^(prefix1|prefix2)-.+",
                  "topic-1",
                  "topic-2"
                ],
                "docs::human_name": "Topics"
              }
            }
          }
        },
        {
          "description": "Kafka authentication configuration.",
          "$ref": "#/definitions/vector::kafka::KafkaAuthConfig"
        }
      ],
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "kafka"
      }
    },
    "vector::sources::kubernetes_logs::Config": {
      "description": "Configuration for the `kubernetes_logs` source.",
      "default": {
        "extra_label_selector": "",
        "extra_namespace_label_selector": "",
        "self_node_name": "${VECTOR_SELF_NODE_NAME}",
        "extra_field_selector": "",
        "auto_partial_merge": true,
        "data_dir": null,
        "pod_annotation_fields": {
          "pod_name": ".kubernetes.pod_name",
          "pod_namespace": ".kubernetes.pod_namespace",
          "pod_uid": ".kubernetes.pod_uid",
          "pod_ip": ".kubernetes.pod_ip",
          "pod_ips": ".kubernetes.pod_ips",
          "pod_labels": ".kubernetes.pod_labels",
          "pod_annotations": ".kubernetes.pod_annotations",
          "pod_node_name": ".kubernetes.pod_node_name",
          "pod_owner": ".kubernetes.pod_owner",
          "container_name": ".kubernetes.container_name",
          "container_id": ".kubernetes.container_id",
          "container_image": ".kubernetes.container_image",
          "container_image_id": ".kubernetes.container_image_id"
        },
        "namespace_annotation_fields": {
          "namespace_labels": ".kubernetes.namespace_labels"
        },
        "node_annotation_fields": {
          "node_labels": ".kubernetes.node_labels"
        },
        "exclude_paths_glob_patterns": [
          "**/*.gz",
          "**/*.tmp"
        ],
        "read_from": "beginning",
        "ignore_older_secs": null,
        "max_read_bytes": 2048,
        "max_line_bytes": 32768,
        "fingerprint_lines": 1,
        "glob_minimum_cooldown_ms": 60000,
        "ingestion_timestamp_field": null,
        "timezone": null,
        "kube_config_file": null,
        "use_apiserver_cache": false,
        "delay_deletion_ms": 60000,
        "log_namespace": null
      },
      "type": "object",
      "properties": {
        "auto_partial_merge": {
          "title": "Whether or not to automatically merge partial events.",
          "description": "Partial events are messages that were split by the Kubernetes Container Runtime\nlog driver.",
          "type": "boolean",
          "_metadata": {
            "docs::human_name": "Auto Partial Merge"
          }
        },
        "data_dir": {
          "title": "The directory used to persist file checkpoint positions.",
          "description": "By default, the global `data_dir` option is used. Make sure the running user has write\npermissions to this directory.",
          "$ref": "#/definitions/core::option::Option<std::path::PathBuf>",
          "_metadata": {
            "docs::examples": "/var/local/lib/vector/",
            "docs::human_name": "Data Directory"
          }
        },
        "delay_deletion_ms": {
          "title": "How long to delay removing metadata entries from the cache when a pod deletion event\nevent is received from the watch stream.",
          "description": "A longer delay allows for continued enrichment of logs after the originating Pod is\nremoved. If relevant metadata has been removed, the log is forwarded un-enriched and a\nwarning is emitted.",
          "$ref": "#/definitions/serde_with::DurationMilliSeconds",
          "_metadata": {
            "docs::human_name": "Delay Deletion"
          }
        },
        "exclude_paths_glob_patterns": {
          "description": "A list of glob patterns to exclude from reading the files.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/stdlib::PathBuf"
          },
          "_metadata": {
            "docs::examples": "**/exclude/**",
            "docs::human_name": "Exclude Paths Glob Patterns"
          }
        },
        "extra_field_selector": {
          "title": "Specifies the [field selector][field_selector] to filter Pods with, to be used in addition\nto the built-in [Node][node] filter.",
          "description": "The built-in Node filter uses `self_node_name` to only watch Pods located on the same Node.\n\n[field_selector]: https://kubernetes.io/docs/concepts/overview/working-with-objects/field-selectors/\n[node]: https://kubernetes.io/docs/concepts/architecture/nodes/",
          "type": "string",
          "_metadata": {
            "docs::examples": [
              "metadata.name!=pod-name-to-exclude",
              "metadata.name!=pod-name-to-exclude,metadata.name=mypod"
            ],
            "docs::human_name": "Extra Field Selector"
          }
        },
        "extra_label_selector": {
          "title": "Specifies the [label selector][label_selector] to filter [Pods][pods] with, to be used in\naddition to the built-in [exclude][exclude] filter.",
          "description": "[label_selector]: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors\n[pods]: https://kubernetes.io/docs/concepts/workloads/pods/\n[exclude]: https://vector.dev/docs/reference/configuration/sources/kubernetes_logs/#pod-exclusion",
          "type": "string",
          "_metadata": {
            "docs::examples": [
              "my_custom_label!=my_value",
              "my_custom_label!=my_value,my_other_custom_label=my_value"
            ],
            "docs::human_name": "Extra Label Selector"
          }
        },
        "extra_namespace_label_selector": {
          "title": "Specifies the [label selector][label_selector] to filter [Namespaces][namespaces] with, to\nbe used in addition to the built-in [exclude][exclude] filter.",
          "description": "[label_selector]: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors\n[namespaces]: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/\n[exclude]: https://vector.dev/docs/reference/configuration/sources/kubernetes_logs/#namespace-exclusion",
          "type": "string",
          "_metadata": {
            "docs::examples": [
              "my_custom_label!=my_value",
              "my_custom_label!=my_value,my_other_custom_label=my_value"
            ],
            "docs::human_name": "Extra Namespace Label Selector"
          }
        },
        "fingerprint_lines": {
          "title": "The number of lines to read for generating the checksum.",
          "description": "If your files share a common header that is not always a fixed size,\n\nIf the file has less than this amount of lines, it won’t be read at all.",
          "type": "integer",
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::type_unit": "lines",
            "docs::human_name": "Fingerprint Lines"
          }
        },
        "glob_minimum_cooldown_ms": {
          "title": "The interval at which the file system is polled to identify new files to read from.",
          "description": "This is quite efficient, yet might still create some load on the\nfile system; in addition, it is currently coupled with checksum dumping\nin the underlying file server, so setting it too low may introduce\na significant overhead.",
          "$ref": "#/definitions/serde_with::DurationMilliSeconds",
          "_metadata": {
            "docs::human_name": "Glob Minimum Cooldown"
          }
        },
        "ignore_older_secs": {
          "description": "Ignore files with a data modification date older than the specified number of seconds.",
          "default": null,
          "type": [
            "integer",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "seconds",
            "docs::examples": 600,
            "docs::human_name": "Ignore Files Older Than"
          }
        },
        "ingestion_timestamp_field": {
          "title": "Overrides the name of the log field used to add the ingestion timestamp to each event.",
          "description": "This is useful to compute the latency between important event processing\nstages. For example, the time delta between when a log line was written and when it was\nprocessed by the `kubernetes_logs` source.",
          "$ref": "#/definitions/core::option::Option<vector_lookup::lookup_v2::optional_path::OptionalTargetPath>",
          "_metadata": {
            "docs::examples": [
              ".ingest_timestamp",
              "ingest_ts"
            ],
            "docs::human_name": "Ingestion Timestamp Field"
          }
        },
        "kube_config_file": {
          "title": "Optional path to a readable [kubeconfig][kubeconfig] file.",
          "description": "If not set, a connection to Kubernetes is made using the in-cluster configuration.\n\n[kubeconfig]: https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/",
          "$ref": "#/definitions/core::option::Option<std::path::PathBuf>",
          "_metadata": {
            "docs::examples": "/path/to/.kube/config",
            "docs::human_name": "Kube Config File"
          }
        },
        "log_namespace": {
          "description": "The namespace to use for logs. This overrides the global setting.",
          "default": null,
          "type": [
            "boolean",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::hidden": true,
            "docs::human_name": "Log Namespace"
          }
        },
        "max_line_bytes": {
          "title": "The maximum number of bytes a line can contain before being discarded.",
          "description": "This protects against malformed lines or tailing incorrect files.",
          "type": "integer",
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::type_unit": "bytes",
            "docs::human_name": "Max Line Bytes"
          }
        },
        "max_read_bytes": {
          "title": "Max amount of bytes to read from a single file before switching over\nto the next file.",
          "description": "This allows distributing the reads more or less evenly across\nthe files.",
          "type": "integer",
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::type_unit": "bytes",
            "docs::human_name": "Max Read Bytes"
          }
        },
        "namespace_annotation_fields": {
          "description": "Configuration for how the events are enriched with Namespace metadata.",
          "default": {
            "namespace_labels": ".kubernetes.namespace_labels"
          },
          "type": "object",
          "properties": {
            "namespace_labels": {
              "title": "Event field for the Namespace's labels.",
              "description": "Set to `\"\"` to suppress this key.",
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalTargetPath",
              "_metadata": {
                "docs::examples": [
                  ".k8s.ns_labels",
                  "k8s.ns_labels",
                  ""
                ],
                "docs::human_name": "Namespace Labels"
              }
            }
          },
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::human_name": "Namespace Annotation Fields"
          }
        },
        "node_annotation_fields": {
          "description": "Configuration for how the events are enriched with Node metadata.",
          "default": {
            "node_labels": ".kubernetes.node_labels"
          },
          "type": "object",
          "properties": {
            "node_labels": {
              "title": "Event field for the Node's labels.",
              "description": "Set to `\"\"` to suppress this key.",
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalTargetPath",
              "_metadata": {
                "docs::examples": [
                  ".k8s.node_labels",
                  "k8s.node_labels",
                  ""
                ],
                "docs::human_name": "Node Labels"
              }
            }
          },
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::human_name": "Node Annotation Fields"
          }
        },
        "pod_annotation_fields": {
          "description": "Configuration for how the events are enriched with Pod metadata.",
          "default": {
            "pod_name": ".kubernetes.pod_name",
            "pod_namespace": ".kubernetes.pod_namespace",
            "pod_uid": ".kubernetes.pod_uid",
            "pod_ip": ".kubernetes.pod_ip",
            "pod_ips": ".kubernetes.pod_ips",
            "pod_labels": ".kubernetes.pod_labels",
            "pod_annotations": ".kubernetes.pod_annotations",
            "pod_node_name": ".kubernetes.pod_node_name",
            "pod_owner": ".kubernetes.pod_owner",
            "container_name": ".kubernetes.container_name",
            "container_id": ".kubernetes.container_id",
            "container_image": ".kubernetes.container_image",
            "container_image_id": ".kubernetes.container_image_id"
          },
          "type": "object",
          "properties": {
            "container_id": {
              "title": "Event field for the Container's ID.",
              "description": "Set to `\"\"` to suppress this key.",
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalTargetPath",
              "_metadata": {
                "docs::examples": [
                  ".k8s.container_id",
                  "k8s.container_id",
                  ""
                ],
                "docs::human_name": "Container ID"
              }
            },
            "container_image": {
              "title": "Event field for the Container's image.",
              "description": "Set to `\"\"` to suppress this key.",
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalTargetPath",
              "_metadata": {
                "docs::examples": [
                  ".k8s.container_image",
                  "k8s.container_image",
                  ""
                ],
                "docs::human_name": "Container Image"
              }
            },
            "container_image_id": {
              "title": "Event field for the Container's image ID.",
              "description": "Set to `\"\"` to suppress this key.",
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalTargetPath",
              "_metadata": {
                "docs::examples": [
                  ".k8s.container_image_id",
                  "k8s.container_image_id",
                  ""
                ],
                "docs::human_name": "Container Image ID"
              }
            },
            "container_name": {
              "title": "Event field for the Container's name.",
              "description": "Set to `\"\"` to suppress this key.",
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalTargetPath",
              "_metadata": {
                "docs::examples": [
                  ".k8s.container_name",
                  "k8s.container_name",
                  ""
                ],
                "docs::human_name": "Container Name"
              }
            },
            "pod_annotations": {
              "title": "Event field for the Pod's annotations.",
              "description": "Set to `\"\"` to suppress this key.",
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalTargetPath",
              "_metadata": {
                "docs::examples": [
                  ".k8s.pod_annotations",
                  "k8s.pod_annotations",
                  ""
                ],
                "docs::human_name": "Pod Annotations"
              }
            },
            "pod_ip": {
              "title": "Event field for the Pod's IPv4 address.",
              "description": "Set to `\"\"` to suppress this key.",
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalTargetPath",
              "_metadata": {
                "docs::examples": [
                  ".k8s.pod_ip",
                  "k8s.pod_ip",
                  ""
                ],
                "docs::human_name": "Pod IP"
              }
            },
            "pod_ips": {
              "title": "Event field for the Pod's IPv4 and IPv6 addresses.",
              "description": "Set to `\"\"` to suppress this key.",
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalTargetPath",
              "_metadata": {
                "docs::examples": [
                  ".k8s.pod_ips",
                  "k8s.pod_ips",
                  ""
                ],
                "docs::human_name": "Pod IPs"
              }
            },
            "pod_labels": {
              "title": "Event field for the `Pod`'s labels.",
              "description": "Set to `\"\"` to suppress this key.",
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalTargetPath",
              "_metadata": {
                "docs::examples": [
                  ".k8s.pod_labels",
                  "k8s.pod_labels",
                  ""
                ],
                "docs::human_name": "Pod Labels"
              }
            },
            "pod_name": {
              "title": "Event field for the Pod's name.",
              "description": "Set to `\"\"` to suppress this key.",
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalTargetPath",
              "_metadata": {
                "docs::examples": [
                  ".k8s.pod_name",
                  "k8s.pod_name",
                  ""
                ],
                "docs::human_name": "Pod Name"
              }
            },
            "pod_namespace": {
              "title": "Event field for the Pod's namespace.",
              "description": "Set to `\"\"` to suppress this key.",
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalTargetPath",
              "_metadata": {
                "docs::examples": [
                  ".k8s.pod_ns",
                  "k8s.pod_ns",
                  ""
                ],
                "docs::human_name": "Pod Namespace"
              }
            },
            "pod_node_name": {
              "title": "Event field for the Pod's node_name.",
              "description": "Set to `\"\"` to suppress this key.",
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalTargetPath",
              "_metadata": {
                "docs::examples": [
                  ".k8s.pod_host",
                  "k8s.pod_host",
                  ""
                ],
                "docs::human_name": "Pod Node Name"
              }
            },
            "pod_owner": {
              "title": "Event field for the Pod's owner reference.",
              "description": "Set to `\"\"` to suppress this key.",
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalTargetPath",
              "_metadata": {
                "docs::examples": [
                  ".k8s.pod_owner",
                  "k8s.pod_owner",
                  ""
                ],
                "docs::human_name": "Pod Owner"
              }
            },
            "pod_uid": {
              "title": "Event field for the Pod's UID.",
              "description": "Set to `\"\"` to suppress this key.",
              "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalTargetPath",
              "_metadata": {
                "docs::examples": [
                  ".k8s.pod_uid",
                  "k8s.pod_uid",
                  ""
                ],
                "docs::human_name": "Pod UID"
              }
            }
          },
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::human_name": "Pod Annotation Fields"
          }
        },
        "read_from": {
          "description": "File position to use when reading a new file.",
          "default": "beginning",
          "$ref": "#/definitions/file_source::ReadFromConfig",
          "_metadata": {
            "docs::human_name": "Read From"
          }
        },
        "self_node_name": {
          "title": "The name of the Kubernetes [Node][node] that is running.",
          "description": "Configured to use an environment variable by default, to be evaluated to a value provided by\nKubernetes at Pod creation.\n\n[node]: https://kubernetes.io/docs/concepts/architecture/nodes/",
          "type": "string",
          "_metadata": {
            "docs::human_name": "Self Node Name"
          }
        },
        "timezone": {
          "description": "The default time zone for timestamps without an explicit zone.",
          "$ref": "#/definitions/core::option::Option<vrl::compiler::datetime::TimeZone>",
          "_metadata": {
            "docs::human_name": "Timezone"
          }
        },
        "use_apiserver_cache": {
          "description": "Determines if requests to the kube-apiserver can be served by a cache.",
          "type": "boolean",
          "_metadata": {
            "docs::human_name": "Use API Server Cache"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "kubernetes_logs"
      }
    },
    "vector::sources::logstash::LogstashConfig": {
      "description": "Configuration for the `logstash` source.",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled by this source.",
          "description": "This setting is **deprecated** in favor of enabling `acknowledgements` at the [global][global_acks] or sink level.\n\nEnabling or disabling acknowledgements at the source level has **no effect** on acknowledgement behavior.\n\nSee [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::SourceAcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "address": {
          "title": "The socket address to listen for connections on, or `systemd{#N}` to use the Nth socket passed by\nsystemd socket activation.",
          "description": "If a socket address is used, it _must_ include a port.",
          "$ref": "#/definitions/vector::sources::util::net::SocketListenAddr",
          "_metadata": {
            "docs::human_name": "Address"
          }
        },
        "connection_limit": {
          "description": "The maximum number of TCP connections that are allowed at any given time.",
          "type": [
            "integer",
            "null"
          ],
          "maximum": 4294967295.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "connections",
            "docs::advanced": true,
            "docs::human_name": "Connection Limit"
          }
        },
        "keepalive": {
          "$ref": "#/definitions/core::option::Option<vector_core::tcp::TcpKeepaliveConfig>",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Keepalive"
          }
        },
        "log_namespace": {
          "description": "The namespace to use for logs. This overrides the global setting.",
          "default": null,
          "type": [
            "boolean",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::hidden": true,
            "docs::human_name": "Log Namespace"
          }
        },
        "receive_buffer_bytes": {
          "description": "The size of the receive buffer used for each connection.",
          "type": [
            "integer",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::type_unit": "bytes",
            "docs::examples": 65536,
            "docs::advanced": true,
            "docs::human_name": "Receive Buffer Bytes"
          }
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsSourceConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "logstash"
      }
    },
    "vector::sources::mongodb_metrics::MongoDbMetricsConfig": {
      "description": "Configuration for the `mongodb_metrics` source.",
      "type": "object",
      "required": [
        "endpoints"
      ],
      "properties": {
        "endpoints": {
          "title": "A list of MongoDB instances to scrape.",
          "description": "Each endpoint must be in the [Connection String URI Format](https://www.mongodb.com/docs/manual/reference/connection-string/).",
          "type": "array",
          "items": {
            "type": "string"
          },
          "_metadata": {
            "docs::examples": "mongodb://localhost:27017",
            "docs::human_name": "Endpoints"
          }
        },
        "namespace": {
          "title": "Overrides the default namespace for the metrics emitted by the source.",
          "description": "If set to an empty string, no namespace is added to the metrics.\n\nBy default, `mongodb` is used.",
          "default": "mongodb",
          "type": "string",
          "_metadata": {
            "docs::human_name": "Namespace"
          }
        },
        "scrape_interval_secs": {
          "description": "The interval between scrapes, in seconds.",
          "default": 15,
          "$ref": "#/definitions/serde_with::DurationSeconds",
          "_metadata": {
            "docs::human_name": "Scrape Interval"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "mongodb_metrics"
      }
    },
    "vector::sources::nats::NatsSourceConfig": {
      "description": "Configuration for the `nats` source.",
      "type": "object",
      "required": [
        "connection_name",
        "subject",
        "url"
      ],
      "properties": {
        "auth": {
          "$ref": "#/definitions/core::option::Option<vector::nats::NatsAuthConfig>",
          "_metadata": {
            "docs::human_name": "Auth"
          }
        },
        "connection_name": {
          "title": "A [name][nats_connection_name] assigned to the NATS connection.",
          "description": "[nats_connection_name]: https://docs.nats.io/using-nats/developer/connecting/name",
          "type": "string",
          "_metadata": {
            "docs::examples": "vector",
            "docs::human_name": "Connection Name"
          }
        },
        "decoding": {
          "description": "Configures how events are decoded from raw bytes.",
          "default": {
            "codec": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::DeserializerConfig",
          "_metadata": {
            "docs::human_name": "Decoding"
          }
        },
        "framing": {
          "title": "Framing configuration.",
          "description": "Framing handles how events are separated when encoded in a raw byte form, where each event is\na frame that must be prefixed, or delimited, in a way that marks where an event begins and\nends within the byte stream.",
          "default": {
            "method": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::FramingConfig",
          "_metadata": {
            "docs::human_name": "Framing"
          }
        },
        "log_namespace": {
          "description": "The namespace to use for logs. This overrides the global setting.",
          "default": null,
          "type": [
            "boolean",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::hidden": true,
            "docs::human_name": "Log Namespace"
          }
        },
        "queue": {
          "description": "The NATS queue group to join.",
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Queue"
          }
        },
        "subject": {
          "title": "The NATS [subject][nats_subject] to pull messages from.",
          "description": "[nats_subject]: https://docs.nats.io/nats-concepts/subjects",
          "type": "string",
          "_metadata": {
            "docs::examples": [
              "foo",
              "time.us.east",
              "time.*.east",
              "time.>",
              ">"
            ],
            "docs::human_name": "Subject"
          }
        },
        "subject_key_field": {
          "description": "The `NATS` subject key.",
          "default": "subject",
          "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
          "_metadata": {
            "docs::human_name": "Subject Key Field"
          }
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        },
        "url": {
          "title": "The NATS URL to connect to.",
          "description": "The URL takes the form of `nats://server:port`.\nIf the port is not specified it defaults to 4222.",
          "type": "string",
          "_metadata": {
            "docs::examples": [
              "nats://demo.nats.io",
              "nats://127.0.0.1:4242"
            ],
            "docs::human_name": "URL"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "nats"
      }
    },
    "vector::sources::nginx_metrics::NginxMetricsConfig": {
      "description": "Configuration for the `nginx_metrics` source.",
      "type": "object",
      "required": [
        "endpoints"
      ],
      "properties": {
        "auth": {
          "$ref": "#/definitions/core::option::Option<vector::http::Auth>",
          "_metadata": {
            "docs::human_name": "Auth"
          }
        },
        "endpoints": {
          "title": "A list of NGINX instances to scrape.",
          "description": "Each endpoint must be a valid HTTP/HTTPS URI pointing to an NGINX instance that has the\n`ngx_http_stub_status_module` module enabled.",
          "type": "array",
          "items": {
            "type": "string"
          },
          "_metadata": {
            "docs::examples": "http://localhost:8000/basic_status",
            "docs::human_name": "Endpoints"
          }
        },
        "namespace": {
          "title": "Overrides the default namespace for the metrics emitted by the source.",
          "description": "If set to an empty string, no namespace is added to the metrics.\n\nBy default, `nginx` is used.",
          "default": "nginx",
          "type": "string",
          "_metadata": {
            "docs::human_name": "Namespace"
          }
        },
        "scrape_interval_secs": {
          "description": "The interval between scrapes.",
          "default": 15,
          "$ref": "#/definitions/serde_with::DurationSeconds",
          "_metadata": {
            "docs::human_name": "Scrape Interval"
          }
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "nginx_metrics"
      }
    },
    "vector::sources::opentelemetry::OpentelemetryConfig": {
      "description": "Configuration for the `opentelemetry` source.",
      "type": "object",
      "required": [
        "grpc",
        "http"
      ],
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled by this source.",
          "description": "This setting is **deprecated** in favor of enabling `acknowledgements` at the [global][global_acks] or sink level.\n\nEnabling or disabling acknowledgements at the source level has **no effect** on acknowledgement behavior.\n\nSee [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::SourceAcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "grpc": {
          "description": "Configuration for the `opentelemetry` gRPC server.",
          "type": "object",
          "required": [
            "address"
          ],
          "properties": {
            "address": {
              "title": "The socket address to listen for connections on.",
              "description": "It _must_ include a port.",
              "$ref": "#/definitions/stdlib::SocketAddr",
              "_metadata": {
                "docs::examples": [
                  "0.0.0.0:4317",
                  "localhost:4317"
                ],
                "docs::human_name": "Address"
              }
            },
            "tls": {
              "default": null,
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              }
            }
          },
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::examples": {
              "address": "0.0.0.0:4317"
            },
            "docs::human_name": "gRPC"
          }
        },
        "http": {
          "description": "Configuration for the `opentelemetry` HTTP server.",
          "type": "object",
          "required": [
            "address"
          ],
          "properties": {
            "address": {
              "title": "The socket address to listen for connections on.",
              "description": "It _must_ include a port.",
              "$ref": "#/definitions/stdlib::SocketAddr",
              "_metadata": {
                "docs::examples": [
                  "0.0.0.0:4318",
                  "localhost:4318"
                ],
                "docs::human_name": "Address"
              }
            },
            "tls": {
              "default": null,
              "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
              "_metadata": {
                "docs::human_name": "TLS"
              }
            }
          },
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::examples": {
              "address": "0.0.0.0:4318"
            },
            "docs::human_name": "HTTP"
          }
        },
        "log_namespace": {
          "description": "The namespace to use for logs. This overrides the global setting.",
          "default": null,
          "type": [
            "boolean",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::hidden": true,
            "docs::human_name": "Log Namespace"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "opentelemetry"
      }
    },
    "vector::sources::postgresql_metrics::PostgresqlMetricsConfig": {
      "description": "Configuration for the `postgresql_metrics` source.",
      "type": "object",
      "required": [
        "endpoints"
      ],
      "properties": {
        "endpoints": {
          "title": "A list of PostgreSQL instances to scrape.",
          "description": "Each endpoint must be in the [Connection URI\nformat](https://www.postgresql.org/docs/current/libpq-connect.html#id-1.7.3.8.3.6).",
          "type": "array",
          "items": {
            "type": "string"
          },
          "_metadata": {
            "docs::examples": "postgresql://postgres:vector@localhost:5432/postgres",
            "docs::human_name": "Endpoints"
          }
        },
        "exclude_databases": {
          "title": "A list of databases to match (by using [POSIX Regular\nExpressions](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-POSIX-REGEXP)) against\nthe `datname` column for which you don’t want to collect metrics from.",
          "description": "Specifying `\"\"` includes metrics where `datname` is `NULL`.\n\nThis can be used in conjunction with `include_databases`.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          },
          "_metadata": {
            "docs::optional": true,
            "docs::examples": [
              "^postgres$",
              "^template.*"
            ],
            "docs::human_name": "Exclude Databases"
          }
        },
        "include_databases": {
          "title": "A list of databases to match (by using [POSIX Regular\nExpressions](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-POSIX-REGEXP)) against\nthe `datname` column for which you want to collect metrics from.",
          "description": "If not set, metrics are collected from all databases. Specifying `\"\"` includes metrics where `datname` is\n`NULL`.\n\nThis can be used in conjunction with `exclude_databases`.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          },
          "_metadata": {
            "docs::optional": true,
            "docs::examples": [
              "^postgres$",
              "^vector$",
              "^foo"
            ],
            "docs::human_name": "Include Databases"
          }
        },
        "namespace": {
          "description": "Overrides the default namespace for the metrics emitted by the source.",
          "default": "postgresql",
          "type": "string",
          "_metadata": {
            "docs::human_name": "Namespace"
          }
        },
        "scrape_interval_secs": {
          "description": "The interval between scrapes.",
          "default": 15,
          "$ref": "#/definitions/serde_with::DurationSeconds",
          "_metadata": {
            "docs::human_name": "Scrape Interval"
          }
        },
        "tls": {
          "description": "Configuration of TLS when connecting to PostgreSQL.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "description": "Configuration of TLS when connecting to PostgreSQL.",
              "type": "object",
              "required": [
                "ca_file"
              ],
              "properties": {
                "ca_file": {
                  "title": "Absolute path to an additional CA certificate file.",
                  "description": "The certificate must be in the DER or PEM (X.509) format.",
                  "$ref": "#/definitions/stdlib::PathBuf",
                  "_metadata": {
                    "docs::examples": "certs/ca.pem",
                    "docs::human_name": "Ca File"
                  }
                }
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "TLS"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "postgresql_metrics"
      }
    },
    "vector::sources::prometheus::remote_write::PrometheusRemoteWriteConfig": {
      "description": "Configuration for the `prometheus_remote_write` source.",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled by this source.",
          "description": "This setting is **deprecated** in favor of enabling `acknowledgements` at the [global][global_acks] or sink level.\n\nEnabling or disabling acknowledgements at the source level has **no effect** on acknowledgement behavior.\n\nSee [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::SourceAcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "address": {
          "title": "The socket address to accept connections on.",
          "description": "The address _must_ include a port.",
          "$ref": "#/definitions/stdlib::SocketAddr",
          "_metadata": {
            "docs::examples": "0.0.0.0:9090",
            "docs::human_name": "Address"
          }
        },
        "auth": {
          "$ref": "#/definitions/core::option::Option<vector::sources::util::http::auth::HttpSourceAuthConfig>",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Auth"
          }
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "prometheus_remote_write"
      }
    },
    "vector::sources::prometheus::scrape::PrometheusScrapeConfig": {
      "description": "Configuration for the `prometheus_scrape` source.",
      "type": "object",
      "required": [
        "endpoints"
      ],
      "properties": {
        "auth": {
          "$ref": "#/definitions/core::option::Option<vector::http::Auth>",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Auth"
          }
        },
        "endpoint_tag": {
          "title": "The tag name added to each event representing the scraped instance's endpoint.",
          "description": "The tag value is the endpoint of the scraped instance.",
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::advanced": true,
            "docs::human_name": "Endpoint Tag"
          }
        },
        "endpoints": {
          "description": "Endpoints to scrape metrics from.",
          "type": "array",
          "items": {
            "type": "string"
          },
          "_metadata": {
            "docs::examples": "http://localhost:9090/metrics",
            "docs::human_name": "Endpoints"
          }
        },
        "honor_labels": {
          "title": "Controls how tag conflicts are handled if the scraped source has tags to be added.",
          "description": "If `true`, the new tag is not added if the scraped metric has the tag already. If `false`, the conflicting tag\nis renamed by prepending `exported_` to the original name.\n\nThis matches Prometheus’ `honor_labels` configuration.",
          "default": false,
          "type": "boolean",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Honor Labels"
          }
        },
        "instance_tag": {
          "title": "The tag name added to each event representing the scraped instance's `host:port`.",
          "description": "The tag value is the host and port of the scraped instance.",
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::advanced": true,
            "docs::human_name": "Instance Tag"
          }
        },
        "query": {
          "title": "Custom parameters for the scrape request query string.",
          "description": "One or more values for the same parameter key can be provided. The parameters provided in this option are\nappended to any parameters manually provided in the `endpoints` option. This option is especially useful when\nscraping the `/federate` endpoint.",
          "default": {},
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "_metadata": {
            "docs::additional_props_description": "A query string parameter.",
            "docs::examples": {
              "match[]": [
                "{job=\"somejob\"}",
                "{__name__=~\"job:.*\"}"
              ]
            },
            "docs::human_name": "Query"
          }
        },
        "scrape_interval_secs": {
          "description": "The interval between scrapes. Requests are run concurrently so if a scrape takes longer\nthan the interval a new scrape will be started. This can take extra resources, set the timeout\nto a value lower than the scrape interval to prevent this from happening.",
          "default": 15,
          "$ref": "#/definitions/serde_with::DurationSeconds",
          "_metadata": {
            "docs::human_name": "Scrape Interval"
          }
        },
        "scrape_timeout_secs": {
          "description": "The timeout for each scrape request.",
          "default": 5.0,
          "$ref": "#/definitions/serde_with::DurationFractionalSeconds",
          "_metadata": {
            "docs::human_name": "Scrape Timeout"
          }
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "prometheus_scrape"
      }
    },
    "vector::sources::redis::RedisSourceConfig": {
      "description": "Configuration for the `redis` source.",
      "type": "object",
      "required": [
        "key",
        "url"
      ],
      "properties": {
        "data_type": {
          "description": "The Redis data type (`list` or `channel`) to use.",
          "default": "list",
          "oneOf": [
            {
              "description": "The `list` data type.",
              "const": "list",
              "_metadata": {
                "logical_name": "List",
                "docs::human_name": "List"
              }
            },
            {
              "title": "The `channel` data type.",
              "description": "This is based on Redis' Pub/Sub capabilities.",
              "const": "channel",
              "_metadata": {
                "logical_name": "Channel",
                "docs::human_name": "Channel"
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::enum_tagging": "external",
            "docs::human_name": "Data Type"
          }
        },
        "decoding": {
          "description": "Configures how events are decoded from raw bytes.",
          "default": {
            "codec": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::DeserializerConfig",
          "_metadata": {
            "docs::human_name": "Decoding"
          }
        },
        "framing": {
          "title": "Framing configuration.",
          "description": "Framing handles how events are separated when encoded in a raw byte form, where each event is\na frame that must be prefixed, or delimited, in a way that marks where an event begins and\nends within the byte stream.",
          "default": {
            "method": "bytes"
          },
          "$ref": "#/definitions/codecs::decoding::FramingConfig",
          "_metadata": {
            "docs::human_name": "Framing"
          }
        },
        "key": {
          "description": "The Redis key to read messages from.",
          "type": "string",
          "_metadata": {
            "docs::examples": "vector",
            "docs::human_name": "Key"
          }
        },
        "list": {
          "description": "Options for the Redis `list` data type.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "description": "Options for the Redis `list` data type.",
              "type": "object",
              "required": [
                "method"
              ],
              "properties": {
                "method": {
                  "description": "Method for getting events from the `list` data type.",
                  "oneOf": [
                    {
                      "description": "Pop messages from the head of the list.",
                      "const": "lpop",
                      "_metadata": {
                        "logical_name": "Lpop",
                        "docs::human_name": "Lpop"
                      }
                    },
                    {
                      "description": "Pop messages from the tail of the list.",
                      "const": "rpop",
                      "_metadata": {
                        "logical_name": "Rpop",
                        "docs::human_name": "Rpop"
                      }
                    }
                  ],
                  "unevaluatedProperties": false,
                  "_metadata": {
                    "docs::enum_tagging": "external",
                    "docs::human_name": "Method"
                  }
                }
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "List"
          }
        },
        "log_namespace": {
          "description": "The namespace to use for logs. This overrides the global setting.",
          "default": null,
          "type": [
            "boolean",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::hidden": true,
            "docs::human_name": "Log Namespace"
          }
        },
        "redis_key": {
          "title": "Sets the name of the log field to use to add the key to each event.",
          "description": "The value is the Redis key that the event was read from.\n\nBy default, this is not set and the field is not automatically added.",
          "$ref": "#/definitions/core::option::Option<vector_lookup::lookup_v2::optional_path::OptionalValuePath>",
          "_metadata": {
            "docs::examples": "redis_key",
            "docs::human_name": "Redis Key"
          }
        },
        "url": {
          "title": "The Redis URL to connect to.",
          "description": "The URL must take the form of `protocol://server:port/db` where the `protocol` can either be `redis` or `rediss` for connections secured using TLS.",
          "type": "string",
          "_metadata": {
            "docs::examples": "redis://127.0.0.1:6379/0",
            "docs::human_name": "URL"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "redis"
      }
    },
    "vector::sources::socket::SocketConfig": {
      "description": "Configuration for the `socket` source.",
      "allOf": [
        {
          "description": "Listening mode for the `socket` source.",
          "oneOf": [
            {
              "description": "Listen on TCP.",
              "allOf": [
                {
                  "description": "TCP configuration for the `socket` source.",
                  "type": "object",
                  "required": [
                    "address"
                  ],
                  "properties": {
                    "address": {
                      "title": "The socket address to listen for connections on, or `systemd{#N}` to use the Nth socket passed by\nsystemd socket activation.",
                      "description": "If a socket address is used, it _must_ include a port.",
                      "$ref": "#/definitions/vector::sources::util::net::SocketListenAddr",
                      "_metadata": {
                        "docs::human_name": "Address"
                      }
                    },
                    "connection_limit": {
                      "description": "The maximum number of TCP connections that are allowed at any given time.",
                      "type": [
                        "integer",
                        "null"
                      ],
                      "maximum": 4294967295.0,
                      "minimum": 0.0,
                      "_metadata": {
                        "docs::numeric_type": "uint",
                        "docs::optional": true,
                        "docs::type_unit": "connections",
                        "docs::human_name": "Connection Limit"
                      }
                    },
                    "decoding": {
                      "description": "Configures how events are decoded from raw bytes.",
                      "default": {
                        "codec": "bytes"
                      },
                      "$ref": "#/definitions/codecs::decoding::DeserializerConfig",
                      "_metadata": {
                        "docs::human_name": "Decoding"
                      }
                    },
                    "framing": {
                      "$ref": "#/definitions/core::option::Option<codecs::decoding::FramingConfig>",
                      "_metadata": {
                        "docs::human_name": "Framing"
                      }
                    },
                    "host_key": {
                      "title": "Overrides the name of the log field used to add the peer host to each event.",
                      "description": "The value will be the peer host's address, including the port i.e. `1.2.3.4:9000`.\n\nBy default, the [global `log_schema.host_key` option][global_host_key] is used.\n\nSet to `\"\"` to suppress this key.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
                      "default": "host",
                      "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
                      "_metadata": {
                        "docs::human_name": "Host Key"
                      }
                    },
                    "keepalive": {
                      "$ref": "#/definitions/core::option::Option<vector_core::tcp::TcpKeepaliveConfig>",
                      "_metadata": {
                        "docs::human_name": "Keepalive"
                      }
                    },
                    "log_namespace": {
                      "description": "The namespace to use for logs. This overrides the global setting.",
                      "default": null,
                      "type": [
                        "boolean",
                        "null"
                      ],
                      "_metadata": {
                        "docs::optional": true,
                        "docs::hidden": true,
                        "docs::human_name": "Log Namespace"
                      }
                    },
                    "max_connection_duration_secs": {
                      "title": "Maximum duration to keep each connection open. Connections open for longer than this duration are closed.",
                      "description": "This is helpful for load balancing long-lived connections.",
                      "type": [
                        "integer",
                        "null"
                      ],
                      "maximum": 9007199254740991.0,
                      "minimum": 0.0,
                      "_metadata": {
                        "docs::numeric_type": "uint",
                        "docs::optional": true,
                        "docs::type_unit": "seconds",
                        "docs::human_name": "Max Connection Duration Secs"
                      }
                    },
                    "port_key": {
                      "title": "Overrides the name of the log field used to add the peer host's port to each event.",
                      "description": "The value will be the peer host's port i.e. `9000`.\n\nBy default, `\"port\"` is used.\n\nSet to `\"\"` to suppress this key.",
                      "default": "port",
                      "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
                      "_metadata": {
                        "docs::human_name": "Port Key"
                      }
                    },
                    "receive_buffer_bytes": {
                      "description": "The size of the receive buffer used for each connection.",
                      "type": [
                        "integer",
                        "null"
                      ],
                      "maximum": 9007199254740991.0,
                      "minimum": 0.0,
                      "_metadata": {
                        "docs::numeric_type": "uint",
                        "docs::optional": true,
                        "docs::type_unit": "bytes",
                        "docs::human_name": "Receive Buffer Bytes"
                      }
                    },
                    "shutdown_timeout_secs": {
                      "description": "The timeout before a connection is forcefully closed during shutdown.",
                      "default": 30,
                      "$ref": "#/definitions/serde_with::DurationSeconds",
                      "_metadata": {
                        "docs::human_name": "Shutdown Timeout"
                      }
                    },
                    "tls": {
                      "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsSourceConfig>",
                      "_metadata": {
                        "docs::human_name": "TLS"
                      }
                    }
                  }
                },
                {
                  "type": "object",
                  "required": [
                    "mode"
                  ],
                  "properties": {
                    "mode": {
                      "description": "Listen on TCP.",
                      "const": "tcp",
                      "_metadata": {
                        "docs::human_name": "Mode"
                      }
                    }
                  }
                }
              ],
              "_metadata": {
                "logical_name": "Tcp",
                "docs::human_name": "TCP"
              }
            },
            {
              "description": "Listen on UDP.",
              "allOf": [
                {
                  "description": "UDP configuration for the `socket` source.",
                  "type": "object",
                  "required": [
                    "address"
                  ],
                  "properties": {
                    "address": {
                      "title": "The socket address to listen for connections on, or `systemd{#N}` to use the Nth socket passed by\nsystemd socket activation.",
                      "description": "If a socket address is used, it _must_ include a port.",
                      "$ref": "#/definitions/vector::sources::util::net::SocketListenAddr",
                      "_metadata": {
                        "docs::human_name": "Address"
                      }
                    },
                    "decoding": {
                      "description": "Configures how events are decoded from raw bytes.",
                      "default": {
                        "codec": "bytes"
                      },
                      "$ref": "#/definitions/codecs::decoding::DeserializerConfig",
                      "_metadata": {
                        "docs::human_name": "Decoding"
                      }
                    },
                    "framing": {
                      "title": "Framing configuration.",
                      "description": "Framing handles how events are separated when encoded in a raw byte form, where each event is\na frame that must be prefixed, or delimited, in a way that marks where an event begins and\nends within the byte stream.",
                      "default": {
                        "method": "bytes"
                      },
                      "$ref": "#/definitions/codecs::decoding::FramingConfig",
                      "_metadata": {
                        "docs::human_name": "Framing"
                      }
                    },
                    "host_key": {
                      "title": "Overrides the name of the log field used to add the peer host to each event.",
                      "description": "The value will be the peer host's address, including the port i.e. `1.2.3.4:9000`.\n\nBy default, the [global `log_schema.host_key` option][global_host_key] is used.\n\nSet to `\"\"` to suppress this key.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
                      "default": "host",
                      "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
                      "_metadata": {
                        "docs::human_name": "Host Key"
                      }
                    },
                    "log_namespace": {
                      "description": "The namespace to use for logs. This overrides the global setting.",
                      "default": null,
                      "type": [
                        "boolean",
                        "null"
                      ],
                      "_metadata": {
                        "docs::optional": true,
                        "docs::hidden": true,
                        "docs::human_name": "Log Namespace"
                      }
                    },
                    "max_length": {
                      "title": "The maximum buffer size of incoming messages.",
                      "description": "Messages larger than this are truncated.",
                      "default": 102400,
                      "type": "integer",
                      "maximum": 9007199254740991.0,
                      "minimum": 0.0,
                      "_metadata": {
                        "docs::numeric_type": "uint",
                        "docs::type_unit": "bytes",
                        "docs::human_name": "Max Length"
                      }
                    },
                    "port_key": {
                      "title": "Overrides the name of the log field used to add the peer host's port to each event.",
                      "description": "The value will be the peer host's port i.e. `9000`.\n\nBy default, `\"port\"` is used.\n\nSet to `\"\"` to suppress this key.",
                      "default": "port",
                      "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
                      "_metadata": {
                        "docs::human_name": "Port Key"
                      }
                    },
                    "receive_buffer_bytes": {
                      "description": "The size of the receive buffer used for the listening socket.",
                      "type": [
                        "integer",
                        "null"
                      ],
                      "maximum": 9007199254740991.0,
                      "minimum": 0.0,
                      "_metadata": {
                        "docs::numeric_type": "uint",
                        "docs::optional": true,
                        "docs::type_unit": "bytes",
                        "docs::human_name": "Receive Buffer Bytes"
                      }
                    }
                  }
                },
                {
                  "type": "object",
                  "required": [
                    "mode"
                  ],
                  "properties": {
                    "mode": {
                      "description": "Listen on UDP.",
                      "const": "udp",
                      "_metadata": {
                        "docs::human_name": "Mode"
                      }
                    }
                  }
                }
              ],
              "_metadata": {
                "logical_name": "Udp",
                "docs::human_name": "UDP"
              }
            },
            {
              "description": "Listen on a Unix domain socket (UDS), in datagram mode.",
              "allOf": [
                {
                  "description": "Unix domain socket configuration for the `socket` source.",
                  "type": "object",
                  "required": [
                    "path"
                  ],
                  "properties": {
                    "decoding": {
                      "description": "Configures how events are decoded from raw bytes.",
                      "default": {
                        "codec": "bytes"
                      },
                      "$ref": "#/definitions/codecs::decoding::DeserializerConfig",
                      "_metadata": {
                        "docs::human_name": "Decoding"
                      }
                    },
                    "framing": {
                      "default": null,
                      "$ref": "#/definitions/core::option::Option<codecs::decoding::FramingConfig>",
                      "_metadata": {
                        "docs::human_name": "Framing"
                      }
                    },
                    "host_key": {
                      "title": "Overrides the name of the log field used to add the peer host to each event.",
                      "description": "The value will be the peer host's address, including the port i.e. `1.2.3.4:9000`.\n\nBy default, the [global `log_schema.host_key` option][global_host_key] is used.\n\nSet to `\"\"` to suppress this key.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
                      "default": "host",
                      "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
                      "_metadata": {
                        "docs::human_name": "Host Key"
                      }
                    },
                    "log_namespace": {
                      "description": "The namespace to use for logs. This overrides the global setting.",
                      "default": null,
                      "type": [
                        "boolean",
                        "null"
                      ],
                      "_metadata": {
                        "docs::optional": true,
                        "docs::hidden": true,
                        "docs::human_name": "Log Namespace"
                      }
                    },
                    "path": {
                      "title": "The Unix socket path.",
                      "description": "This should be an absolute path.",
                      "$ref": "#/definitions/stdlib::PathBuf",
                      "_metadata": {
                        "docs::examples": "/path/to/socket",
                        "docs::human_name": "Path"
                      }
                    },
                    "socket_file_mode": {
                      "title": "Unix file mode bits to be applied to the unix socket file as its designated file permissions.",
                      "description": "Note: The file mode value can be specified in any numeric format supported by your configuration\nlanguage, but it is most intuitive to use an octal number.",
                      "type": [
                        "integer",
                        "null"
                      ],
                      "maximum": 4294967295.0,
                      "minimum": 0.0,
                      "_metadata": {
                        "docs::numeric_type": "uint",
                        "docs::optional": true,
                        "docs::examples": [
                          511,
                          384,
                          508
                        ],
                        "docs::human_name": "Socket File Mode"
                      }
                    }
                  }
                },
                {
                  "type": "object",
                  "required": [
                    "mode"
                  ],
                  "properties": {
                    "mode": {
                      "description": "Listen on a Unix domain socket (UDS), in datagram mode.",
                      "const": "unix_datagram",
                      "_metadata": {
                        "docs::human_name": "Mode"
                      }
                    }
                  }
                }
              ],
              "_metadata": {
                "logical_name": "UnixDatagram",
                "docs::human_name": "Unix Datagram"
              }
            },
            {
              "description": "Listen on a Unix domain socket (UDS), in stream mode.",
              "allOf": [
                {
                  "description": "Unix domain socket configuration for the `socket` source.",
                  "type": "object",
                  "required": [
                    "path"
                  ],
                  "properties": {
                    "decoding": {
                      "description": "Configures how events are decoded from raw bytes.",
                      "default": {
                        "codec": "bytes"
                      },
                      "$ref": "#/definitions/codecs::decoding::DeserializerConfig",
                      "_metadata": {
                        "docs::human_name": "Decoding"
                      }
                    },
                    "framing": {
                      "default": null,
                      "$ref": "#/definitions/core::option::Option<codecs::decoding::FramingConfig>",
                      "_metadata": {
                        "docs::human_name": "Framing"
                      }
                    },
                    "host_key": {
                      "title": "Overrides the name of the log field used to add the peer host to each event.",
                      "description": "The value will be the peer host's address, including the port i.e. `1.2.3.4:9000`.\n\nBy default, the [global `log_schema.host_key` option][global_host_key] is used.\n\nSet to `\"\"` to suppress this key.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
                      "default": "host",
                      "$ref": "#/definitions/vector_lookup::lookup_v2::optional_path::OptionalValuePath",
                      "_metadata": {
                        "docs::human_name": "Host Key"
                      }
                    },
                    "log_namespace": {
                      "description": "The namespace to use for logs. This overrides the global setting.",
                      "default": null,
                      "type": [
                        "boolean",
                        "null"
                      ],
                      "_metadata": {
                        "docs::optional": true,
                        "docs::hidden": true,
                        "docs::human_name": "Log Namespace"
                      }
                    },
                    "path": {
                      "title": "The Unix socket path.",
                      "description": "This should be an absolute path.",
                      "$ref": "#/definitions/stdlib::PathBuf",
                      "_metadata": {
                        "docs::examples": "/path/to/socket",
                        "docs::human_name": "Path"
                      }
                    },
                    "socket_file_mode": {
                      "title": "Unix file mode bits to be applied to the unix socket file as its designated file permissions.",
                      "description": "Note: The file mode value can be specified in any numeric format supported by your configuration\nlanguage, but it is most intuitive to use an octal number.",
                      "type": [
                        "integer",
                        "null"
                      ],
                      "maximum": 4294967295.0,
                      "minimum": 0.0,
                      "_metadata": {
                        "docs::numeric_type": "uint",
                        "docs::optional": true,
                        "docs::examples": [
                          511,
                          384,
                          508
                        ],
                        "docs::human_name": "Socket File Mode"
                      }
                    }
                  }
                },
                {
                  "type": "object",
                  "required": [
                    "mode"
                  ],
                  "properties": {
                    "mode": {
                      "description": "Listen on a Unix domain socket (UDS), in stream mode.",
                      "const": "unix_stream",
                      "_metadata": {
                        "docs::human_name": "Mode"
                      }
                    }
                  }
                }
              ],
              "_metadata": {
                "logical_name": "UnixStream",
                "docs::human_name": "Unix Stream"
              }
            }
          ],
          "_metadata": {
            "docs::enum_tag_description": "The type of socket to use.",
            "docs::enum_tagging": "internal",
            "docs::enum_tag_field": "mode"
          }
        }
      ],
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "socket"
      }
    },
    "vector::sources::splunk_hec::SplunkConfig": {
      "description": "Configuration for the `splunk_hec` source.",
      "default": {
        "address": "0.0.0.0:8088",
        "token": null,
        "valid_tokens": null,
        "store_hec_token": false,
        "tls": null,
        "acknowledgements": {
          "enabled": null,
          "max_pending_acks": 10000000,
          "max_number_of_ack_channels": 1000000,
          "max_pending_acks_per_channel": 1000000,
          "ack_idle_cleanup": false,
          "max_idle_time": 300
        },
        "log_namespace": null
      },
      "type": "object",
      "properties": {
        "acknowledgements": {
          "description": "Acknowledgement configuration for the `splunk_hec` source.",
          "default": {
            "enabled": null,
            "max_pending_acks": 10000000,
            "max_number_of_ack_channels": 1000000,
            "max_pending_acks_per_channel": 1000000,
            "ack_idle_cleanup": false,
            "max_idle_time": 300
          },
          "type": "object",
          "properties": {
            "ack_idle_cleanup": {
              "title": "Whether or not to remove channels after idling for `max_idle_time` seconds.",
              "description": "A channel is idling if it is not used for sending data or querying acknowledgement statuses.",
              "type": "boolean",
              "_metadata": {
                "docs::human_name": "Acknowledgement Idle Cleanup"
              }
            },
            "enabled": {
              "description": "Enables end-to-end acknowledgements.",
              "type": [
                "boolean",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::human_name": "Enabled"
              }
            },
            "max_idle_time": {
              "title": "The amount of time, in seconds, a channel is allowed to idle before removal.",
              "description": "Channels can potentially idle for longer than this setting but clients should not rely on such behavior.\n\nMinimum of `1`.",
              "type": "integer",
              "maximum": 9007199254740991.0,
              "minimum": 1.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::human_name": "Max Idle Time"
              }
            },
            "max_number_of_ack_channels": {
              "title": "The maximum number of Splunk HEC channels clients can use with this source.",
              "description": "Minimum of `1`.",
              "type": "integer",
              "maximum": 9007199254740991.0,
              "minimum": 1.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::human_name": "Max Number of Acknowledgement Channels"
              }
            },
            "max_pending_acks": {
              "title": "The maximum number of acknowledgement statuses pending query across all channels.",
              "description": "Equivalent to the `max_number_of_acked_requests_pending_query` Splunk HEC setting.\n\nMinimum of `1`.",
              "type": "integer",
              "maximum": 9007199254740991.0,
              "minimum": 1.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::human_name": "Max Number of Pending Acknowledgements"
              }
            },
            "max_pending_acks_per_channel": {
              "title": "The maximum number of acknowledgement statuses pending query for a single channel.",
              "description": "Equivalent to the `max_number_of_acked_requests_pending_query_per_ack_channel` Splunk HEC setting.\n\nMinimum of `1`.",
              "type": "integer",
              "maximum": 9007199254740991.0,
              "minimum": 1.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::human_name": "Max Number of Pending Acknowledgements Per Channel"
              }
            }
          },
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "address": {
          "title": "The socket address to listen for connections on.",
          "description": "The address _must_ include a port.",
          "default": "0.0.0.0:8088",
          "$ref": "#/definitions/stdlib::SocketAddr",
          "_metadata": {
            "docs::human_name": "Address"
          }
        },
        "log_namespace": {
          "description": "The namespace to use for logs. This overrides the global settings.",
          "default": null,
          "type": [
            "boolean",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::hidden": true,
            "docs::human_name": "Log Namespace"
          }
        },
        "store_hec_token": {
          "title": "Whether or not to forward the Splunk HEC authentication token with events.",
          "description": "If set to `true`, when incoming requests contain a Splunk HEC token, the token used is kept in the\nevent metadata and preferentially used if the event is sent to a Splunk HEC sink.",
          "type": "boolean",
          "_metadata": {
            "docs::human_name": "Store HEC Token"
          }
        },
        "tls": {
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        },
        "token": {
          "title": "Optional authorization token.",
          "description": "If supplied, incoming requests must supply this token in the `Authorization` header, just as a client would if\nit was communicating with the Splunk HEC endpoint directly.\n\nIf _not_ supplied, the `Authorization` header is ignored and requests are not authenticated.",
          "deprecated": true,
          "$ref": "#/definitions/core::option::Option<vector_common::sensitive_string::SensitiveString>",
          "_metadata": {
            "deprecated_message": "This option has been deprecated, use `valid_tokens` instead.",
            "docs::human_name": "Token"
          }
        },
        "valid_tokens": {
          "title": "A list of valid authorization tokens.",
          "description": "If supplied, incoming requests must supply one of these tokens in the `Authorization` header, just as a client\nwould if it was communicating with the Splunk HEC endpoint directly.\n\nIf _not_ supplied, the `Authorization` header is ignored and requests are not authenticated.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/vector_common::sensitive_string::SensitiveString"
          },
          "_metadata": {
            "sensitive": true,
            "docs::optional": true,
            "docs::examples": "A94A8FE5CCB19BA61C4C08",
            "docs::human_name": "Valid Tokens"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "splunk_hec"
      }
    },
    "vector::sources::statsd::StatsdConfig": {
      "description": "Configuration for the `statsd` source.",
      "oneOf": [
        {
          "description": "Listen on TCP.",
          "allOf": [
            {
              "description": "TCP configuration for the `statsd` source.",
              "type": "object",
              "required": [
                "address"
              ],
              "properties": {
                "address": {
                  "title": "The socket address to listen for connections on, or `systemd{#N}` to use the Nth socket passed by\nsystemd socket activation.",
                  "description": "If a socket address is used, it _must_ include a port.",
                  "$ref": "#/definitions/vector::sources::util::net::SocketListenAddr",
                  "_metadata": {
                    "docs::human_name": "Address"
                  }
                },
                "connection_limit": {
                  "description": "The maximum number of TCP connections that are allowed at any given time.",
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 4294967295.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "connections",
                    "docs::human_name": "Connection Limit"
                  }
                },
                "keepalive": {
                  "$ref": "#/definitions/core::option::Option<vector_core::tcp::TcpKeepaliveConfig>",
                  "_metadata": {
                    "docs::human_name": "Keepalive"
                  }
                },
                "receive_buffer_bytes": {
                  "description": "The size of the receive buffer used for each connection.",
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes",
                    "docs::human_name": "Receive Buffer Bytes"
                  }
                },
                "shutdown_timeout_secs": {
                  "description": "The timeout before a connection is forcefully closed during shutdown.",
                  "default": 30,
                  "$ref": "#/definitions/serde_with::DurationSeconds",
                  "_metadata": {
                    "docs::human_name": "Shutdown Timeout"
                  }
                },
                "tls": {
                  "default": null,
                  "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsSourceConfig>",
                  "_metadata": {
                    "docs::human_name": "TLS"
                  }
                }
              }
            },
            {
              "type": "object",
              "required": [
                "mode"
              ],
              "properties": {
                "mode": {
                  "description": "Listen on TCP.",
                  "const": "tcp",
                  "_metadata": {
                    "docs::human_name": "Mode"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Tcp",
            "docs::human_name": "TCP"
          }
        },
        {
          "description": "Listen on UDP.",
          "allOf": [
            {
              "description": "UDP configuration for the `statsd` source.",
              "type": "object",
              "required": [
                "address"
              ],
              "properties": {
                "address": {
                  "title": "The socket address to listen for connections on, or `systemd{#N}` to use the Nth socket passed by\nsystemd socket activation.",
                  "description": "If a socket address is used, it _must_ include a port.",
                  "$ref": "#/definitions/vector::sources::util::net::SocketListenAddr",
                  "_metadata": {
                    "docs::human_name": "Address"
                  }
                },
                "receive_buffer_bytes": {
                  "description": "The size of the receive buffer used for each connection.",
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::human_name": "Receive Buffer Bytes"
                  }
                }
              }
            },
            {
              "type": "object",
              "required": [
                "mode"
              ],
              "properties": {
                "mode": {
                  "description": "Listen on UDP.",
                  "const": "udp",
                  "_metadata": {
                    "docs::human_name": "Mode"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Udp",
            "docs::human_name": "UDP"
          }
        },
        {
          "description": "Listen on a Unix domain Socket (UDS).",
          "allOf": [
            {
              "description": "Unix domain socket configuration for the `statsd` source.",
              "type": "object",
              "required": [
                "path"
              ],
              "properties": {
                "path": {
                  "title": "The Unix socket path.",
                  "description": "This should be an absolute path.",
                  "$ref": "#/definitions/stdlib::PathBuf",
                  "_metadata": {
                    "docs::examples": "/path/to/socket",
                    "docs::human_name": "Path"
                  }
                }
              }
            },
            {
              "type": "object",
              "required": [
                "mode"
              ],
              "properties": {
                "mode": {
                  "description": "Listen on a Unix domain Socket (UDS).",
                  "const": "unix",
                  "_metadata": {
                    "docs::human_name": "Mode"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "Unix",
            "docs::human_name": "Unix"
          }
        }
      ],
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "statsd",
        "docs::enum_tag_description": "The type of socket to use.",
        "docs::enum_tagging": "internal",
        "docs::enum_tag_field": "mode"
      }
    },
    "vector::sources::syslog::SyslogConfig": {
      "description": "Configuration for the `syslog` source.",
      "allOf": [
        {
          "type": "object",
          "properties": {
            "host_key": {
              "title": "Overrides the name of the log field used to add the peer host to each event.",
              "description": "If using TCP or UDP, the value is the peer host's address, including the port. For example, `1.2.3.4:9000`. If using\nUDS, the value is the socket path itself.\n\nBy default, the [global `log_schema.host_key` option][global_host_key] is used.\n\n[global_host_key]: https://vector.dev/docs/reference/configuration/global-options/#log_schema.host_key",
              "$ref": "#/definitions/core::option::Option<vector_lookup::lookup_v2::optional_path::OptionalValuePath>",
              "_metadata": {
                "docs::human_name": "Host Key"
              }
            },
            "log_namespace": {
              "description": "The namespace to use for logs. This overrides the global setting.",
              "default": null,
              "type": [
                "boolean",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::hidden": true,
                "docs::human_name": "Log Namespace"
              }
            },
            "max_length": {
              "title": "The maximum buffer size of incoming messages, in bytes.",
              "description": "Messages larger than this are truncated.",
              "default": 102400,
              "type": "integer",
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::type_unit": "bytes",
                "docs::human_name": "Max Length"
              }
            }
          }
        },
        {
          "description": "Listener mode for the `syslog` source.",
          "oneOf": [
            {
              "description": "Listen on TCP.",
              "type": "object",
              "required": [
                "address",
                "mode"
              ],
              "properties": {
                "address": {
                  "title": "The socket address to listen for connections on, or `systemd{#N}` to use the Nth socket passed by\nsystemd socket activation.",
                  "description": "If a socket address is used, it _must_ include a port.",
                  "$ref": "#/definitions/vector::sources::util::net::SocketListenAddr",
                  "_metadata": {
                    "docs::human_name": "Address"
                  }
                },
                "connection_limit": {
                  "description": "The maximum number of TCP connections that are allowed at any given time.",
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 4294967295.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::human_name": "Connection Limit"
                  }
                },
                "keepalive": {
                  "$ref": "#/definitions/core::option::Option<vector_core::tcp::TcpKeepaliveConfig>",
                  "_metadata": {
                    "docs::human_name": "Keepalive"
                  }
                },
                "mode": {
                  "description": "Listen on TCP.",
                  "const": "tcp",
                  "_metadata": {
                    "docs::human_name": "Mode"
                  }
                },
                "receive_buffer_bytes": {
                  "title": "The size of the receive buffer used for each connection.",
                  "description": "This should not typically needed to be changed.",
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes",
                    "docs::human_name": "Receive Buffer Bytes"
                  }
                },
                "tls": {
                  "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsSourceConfig>",
                  "_metadata": {
                    "docs::human_name": "TLS"
                  }
                }
              },
              "_metadata": {
                "logical_name": "Tcp",
                "docs::human_name": "TCP"
              }
            },
            {
              "description": "Listen on UDP.",
              "type": "object",
              "required": [
                "address",
                "mode"
              ],
              "properties": {
                "address": {
                  "title": "The socket address to listen for connections on, or `systemd{#N}` to use the Nth socket passed by\nsystemd socket activation.",
                  "description": "If a socket address is used, it _must_ include a port.",
                  "$ref": "#/definitions/vector::sources::util::net::SocketListenAddr",
                  "_metadata": {
                    "docs::human_name": "Address"
                  }
                },
                "mode": {
                  "description": "Listen on UDP.",
                  "const": "udp",
                  "_metadata": {
                    "docs::human_name": "Mode"
                  }
                },
                "receive_buffer_bytes": {
                  "title": "The size of the receive buffer used for the listening socket.",
                  "description": "This should not typically needed to be changed.",
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 9007199254740991.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::type_unit": "bytes",
                    "docs::human_name": "Receive Buffer Bytes"
                  }
                }
              },
              "_metadata": {
                "logical_name": "Udp",
                "docs::human_name": "UDP"
              }
            },
            {
              "description": "Listen on UDS. (Unix domain socket)",
              "type": "object",
              "required": [
                "mode",
                "path"
              ],
              "properties": {
                "mode": {
                  "description": "Listen on UDS. (Unix domain socket)",
                  "const": "unix",
                  "_metadata": {
                    "docs::human_name": "Mode"
                  }
                },
                "path": {
                  "title": "The Unix socket path.",
                  "description": "This should be an absolute path.",
                  "$ref": "#/definitions/stdlib::PathBuf",
                  "_metadata": {
                    "docs::examples": "/path/to/socket",
                    "docs::human_name": "Path"
                  }
                },
                "socket_file_mode": {
                  "title": "Unix file mode bits to be applied to the unix socket file as its designated file permissions.",
                  "description": "The file mode value can be specified in any numeric format supported by your configuration\nlanguage, but it is most intuitive to use an octal number.",
                  "type": [
                    "integer",
                    "null"
                  ],
                  "maximum": 4294967295.0,
                  "minimum": 0.0,
                  "_metadata": {
                    "docs::numeric_type": "uint",
                    "docs::optional": true,
                    "docs::human_name": "Socket File Mode"
                  }
                }
              },
              "_metadata": {
                "logical_name": "Unix",
                "docs::human_name": "Unix"
              }
            }
          ],
          "_metadata": {
            "docs::enum_tag_description": "The type of socket to use.",
            "docs::enum_tagging": "internal",
            "docs::enum_tag_field": "mode"
          }
        }
      ],
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "syslog"
      }
    },
    "vector::sources::util::http::method::HttpMethod": {
      "description": "HTTP method.",
      "oneOf": [
        {
          "description": "HTTP HEAD method.",
          "const": "HEAD",
          "_metadata": {
            "logical_name": "Head",
            "docs::human_name": "Head"
          }
        },
        {
          "description": "HTTP GET method.",
          "const": "GET",
          "_metadata": {
            "logical_name": "Get",
            "docs::human_name": "Get"
          }
        },
        {
          "description": "HTTP POST method.",
          "const": "POST",
          "_metadata": {
            "logical_name": "Post",
            "docs::human_name": "Post"
          }
        },
        {
          "description": "HTTP Put method.",
          "const": "PUT",
          "_metadata": {
            "logical_name": "Put",
            "docs::human_name": "Put"
          }
        },
        {
          "description": "HTTP PATCH method.",
          "const": "PATCH",
          "_metadata": {
            "logical_name": "Patch",
            "docs::human_name": "Patch"
          }
        },
        {
          "description": "HTTP DELETE method.",
          "const": "DELETE",
          "_metadata": {
            "logical_name": "Delete",
            "docs::human_name": "Delete"
          }
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::enum_tagging": "external"
      }
    },
    "vector::sources::util::net::SocketListenAddr": {
      "title": "The socket address to listen for connections on, or `systemd{#N}` to use the Nth socket passed by\nsystemd socket activation.",
      "description": "If a socket address is used, it _must_ include a port.",
      "type": "string",
      "_metadata": {
        "docs::examples": [
          "0.0.0.0:9000",
          "systemd",
          "systemd#3"
        ],
        "docs::enum_tagging": "untagged"
      }
    },
    "vector::sources::vector::VectorConfig": {
      "description": "Configuration for the `vector` source.",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "acknowledgements": {
          "title": "Controls how acknowledgements are handled by this source.",
          "description": "This setting is **deprecated** in favor of enabling `acknowledgements` at the [global][global_acks] or sink level.\n\nEnabling or disabling acknowledgements at the source level has **no effect** on acknowledgement behavior.\n\nSee [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
          "default": {
            "enabled": null
          },
          "$ref": "#/definitions/vector_core::config::SourceAcknowledgementsConfig",
          "_metadata": {
            "docs::human_name": "Acknowledgements"
          }
        },
        "address": {
          "title": "The socket address to listen for connections on.",
          "description": "It _must_ include a port.",
          "$ref": "#/definitions/stdlib::SocketAddr",
          "_metadata": {
            "docs::human_name": "Address"
          }
        },
        "log_namespace": {
          "description": "The namespace to use for logs. This overrides the global setting.",
          "default": null,
          "type": [
            "boolean",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::hidden": true,
            "docs::human_name": "Log Namespace"
          }
        },
        "tls": {
          "default": null,
          "$ref": "#/definitions/core::option::Option<vector_core::tls::settings::TlsEnableableConfig>",
          "_metadata": {
            "docs::human_name": "TLS"
          }
        },
        "version": {
          "description": "Version of the configuration.",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "description": "Marker type for version two of the configuration for the `vector` source.",
              "oneOf": [
                {
                  "description": "Marker value for version two.",
                  "const": "2",
                  "_metadata": {
                    "logical_name": "V2",
                    "docs::human_name": "V2"
                  }
                }
              ],
              "_metadata": {
                "docs::enum_tagging": "external"
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Version"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "source",
        "docs::component_name": "vector"
      }
    },
    "vector::template::Template": {
      "title": "A templated field.",
      "description": "In many cases, components can be configured so that part of the component's functionality can be\ncustomized on a per-event basis. For example, you have a sink that writes events to a file and you want to\nspecify which file an event should go to by using an event field as part of the\ninput to the filename used.\n\nBy using `Template`, users can specify either fixed strings or templated strings. Templated strings use a common syntax to\nrefer to fields in an event that is used as the input data when rendering the template. An example of a fixed string\nis `my-file.log`. An example of a template string is `my-file-{{key}}.log`, where `{{key}}`\nis the key's value when the template is rendered into a string.",
      "type": "string",
      "_metadata": {
        "docs::templateable": true
      }
    },
    "vector::transforms::Transforms": {
      "description": "Configurable transforms in Vector.",
      "oneOf": [
        {
          "description": "Aggregate metrics passing through a topology.",
          "allOf": [
            {
              "description": "Configuration for the `aggregate` transform.",
              "$ref": "#/definitions/vector::transforms::aggregate::AggregateConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Aggregate metrics passing through a topology.",
                  "const": "aggregate",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Aggregate",
            "logical_name": "Aggregate"
          }
        },
        {
          "description": "Parse metadata emitted by AWS EC2 instances.",
          "allOf": [
            {
              "description": "Configuration for the `aws_ec2_metadata` transform.",
              "$ref": "#/definitions/vector::transforms::aws_ec2_metadata::Ec2Metadata"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Parse metadata emitted by AWS EC2 instances.",
                  "const": "aws_ec2_metadata",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "AWS EC2 Metadata",
            "logical_name": "Ec2Metadata"
          }
        },
        {
          "description": "Deduplicate logs passing through a topology.",
          "allOf": [
            {
              "description": "Configuration for the `dedupe` transform.",
              "$ref": "#/definitions/vector::transforms::dedupe::DedupeConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Deduplicate logs passing through a topology.",
                  "const": "dedupe",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Dedupe",
            "logical_name": "Dedupe"
          }
        },
        {
          "description": "Filter events based on a set of conditions.",
          "allOf": [
            {
              "description": "Configuration for the `filter` transform.",
              "$ref": "#/definitions/vector::transforms::filter::FilterConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Filter events based on a set of conditions.",
                  "const": "filter",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Filter",
            "logical_name": "Filter"
          }
        },
        {
          "description": "Convert log events to metric events.",
          "allOf": [
            {
              "description": "Configuration for the `log_to_metric` transform.",
              "$ref": "#/definitions/vector::transforms::log_to_metric::LogToMetricConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Convert log events to metric events.",
                  "const": "log_to_metric",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Log To Metric",
            "logical_name": "LogToMetric"
          }
        },
        {
          "description": "Modify event data using the Lua programming language.",
          "allOf": [
            {
              "description": "Configuration for the `lua` transform.",
              "$ref": "#/definitions/vector::transforms::lua::LuaConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Modify event data using the Lua programming language.",
                  "const": "lua",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Lua",
            "logical_name": "Lua"
          }
        },
        {
          "description": "Convert metric events to log events.",
          "allOf": [
            {
              "description": "Configuration for the `metric_to_log` transform.",
              "$ref": "#/definitions/vector::transforms::metric_to_log::MetricToLogConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Convert metric events to log events.",
                  "const": "metric_to_log",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Metric To Log",
            "logical_name": "MetricToLog"
          }
        },
        {
          "description": "Collapse multiple log events into a single event based on a set of conditions and merge strategies.",
          "allOf": [
            {
              "description": "Configuration for the `reduce` transform.",
              "$ref": "#/definitions/vector::transforms::reduce::ReduceConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Collapse multiple log events into a single event based on a set of conditions and merge strategies.",
                  "const": "reduce",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Reduce",
            "logical_name": "Reduce"
          }
        },
        {
          "description": "Modify your observability data as it passes through your topology using Vector Remap Language (VRL).",
          "allOf": [
            {
              "description": "Configuration for the `remap` transform.",
              "$ref": "#/definitions/vector::transforms::remap::RemapConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Modify your observability data as it passes through your topology using Vector Remap Language (VRL).",
                  "const": "remap",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Remap",
            "logical_name": "Remap"
          }
        },
        {
          "description": "Split a stream of events into multiple sub-streams based on user-supplied conditions.",
          "allOf": [
            {
              "description": "Configuration for the `route` transform.",
              "$ref": "#/definitions/vector::transforms::route::RouteConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Split a stream of events into multiple sub-streams based on user-supplied conditions.",
                  "const": "route",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Route",
            "logical_name": "Route"
          }
        },
        {
          "description": "Sample events from an event stream based on supplied criteria and at a configurable rate.",
          "allOf": [
            {
              "description": "Configuration for the `sample` transform.",
              "$ref": "#/definitions/vector::transforms::sample::SampleConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Sample events from an event stream based on supplied criteria and at a configurable rate.",
                  "const": "sample",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Sample",
            "logical_name": "Sample"
          }
        },
        {
          "description": "Limit the cardinality of tags on metrics events as a safeguard against cardinality explosion.",
          "allOf": [
            {
              "description": "Configuration for the `tag_cardinality_limit` transform.",
              "$ref": "#/definitions/vector::transforms::tag_cardinality_limit::config::TagCardinalityLimitConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Limit the cardinality of tags on metrics events as a safeguard against cardinality explosion.",
                  "const": "tag_cardinality_limit",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Tag Cardinality Limit",
            "logical_name": "TagCardinalityLimit"
          }
        },
        {
          "description": "Rate limit logs passing through a topology.",
          "allOf": [
            {
              "description": "Configuration for the `throttle` transform.",
              "$ref": "#/definitions/vector::transforms::throttle::ThrottleConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "description": "Rate limit logs passing through a topology.",
                  "const": "throttle",
                  "_metadata": {
                    "docs::human_name": "Type"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "docs::human_name": "Throttle",
            "logical_name": "Throttle"
          }
        }
      ],
      "_metadata": {
        "docs::enum_tagging": "internal",
        "docs::enum_tag_field": "type"
      }
    },
    "vector::transforms::aggregate::AggregateConfig": {
      "description": "Configuration for the `aggregate` transform.",
      "type": "object",
      "properties": {
        "interval_ms": {
          "title": "The interval between flushes, in milliseconds.",
          "description": "During this time frame, metrics with the same series data (name, namespace, tags, and so on) are aggregated.",
          "default": 10000,
          "type": "integer",
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::human_name": "Flush Interval"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "transform",
        "docs::component_name": "aggregate"
      }
    },
    "vector::transforms::aws_ec2_metadata::Ec2Metadata": {
      "description": "Configuration for the `aws_ec2_metadata` transform.",
      "type": "object",
      "properties": {
        "endpoint": {
          "description": "Overrides the default EC2 metadata endpoint.",
          "default": "http://169.254.169.254",
          "type": "string",
          "_metadata": {
            "docs::human_name": "Endpoint"
          }
        },
        "fields": {
          "description": "A list of metadata fields to include in each transformed event.",
          "default": [
            "ami-id",
            "availability-zone",
            "instance-id",
            "instance-type",
            "local-hostname",
            "local-ipv4",
            "public-hostname",
            "public-ipv4",
            "region",
            "subnet-id",
            "vpc-id",
            "role-name"
          ],
          "type": "array",
          "items": {
            "type": "string"
          },
          "_metadata": {
            "docs::examples": [
              "instance-id",
              "local-hostname"
            ],
            "docs::human_name": "Fields"
          }
        },
        "namespace": {
          "description": "Sets a prefix for all event fields added by the transform.",
          "$ref": "#/definitions/core::option::Option<vector_lookup::lookup_v2::optional_path::OptionalTargetPath>",
          "_metadata": {
            "docs::examples": [
              "",
              "ec2",
              "aws.ec2"
            ],
            "docs::human_name": "Namespace"
          }
        },
        "proxy": {
          "title": "Proxy configuration.",
          "description": "Configure to proxy traffic through an HTTP(S) proxy when making external requests.\n\nSimilar to common proxy configuration convention, you can set different proxies\nto use based on the type of traffic being proxied, as well as set specific hosts that\nshould not be proxied.",
          "default": {
            "enabled": true,
            "http": null,
            "https": null
          },
          "$ref": "#/definitions/vector_core::config::proxy::ProxyConfig",
          "_metadata": {
            "docs::human_name": "Proxy"
          }
        },
        "refresh_interval_secs": {
          "description": "The interval between querying for updated metadata, in seconds.",
          "default": 10,
          "$ref": "#/definitions/serde_with::DurationSeconds",
          "_metadata": {
            "docs::human_name": "Refresh Interval Secs"
          }
        },
        "refresh_timeout_secs": {
          "description": "The timeout for querying the EC2 metadata endpoint, in seconds.",
          "default": 1,
          "$ref": "#/definitions/serde_with::DurationSeconds",
          "_metadata": {
            "docs::human_name": "Refresh Timeout Secs"
          }
        },
        "required": {
          "description": "Requires the transform to be able to successfully query the EC2 metadata before starting to process the data.",
          "default": true,
          "type": "boolean",
          "_metadata": {
            "docs::human_name": "Required"
          }
        },
        "tags": {
          "description": "A list of instance tags to include in each transformed event.",
          "default": [],
          "type": "array",
          "items": {
            "type": "string"
          },
          "_metadata": {
            "docs::examples": [
              "Name",
              "Project"
            ],
            "docs::human_name": "Tags"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "transform",
        "docs::component_name": "aws_ec2_metadata"
      }
    },
    "vector::transforms::dedupe::DedupeConfig": {
      "description": "Configuration for the `dedupe` transform.",
      "type": "object",
      "properties": {
        "cache": {
          "description": "Caching configuration for deduplication.",
          "default": {
            "num_events": 5000
          },
          "type": "object",
          "required": [
            "num_events"
          ],
          "properties": {
            "num_events": {
              "description": "Number of events to cache and use for comparing incoming events to previously seen events.",
              "type": "integer",
              "maximum": 9007199254740991.0,
              "minimum": 1.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::human_name": "Num Events"
              }
            }
          },
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::human_name": "Cache"
          }
        },
        "fields": {
          "title": "Options to control what fields to match against.",
          "description": "When no field matching configuration is specified, events are matched using the `timestamp`,\n`host`, and `message` fields from an event. The specific field names used are those set in\nthe global [`log schema`][global_log_schema] configuration.\n\n[global_log_schema]: https://vector.dev/docs/reference/configuration/global-options/#log_schema",
          "default": null,
          "oneOf": [
            {
              "type": "null"
            },
            {
              "title": "Options to control what fields to match against.",
              "description": "When no field matching configuration is specified, events are matched using the `timestamp`,\n`host`, and `message` fields from an event. The specific field names used are those set in\nthe global [`log schema`][global_log_schema] configuration.\n\n[global_log_schema]: https://vector.dev/docs/reference/configuration/global-options/#log_schema",
              "oneOf": [
                {
                  "description": "Matches events using only the specified fields.",
                  "type": "object",
                  "required": [
                    "match"
                  ],
                  "properties": {
                    "match": {
                      "description": "A wrapper around `OwnedTargetPath` that allows it to be used in Vector config\nwith prefix default to `PathPrefix::Event`",
                      "type": "array",
                      "items": {
                        "$ref": "#/definitions/vector_lookup::lookup_v2::ConfigTargetPath"
                      },
                      "_metadata": {
                        "docs::examples": [
                          "field1",
                          "parent.child_field"
                        ],
                        "docs::human_name": "Match"
                      }
                    }
                  },
                  "_metadata": {
                    "logical_name": "MatchFields",
                    "docs::human_name": "Match Fields"
                  }
                },
                {
                  "description": "Matches events using all fields except for the ignored ones.",
                  "type": "object",
                  "required": [
                    "ignore"
                  ],
                  "properties": {
                    "ignore": {
                      "description": "A wrapper around `OwnedTargetPath` that allows it to be used in Vector config\nwith prefix default to `PathPrefix::Event`",
                      "type": "array",
                      "items": {
                        "$ref": "#/definitions/vector_lookup::lookup_v2::ConfigTargetPath"
                      },
                      "_metadata": {
                        "docs::examples": [
                          "field1",
                          "parent.child_field",
                          "host",
                          "hostname"
                        ],
                        "docs::human_name": "Ignore"
                      }
                    }
                  },
                  "_metadata": {
                    "logical_name": "IgnoreFields",
                    "docs::human_name": "Ignore Fields"
                  }
                }
              ],
              "_metadata": {
                "docs::enum_tagging": "external"
              }
            }
          ],
          "unevaluatedProperties": false,
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Fields"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "transform",
        "docs::component_name": "dedupe"
      }
    },
    "vector::transforms::filter::FilterConfig": {
      "description": "Configuration for the `filter` transform.",
      "type": "object",
      "required": [
        "condition"
      ],
      "properties": {
        "condition": {
          "title": "The condition that every input event is matched against.",
          "description": "If an event is matched by the condition, it is forwarded. Otherwise, the event is dropped.",
          "$ref": "#/definitions/vector::conditions::AnyCondition",
          "_metadata": {
            "docs::human_name": "Condition"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "transform",
        "docs::component_name": "filter"
      }
    },
    "vector::transforms::log_to_metric::LogToMetricConfig": {
      "description": "Configuration for the `log_to_metric` transform.",
      "type": "object",
      "required": [
        "metrics"
      ],
      "properties": {
        "metrics": {
          "description": "A list of metrics to generate.",
          "type": "array",
          "items": {
            "description": "Specification of a metric derived from a log event.",
            "allOf": [
              {
                "type": "object",
                "required": [
                  "field"
                ],
                "properties": {
                  "field": {
                    "description": "Name of the field in the event to generate the metric.",
                    "$ref": "#/definitions/vector::template::Template",
                    "_metadata": {
                      "docs::human_name": "Field"
                    }
                  },
                  "name": {
                    "title": "Overrides the name of the counter.",
                    "description": "If not specified, `field` is used as the name of the metric.",
                    "$ref": "#/definitions/core::option::Option<vector::template::Template>",
                    "_metadata": {
                      "docs::human_name": "Name"
                    }
                  },
                  "namespace": {
                    "description": "Sets the namespace for the metric.",
                    "$ref": "#/definitions/core::option::Option<vector::template::Template>",
                    "_metadata": {
                      "docs::human_name": "Namespace"
                    }
                  },
                  "tags": {
                    "description": "Tags to apply to the metric.",
                    "type": [
                      "object",
                      "null"
                    ],
                    "additionalProperties": {
                      "title": "Specification of the value of a created tag.",
                      "description": "This may be a single value, a `null` for a bare tag, or an array of either.",
                      "oneOf": [
                        {
                          "description": "A single tag value.",
                          "$ref": "#/definitions/core::option::Option<vector::template::Template>",
                          "_metadata": {
                            "logical_name": "Plain",
                            "docs::human_name": "Plain"
                          }
                        },
                        {
                          "description": "An array of values to give to the same tag name.",
                          "type": "array",
                          "items": {
                            "$ref": "#/definitions/core::option::Option<vector::template::Template>"
                          },
                          "_metadata": {
                            "logical_name": "Multi",
                            "docs::human_name": "Multi"
                          }
                        }
                      ],
                      "unevaluatedProperties": false,
                      "_metadata": {
                        "docs::enum_tagging": "untagged"
                      }
                    },
                    "_metadata": {
                      "docs::optional": true,
                      "docs::additional_props_description": "A metric tag.",
                      "docs::human_name": "Tags"
                    }
                  }
                }
              },
              {
                "description": "Specification of the type of an individual metric, and any associated data.",
                "oneOf": [
                  {
                    "description": "A counter.",
                    "allOf": [
                      {
                        "description": "Specification of a counter derived from a log event.",
                        "type": "object",
                        "properties": {
                          "increment_by_value": {
                            "description": "Increments the counter by the value in `field`, instead of only by `1`.",
                            "default": false,
                            "type": "boolean",
                            "_metadata": {
                              "docs::human_name": "Increment By Value"
                            }
                          },
                          "kind": {
                            "title": "Metric kind.",
                            "description": "Metrics can be either absolute of incremental. Absolute metrics represent a sort of \"last write wins\" scenario,\nwhere the latest absolute value seen is meant to be the actual metric value.  In contrast, and perhaps intuitively,\nincremental metrics are meant to be additive, such that we don't know what total value of the metric is, but we know\nthat we'll be adding or subtracting the given value from it.\n\nGenerally speaking, most metrics storage systems deal with incremental updates. A notable exception is Prometheus,\nwhich deals with, and expects, absolute values from clients.",
                            "default": "incremental",
                            "$ref": "#/definitions/vector_core::event::metric::MetricKind",
                            "_metadata": {
                              "docs::human_name": "Kind"
                            }
                          }
                        }
                      },
                      {
                        "type": "object",
                        "required": [
                          "type"
                        ],
                        "properties": {
                          "type": {
                            "description": "A counter.",
                            "const": "counter",
                            "_metadata": {
                              "docs::human_name": "Type"
                            }
                          }
                        }
                      }
                    ],
                    "_metadata": {
                      "logical_name": "Counter",
                      "docs::human_name": "Counter"
                    }
                  },
                  {
                    "description": "A histogram.",
                    "type": "object",
                    "required": [
                      "type"
                    ],
                    "properties": {
                      "type": {
                        "description": "A histogram.",
                        "const": "histogram",
                        "_metadata": {
                          "docs::human_name": "Type"
                        }
                      }
                    },
                    "_metadata": {
                      "logical_name": "Histogram",
                      "docs::human_name": "Histogram"
                    }
                  },
                  {
                    "description": "A gauge.",
                    "type": "object",
                    "required": [
                      "type"
                    ],
                    "properties": {
                      "type": {
                        "description": "A gauge.",
                        "const": "gauge",
                        "_metadata": {
                          "docs::human_name": "Type"
                        }
                      }
                    },
                    "_metadata": {
                      "logical_name": "Gauge",
                      "docs::human_name": "Gauge"
                    }
                  },
                  {
                    "description": "A set.",
                    "type": "object",
                    "required": [
                      "type"
                    ],
                    "properties": {
                      "type": {
                        "description": "A set.",
                        "const": "set",
                        "_metadata": {
                          "docs::human_name": "Type"
                        }
                      }
                    },
                    "_metadata": {
                      "logical_name": "Set",
                      "docs::human_name": "Set"
                    }
                  },
                  {
                    "description": "A summary.",
                    "type": "object",
                    "required": [
                      "type"
                    ],
                    "properties": {
                      "type": {
                        "description": "A summary.",
                        "const": "summary",
                        "_metadata": {
                          "docs::human_name": "Type"
                        }
                      }
                    },
                    "_metadata": {
                      "logical_name": "Summary",
                      "docs::human_name": "Summary"
                    }
                  }
                ],
                "_metadata": {
                  "docs::enum_tag_description": "The type of metric to create.",
                  "docs::enum_tagging": "internal",
                  "docs::enum_tag_field": "type"
                }
              }
            ],
            "unevaluatedProperties": false
          },
          "_metadata": {
            "docs::human_name": "Metrics"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "transform",
        "docs::component_name": "log_to_metric"
      }
    },
    "vector::transforms::lua::LuaConfig": {
      "description": "Configuration for the `lua` transform.",
      "oneOf": [
        {
          "description": "Configuration for version one.",
          "allOf": [
            {
              "type": "object",
              "properties": {
                "version": {
                  "title": "Transform API version.",
                  "description": "Specifying this version ensures that backward compatibility is not broken.",
                  "oneOf": [
                    {
                      "type": "null"
                    },
                    {
                      "description": "Marker type for the version one of the configuration for the `lua` transform.",
                      "oneOf": [
                        {
                          "title": "Lua transform API version 1.",
                          "description": "This version is deprecated and will be removed in a future version.",
                          "const": "1",
                          "_metadata": {
                            "deprecated": true,
                            "logical_name": "V1",
                            "docs::human_name": "V1"
                          }
                        }
                      ],
                      "_metadata": {
                        "docs::enum_tagging": "external"
                      }
                    }
                  ],
                  "unevaluatedProperties": false,
                  "_metadata": {
                    "docs::optional": true,
                    "docs::human_name": "Version"
                  }
                }
              }
            },
            {
              "description": "Configuration for version one of the `lua` transform.",
              "type": "object",
              "required": [
                "source"
              ],
              "properties": {
                "search_dirs": {
                  "title": "A list of directories to search when loading a Lua file via the `require` function.",
                  "description": "If not specified, the modules are looked up in the configuration directories.",
                  "default": [],
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "_metadata": {
                    "docs::human_name": "Search Dirs"
                  }
                },
                "source": {
                  "description": "The Lua program to execute for each event.",
                  "type": "string",
                  "_metadata": {
                    "docs::human_name": "Source"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "V1",
            "docs::human_name": "V1"
          }
        },
        {
          "description": "Configuration for version two.",
          "allOf": [
            {
              "type": "object",
              "required": [
                "version"
              ],
              "properties": {
                "version": {
                  "title": "Transform API version.",
                  "description": "Specifying this version ensures that backward compatibility is not broken.",
                  "oneOf": [
                    {
                      "description": "Lua transform API version 2.",
                      "const": "2",
                      "_metadata": {
                        "logical_name": "V2",
                        "docs::human_name": "V2"
                      }
                    }
                  ],
                  "unevaluatedProperties": false,
                  "_metadata": {
                    "docs::enum_tagging": "external",
                    "docs::human_name": "Version"
                  }
                }
              }
            },
            {
              "description": "Configuration for the version two of the `lua` transform.",
              "type": "object",
              "required": [
                "hooks"
              ],
              "properties": {
                "hooks": {
                  "title": "Lifecycle hooks.",
                  "description": "These hooks can be set to perform additional processing during the lifecycle of the transform.",
                  "type": "object",
                  "required": [
                    "process"
                  ],
                  "properties": {
                    "init": {
                      "title": "The function called when the first event comes in, before `hooks.process` is called.",
                      "description": "It can produce new events using the `emit` function.\n\nThis can either be inline Lua that defines a closure to use, or the name of the Lua function to call. In both\ncases, the closure/function takes a single parameter, `emit`, which is a reference to a function for emitting events.",
                      "type": [
                        "string",
                        "null"
                      ],
                      "_metadata": {
                        "docs::optional": true,
                        "docs::examples": [
                          "function (emit)\n\t-- Custom Lua code here\nend",
                          "init"
                        ],
                        "docs::human_name": "Init"
                      }
                    },
                    "process": {
                      "title": "The function called for each incoming event.",
                      "description": "It can produce new events using the `emit` function.\n\nThis can either be inline Lua that defines a closure to use, or the name of the Lua function to call. In both\ncases, the closure/function takes two parameters. The first parameter, `event`, is the event being processed,\nwhile the second parameter, `emit`, is a reference to a function for emitting events.",
                      "type": "string",
                      "_metadata": {
                        "docs::examples": [
                          "function (event, emit)\n\tevent.log.field = \"value\" -- set value of a field\n\tevent.log.another_field = nil -- remove field\n\tevent.log.first, event.log.second = nil, event.log.first -- rename field\n\t-- Very important! Emit the processed event.\n\temit(event)\nend",
                          "process"
                        ],
                        "docs::human_name": "Process"
                      }
                    },
                    "shutdown": {
                      "title": "The function called when the transform is stopped.",
                      "description": "It can produce new events using the `emit` function.\n\nThis can either be inline Lua that defines a closure to use, or the name of the Lua function to call. In both\ncases, the closure/function takes a single parameter, `emit`, which is a reference to a function for emitting events.",
                      "type": [
                        "string",
                        "null"
                      ],
                      "_metadata": {
                        "docs::optional": true,
                        "docs::examples": [
                          "function (emit)\n\t-- Custom Lua code here\nend",
                          "shutdown"
                        ],
                        "docs::human_name": "Shutdown"
                      }
                    }
                  },
                  "unevaluatedProperties": false,
                  "_metadata": {
                    "docs::human_name": "Hooks"
                  }
                },
                "metric_tag_values": {
                  "title": "When set to `single`, metric tag values are exposed as single strings, the\nsame as they were before this config option. Tags with multiple values show the last assigned value, and null values\nare ignored.",
                  "description": "When set to `full`, all metric tags are exposed as arrays of either string or null\nvalues.",
                  "default": "single",
                  "$ref": "#/definitions/codecs::MetricTagValues",
                  "_metadata": {
                    "docs::human_name": "Metric Tag Values"
                  }
                },
                "search_dirs": {
                  "title": "A list of directories to search when loading a Lua file via the `require` function.",
                  "description": "If not specified, the modules are looked up in the configuration directories.",
                  "default": [],
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/stdlib::PathBuf"
                  },
                  "_metadata": {
                    "docs::examples": "/etc/vector/lua",
                    "docs::human_name": "Search Directories"
                  }
                },
                "source": {
                  "title": "The Lua program to initialize the transform with.",
                  "description": "The program can be used to to import external dependencies, as well as define the functions\nused for the various lifecycle hooks. However, it's not strictly required, as the lifecycle\nhooks can be configured directly with inline Lua source for each respective hook.",
                  "type": [
                    "string",
                    "null"
                  ],
                  "_metadata": {
                    "docs::optional": true,
                    "docs::examples": [
                      "function init()\n\tcount = 0\nend\n\nfunction process()\n\tcount = count + 1\nend\n\nfunction timer_handler(emit)\n\temit(make_counter(counter))\n\tcounter = 0\nend\n\nfunction shutdown(emit)\n\temit(make_counter(counter))\nend\n\nfunction make_counter(value)\n\treturn metric = {\n\t\tname = \"event_counter\",\n\t\tkind = \"incremental\",\n\t\ttimestamp = os.date(\"!*t\"),\n\t\tcounter = {\n\t\t\tvalue = value\n\t\t}\n \t}\nend",
                      "-- external file with hooks and timers defined\nrequire('custom_module')"
                    ],
                    "docs::human_name": "Source"
                  }
                },
                "timers": {
                  "description": "A list of timers which should be configured and executed periodically.",
                  "default": [],
                  "type": "array",
                  "items": {
                    "description": "A Lua timer.",
                    "type": "object",
                    "required": [
                      "handler",
                      "interval_seconds"
                    ],
                    "properties": {
                      "handler": {
                        "title": "The handler function which is called when the timer ticks.",
                        "description": "It can produce new events using the `emit` function.\n\nThis can either be inline Lua that defines a closure to use, or the name of the Lua function\nto call. In both cases, the closure/function takes a single parameter, `emit`, which is a\nreference to a function for emitting events.",
                        "type": "string",
                        "_metadata": {
                          "docs::examples": "timer_handler",
                          "docs::human_name": "Handler"
                        }
                      },
                      "interval_seconds": {
                        "description": "The interval to execute the handler, in seconds.",
                        "$ref": "#/definitions/serde_with::DurationSeconds",
                        "_metadata": {
                          "docs::human_name": "Interval"
                        }
                      }
                    },
                    "unevaluatedProperties": false
                  },
                  "_metadata": {
                    "docs::human_name": "Timers"
                  }
                }
              }
            }
          ],
          "_metadata": {
            "logical_name": "V2",
            "docs::human_name": "V2"
          }
        }
      ],
      "_metadata": {
        "docs::component_type": "transform",
        "docs::component_name": "lua",
        "docs::enum_tagging": "untagged"
      }
    },
    "vector::transforms::metric_to_log::MetricToLogConfig": {
      "description": "Configuration for the `metric_to_log` transform.",
      "type": "object",
      "properties": {
        "host_tag": {
          "title": "Name of the tag in the metric to use for the source host.",
          "description": "If present, the value of the tag is set on the generated log event in the `host` field,\nwhere the field key uses the [global `host_key` option][global_log_schema_host_key].\n\n[global_log_schema_host_key]: https://vector.dev/docs/reference/configuration//global-options#log_schema.host_key",
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::examples": [
              "host",
              "hostname"
            ],
            "docs::human_name": "Host Tag"
          }
        },
        "log_namespace": {
          "description": "The namespace to use for logs. This overrides the global setting.",
          "default": null,
          "type": [
            "boolean",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::hidden": true,
            "docs::human_name": "Log Namespace"
          }
        },
        "metric_tag_values": {
          "title": "Controls how metric tag values are encoded.",
          "description": "When set to `single`, only the last non-bare value of tags are displayed with the\nmetric.  When set to `full`, all metric tags are exposed as separate assignments as\ndescribed by [the `native_json` codec][vector_native_json].\n\n[vector_native_json]: https://github.com/vectordotdev/vector/blob/master/lib/codecs/tests/data/native_encoding/schema.cue",
          "default": "single",
          "$ref": "#/definitions/codecs::MetricTagValues",
          "_metadata": {
            "docs::human_name": "Metric Tag Values"
          }
        },
        "timezone": {
          "title": "The name of the time zone to apply to timestamp conversions that do not contain an explicit\ntime zone.",
          "description": "This overrides the [global `timezone`][global_timezone] option. The time zone name may be\nany name in the [TZ database][tz_database] or `local` to indicate system local time.\n\n[global_timezone]: https://vector.dev/docs/reference/configuration//global-options#timezone\n[tz_database]: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones",
          "$ref": "#/definitions/core::option::Option<vrl::compiler::datetime::TimeZone>",
          "_metadata": {
            "docs::human_name": "Timezone"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "transform",
        "docs::component_name": "metric_to_log"
      }
    },
    "vector::transforms::reduce::ReduceConfig": {
      "description": "Configuration for the `reduce` transform.",
      "type": "object",
      "properties": {
        "ends_when": {
          "title": "A condition used to distinguish the final event of a transaction.",
          "description": "If this condition resolves to `true` for an event, the current transaction is immediately\nflushed with this event.",
          "$ref": "#/definitions/core::option::Option<vector::conditions::AnyCondition>",
          "_metadata": {
            "docs::human_name": "Ends When"
          }
        },
        "expire_after_ms": {
          "description": "The maximum period of time to wait after the last event is received, in milliseconds, before\na combined event should be considered complete.",
          "default": 30000,
          "$ref": "#/definitions/serde_with::DurationMilliSeconds",
          "_metadata": {
            "docs::human_name": "Expire After"
          }
        },
        "flush_period_ms": {
          "description": "The interval to check for and flush any expired events, in milliseconds.",
          "default": 1000,
          "$ref": "#/definitions/serde_with::DurationMilliSeconds",
          "_metadata": {
            "docs::human_name": "Flush Period"
          }
        },
        "group_by": {
          "title": "An ordered list of fields by which to group events.",
          "description": "Each group with matching values for the specified keys is reduced independently, allowing\nyou to keep independent event streams separate. When no fields are specified, all events\nare combined in a single group.\n\nFor example, if `group_by = [\"host\", \"region\"]`, then all incoming events that have the same\nhost and region are grouped together before being reduced.",
          "default": [],
          "type": "array",
          "items": {
            "type": "string"
          },
          "_metadata": {
            "docs::examples": [
              "request_id",
              "user_id",
              "transaction_id"
            ],
            "docs::human_name": "Group By"
          }
        },
        "max_events": {
          "description": "The maximum number of events to group together.",
          "type": [
            "integer",
            "null"
          ],
          "maximum": 9007199254740991.0,
          "minimum": 1.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::optional": true,
            "docs::human_name": "Max Events"
          }
        },
        "merge_strategies": {
          "title": "A map of field names to custom merge strategies.",
          "description": "For each field specified, the given strategy is used for combining events rather than\nthe default behavior.\n\nThe default behavior is as follows:\n\n- The first value of a string field is kept and subsequent values are discarded.\n- For timestamp fields the first is kept and a new field `[field-name]_end` is added with\n  the last received timestamp value.\n- Numeric values are summed.",
          "default": {},
          "type": "object",
          "additionalProperties": {
            "description": "Strategies for merging events.",
            "oneOf": [
              {
                "description": "Discard all but the first value found.",
                "const": "discard",
                "_metadata": {
                  "logical_name": "Discard",
                  "docs::human_name": "Discard"
                }
              },
              {
                "title": "Discard all but the last value found.",
                "description": "Works as a way to coalesce by not retaining `null`.",
                "const": "retain",
                "_metadata": {
                  "logical_name": "Retain",
                  "docs::human_name": "Retain"
                }
              },
              {
                "description": "Sum all numeric values.",
                "const": "sum",
                "_metadata": {
                  "logical_name": "Sum",
                  "docs::human_name": "Sum"
                }
              },
              {
                "description": "Keep the maximum numeric value seen.",
                "const": "max",
                "_metadata": {
                  "logical_name": "Max",
                  "docs::human_name": "Max"
                }
              },
              {
                "description": "Keep the minimum numeric value seen.",
                "const": "min",
                "_metadata": {
                  "logical_name": "Min",
                  "docs::human_name": "Min"
                }
              },
              {
                "description": "Append each value to an array.",
                "const": "array",
                "_metadata": {
                  "logical_name": "Array",
                  "docs::human_name": "Array"
                }
              },
              {
                "description": "Concatenate each string value, delimited with a space.",
                "const": "concat",
                "_metadata": {
                  "logical_name": "Concat",
                  "docs::human_name": "Concat"
                }
              },
              {
                "description": "Concatenate each string value, delimited with a newline.",
                "const": "concat_newline",
                "_metadata": {
                  "logical_name": "ConcatNewline",
                  "docs::human_name": "Concat Newline"
                }
              },
              {
                "description": "Concatenate each string, without a delimiter.",
                "const": "concat_raw",
                "_metadata": {
                  "logical_name": "ConcatRaw",
                  "docs::human_name": "Concat Raw"
                }
              },
              {
                "description": "Keep the shortest array seen.",
                "const": "shortest_array",
                "_metadata": {
                  "logical_name": "ShortestArray",
                  "docs::human_name": "Shortest Array"
                }
              },
              {
                "description": "Keep the longest array seen.",
                "const": "longest_array",
                "_metadata": {
                  "logical_name": "LongestArray",
                  "docs::human_name": "Longest Array"
                }
              },
              {
                "description": "Create a flattened array of all unique values.",
                "const": "flat_unique",
                "_metadata": {
                  "logical_name": "FlatUnique",
                  "docs::human_name": "Flat Unique"
                }
              }
            ],
            "unevaluatedProperties": false,
            "_metadata": {
              "docs::enum_tagging": "external"
            }
          },
          "_metadata": {
            "docs::additional_props_description": "An individual merge strategy.",
            "docs::human_name": "Merge Strategies"
          }
        },
        "starts_when": {
          "title": "A condition used to distinguish the first event of a transaction.",
          "description": "If this condition resolves to `true` for an event, the previous transaction is flushed\n(without this event) and a new transaction is started.",
          "$ref": "#/definitions/core::option::Option<vector::conditions::AnyCondition>",
          "_metadata": {
            "docs::human_name": "Starts When"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "transform",
        "docs::component_name": "reduce"
      }
    },
    "vector::transforms::remap::RemapConfig": {
      "description": "Configuration for the `remap` transform.",
      "type": "object",
      "properties": {
        "drop_on_abort": {
          "title": "Drops any event that is manually aborted during processing.",
          "description": "Normally, if a VRL program is manually aborted (using [`abort`][vrl_docs_abort]) when\nprocessing an event, the original, unmodified event is sent downstream. In some cases,\nyou may not wish to send the event any further, such as if certain transformation or\nenrichment is strictly required. Setting `drop_on_abort` to `true` allows you to ensure\nthese events do not get processed any further.\n\nAdditionally, dropped events can potentially be diverted to a specially-named output for\nfurther logging and analysis by setting `reroute_dropped`.\n\n[vrl_docs_abort]: https://vector.dev/docs/reference/vrl/expressions/#abort",
          "default": true,
          "type": "boolean",
          "_metadata": {
            "docs::human_name": "Drop Event on Abort"
          }
        },
        "drop_on_error": {
          "title": "Drops any event that encounters an error during processing.",
          "description": "Normally, if a VRL program encounters an error when processing an event, the original,\nunmodified event is sent downstream. In some cases, you may not want to send the event\nany further, such as if certain transformation or enrichment is strictly required. Setting\n`drop_on_error` to `true` allows you to ensure these events do not get processed any\nfurther.\n\nAdditionally, dropped events can potentially be diverted to a specially named output for\nfurther logging and analysis by setting `reroute_dropped`.",
          "default": false,
          "type": "boolean",
          "_metadata": {
            "docs::human_name": "Drop Event on Error"
          }
        },
        "file": {
          "title": "File path to the [Vector Remap Language][vrl] (VRL) program to execute for each event.",
          "description": "If a relative path is provided, its root is the current working directory.\n\nRequired if `source` is missing.\n\n[vrl]: https://vector.dev/docs/reference/vrl",
          "$ref": "#/definitions/core::option::Option<std::path::PathBuf>",
          "_metadata": {
            "docs::examples": "./my/program.vrl",
            "docs::human_name": "File"
          }
        },
        "metric_tag_values": {
          "title": "When set to `single`, metric tag values are exposed as single strings, the\nsame as they were before this config option. Tags with multiple values show the last assigned value, and null values\nare ignored.",
          "description": "When set to `full`, all metric tags are exposed as arrays of either string or null\nvalues.",
          "default": "single",
          "$ref": "#/definitions/codecs::MetricTagValues",
          "_metadata": {
            "docs::human_name": "Metric Tag Values"
          }
        },
        "reroute_dropped": {
          "title": "Reroutes dropped events to a named output instead of halting processing on them.",
          "description": "When using `drop_on_error` or `drop_on_abort`, events that are \"dropped\" are processed no\nfurther. In some cases, it may be desirable to keep the events around for further analysis,\ndebugging, or retrying.\n\nIn these cases, `reroute_dropped` can be set to `true` which forwards the original event\nto a specially-named output, `dropped`. The original event is annotated with additional\nfields describing why the event was dropped.",
          "default": false,
          "type": "boolean",
          "_metadata": {
            "docs::human_name": "Reroute Dropped Events"
          }
        },
        "runtime": {
          "description": "The runtime to use for executing VRL code.",
          "default": "ast",
          "type": "string",
          "_metadata": {
            "docs::hidden": true,
            "docs::human_name": "Runtime"
          }
        },
        "source": {
          "title": "The [Vector Remap Language][vrl] (VRL) program to execute for each event.",
          "description": "Required if `file` is missing.\n\n[vrl]: https://vector.dev/docs/reference/vrl",
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::examples": ". = parse_json!(.message)\n.new_field = \"new value\"\n.status = to_int!(.status)\n.duration = parse_duration!(.duration, \"s\")\n.new_name = del(.old_name)",
            "docs::syntax_override": "remap_program",
            "docs::human_name": "Source"
          }
        },
        "timezone": {
          "title": "The name of the timezone to apply to timestamp conversions that do not contain an explicit\ntime zone.",
          "description": "This overrides the [global `timezone`][global_timezone] option. The time zone name may be\nany name in the [TZ database][tz_database], or `local` to indicate system local time.\n\n[global_timezone]: https://vector.dev/docs/reference/configuration//global-options#timezone\n[tz_database]: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones",
          "default": null,
          "$ref": "#/definitions/core::option::Option<vrl::compiler::datetime::TimeZone>",
          "_metadata": {
            "docs::advanced": true,
            "docs::human_name": "Timezone"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "transform",
        "docs::component_name": "remap"
      }
    },
    "vector::transforms::route::RouteConfig": {
      "description": "Configuration for the `route` transform.",
      "type": "object",
      "properties": {
        "reroute_unmatched": {
          "title": "Reroutes unmatched events to a named output instead of silently discarding them.",
          "description": "Normally, if an event doesn't match any defined route, it is sent to the `<transform_name>._unmatched`\noutput for further processing. In some cases, you may want to simply discard unmatched events and not\nprocess them any further.\n\nIn these cases, `reroute_unmatched` can be set to `false` to disable the `<transform_name>._unmatched`\noutput and instead silently discard any unmatched events.",
          "default": true,
          "type": "boolean",
          "_metadata": {
            "docs::human_name": "Reroute Unmatched Events"
          }
        },
        "route": {
          "title": "A table of route identifiers to logical conditions representing the filter of the route.",
          "description": "Each route can then be referenced as an input by other components with the name\n`<transform_name>.<route_id>`. If an event doesn’t match any route, and if `reroute_unmatched`\nis set to `true` (the default), it is sent to the `<transform_name>._unmatched` output.\nOtherwise, the unmatched event is instead silently discarded.\n\nBoth `_unmatched`, as well as `_default`, are reserved output names and thus cannot be used\nas a route name.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/vector::conditions::AnyCondition"
          },
          "_metadata": {
            "docs::additional_props_description": "An individual route.",
            "docs::human_name": "Route"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "transform",
        "docs::component_name": "route"
      }
    },
    "vector::transforms::sample::SampleConfig": {
      "description": "Configuration for the `sample` transform.",
      "type": "object",
      "required": [
        "rate"
      ],
      "properties": {
        "exclude": {
          "description": "A logical condition used to exclude events from sampling.",
          "$ref": "#/definitions/core::option::Option<vector::conditions::AnyCondition>",
          "_metadata": {
            "docs::human_name": "Exclude"
          }
        },
        "key_field": {
          "title": "The name of the field whose value is hashed to determine if the event should be\nsampled.",
          "description": "Each unique value for the key creates a bucket of related events to be sampled together\nand the rate is applied to the buckets themselves to sample `1/N` buckets.  The overall rate\nof sampling may differ from the configured one if values in the field are not uniformly\ndistributed. If left unspecified, or if the event doesn’t have `key_field`, then the\nevent is sampled independently.\n\nThis can be useful to, for example, ensure that all logs for a given transaction are\nsampled together, but that overall `1/N` transactions are sampled.",
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::examples": "message",
            "docs::human_name": "Key Field"
          }
        },
        "rate": {
          "title": "The rate at which events are forwarded, expressed as `1/N`.",
          "description": "For example, `rate = 10` means 1 out of every 10 events are forwarded and the rest are\ndropped.",
          "type": "integer",
          "maximum": 9007199254740991.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::human_name": "Rate"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "transform",
        "docs::component_name": "sample"
      }
    },
    "vector::transforms::tag_cardinality_limit::config::TagCardinalityLimitConfig": {
      "description": "Configuration for the `tag_cardinality_limit` transform.",
      "allOf": [
        {
          "type": "object",
          "properties": {
            "limit_exceeded_action": {
              "description": "Possible actions to take when an event arrives that would exceed the cardinality limit for one\nor more of its tags.",
              "default": "drop_tag",
              "oneOf": [
                {
                  "description": "Drop the tag(s) that would exceed the configured limit.",
                  "const": "drop_tag",
                  "_metadata": {
                    "logical_name": "DropTag",
                    "docs::human_name": "Drop Tag"
                  }
                },
                {
                  "description": "Drop the entire event itself.",
                  "const": "drop_event",
                  "_metadata": {
                    "logical_name": "DropEvent",
                    "docs::human_name": "Drop Event"
                  }
                }
              ],
              "unevaluatedProperties": false,
              "_metadata": {
                "docs::enum_tagging": "external",
                "docs::human_name": "Limit Exceeded Action"
              }
            },
            "value_limit": {
              "description": "How many distinct values to accept for any given key.",
              "default": 500,
              "type": "integer",
              "maximum": 9007199254740991.0,
              "minimum": 0.0,
              "_metadata": {
                "docs::numeric_type": "uint",
                "docs::human_name": "Value Limit"
              }
            }
          }
        },
        {
          "description": "Controls the approach taken for tracking tag cardinality.",
          "oneOf": [
            {
              "title": "Tracks cardinality exactly.",
              "description": "This mode has higher memory requirements than `probabilistic`, but never falsely outputs\nmetrics with new tags after the limit has been hit.",
              "type": "object",
              "required": [
                "mode"
              ],
              "properties": {
                "mode": {
                  "title": "Tracks cardinality exactly.",
                  "description": "This mode has higher memory requirements than `probabilistic`, but never falsely outputs\nmetrics with new tags after the limit has been hit.",
                  "const": "exact",
                  "_metadata": {
                    "docs::human_name": "Mode"
                  }
                }
              },
              "_metadata": {
                "logical_name": "Exact",
                "docs::human_name": "Exact"
              }
            },
            {
              "title": "Tracks cardinality probabilistically.",
              "description": "This mode has lower memory requirements than `exact`, but may occasionally allow metric\nevents to pass through the transform even when they contain new tags that exceed the\nconfigured limit. The rate at which this happens can be controlled by changing the value of\n`cache_size_per_tag`.",
              "allOf": [
                {
                  "description": "Bloom filter configuration in probabilistic mode.",
                  "type": "object",
                  "properties": {
                    "cache_size_per_key": {
                      "title": "The size of the cache for detecting duplicate tags, in bytes.",
                      "description": "The larger the cache size, the less likely it is to have a false positive, or a case where\nwe allow a new value for tag even after we have reached the configured limits.",
                      "default": 5120000,
                      "type": "integer",
                      "maximum": 9007199254740991.0,
                      "minimum": 0.0,
                      "_metadata": {
                        "docs::numeric_type": "uint",
                        "docs::human_name": "Cache Size per Key"
                      }
                    }
                  }
                },
                {
                  "type": "object",
                  "required": [
                    "mode"
                  ],
                  "properties": {
                    "mode": {
                      "title": "Tracks cardinality probabilistically.",
                      "description": "This mode has lower memory requirements than `exact`, but may occasionally allow metric\nevents to pass through the transform even when they contain new tags that exceed the\nconfigured limit. The rate at which this happens can be controlled by changing the value of\n`cache_size_per_tag`.",
                      "const": "probabilistic",
                      "_metadata": {
                        "docs::human_name": "Mode"
                      }
                    }
                  }
                }
              ],
              "_metadata": {
                "logical_name": "Probabilistic",
                "docs::human_name": "Probabilistic"
              }
            }
          ],
          "_metadata": {
            "docs::enum_tag_description": "Controls the approach taken for tracking tag cardinality.",
            "docs::enum_tagging": "internal",
            "docs::enum_tag_field": "mode"
          }
        }
      ],
      "_metadata": {
        "docs::component_type": "transform",
        "docs::component_name": "tag_cardinality_limit"
      }
    },
    "vector::transforms::throttle::ThrottleConfig": {
      "description": "Configuration for the `throttle` transform.",
      "type": "object",
      "required": [
        "threshold",
        "window_secs"
      ],
      "properties": {
        "exclude": {
          "description": "A logical condition used to exclude events from sampling.",
          "$ref": "#/definitions/core::option::Option<vector::conditions::AnyCondition>",
          "_metadata": {
            "docs::human_name": "Exclude"
          }
        },
        "key_field": {
          "title": "The value to group events into separate buckets to be rate limited independently.",
          "description": "If left unspecified, or if the event doesn't have `key_field`, then the event is not rate\nlimited separately.",
          "$ref": "#/definitions/core::option::Option<vector::template::Template>",
          "_metadata": {
            "docs::examples": [
              "{{ message }}",
              "{{ hostname }}"
            ],
            "docs::human_name": "Key Field"
          }
        },
        "threshold": {
          "title": "The number of events allowed for a given bucket per configured `window_secs`.",
          "description": "Each unique key has its own `threshold`.",
          "type": "integer",
          "maximum": 4294967295.0,
          "minimum": 0.0,
          "_metadata": {
            "docs::numeric_type": "uint",
            "docs::human_name": "Threshold"
          }
        },
        "window_secs": {
          "description": "The time window in which the configured `threshold` is applied, in seconds.",
          "$ref": "#/definitions/serde_with::DurationFractionalSeconds",
          "_metadata": {
            "docs::human_name": "Time Window"
          }
        }
      },
      "_metadata": {
        "docs::component_type": "transform",
        "docs::component_name": "throttle"
      }
    },
    "vector_common::sensitive_string::SensitiveString": {
      "description": "Wrapper for sensitive strings containing credentials",
      "type": "string",
      "_metadata": {
        "sensitive": true
      }
    },
    "vector_core::config::AcknowledgementsConfig": {
      "title": "Controls how acknowledgements are handled for this sink.",
      "description": "See [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
      "type": "object",
      "properties": {
        "enabled": {
          "title": "Whether or not end-to-end acknowledgements are enabled.",
          "description": "When enabled for a sink, any source connected to that sink, where the source supports\nend-to-end acknowledgements as well, waits for events to be acknowledged by the sink\nbefore acknowledging them at the source.\n\nEnabling or disabling acknowledgements at the sink level takes precedence over any global\n[`acknowledgements`][global_acks] configuration.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements",
          "type": [
            "boolean",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Enabled"
          }
        }
      },
      "unevaluatedProperties": false
    },
    "vector_core::config::SourceAcknowledgementsConfig": {
      "title": "Controls how acknowledgements are handled by this source.",
      "description": "This setting is **deprecated** in favor of enabling `acknowledgements` at the [global][global_acks] or sink level.\n\nEnabling or disabling acknowledgements at the source level has **no effect** on acknowledgement behavior.\n\nSee [End-to-end Acknowledgements][e2e_acks] for more information on how event acknowledgement is handled.\n\n[global_acks]: https://vector.dev/docs/reference/configuration/global-options/#acknowledgements\n[e2e_acks]: https://vector.dev/docs/about/under-the-hood/architecture/end-to-end-acknowledgements/",
      "deprecated": true,
      "type": "object",
      "properties": {
        "enabled": {
          "description": "Whether or not end-to-end acknowledgements are enabled for this source.",
          "type": [
            "boolean",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Enabled"
          }
        }
      },
      "unevaluatedProperties": false
    },
    "vector_core::config::proxy::ProxyConfig": {
      "title": "Proxy configuration.",
      "description": "Configure to proxy traffic through an HTTP(S) proxy when making external requests.\n\nSimilar to common proxy configuration convention, you can set different proxies\nto use based on the type of traffic being proxied, as well as set specific hosts that\nshould not be proxied.",
      "type": "object",
      "properties": {
        "enabled": {
          "description": "Enables proxying support.",
          "default": true,
          "type": "boolean",
          "_metadata": {
            "docs::human_name": "Enabled"
          }
        },
        "http": {
          "title": "Proxy endpoint to use when proxying HTTP traffic.",
          "description": "Must be a valid URI string.",
          "default": null,
          "type": [
            "string",
            "null"
          ],
          "format": "uri",
          "_metadata": {
            "docs::optional": true,
            "docs::examples": "http://foo.bar:3128",
            "docs::human_name": "HTTP"
          }
        },
        "https": {
          "title": "Proxy endpoint to use when proxying HTTPS traffic.",
          "description": "Must be a valid URI string.",
          "default": null,
          "type": [
            "string",
            "null"
          ],
          "format": "uri",
          "_metadata": {
            "docs::optional": true,
            "docs::examples": "http://foo.bar:3128",
            "docs::human_name": "HTTPS"
          }
        },
        "no_proxy": {
          "title": "A list of hosts to avoid proxying.",
          "description": "Multiple patterns are allowed:\n\n| Pattern             | Example match                                                               |\n| ------------------- | --------------------------------------------------------------------------- |\n| Domain names        | `example.com` matches requests to `example.com`                     |\n| Wildcard domains    | `.example.com` matches requests to `example.com` and its subdomains |\n| IP addresses        | `127.0.0.1` matches requests to `127.0.0.1`                         |\n| [CIDR][cidr] blocks | `192.168.0.0/16` matches requests to any IP addresses in this range     |\n| Splat               | `*` matches all hosts                                                   |\n\n[cidr]: https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing",
          "default": [],
          "type": "array",
          "items": {
            "type": "string"
          },
          "_metadata": {
            "docs::examples": [
              "localhost",
              ".foo.bar",
              "*"
            ],
            "docs::human_name": "No Proxy"
          }
        }
      },
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::advanced": true
      }
    },
    "vector_core::event::metric::MetricKind": {
      "title": "Metric kind.",
      "description": "Metrics can be either absolute of incremental. Absolute metrics represent a sort of \"last write wins\" scenario,\nwhere the latest absolute value seen is meant to be the actual metric value.  In contrast, and perhaps intuitively,\nincremental metrics are meant to be additive, such that we don't know what total value of the metric is, but we know\nthat we'll be adding or subtracting the given value from it.\n\nGenerally speaking, most metrics storage systems deal with incremental updates. A notable exception is Prometheus,\nwhich deals with, and expects, absolute values from clients.",
      "oneOf": [
        {
          "description": "Incremental metric.",
          "const": "incremental",
          "_metadata": {
            "logical_name": "Incremental",
            "docs::human_name": "Incremental"
          }
        },
        {
          "description": "Absolute metric.",
          "const": "absolute",
          "_metadata": {
            "logical_name": "Absolute",
            "docs::human_name": "Absolute"
          }
        }
      ],
      "unevaluatedProperties": false,
      "_metadata": {
        "docs::enum_tagging": "external"
      }
    },
    "vector_core::tls::settings::TlsConfig": {
      "description": "TLS configuration.",
      "type": "object",
      "properties": {
        "alpn_protocols": {
          "title": "Sets the list of supported ALPN protocols.",
          "description": "Declare the supported ALPN protocols, which are used during negotiation with peer. They are prioritized in the order\nthat they are defined.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          },
          "_metadata": {
            "docs::optional": true,
            "docs::examples": "h2",
            "docs::human_name": "ALPN Protocols"
          }
        },
        "ca_file": {
          "title": "Absolute path to an additional CA certificate file.",
          "description": "The certificate must be in the DER or PEM (X.509) format. Additionally, the certificate can be provided as an inline string in PEM format.",
          "$ref": "#/definitions/core::option::Option<std::path::PathBuf>",
          "_metadata": {
            "docs::examples": "/path/to/certificate_authority.crt",
            "docs::human_name": "CA File Path"
          }
        },
        "crt_file": {
          "title": "Absolute path to a certificate file used to identify this server.",
          "description": "The certificate must be in DER, PEM (X.509), or PKCS#12 format. Additionally, the certificate can be provided as\nan inline string in PEM format.\n\nIf this is set, and is not a PKCS#12 archive, `key_file` must also be set.",
          "$ref": "#/definitions/core::option::Option<std::path::PathBuf>",
          "_metadata": {
            "docs::examples": "/path/to/host_certificate.crt",
            "docs::human_name": "Certificate File Path"
          }
        },
        "key_file": {
          "title": "Absolute path to a private key file used to identify this server.",
          "description": "The key must be in DER or PEM (PKCS#8) format. Additionally, the key can be provided as an inline string in PEM format.",
          "$ref": "#/definitions/core::option::Option<std::path::PathBuf>",
          "_metadata": {
            "docs::examples": "/path/to/host_certificate.key",
            "docs::human_name": "Key File Path"
          }
        },
        "key_pass": {
          "title": "Passphrase used to unlock the encrypted key file.",
          "description": "This has no effect unless `key_file` is set.",
          "type": [
            "string",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::examples": [
              "${KEY_PASS_ENV_VAR}",
              "PassWord1"
            ],
            "docs::human_name": "Key File Password"
          }
        },
        "verify_certificate": {
          "title": "Enables certificate verification.",
          "description": "If enabled, certificates must not be expired and must be issued by a trusted\nissuer. This verification operates in a hierarchical manner, checking that the leaf certificate (the\ncertificate presented by the client/server) is not only valid, but that the issuer of that certificate is also valid, and\nso on until the verification process reaches a root certificate.\n\nRelevant for both incoming and outgoing connections.\n\nDo NOT set this to `false` unless you understand the risks of not verifying the validity of certificates.",
          "type": [
            "boolean",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Verify Certificate"
          }
        },
        "verify_hostname": {
          "title": "Enables hostname verification.",
          "description": "If enabled, the hostname used to connect to the remote host must be present in the TLS certificate presented by\nthe remote host, either as the Common Name or as an entry in the Subject Alternative Name extension.\n\nOnly relevant for outgoing connections.\n\nDo NOT set this to `false` unless you understand the risks of not verifying the remote hostname.",
          "type": [
            "boolean",
            "null"
          ],
          "_metadata": {
            "docs::optional": true,
            "docs::human_name": "Verify Hostname"
          }
        }
      },
      "_metadata": {
        "docs::advanced": true
      }
    },
    "vector_core::tls::settings::TlsEnableableConfig": {
      "description": "Configures the TLS options for incoming/outgoing connections.",
      "allOf": [
        {
          "type": "object",
          "properties": {
            "enabled": {
              "title": "Whether or not to require TLS for incoming or outgoing connections.",
              "description": "When enabled and used for incoming connections, an identity certificate is also required. See `tls.crt_file` for\nmore information.",
              "type": [
                "boolean",
                "null"
              ],
              "_metadata": {
                "docs::optional": true,
                "docs::human_name": "Enabled"
              }
            }
          }
        },
        {
          "description": "TLS configuration.",
          "$ref": "#/definitions/vector_core::tls::settings::TlsConfig"
        }
      ],
      "_metadata": {
        "docs::advanced": true
      }
    },
    "vector_lookup::lookup_v2::ConfigTargetPath": {
      "description": "A wrapper around `OwnedTargetPath` that allows it to be used in Vector config\nwith prefix default to `PathPrefix::Event`",
      "type": "string"
    },
    "vector_lookup::lookup_v2::ConfigValuePath": {
      "description": "A wrapper around `OwnedValuePath` that allows it to be used in Vector config.\nThis requires a valid path to be used. If you want to allow optional paths,\nuse [optional_path::OptionalValuePath].",
      "type": "string"
    },
    "vector_lookup::lookup_v2::optional_path::OptionalTargetPath": {
      "description": "An optional path that deserializes an empty string to `None`.",
      "type": "string"
    },
    "vector_lookup::lookup_v2::optional_path::OptionalValuePath": {
      "description": "An optional path that deserializes an empty string to `None`.",
      "type": "string"
    }
  }
}

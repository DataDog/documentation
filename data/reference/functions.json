{
  "Number": [
    {
      "anchor": "abs",
      "name": "abs",
      "category": "Number",
      "description": "Computes the absolute value of `value`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The number to calculate the absolute value.",
          "required": true,
          "type": [
            "integer",
            "float"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "integer",
          "float"
        ],
        "rules": [
          "Returns the absolute value."
        ]
      },
      "examples": [
        {
          "title": "Computes the absolute value of the integer",
          "source": "abs(-42)",
          "return": "42"
        },
        {
          "title": "Computes the absolute value of the float",
          "source": "abs(-42.2)",
          "return": "42.2"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "ceil",
      "name": "ceil",
      "category": "Number",
      "description": "Rounds the `value` up to the specified `precision`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The number to round up.",
          "required": true,
          "type": [
            "integer",
            "float"
          ]
        },
        {
          "name": "precision",
          "description": "The number of decimal places to round to.",
          "required": false,
          "default": 0,
          "type": [
            "integer"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "integer",
          "float"
        ],
        "rules": [
          "Returns an integer if `precision` is `0` (this is the default). Returns a float otherwise."
        ]
      },
      "examples": [
        {
          "title": "Round a number up (without precision)",
          "source": "ceil(4.345)",
          "return": "5"
        },
        {
          "title": "Round a number up (with precision)",
          "source": "ceil(4.345, precision: 2)",
          "return": "4.35"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "floor",
      "name": "floor",
      "category": "Number",
      "description": "Rounds the `value` down to the specified `precision`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The number to round down.",
          "required": true,
          "type": [
            "integer",
            "float"
          ]
        },
        {
          "name": "precision",
          "description": "The number of decimal places to round to.",
          "required": false,
          "default": 0,
          "type": [
            "integer"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "integer",
          "float"
        ],
        "rules": [
          "Returns an integer if `precision` is `0` (this is the default). Returns a float otherwise."
        ]
      },
      "examples": [
        {
          "title": "Round a number down (without precision)",
          "source": "floor(4.345)",
          "return": "4"
        },
        {
          "title": "Round a number down (with precision)",
          "source": "floor(4.345, precision: 2)",
          "return": "4.34"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "format_int",
      "name": "format_int",
      "category": "Number",
      "description": "Formats the integer `value` into a string representation using the given base/radix.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The number to format.",
          "required": true,
          "type": [
            "integer"
          ]
        },
        {
          "name": "base",
          "description": "The base to format the number in. Must be between 2 and 36 (inclusive).",
          "required": false,
          "type": [
            "integer"
          ],
          "default": 10
        }
      ],
      "internal_failure_reasons": [
        "base is not between 2 and 36"
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Format as a hexadecimal integer",
          "source": "format_int!(42, 16)",
          "return": "\"2a\""
        },
        {
          "title": "Format as a negative hexadecimal integer",
          "source": "format_int!(-42, 16)",
          "return": "\"-2a\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "format_number",
      "name": "format_number",
      "category": "Number",
      "description": "Formats the `value` into a string representation of the number.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The number to format as a string.",
          "required": true,
          "type": [
            "integer",
            "float"
          ]
        },
        {
          "name": "scale",
          "description": "The number of decimal places to display.",
          "required": false,
          "type": [
            "integer"
          ]
        },
        {
          "name": "decimal_separator",
          "description": "The character to use between the whole and decimal parts of the number.",
          "required": false,
          "type": [
            "string"
          ],
          "default": "."
        },
        {
          "name": "grouping_separator",
          "description": "The character to use between each thousands part of the number.",
          "required": false,
          "type": [
            "string"
          ],
          "default": ","
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Format a number (3 decimals)",
          "source": "format_number(1234567.89, 3, decimal_separator: \".\", grouping_separator: \",\")",
          "return": "\"1,234,567.890\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "mod",
      "name": "mod",
      "category": "Number",
      "description": "Calculates the remainder of `value` divided by `modulus`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value the `modulus` is applied to.",
          "required": true,
          "type": [
            "integer",
            "float"
          ]
        },
        {
          "name": "modulus",
          "description": "The `modulus` value.",
          "required": true,
          "type": [
            "integer",
            "float"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't an integer or float",
        "`modulus` isn't an integer or float",
        "`modulus` is equal to 0"
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Calculate the remainder of two integers",
          "source": "remainder = mod(5, 2)",
          "return": "1"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "round",
      "name": "round",
      "category": "Number",
      "description": "Rounds the `value` to the specified `precision`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The number to round.",
          "required": true,
          "type": [
            "integer",
            "float"
          ]
        },
        {
          "name": "precision",
          "description": "The number of decimal places to round to.",
          "required": false,
          "default": 0,
          "type": [
            "integer"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "integer",
          "float"
        ],
        "rules": [
          "If `precision` is `0`, then an integer is returned, otherwise a float is returned."
        ]
      },
      "examples": [
        {
          "title": "Round a number (without precision)",
          "source": "round(4.345)",
          "return": "4"
        },
        {
          "title": "Round a number (with precision)",
          "source": "round(4.345, precision: 2)",
          "return": "4.35"
        }
      ],
      "deprecated": false
    }
  ],
  "Array": [
    {
      "anchor": "append",
      "name": "append",
      "category": "Array",
      "description": "Appends each item in the `items` array to the end of the `value` array.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The initial array",
          "required": true,
          "type": [
            "array"
          ]
        },
        {
          "name": "items",
          "description": "The items to append",
          "required": true,
          "type": [
            "array"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "array"
        ]
      },
      "examples": [
        {
          "title": "Append to an array",
          "source": "append([1, 2], [3, 4])",
          "return": "[1,2,3,4]"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "chunks",
      "name": "chunks",
      "category": "Array",
      "description": "Chunks `value` into slices of length `chunk_size` bytes",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The array of bytes to split.",
          "required": true,
          "type": [
            "array",
            "string"
          ]
        },
        {
          "name": "chunk_size",
          "description": "The desired length of each chunk in bytes. This may be constrained by the host platform architecture.",
          "required": true,
          "type": [
            "integer"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`chunk_size` must be at least 1 byte",
        "`chunk_size` is too large"
      ],
      "return": {
        "types": [
          "array"
        ],
        "rules": [
          "`chunks` is considered fallible if the supplied `chunk_size` is an expression, and infallible if it's a literal integer."
        ]
      },
      "examples": [
        {
          "title": "Split a string into chunks",
          "source": "chunks(\"abcdefgh\", 4)",
          "return": "[\"abcd\",\"efgh\"]"
        },
        {
          "title": "Chunks do not respect unicode code point boundaries",
          "source": "chunks(\"ab你好\", 4)",
          "return": "[\"ab�\",\"�好\"]"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "push",
      "name": "push",
      "category": "Array",
      "description": "Adds the `item` to the end of the `value` array.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The target array.",
          "required": true,
          "type": [
            "array"
          ]
        },
        {
          "name": "item",
          "description": "The item to push.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "array"
        ],
        "rules": [
          "Returns a new array. The `value` is _not_ modified in place."
        ]
      },
      "examples": [
        {
          "title": "Push an item onto an array",
          "source": "push([1, 2], 3)",
          "return": "[1,2,3]"
        }
      ],
      "deprecated": false
    }
  ],
  "Type": [
    {
      "anchor": "array",
      "name": "array",
      "category": "Type",
      "description": "Returns the `value` if it's an array and errors otherwise. This enables the type checker to guarantee that the\nreturned value is an array and can be used in any function that expects one.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value that you need to ensure is an array.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't an array."
      ],
      "return": {
        "types": [
          "array"
        ],
        "rules": [
          "Returns the `value` if it's an array.",
          "Raises an error if not an array."
        ]
      },
      "examples": [
        {
          "title": "Declare an array type",
          "input": {
            "log": {
              "value": [
                1,
                2,
                3
              ]
            }
          },
          "source": "array!(.value)",
          "return": "[1,2,3]"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "bool",
      "name": "bool",
      "category": "Type",
      "description": "Returns the `value` if it's a Boolean and errors otherwise. This enables the type checker to guarantee that the\nreturned value is a Boolean and can be used in any function that expects one.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value that you need to ensure is a Boolean.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a Boolean."
      ],
      "return": {
        "types": [
          "boolean"
        ],
        "rules": [
          "Returns `value` if it's a Boolean.",
          "Raises an error if not a Boolean."
        ]
      },
      "examples": [
        {
          "title": "Declare a Boolean type",
          "input": {
            "log": {
              "value": false
            }
          },
          "source": "bool!(.value)",
          "return": "false"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "float",
      "name": "float",
      "category": "Type",
      "description": "Returns the `value` if it's a float and errors otherwise. This enables the type checker to guarantee that the\nreturned value is a float and can be used in any function that expects one.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value that you need to ensure is a float.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a float."
      ],
      "return": {
        "types": [
          "float"
        ],
        "rules": [
          "Returns the `value` if it's a float.",
          "Raises an error if not a float."
        ]
      },
      "examples": [
        {
          "title": "Declare a float type",
          "input": {
            "log": {
              "value": 42
            }
          },
          "source": "float!(.value)",
          "return": "42"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "int",
      "name": "int",
      "category": "Type",
      "description": "Returns the `value` if it's an integer and errors otherwise. This enables the type checker to guarantee that the\nreturned value is an integer and can be used in any function that expects one.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value that you need to ensure is an integer.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not an integer."
      ],
      "return": {
        "types": [
          "integer"
        ],
        "rules": [
          "Returns the `value` if it's an integer.",
          "Raises an error if not an integer."
        ]
      },
      "examples": [
        {
          "title": "Declare an integer type",
          "input": {
            "log": {
              "value": 42
            }
          },
          "source": "int!(.value)",
          "return": "42"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "is_array",
      "name": "is_array",
      "category": "Type",
      "description": "Check if the type of a `value` is an array or not.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to check",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ],
        "rules": [
          "Returns `true` if `value` is an array.",
          "Returns `false` if `value` is anything else."
        ]
      },
      "examples": [
        {
          "title": "Valid array",
          "source": "is_array([1, 2, 3])",
          "return": "true"
        },
        {
          "title": "Non-matching type",
          "source": "is_array(\"a string\")",
          "return": "false"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "is_boolean",
      "name": "is_boolean",
      "category": "Type",
      "description": "Check if the type of a `value` is a boolean or not.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to check",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ],
        "rules": [
          "Returns `true` if `value` is a boolean.",
          "Returns `false` if `value` is anything else."
        ]
      },
      "examples": [
        {
          "title": "Valid boolean",
          "source": "is_boolean(false)",
          "return": "true"
        },
        {
          "title": "Non-matching type",
          "source": "is_boolean(\"a string\")",
          "return": "false"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "is_empty",
      "name": "is_empty",
      "category": "Type",
      "description": "Check if the object, array, or string has a length of 0.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to check.",
          "required": true,
          "type": [
            "object",
            "array",
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ],
        "rules": [
          "Returns `true` if `value` is empty.",
          "Returns `false` if `value` is non-empty."
        ]
      },
      "examples": [
        {
          "title": "Empty array",
          "source": "is_empty([])",
          "return": "true"
        },
        {
          "title": "Non-empty string",
          "source": "is_empty(\"a string\")",
          "return": "false"
        },
        {
          "title": "Non-empty object",
          "source": "is_empty({\"foo\": \"bar\"})",
          "return": "false"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "is_float",
      "name": "is_float",
      "category": "Type",
      "description": "Check if the type of a `value` is a float or not.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to check",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ],
        "rules": [
          "Returns `true` if `value` is a float.",
          "Returns `false` if `value` is anything else."
        ]
      },
      "examples": [
        {
          "title": "Valid float",
          "source": "is_float(0.577)",
          "return": "true"
        },
        {
          "title": "Non-matching type",
          "source": "is_float(\"a string\")",
          "return": "false"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "is_integer",
      "name": "is_integer",
      "category": "Type",
      "description": "Check if the type of a `value` is an integer or not.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to check",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ],
        "rules": [
          "Returns `true` if `value` is an integer.",
          "Returns `false` if `value` is anything else."
        ]
      },
      "examples": [
        {
          "title": "Valid integer",
          "source": "is_integer(1)",
          "return": "true"
        },
        {
          "title": "Non-matching type",
          "source": "is_integer(\"a string\")",
          "return": "false"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "is_json",
      "name": "is_json",
      "category": "Type",
      "description": "Check if the string is a valid JSON document.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to check",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "variant",
          "description": "The variant of the JSON type to explicitly check for.",
          "enum": {
            "object": "JSON object - {}",
            "array": "JSON array - []",
            "string": "JSON-formatted string values wrapped with quote marks",
            "number": "Integer or float numbers",
            "bool": "True or false",
            "null": "Exact null value"
          },
          "required": false,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ],
        "rules": [
          "Returns `true` if `value` is a valid JSON document.",
          "Returns `false` if `value` is not JSON-formatted."
        ]
      },
      "examples": [
        {
          "title": "Valid JSON object",
          "source": "is_json(\"{}\")",
          "return": "true"
        },
        {
          "title": "Non-valid value",
          "source": "is_json(\"{\")",
          "return": "false"
        },
        {
          "title": "Exact variant",
          "source": "is_json(\"{}\", variant: \"object\")",
          "return": "true"
        },
        {
          "title": "Non-valid exact variant",
          "source": "is_json(\"{}\", variant: \"array\")",
          "return": "false"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "is_null",
      "name": "is_null",
      "category": "Type",
      "description": "Check if the type of a `value` is `null` or not. For a more relaxed function please\ncheck [`is_nullish`](/docs/reference/vrl/functions#is_nullish).",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to check",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ],
        "rules": [
          "Returns `true` if `value` is null.",
          "Returns `false` if `value` is anything else."
        ]
      },
      "examples": [
        {
          "title": "Null value",
          "source": "is_null(null)",
          "return": "true"
        },
        {
          "title": "Non-matching type",
          "source": "is_null(\"a string\")",
          "return": "false"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "is_nullish",
      "name": "is_nullish",
      "category": "Type",
      "description": "Determines whether the `value` is \"nullish,\" where nullish denotes the absence of a\nmeaningful value.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to check for \"nullishness,\" i.e. a useless value.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ],
        "rules": [
          "Returns `true` if `value` is `null`.",
          "Returns `true` if `value` is `\"-\"`.",
          "Returns `true` if `value` is whitespace as defined by [Unicode `White_Space` property](https://en.wikipedia.org/wiki/Unicode_character_property#Whitespace).",
          "Returns `false` if `value` is anything else."
        ]
      },
      "examples": [
        {
          "title": "Null detection (blank string)",
          "source": "is_nullish(\"\")",
          "return": "true"
        },
        {
          "title": "Null detection (dash string)",
          "source": "is_nullish(\"-\")",
          "return": "true"
        },
        {
          "title": "Null detection (whitespace)",
          "source": "is_nullish(\"\n  \n\")",
          "return": "true"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "is_object",
      "name": "is_object",
      "category": "Type",
      "description": "Check if the type of a `value` is an object or not.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to check",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ],
        "rules": [
          "Returns `true` if `value` is an object.",
          "Returns `false` if `value` is anything else."
        ]
      },
      "examples": [
        {
          "title": "Valid object",
          "source": "is_object({\"foo\": \"bar\"})",
          "return": "true"
        },
        {
          "title": "Non-matching type",
          "source": "is_object(\"a string\")",
          "return": "false"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "is_regex",
      "name": "is_regex",
      "category": "Type",
      "description": "Check if the type of a `value` is a regex or not.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to check",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ],
        "rules": [
          "Returns `true` if `value` is a regex.",
          "Returns `false` if `value` is anything else."
        ]
      },
      "examples": [
        {
          "title": "Valid regex",
          "source": "is_regex(r'pattern')",
          "return": "true"
        },
        {
          "title": "Non-matching type",
          "source": "is_regex(\"a string\")",
          "return": "false"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "is_string",
      "name": "is_string",
      "category": "Type",
      "description": "Check if the type of a `value` is a string or not.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to check",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ],
        "rules": [
          "Returns `true` if `value` is a string.",
          "Returns `false` if `value` is anything else."
        ]
      },
      "examples": [
        {
          "title": "Valid string",
          "source": "is_string(\"a string\")",
          "return": "true"
        },
        {
          "title": "Non-matching type",
          "source": "is_string([1, 2, 3])",
          "return": "false"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "is_timestamp",
      "name": "is_timestamp",
      "category": "Type",
      "description": "Check if the type of a `value` is a timestamp or not.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to check",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ],
        "rules": [
          "Returns `true` if `value` is a timestamp.",
          "Returns `false` if `value` is anything else."
        ]
      },
      "examples": [
        {
          "title": "Valid timestamp",
          "source": "is_timestamp(t'2021-03-26T16:00:00Z')",
          "return": "true"
        },
        {
          "title": "Non-matching type",
          "source": "is_timestamp(\"a string\")",
          "return": "false"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "object",
      "name": "object",
      "category": "Type",
      "description": "Returns the `value` if it's an object and errors otherwise. This enables the type checker to guarantee that the\nreturned value is an object and can be used in any function that expects one.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value that you need to ensure is an object.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't an object."
      ],
      "return": {
        "types": [
          "object"
        ],
        "rules": [
          "Returns the `value` if it's an object.",
          "Raises an error if not an object."
        ]
      },
      "examples": [
        {
          "title": "Declare an object type",
          "input": {
            "log": {
              "value": {
                "field1": "value1",
                "field2": "value2"
              }
            }
          },
          "source": "object!(.value)",
          "return": "{\"field1\":\"value1\",\"field2\":\"value2\"}"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "string",
      "name": "string",
      "category": "Type",
      "description": "Returns the `value` if it's a string and errors otherwise. This enables the type checker to guarantee that the\nreturned value is a string and can be used in any function that expects one.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value that you need to ensure is a string.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a string."
      ],
      "return": {
        "types": [
          "string"
        ],
        "rules": [
          "Returns the `value` if it's a string.",
          "Raises an error if not a string."
        ]
      },
      "examples": [
        {
          "title": "Declare a string type",
          "input": {
            "log": {
              "message": "{\"field\": \"value\"}"
            }
          },
          "source": "string!(.message)",
          "return": "\"{\\\"field\\\": \\\"value\\\"}\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "tag_types_externally",
      "name": "tag_types_externally",
      "category": "Type",
      "description": "Adds type information to all (nested) scalar values in the provided `value`.\n\nThe type information is added externally, meaning that `value` has the shape of `\"type\": value` after this\ntransformation.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to tag with types.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "object",
          "array",
          "null"
        ]
      },
      "examples": [
        {
          "title": "Tag types externally (scalar)",
          "source": "tag_types_externally(123)",
          "return": "{\"integer\":123}"
        },
        {
          "title": "Tag types externally (object)",
          "source": "tag_types_externally({\n\t\"message\": \"Hello world\",\n\t\"request\": {\n\t\t\"duration_ms\": 67.9\n\t}\n})",
          "return": "{\"message\":{\"string\":\"Hello world\"},\"request\":{\"duration_ms\":{\"float\":67.9}}}"
        },
        {
          "title": "Tag types externally (array)",
          "source": "tag_types_externally([\"foo\", \"bar\"])",
          "return": "[{\"string\":\"foo\"},{\"string\":\"bar\"}]"
        },
        {
          "title": "Tag types externally (null)",
          "source": "tag_types_externally(null)",
          "return": "null"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "timestamp",
      "name": "timestamp",
      "category": "Type",
      "description": "Returns the `value` if it's a timestamp and errors otherwise. This enables the type checker to guarantee that\nthe returned value is a timestamp and can be used in any function that expects one.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value that you need to ensure is a timestamp.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a timestamp."
      ],
      "return": {
        "types": [
          "timestamp"
        ],
        "rules": [
          "Returns the `value` if it's a timestamp.",
          "Raises an error if not a timestamp."
        ]
      },
      "examples": [
        {
          "title": "Declare a timestamp type",
          "input": {
            "log": {
              "timestamp": "2020-10-10T16:00:00Z"
            }
          },
          "source": "ok, err = timestamp(.timestamp)",
          "return": "\"function call error for \\\"timestamp\\\" at (10:31): expected timestamp, got string\""
        }
      ],
      "deprecated": false
    }
  ],
  "Debug": [
    {
      "anchor": "assert",
      "name": "assert",
      "category": "Debug",
      "description": "Asserts the `condition`, which must be a Boolean expression. The program is aborted with\n`message` if the condition evaluates to `false`.",
      "notices": [
        "The `assert` function should be used in a standalone fashion and only when you want to abort the program. You\nshould avoid it in logical expressions and other situations in which you want the program to continue if the\ncondition evaluates to `false`."
      ],
      "arguments": [
        {
          "name": "condition",
          "description": "The condition to check.",
          "required": true,
          "type": [
            "boolean"
          ]
        },
        {
          "name": "message",
          "description": "An optional custom error message. If the equality assertion fails, `message` is\nappended to the default message prefix. See the [examples](#assert-examples) below\nfor a sample fully formed log message.",
          "required": false,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`condition` evaluates to `false`"
      ],
      "return": {
        "types": [
          "null"
        ]
      },
      "examples": [
        {
          "title": "Assertion (true)",
          "source": "ok, err = assert(\"foo\" == \"foo\", message: \"\\\"foo\\\" must be \\\"foo\\\"!\")",
          "return": "true"
        },
        {
          "title": "Assertion (false)",
          "source": "assert!(\"foo\" == \"bar\", message: \"\\\"foo\\\" must be \\\"foo\\\"!\")",
          "raises": {
            "runtime": "function call error for \"assert\" at (0:60): \"foo\" must be \"foo\"!"
          }
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "assert_eq",
      "name": "assert_eq",
      "category": "Debug",
      "description": "Asserts that two expressions, `left` and `right`, have the same value. The program is\naborted with the `message` if they are unequal.",
      "notices": [
        "The `assert_eq` function should be used in a standalone fashion and only when you want to\nabort the program. You should avoid it in logical expressions and other situations in which\nyou want the program to continue if the condition evaluates to `false`."
      ],
      "arguments": [
        {
          "name": "left",
          "description": "The value to check for equality against `right`.",
          "required": true,
          "type": [
            "any"
          ]
        },
        {
          "name": "right",
          "description": "The value to check for equality against `left`.",
          "required": true,
          "type": [
            "any"
          ]
        },
        {
          "name": "message",
          "description": "An optional custom error message. If the equality assertion fails, `message` is\nappended to the default message prefix. See the [examples](#assert_eq-examples)\nbelow for a sample fully formed log message.",
          "required": false,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ]
      },
      "examples": [
        {
          "title": "Successful assertion",
          "source": "assert_eq!(1, 1)",
          "return": "true"
        },
        {
          "title": "Unsuccessful assertion",
          "source": "assert_eq!(127, [1, 2, 3])",
          "raises": {
            "runtime": "function call error for \"assert_eq\" at (0:26): assertion failed: 127 == [1, 2, 3]"
          }
        },
        {
          "title": "Unsuccessful assertion with custom log message",
          "source": " assert_eq!(1, 0, message: \"Unequal integers\")",
          "raises": {
            "runtime": "function call error for \"assert_eq\" at (1:46): Unequal integers"
          }
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "log",
      "name": "log",
      "category": "Debug",
      "description": "Logs the `value` to Vector's [stdout](https://en.wikipedia.org/wiki/Standard_streams#Standard_output_(stdout)) at the specified `level`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to log.",
          "required": true,
          "type": [
            "any"
          ]
        },
        {
          "name": "level",
          "description": "The log level.",
          "required": false,
          "type": [
            "string"
          ],
          "enum": {
            "trace": "Log at the `trace` level.",
            "debug": "Log at the `debug` level.",
            "info": "Log at the `info` level.",
            "warn": "Log at the `warn` level.",
            "error": "Log at the `error` level."
          },
          "default": "info"
        },
        {
          "name": "rate_limit_secs",
          "description": "Specifies that the log message is output no more than once per the given number of seconds.\nUse a value of `0` to turn rate limiting off.",
          "type": [
            "integer"
          ],
          "required": false,
          "default": 1
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "null"
        ]
      },
      "examples": [
        {
          "title": "Log a message",
          "source": "log(\"Hello, World!\", level: \"info\", rate_limit_secs: 60)",
          "return": "null"
        },
        {
          "title": "Log an error",
          "input": {
            "log": {
              "field": "not an integer"
            }
          },
          "source": "ts, err = to_int(.field)\nif err != null {\n\tlog(err, level: \"error\")\n}",
          "return": "null"
        }
      ],
      "deprecated": false
    }
  ],
  "Enumerate": [
    {
      "anchor": "compact",
      "name": "compact",
      "category": "Enumerate",
      "description": "Compacts the `value` by removing \"empty\" values, where emptiness is defined using the\navailable parameters.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The object or array to compact.",
          "required": true,
          "type": [
            "array",
            "object"
          ]
        },
        {
          "name": "recursive",
          "description": "Whether the compaction be recursive.",
          "required": false,
          "default": true,
          "type": [
            "boolean"
          ]
        },
        {
          "name": "null",
          "description": "Whether null should be treated as an empty value.",
          "required": false,
          "default": true,
          "type": [
            "boolean"
          ]
        },
        {
          "name": "string",
          "description": "Whether an empty string should be treated as an empty value.",
          "required": false,
          "default": true,
          "type": [
            "boolean"
          ]
        },
        {
          "name": "object",
          "description": "Whether an empty object should be treated as an empty value.",
          "required": false,
          "default": true,
          "type": [
            "boolean"
          ]
        },
        {
          "name": "array",
          "description": "Whether an empty array should be treated as an empty value.",
          "required": false,
          "default": true,
          "type": [
            "boolean"
          ]
        },
        {
          "name": "nullish",
          "description": "Tests whether the value is \"nullish\" as defined by the [`is_nullish`](#is_nullish) function.",
          "required": false,
          "default": false,
          "type": [
            "boolean"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "array",
          "object"
        ],
        "rules": [
          "The return type matches the `value` type."
        ]
      },
      "examples": [
        {
          "title": "Compact an array",
          "source": "compact([\"foo\", \"bar\", \"\", null, [], \"buzz\"], string: true, array: true, null: true)",
          "return": "[\"foo\",\"bar\",\"buzz\"]"
        },
        {
          "title": "Compact an object",
          "source": "compact({\"field1\": 1, \"field2\": \"\", \"field3\": [], \"field4\": null}, string: true, array: true, null: true)",
          "return": "{\"field1\":1}"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "filter",
      "name": "filter",
      "category": "Enumerate",
      "description": "Filter elements from a collection.\n\nThis function currently *does not* support recursive iteration.\nIf you have a need for recursive iteration using `filter`, then\n[please let us know](https://github.com/vectordotdev/vector/issues/new?labels=type%3A+new+feature)!\n\nThe function uses the \"function closure syntax\" to allow reading\nthe key/value or index/value combination for each item in the\ncollection.\n\nThe same scoping rules apply to closure blocks as they do for\nregular blocks, meaning, any variable defined in parent scopes\nare accessible, and mutations to those variables are preserved,\nbut any new variables instantiated in the closure block are\nunavailable outside of the block.\n\nCheck out the examples below to learn about the closure syntax.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The array or object to filter.",
          "required": true,
          "type": [
            "array",
            "object"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "array",
          "object"
        ]
      },
      "examples": [
        {
          "title": "Filter elements",
          "input": {
            "log": {
              "tags": [
                "foo",
                "bar",
                "foo",
                "baz"
              ]
            }
          },
          "source": "filter(array!(.tags)) -> |_index, value| {\n    # keep any elements that aren't equal to \"foo\"\n    value != \"foo\"\n}",
          "return": "[\"bar\",\"baz\"]"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "flatten",
      "name": "flatten",
      "category": "Enumerate",
      "description": "Flattens the `value` into a single-level representation.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The array or object to flatten.",
          "required": true,
          "type": [
            "array",
            "object"
          ]
        },
        {
          "name": "separator",
          "description": "The separator to be used to join nested keys",
          "required": false,
          "default": ".",
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "array",
          "object"
        ],
        "rules": [
          "The return type matches the `value` type."
        ]
      },
      "examples": [
        {
          "title": "Flatten array",
          "source": "flatten([1, [2, 3, 4], [5, [6, 7], 8], 9])",
          "return": "[1,2,3,4,5,6,7,8,9]"
        },
        {
          "title": "Flatten object",
          "source": "flatten({\n\t\"parent1\": {\n\t\t\"child1\": 1,\n\t\t\"child2\": 2\n\t},\n\t\"parent2\": {\n\t\t\"child3\": 3\n\t}\n})",
          "return": "{\"parent1.child1\":1,\"parent1.child2\":2,\"parent2.child3\":3}"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "for_each",
      "name": "for_each",
      "category": "Enumerate",
      "description": "Iterate over a collection.\n\nThis function currently *does not* support recursive iteration.\nIf you have a need for recursive iteration using `for_each`,\nwhich can't be solved using the `map_keys` or `map_values`\nenumeration functions (which *do* support recursion), then\n[please let us know](https://github.com/vectordotdev/vector/issues/new?labels=type%3A+new+feature)!\n\nThe function uses the \"function closure syntax\" to allow reading\nthe key/value or index/value combination for each item in the\ncollection.\n\nThe same scoping rules apply to closure blocks as they do for\nregular blocks, meaning, any variable defined in parent scopes\nare accessible, and mutations to those variables are preserved,\nbut any new variables instantiated in the closure block are\nunavailable outside of the block.\n\nCheck out the examples below to learn about the closure syntax.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The array or object to iterate.",
          "required": true,
          "type": [
            "array",
            "object"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "null"
        ]
      },
      "examples": [
        {
          "title": "Tally elements",
          "input": {
            "log": {
              "tags": [
                "foo",
                "bar",
                "foo",
                "baz"
              ]
            }
          },
          "source": "tally = {}\nfor_each(array!(.tags)) -> |_index, value| {\n    # Get the current tally for the `value`, or\n    # set to `0`.\n    count = int(get!(tally, [value])) ?? 0\n\n    # Increment the tally for the value by `1`.\n    tally = set!(tally, [value], count + 1)\n}\n\ntally",
          "return": "{\"foo\":2,\"bar\":1,\"baz\":1}"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "includes",
      "name": "includes",
      "category": "Enumerate",
      "description": "Determines whether the `value` array includes the specified `item`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The array.",
          "required": true,
          "type": [
            "array"
          ]
        },
        {
          "name": "item",
          "description": "The item to check.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ]
      },
      "examples": [
        {
          "title": "Array includes",
          "source": "includes([\"apple\", \"orange\", \"banana\"], \"banana\")",
          "return": "true"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "keys",
      "name": "keys",
      "category": "Enumerate",
      "description": "Returns the keys from the object passed into the function.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The object to extract keys from.",
          "required": true,
          "type": [
            "object"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "array"
        ],
        "rules": [
          "Returns an array of all the keys"
        ]
      },
      "examples": [
        {
          "title": "Get keys from the object.",
          "input": {
            "log": {
              "key1": "val1",
              "key2": "val2"
            }
          },
          "source": "keys({\"key1\": \"val1\", \"key2\": \"val2\"})",
          "return": "[\"key1\",\"key2\"]"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "length",
      "name": "length",
      "category": "Enumerate",
      "description": "Returns the length of the `value`.\n\n* If `value` is an array, returns the number of elements.\n* If `value` is an object, returns the number of top-level keys.\n* If `value` is a string, returns the number of bytes in the string. If\n  you want the number of characters, see `strlen`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The array or object",
          "required": true,
          "type": [
            "array",
            "object",
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "integer"
        ],
        "rules": [
          "If `value` is an array, returns the number of elements.",
          "If `value` is an object, returns the number of top-level keys.",
          "If `value` is a string, returns the number of bytes in the string."
        ]
      },
      "examples": [
        {
          "title": "Length (object)",
          "source": "length({\n\t\"portland\": \"Trail Blazers\",\n\t\"seattle\":  \"Supersonics\"\n})",
          "return": "2"
        },
        {
          "title": "Length (nested object)",
          "source": "length({\n\t\"home\": {\n\t\t\"city\":  \"Portland\",\n\t\t\"state\": \"Oregon\"\n\t},\n\t\"name\": \"Trail Blazers\",\n\t\"mascot\": {\n\t\t\"name\": \"Blaze the Trail Cat\"\n\t}\n})",
          "return": "3"
        },
        {
          "title": "Length (array)",
          "source": "length([\"Trail Blazers\", \"Supersonics\", \"Grizzlies\"])",
          "return": "3"
        },
        {
          "title": "Length (string)",
          "source": "length(\"The Planet of the Apes Musical\")",
          "return": "30"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "map_keys",
      "name": "map_keys",
      "category": "Enumerate",
      "description": "Map the keys within an object.\n\nIf `recursive` is enabled, the function iterates into nested\nobjects, using the following rules:\n\n1. Iteration starts at the root.\n2. For every nested object type:\n   - First return the key of the object type itself.\n   - Then recurse into the object, and loop back to item (1)\n     in this list.\n   - Any mutation done on a nested object *before* recursing into\n     it, are preserved.\n3. For every nested array type:\n   - First return the key of the array type itself\n   - Then find all objects within the array, and apply item (2)\n     to each individual object.\n\nPractically speaking, the above rules mean that `map_keys` with\n`recursive` enabled will find *all* keys in the target,\nregardless of whether nested objects are nested inside arrays.\n\nThe function uses the \"function closure syntax\" to allow reading\nthe key for each item in the object.\n\nThe same scoping rules apply to closure blocks as they do for\nregular blocks, meaning, any variable defined in parent scopes\nare accessible, and mutations to those variables are preserved,\nbut any new variables instantiated in the closure block are\nunavailable outside of the block.\n\nCheck out the examples below to learn about the closure syntax.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The object to iterate.",
          "required": true,
          "type": [
            "object"
          ]
        },
        {
          "name": "recursive",
          "description": "Whether to recursively iterate the collection.",
          "required": false,
          "default": false,
          "type": [
            "boolean"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Upcase keys",
          "input": {
            "log": {
              "foo": "foo",
              "bar": "bar"
            }
          },
          "source": "map_keys(.) -> |key| { upcase(key) }",
          "return": "{\"FOO\":\"foo\",\"BAR\":\"bar\"}"
        },
        {
          "title": "De-dot keys",
          "input": {
            "log": {
              "labels": {
                "app.kubernetes.io/name": "mysql"
              }
            }
          },
          "source": "map_keys(., recursive: true) -> |key| { replace(key, \".\", \"_\") }",
          "return": "{\"labels\":{\"app_kubernetes_io/name\":\"mysql\"}}"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "map_values",
      "name": "map_values",
      "category": "Enumerate",
      "description": "Map the values within a collection.\n\nIf `recursive` is enabled, the function iterates into nested\ncollections, using the following rules:\n\n1. Iteration starts at the root.\n2. For every nested collection type:\n   - First return the collection type itself.\n   - Then recurse into the collection, and loop back to item (1)\n     in the list\n   - Any mutation done on a collection *before* recursing into it,\n     are preserved.\n\nThe function uses the \"function closure syntax\" to allow mutating\nthe value for each item in the collection.\n\nThe same scoping rules apply to closure blocks as they do for\nregular blocks, meaning, any variable defined in parent scopes\nare accessible, and mutations to those variables are preserved,\nbut any new variables instantiated in the closure block are\nunavailable outside of the block.\n\nCheck out the examples below to learn about the closure syntax.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The object or array to iterate.",
          "required": true,
          "type": [
            "array",
            "object"
          ]
        },
        {
          "name": "recursive",
          "description": "Whether to recursively iterate the collection.",
          "required": false,
          "default": false,
          "type": [
            "boolean"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "array",
          "object"
        ]
      },
      "examples": [
        {
          "title": "Upcase values",
          "input": {
            "log": {
              "foo": "foo",
              "bar": "bar"
            }
          },
          "source": "map_values(.) -> |value| { upcase!(value) }",
          "return": "{\"foo\":\"FOO\",\"bar\":\"BAR\"}"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "match_array",
      "name": "match_array",
      "category": "Enumerate",
      "description": "Determines whether the elements in the `value` array matches the `pattern` - by default it checks at least one element matches, but can be set to determine if all the elements match.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The array.",
          "required": true,
          "type": [
            "array"
          ]
        },
        {
          "name": "pattern",
          "description": "The regular expression pattern to match against.",
          "required": true,
          "type": [
            "regex"
          ]
        },
        {
          "name": "all",
          "description": "Whether to match on all elements of `value`.",
          "required": false,
          "default": false,
          "type": [
            "boolean"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ]
      },
      "examples": [
        {
          "title": "Match at least one element",
          "source": "\tmatch_array([\"foobar\", \"bazqux\"], r'foo')",
          "return": "true"
        },
        {
          "title": "Match all elements",
          "source": "\tmatch_array([\"foo\", \"foobar\", \"barfoo\"], r'foo', all: true)",
          "return": "true"
        },
        {
          "title": "No matches",
          "source": "\tmatch_array([\"bazqux\", \"xyz\"], r'foo')",
          "return": "false"
        },
        {
          "title": "Not all elements match",
          "source": "\tmatch_array([\"foo\", \"foobar\", \"baz\"], r'foo', all: true)",
          "return": "false"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "strlen",
      "name": "strlen",
      "category": "Enumerate",
      "description": "Returns the number of UTF-8 characters in `value`. This differs from\n`length` which would count the number of bytes of a string.\n\nNote that this is the count of [unicode scalar values](https://www.unicode.org/glossary/#unicode_scalar_value)\nwhich can sometimes differ from [unicode code points](https://www.unicode.org/glossary/#code_point).",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "integer"
        ]
      },
      "examples": [
        {
          "title": "strlen",
          "source": "strlen(\"ñandú\")",
          "return": "5"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "unique",
      "name": "unique",
      "category": "Enumerate",
      "description": "Returns unique values for an array.\n\nThe first occurrence of each element is kept.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The array to return unique elements from.",
          "required": true,
          "type": [
            "array"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "array"
        ]
      },
      "examples": [
        {
          "title": "Unique",
          "source": "unique([\"foo\", \"bar\", \"foo\", \"baz\"])",
          "return": "[\"foo\",\"bar\",\"baz\"]"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "values",
      "name": "values",
      "category": "Enumerate",
      "description": "Returns the values from the object passed into the function.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The object to extract values from.",
          "required": true,
          "type": [
            "object"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "array"
        ],
        "rules": [
          "Returns an array of all the values."
        ]
      },
      "examples": [
        {
          "title": "Get values from the object.",
          "input": {
            "log": {
              "key1": "val1",
              "key2": "val2"
            }
          },
          "source": "values({\"key1\": \"val1\", \"key2\": \"val2\"})",
          "return": "[\"val1\",\"val2\"]"
        }
      ],
      "deprecated": false
    }
  ],
  "String": [
    {
      "anchor": "contains",
      "name": "contains",
      "category": "String",
      "description": "Determines whether the `value` string contains the specified `substring`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The text to search.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "substring",
          "description": "The substring to search for in `value`.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "case_sensitive",
          "description": "Whether the match should be case sensitive.",
          "required": false,
          "type": [
            "boolean"
          ],
          "default": true
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ]
      },
      "examples": [
        {
          "title": "String contains (case sensitive)",
          "source": "contains(\"The Needle In The Haystack\", \"Needle\")",
          "return": "true"
        },
        {
          "title": "String contains (case insensitive)",
          "source": "contains(\"The Needle In The Haystack\", \"needle\", case_sensitive: false)",
          "return": "true"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "downcase",
      "name": "downcase",
      "category": "String",
      "description": "Downcases the `value` string, where \"downcase\" is defined according to the terms of the\nUnicode Derived Core Property Lowercase.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to convert to lowercase.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Downcase a string",
          "source": "downcase(\"Hello, World!\")",
          "return": "\"hello, world!\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "ends_with",
      "name": "ends_with",
      "category": "String",
      "description": "Determines whether the `value` string ends with the specified `substring`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to search.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "substring",
          "description": "The substring with which `value` must end.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "case_sensitive",
          "description": "Whether the match should be case sensitive.",
          "required": false,
          "type": [
            "boolean"
          ],
          "default": true
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ]
      },
      "examples": [
        {
          "title": "String ends with (case sensitive)",
          "source": "ends_with(\"The Needle In The Haystack\", \"The Haystack\")",
          "return": "true"
        },
        {
          "title": "String ends with (case insensitive)",
          "source": "ends_with(\"The Needle In The Haystack\", \"the haystack\", case_sensitive: false)",
          "return": "true"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "find",
      "name": "find",
      "category": "String",
      "description": "Determines the start position of the first found element in `value`,\nfrom left to right, that matches the `pattern` or returns -1 if not found.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to find the pattern in.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "pattern",
          "description": "The regular expression or string pattern to match against.",
          "required": true,
          "type": [
            "regex",
            "string"
          ]
        },
        {
          "name": "from",
          "description": "Offset to start searching.",
          "required": false,
          "default": 0,
          "type": [
            "integer"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "integer"
        ]
      },
      "examples": [
        {
          "title": "Match text",
          "source": "find(\"foobar\", \"foo\")",
          "return": "0"
        },
        {
          "title": "Match regex",
          "source": "find(\"foobar\", r'b.r')",
          "return": "3"
        },
        {
          "title": "No matches",
          "source": "find(\"foobar\", \"baz\")",
          "return": "-1"
        },
        {
          "title": "With an offset",
          "source": "find(\"foobarfoobarfoo\", \"bar\", 4)",
          "return": "9"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "join",
      "name": "join",
      "category": "String",
      "description": "Joins each string in the `value` array into a single string, with items optionally separated from one another\nby a `separator`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The array of strings to join together.",
          "required": true,
          "type": [
            "array"
          ]
        },
        {
          "name": "separator",
          "description": "The string separating each original element when joined.",
          "required": false,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Join array (no separator)",
          "source": "join!([\"bring\", \"us\", \"together\"])",
          "return": "\"bringustogether\""
        },
        {
          "title": "Join array (comma separator)",
          "source": "join!([\"sources\", \"transforms\", \"sinks\"], separator: \", \")",
          "return": "\"sources, transforms, sinks\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "match",
      "name": "match",
      "category": "String",
      "description": "Determines whether the `value` matches the `pattern`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to match.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "pattern",
          "description": "The regular expression pattern to match against.",
          "required": true,
          "type": [
            "regex"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ]
      },
      "examples": [
        {
          "title": "Regex match on a string",
          "source": "match(\"I'm a little teapot\", r'teapot')",
          "return": "true"
        },
        {
          "title": "String does not match the regular expression",
          "source": "match(\"I'm a little teapot\", r'.*balloon')",
          "return": "false"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "match_any",
      "name": "match_any",
      "category": "String",
      "description": "Determines whether the `value` matches any the given `patterns`. All\npatterns are checked in a single pass over the target string, giving this\nfunction a potentially significant performance advantage over multiple calls\nto `match`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to match.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "patterns",
          "description": "The array of regular expression patterns to match against.",
          "required": true,
          "type": [
            "array"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ]
      },
      "examples": [
        {
          "title": "Regex match on a string",
          "source": "match_any(\"I'm a little teapot\", [r'frying pan', r'teapot'])",
          "return": "true"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "redact",
      "name": "redact",
      "category": "String",
      "description": "Redact sensitive data in `value` such as:\n\n- [US social security card numbers](https://www.ssa.gov/history/ssn/geocard.html)\n- and other forms of personally identifiable information via custom patterns\n- (more to come!)\n\nThis can help achieve compliance by ensuring sensitive data never leaves your network.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to redact sensitive data from.\n\nIts behavior differs depending on the type of `value`:\n\n- For strings, it simply redacts the sensitive data and returns a new string\n- For arrays, it redacts the sensitive data in each string element\n- For objects, it masks the sensitive data in each string value, but not keys\n\nFor arrays and objects it will recurse into any nested arrays or objects. Any non-string elements will\nbe skipped.\n\nAny redacted text will be replaced with `[REDACTED]`.",
          "required": true,
          "type": [
            "string",
            "object",
            "array"
          ]
        },
        {
          "name": "filters",
          "description": "List of filters to be applied to the `value`.\n\nEach filter can be specified in one of three ways:\n\n- As a regular expression directly, which will be used to redact text matching it\n- As an object with a `type` key that corresponds to a named filter and additional keys for customizing that filter\n- As a named filter, if it has no required parameters\n\nNamed filters are:\n\n- `pattern`: Redact text matching any regular expressions specified in the, required, `patterns`\n\tkey. This is the expanded form of just passing a regular expression as a filter.\n- `us_social_security_number`: Redact US social security card numbers.\n\nSee examples for more details.\n\nThis parameter must be a static expression. You cannot use variables or other dynamic expressions\nwith it. This allows us to validate the argument at compile-time to avoid runtime errors.",
          "required": true,
          "type": [
            "array"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string",
          "object",
          "array"
        ]
      },
      "examples": [
        {
          "title": "Replace text using a regex",
          "source": "redact(\"my id is 123456\", filters: [r'\\d+'])",
          "return": "\"my id is [REDACTED]\""
        },
        {
          "title": "Replace us social security numbers in any field",
          "source": "redact({ \"name\": \"John Doe\", \"ssn\": \"123-12-1234\"}, filters: [\"us_social_security_number\"])",
          "return": "{\"name\":\"John Doe\",\"ssn\":\"[REDACTED]\"}"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "replace",
      "name": "replace",
      "category": "String",
      "description": "Replaces all matching instances of `pattern` in the `value`.\n\nThe `pattern` argument accepts regular expression capture groups. Note that `$foo` is interpreted in a Vector configuration file, instead use `$$foo`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The original string.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "pattern",
          "description": "Replace all matches of this pattern. Can be a static string or a regular expression.",
          "required": true,
          "type": [
            "regex",
            "string"
          ]
        },
        {
          "name": "with",
          "description": "The string that the matches are replaced with.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "count",
          "description": "The maximum number of replacements to perform. -1 means replace all matches.",
          "required": false,
          "default": -1,
          "type": [
            "integer"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Replace literal text",
          "source": "replace(\"Apples and Bananas\", \"and\", \"not\")",
          "return": "\"Apples not Bananas\""
        },
        {
          "title": "Replace via regular expression",
          "source": "replace(\"Apples and Bananas\", r'(?i)bananas', \"Pineapples\")",
          "return": "\"Apples and Pineapples\""
        },
        {
          "title": "Replace first instance",
          "source": "replace(\"Bananas and Bananas\", \"Bananas\", \"Pineapples\", count: 1)",
          "return": "\"Pineapples and Bananas\""
        },
        {
          "title": "Replace with capture groups",
          "source": "replace(\"foo123bar\", r'foo(?P<num>\\d+)bar', \"$num\")",
          "return": "\"123\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "slice",
      "name": "slice",
      "category": "String",
      "description": "Returns a slice of the `value` between the `start` and `end` positions.\n\nIf the `start` and `end` parameters are negative, they refer to positions counting from the right of the\nstring or array. If `end` refers to a position that is greater than the length of the string or array\na slice up to the end of the string or array is returned.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string or array to slice.",
          "required": true,
          "type": [
            "array",
            "string"
          ]
        },
        {
          "name": "start",
          "description": "The inclusive start position. A zero-based index that can be negative.",
          "required": true,
          "type": [
            "integer"
          ]
        },
        {
          "name": "end",
          "description": "The exclusive end position. A zero-based index that can be negative.",
          "required": false,
          "default": "String length",
          "type": [
            "integer"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Slice a string (positive index)",
          "source": "slice!(\"Supercalifragilisticexpialidocious\", start: 5, end: 13)",
          "return": "\"califrag\""
        },
        {
          "title": "Slice a string (negative index)",
          "source": "slice!(\"Supercalifragilisticexpialidocious\", start: 5, end: -14)",
          "return": "\"califragilistic\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "split",
      "name": "split",
      "category": "String",
      "description": "Splits the `value` string via the `pattern`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to split.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "pattern",
          "description": "The string is split whenever this pattern is matched.",
          "required": true,
          "type": [
            "string",
            "regex"
          ]
        },
        {
          "name": "limit",
          "description": "The maximum number of substrings to return.",
          "required": false,
          "type": [
            "integer"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "array"
        ],
        "rules": [
          "If `limit` is specified, the remainder of the string is returned unsplit after `limit` has been reached."
        ]
      },
      "examples": [
        {
          "title": "Split a string (no limit)",
          "source": "split(\"apples and pears and bananas\", \" and \")",
          "return": "[\"apples\",\"pears\",\"bananas\"]"
        },
        {
          "title": "Split a string (with a limit)",
          "source": "split(\"apples and pears and bananas\", \" and \", limit: 2)",
          "return": "[\"apples\",\"pears and bananas\"]"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "starts_with",
      "name": "starts_with",
      "category": "String",
      "description": "Determines whether the `value` begins with the `substring`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to search.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "substring",
          "description": "The substring that the `value` must start with.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "case_sensitive",
          "description": "Whether the match should be case sensitive.",
          "required": false,
          "type": [
            "boolean"
          ],
          "default": true
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ]
      },
      "examples": [
        {
          "title": "String starts with (case sensitive)",
          "source": "starts_with(\"The Needle In The Haystack\", \"The Needle\")",
          "return": "true"
        },
        {
          "title": "String starts with (case insensitive)",
          "source": "starts_with(\"The Needle In The Haystack\", \"the needle\", case_sensitive: false)",
          "return": "true"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "strip_ansi_escape_codes",
      "name": "strip_ansi_escape_codes",
      "category": "String",
      "description": "Strips [ANSI escape codes](https://en.wikipedia.org/wiki/ANSI_escape_code) from the `value`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to strip.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Strip ANSI escape codes",
          "source": "strip_ansi_escape_codes(\"\\e[46mfoo\\e[0m bar\")",
          "return": "\"foo bar\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "strip_whitespace",
      "name": "strip_whitespace",
      "category": "String",
      "description": "Strips whitespace from the start and end of the `value`, where whitespace is defined by the [Unicode\n`White_Space` property](https://en.wikipedia.org/wiki/Unicode_character_property#Whitespace)",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to trim.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Strip whitespace",
          "source": "strip_whitespace(\"  A sentence.  \")",
          "return": "\"A sentence.\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "truncate",
      "name": "truncate",
      "category": "String",
      "description": "Truncates the `value` string up to the `limit` number of characters.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to truncate.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "limit",
          "description": "The number of characters to truncate the string after.",
          "required": true,
          "type": [
            "integer",
            "float"
          ]
        },
        {
          "name": "ellipsis",
          "description": "An ellipsis (`...`) is appended if this is set to `true` _and_ the `value` string ends up being\ntruncated because it's exceeded the `limit`.",
          "required": true,
          "type": [
            "boolean"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ],
        "rules": [
          "The string is returned unchanged its length is less than `limit`.",
          "If `ellipsis` is `true`, then an ellipsis (`...`) is appended to the string (beyond the specified `limit`)."
        ]
      },
      "examples": [
        {
          "title": "Truncate a string",
          "source": "truncate(\"A rather long sentence.\", limit: 11, ellipsis: true)",
          "return": "\"A rather lo...\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "upcase",
      "name": "upcase",
      "description": "Upcases the `value`, where \"upcase\" is defined according to the terms of the Unicode Derived Core Property\nUppercase.",
      "arguments": [
        {
          "name": "value",
          "description": "The string to convert to uppercase.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "category": "String",
      "notices": [],
      "examples": [
        {
          "title": "Upcase a string",
          "source": "upcase(\"Hello, World!\")",
          "return": "\"HELLO, WORLD!\""
        }
      ],
      "deprecated": false
    }
  ],
  "Codec": [
    {
      "anchor": "decode_base16",
      "name": "decode_base16",
      "category": "Codec",
      "description": "Decodes the `value` (a [Base16](https://en.wikipedia.org/wiki/Hexadecimal) string) into its original string.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The [Base16](https://en.wikipedia.org/wiki/Hexadecimal) data to decode.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a valid encoded Base16 string."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Decode Base16 data",
          "source": "decode_base16!(\"796f752068617665207375636365737366756c6c79206465636f646564206d65\")",
          "return": "\"you have successfully decoded me\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "decode_base64",
      "name": "decode_base64",
      "category": "Codec",
      "description": "Decodes the `value` (a [Base64](https://en.wikipedia.org/wiki/Base64) string) into its original string.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The [Base64](https://en.wikipedia.org/wiki/Base64) data to decode.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "charset",
          "description": "The character set to use when decoding the data.",
          "required": false,
          "type": [
            "string"
          ],
          "default": "standard",
          "enum": {
            "standard": "[Standard](https://tools.ietf.org/html/rfc4648#section-4) Base64 format.",
            "url_safe": "Modified Base64 for [URL variants](https://en.wikipedia.org/wiki/Base64#URL_applications)."
          }
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a valid encoded Base64 string."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Decode Base64 data (default)",
          "source": "decode_base64!(\"eW91IGhhdmUgc3VjY2Vzc2Z1bGx5IGRlY29kZWQgbWU=\")",
          "return": "\"you have successfully decoded me\""
        },
        {
          "title": "Decode Base64 data (URL safe)",
          "source": "decode_base64!(\"eW91IGNhbid0IG1ha2UgeW91ciBoZWFydCBmZWVsIHNvbWV0aGluZyBpdCB3b24ndA==\", charset: \"url_safe\")",
          "return": "\"you can't make your heart feel something it won't\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "decode_gzip",
      "name": "decode_gzip",
      "category": "Codec",
      "description": "Decodes the `value` (a [Gzip](https://www.gzip.org/) string) into its original string.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The [Gzip](https://www.gzip.org/) data to decode.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a valid encoded Gzip string."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Decode Gzip data",
          "source": "encoded_text = decode_base64!(\"H4sIAHEAymMAA6vML1XISCxLVSguTU5OLS5OK83JqVRISU3OT0lNUchNBQD7BGDaIAAAAA==\")\ndecode_gzip!(encoded_text)",
          "return": "\"you have successfully decoded me\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "decode_mime_q",
      "name": "decode_mime_q",
      "category": "Codec",
      "description": "Replaces q-encoded or base64-encoded [encoded-word](https://datatracker.ietf.org/doc/html/rfc2047#section-2) substrings in the `value` with their original string.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string with [encoded-words](https://datatracker.ietf.org/doc/html/rfc2047#section-2) to decode.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` has invalid encoded [encoded-word](https://datatracker.ietf.org/doc/html/rfc2047#section-2) string."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Decode single encoded-word",
          "source": "decode_mime_q!(\"=?utf-8?b?SGVsbG8sIFdvcmxkIQ==?=\")",
          "return": "\"Hello, World!\""
        },
        {
          "title": "Embedded",
          "source": "decode_mime_q!(\"From: =?utf-8?b?SGVsbG8sIFdvcmxkIQ==?= <=?utf-8?q?hello=5Fworld=40example=2ecom?=>\")",
          "return": "\"From: Hello, World! <hello_world@example.com>\""
        },
        {
          "title": "Without charset",
          "source": "decode_mime_q!(\"?b?SGVsbG8sIFdvcmxkIQ==\")",
          "return": "\"Hello, World!\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "decode_percent",
      "name": "decode_percent",
      "category": "Codec",
      "description": "Decodes a [percent-encoded](https://url.spec.whatwg.org/#percent-encoded-bytes) `value` like a URL.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to decode.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Percent decode a value",
          "source": "decode_percent(\"foo%20bar%3F\")",
          "return": "\"foo bar?\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "decode_zlib",
      "name": "decode_zlib",
      "category": "Codec",
      "description": "Decodes the `value` (a [Zlib](https://www.zlib.net) string) into its original string.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The [Zlib](https://www.zlib.net) data to decode.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a valid encoded Zlib string."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Decode Zlib data",
          "source": "encoded_text = decode_base64!(\"eJwNy4ENwCAIBMCNXIlQ/KqplUSgCdvXAS41qPMHshCB2R1zJlWIVlR6UURX2+wx2YcuK3kAb9C1wd6dn7Fa+QH9gRxr\")\ndecode_zlib!(encoded_text)",
          "return": "\"you_have_successfully_decoded_me.congratulations.you_are_breathtaking.\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "decode_zstd",
      "name": "decode_zstd",
      "category": "Codec",
      "description": "Decodes the `value` (a [Zstandard](https://facebook.github.io/zstd) string) into its original string.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The [Zstandard](https://facebook.github.io/zstd) data to decode.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a valid encoded Zstd string."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Decode Zstd data",
          "source": "encoded_text = decode_base64!(\"KLUv/QBY/QEAYsQOFKClbQBedqXsb96EWDax/f/F/z+gNU4ZTInaUeAj82KqPFjUzKqhcfDqAIsLvAsnY1bI/N2mHzDixRQA\")\ndecode_zstd!(encoded_text)",
          "return": "\"you_have_successfully_decoded_me.congratulations.you_are_breathtaking.\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "encode_base16",
      "name": "encode_base16",
      "category": "Codec",
      "description": "Encodes the `value` to [Base16](https://en.wikipedia.org/wiki/Hexadecimal).",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to encode.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Encode to Base16",
          "source": "encode_base16(\"please encode me\")",
          "return": "\"706c6561736520656e636f6465206d65\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "encode_base64",
      "name": "encode_base64",
      "category": "Codec",
      "description": "Encodes the `value` to [Base64](https://en.wikipedia.org/wiki/Base64).",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to encode.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "padding",
          "description": "Whether the Base64 output is [padded](https://en.wikipedia.org/wiki/Base64#Output_padding).",
          "required": false,
          "type": [
            "boolean"
          ],
          "default": true
        },
        {
          "name": "charset",
          "description": "The character set to use when encoding the data.",
          "required": false,
          "type": [
            "string"
          ],
          "default": "standard",
          "enum": {
            "standard": "[Standard](https://tools.ietf.org/html/rfc4648#section-4) Base64 format.",
            "url_safe": "Modified Base64 for [URL variants](https://en.wikipedia.org/wiki/Base64#URL_applications)."
          }
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Encode to Base64 (default)",
          "source": "encode_base64(\"please encode me\")",
          "return": "\"cGxlYXNlIGVuY29kZSBtZQ==\""
        },
        {
          "title": "Encode to Base64 (without padding)",
          "source": "encode_base64(\"please encode me, no padding though\", padding: false)",
          "return": "\"cGxlYXNlIGVuY29kZSBtZSwgbm8gcGFkZGluZyB0aG91Z2g\""
        },
        {
          "title": "Encode to Base64 (URL safe)",
          "source": "encode_base64(\"please encode me, but safe for URLs\", charset: \"url_safe\")",
          "return": "\"cGxlYXNlIGVuY29kZSBtZSwgYnV0IHNhZmUgZm9yIFVSTHM=\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "encode_gzip",
      "name": "encode_gzip",
      "category": "Codec",
      "description": "Encodes the `value` to [Gzip](https://www.gzip.org/).",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to encode.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "compression_level",
          "description": "The default compression level.",
          "required": false,
          "type": [
            "integer"
          ],
          "default": 6
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Encode to Gzip",
          "source": "encoded_text = encode_gzip(\"please encode me\")\nencode_base64(encoded_text)",
          "return": "\"H4sIAAAAAAAA/yvISU0sTlVIzUvOT0lVyE0FAI4R4vcQAAAA\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "encode_json",
      "name": "encode_json",
      "category": "Codec",
      "description": "Encodes the `value` to JSON.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to convert to a JSON string.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Encode to JSON",
          "source": ".payload = encode_json({\"hello\": \"world\"})",
          "return": "\"{\\\"hello\\\":\\\"world\\\"}\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "encode_key_value",
      "name": "encode_key_value",
      "category": "Codec",
      "description": "Encodes the `value` to in key/value format with customizable delimiters. Default delimiters match\nthe [logfmt](https://brandur.org/logfmt) format.",
      "notices": [
        "If `fields_ordering` is specified then the function is fallible else it is infallible."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The value to convert to a string.",
          "required": true,
          "type": [
            "object"
          ]
        },
        {
          "name": "fields_ordering",
          "description": "The ordering of fields to preserve. Any fields not in this list will appear unordered, after any ordered fields.",
          "required": false,
          "type": [
            "array"
          ]
        },
        {
          "name": "key_value_delimiter",
          "description": "The string that separates the key from the value.",
          "required": false,
          "default": "=",
          "type": [
            "string"
          ]
        },
        {
          "name": "field_delimiter",
          "description": "The string that separates each key/value pair.",
          "required": false,
          "default": " ",
          "type": [
            "string"
          ]
        },
        {
          "name": "flatten_boolean",
          "description": "Whether to encode key/value with a boolean value as a standalone key if `true` and nothing if `false`.",
          "required": false,
          "type": [
            "boolean"
          ],
          "default": false
        }
      ],
      "internal_failure_reasons": [
        "`fields_ordering` contains a non-string element"
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Encode with default delimiters (no ordering)",
          "source": "encode_key_value({\"ts\": \"2021-06-05T17:20:00Z\", \"msg\": \"This is a message\", \"lvl\": \"info\"})",
          "return": "\"lvl=info msg=\\\"This is a message\\\" ts=2021-06-05T17:20:00Z\""
        },
        {
          "title": "Encode with default delimiters (fields ordering)",
          "source": "encode_key_value!({\"ts\": \"2021-06-05T17:20:00Z\", \"msg\": \"This is a message\", \"lvl\": \"info\", \"log_id\": 12345}, [\"ts\", \"lvl\", \"msg\"])",
          "return": "\"ts=2021-06-05T17:20:00Z lvl=info msg=\\\"This is a message\\\" log_id=12345\""
        },
        {
          "title": "Encode with default delimiters (nested fields)",
          "source": "encode_key_value({\"agent\": {\"name\": \"vector\"}, \"log\": {\"file\": {\"path\": \"my.log\"}}, \"event\": \"log\"})",
          "return": "\"agent.name=vector event=log log.file.path=my.log\""
        },
        {
          "title": "Encode with default delimiters (nested fields ordering)",
          "source": "encode_key_value!({\"agent\": {\"name\": \"vector\"}, \"log\": {\"file\": {\"path\": \"my.log\"}}, \"event\": \"log\"}, [\"event\", \"log.file.path\", \"agent.name\"])",
          "return": "\"event=log log.file.path=my.log agent.name=vector\""
        },
        {
          "title": "Encode with custom delimiters (no ordering)",
          "source": "encode_key_value(\n\t{\"ts\": \"2021-06-05T17:20:00Z\", \"msg\": \"This is a message\", \"lvl\": \"info\"},\n\tfield_delimiter: \",\",\n\tkey_value_delimiter: \":\"\n)",
          "return": "\"lvl:info,msg:\\\"This is a message\\\",ts:2021-06-05T17:20:00Z\""
        },
        {
          "title": "Encode with custom delimiters and flatten boolean",
          "source": "encode_key_value(\n\t{\"ts\": \"2021-06-05T17:20:00Z\", \"msg\": \"This is a message\", \"lvl\": \"info\", \"beta\": true, \"dropped\": false},\n\tfield_delimiter: \",\",\n\tkey_value_delimiter: \":\",\n\tflatten_boolean: true\n)",
          "return": "\"beta,lvl:info,msg:\\\"This is a message\\\",ts:2021-06-05T17:20:00Z\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "encode_logfmt",
      "name": "encode_logfmt",
      "category": "Codec",
      "description": "Encodes the `value` to [logfmt](https://brandur.org/logfmt).",
      "notices": [
        "If `fields_ordering` is specified then the function is fallible else it is infallible."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The value to convert to a logfmt string.",
          "required": true,
          "type": [
            "object"
          ]
        },
        {
          "name": "fields_ordering",
          "description": "The ordering of fields to preserve. Any fields not in this list will appear unordered, after any ordered fields.",
          "required": false,
          "type": [
            "array"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`fields_ordering` contains a non-string element"
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Encode to logfmt (no ordering)",
          "source": "encode_logfmt({\"ts\": \"2021-06-05T17:20:00Z\", \"msg\": \"This is a message\", \"lvl\": \"info\"})",
          "return": "\"lvl=info msg=\\\"This is a message\\\" ts=2021-06-05T17:20:00Z\""
        },
        {
          "title": "Encode to logfmt (fields ordering)",
          "source": "encode_logfmt!({\"ts\": \"2021-06-05T17:20:00Z\", \"msg\": \"This is a message\", \"lvl\": \"info\", \"log_id\": 12345}, [\"ts\", \"lvl\", \"msg\"])",
          "return": "\"ts=2021-06-05T17:20:00Z lvl=info msg=\\\"This is a message\\\" log_id=12345\""
        },
        {
          "title": "Encode to logfmt (nested fields)",
          "source": "encode_logfmt({\"agent\": {\"name\": \"vector\"}, \"log\": {\"file\": {\"path\": \"my.log\"}}, \"event\": \"log\"})",
          "return": "\"agent.name=vector event=log log.file.path=my.log\""
        },
        {
          "title": "Encode to logfmt (nested fields ordering)",
          "source": "encode_logfmt!({\"agent\": {\"name\": \"vector\"}, \"log\": {\"file\": {\"path\": \"my.log\"}}, \"event\": \"log\"}, [\"event\", \"log.file.path\", \"agent.name\"])",
          "return": "\"event=log log.file.path=my.log agent.name=vector\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "encode_percent",
      "name": "encode_percent",
      "category": "Codec",
      "description": "Encodes a `value` with [percent encoding](https://url.spec.whatwg.org/#percent-encoded-bytes) to safely be used in URLs.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to encode.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "ascii_set",
          "description": "The ascii set to use when encoding the data.",
          "required": false,
          "type": [
            "string"
          ],
          "default": "NON_ALPHANUMERIC",
          "enum": {
            "NON_ALPHANUMERIC": "Encode any non-alphanumeric characters. This is the safest option.",
            "CONTROLS": "Encode only [control characters](https://infra.spec.whatwg.org/#c0-control).",
            "FRAGMENT": "Encode only [fragment characters](https://url.spec.whatwg.org/#fragment-percent-encode-set)",
            "QUERY": "Encode only [query characters](https://url.spec.whatwg.org/#query-percent-encode-set)",
            "SPECIAL": "Encode only [special characters](https://url.spec.whatwg.org/#special-percent-encode-set)",
            "PATH": "Encode only [path characters](https://url.spec.whatwg.org/#path-percent-encode-set)",
            "USERINFO": "Encode only [userinfo characters](https://url.spec.whatwg.org/#userinfo-percent-encode-set)",
            "COMPONENT": "Encode only [component characters](https://url.spec.whatwg.org/#component-percent-encode-set)",
            "WWW_FORM_URLENCODED": "Encode only [`application/x-www-form-urlencoded`](https://url.spec.whatwg.org/#application-x-www-form-urlencoded-percent-encode-set)"
          }
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Percent encode all non-alphanumeric characters (default)",
          "source": "encode_percent(\"foo bar?\")",
          "return": "\"foo%20bar%3F\""
        },
        {
          "title": "Percent encode only control characters",
          "source": "encode_percent(\"foo \tbar\", ascii_set: \"CONTROLS\")",
          "return": "\"foo %09bar\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "encode_zlib",
      "name": "encode_zlib",
      "category": "Codec",
      "description": "Encodes the `value` to [Zlib](https://www.zlib.net).",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to encode.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "compression_level",
          "description": "The default compression level.",
          "required": false,
          "type": [
            "integer"
          ],
          "default": 6
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Encode to Zlib",
          "source": "encoded_text = encode_zlib(\"please encode me\")\nencode_base64(encoded_text)",
          "return": "\"eJwryElNLE5VSM1Lzk9JVchNBQA0RQX7\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "encode_zstd",
      "name": "encode_zstd",
      "category": "Codec",
      "description": "Encodes the `value` to [Zstandard](https://facebook.github.io/zstd).",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to encode.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "compression_level",
          "description": "The default compression level.",
          "required": false,
          "type": [
            "integer"
          ],
          "default": 3
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Encode to Zstd",
          "source": "encoded_text = encode_zstd(\"please encode me\")\nencode_base64(encoded_text)",
          "return": "\"KLUv/QBYgQAAcGxlYXNlIGVuY29kZSBtZQ==\""
        }
      ],
      "deprecated": false
    }
  ],
  "Cryptography": [
    {
      "anchor": "decrypt",
      "name": "decrypt",
      "category": "Cryptography",
      "description": "Decrypts a string with a symmetric encryption algorithm.\n\nSupported Algorithms:\n\n* AES-256-CFB (key = 32 bytes, iv = 16 bytes)\n* AES-192-CFB (key = 24 bytes, iv = 16 bytes)\n* AES-128-CFB (key = 16 bytes, iv = 16 bytes)\n* AES-256-OFB (key = 32 bytes, iv = 16 bytes)\n* AES-192-OFB  (key = 24 bytes, iv = 16 bytes)\n* AES-128-OFB (key = 16 bytes, iv = 16 bytes)\n* AES-256-CTR (key = 32 bytes, iv = 16 bytes)\n* AES-192-CTR (key = 24 bytes, iv = 16 bytes)\n* AES-128-CTR (key = 16 bytes, iv = 16 bytes)\n* AES-256-CBC-PKCS7 (key = 32 bytes, iv = 16 bytes)\n* AES-192-CBC-PKCS7 (key = 24 bytes, iv = 16 bytes)\n* AES-128-CBC-PKCS7 (key = 16 bytes, iv = 16 bytes)\n* AES-256-CBC-ANSIX923 (key = 32 bytes, iv = 16 bytes)\n* AES-192-CBC-ANSIX923 (key = 24 bytes, iv = 16 bytes)\n* AES-128-CBC-ANSIX923 (key = 16 bytes, iv = 16 bytes)\n* AES-256-CBC-ISO7816 (key = 32 bytes, iv = 16 bytes)\n* AES-192-CBC-ISO7816 (key = 24 bytes, iv = 16 bytes)\n* AES-128-CBC-ISO7816 (key = 16 bytes, iv = 16 bytes)\n* AES-256-CBC-ISO10126 (key = 32 bytes, iv = 16 bytes)\n* AES-192-CBC-ISO10126 (key = 24 bytes, iv = 16 bytes)\n* AES-128-CBC-ISO10126 (key = 16 bytes, iv = 16 bytes)",
      "notices": [],
      "arguments": [
        {
          "name": "ciphertext",
          "description": "The string to decrypt. The should be raw bytes (not encoded).",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "algorithm",
          "description": "The algorithm to use.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "key",
          "description": "The key for decryption. The should be raw bytes of the key (not encoded). The length must match the algorithm requested.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "iv",
          "description": "The IV for decryption. The should be raw bytes of the IV (not encoded). The length must match the algorithm requested.\nA new IV should be generated for every message. You can use `random_bytes` to generate a cryptographically secure random value.\nThe value should match the one used during encryption.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`algorithm` isn't a supported algorithm",
        "`key` length doesn't match the key size required for the algorithm specified",
        "`iv` length doesn't match the iv size required for the algorithm specified"
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Decrypt value",
          "source": "ciphertext = decode_base64!(\"5fLGcu1VHdzsPcGNDio7asLqE1P43QrVfPfmP4i4zOU=\")\niv = decode_base64!(\"fVEIRkIiczCRWNxaarsyxA==\")\nkey = \"16_byte_keyxxxxx\"\ndecrypt!(ciphertext, \"AES-128-CBC-PKCS7\", key, iv: iv)",
          "return": "\"super_secret_message\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "encrypt",
      "name": "encrypt",
      "category": "Cryptography",
      "description": "Encrypts a string with a symmetric encryption algorithm.\n\nSupported Algorithms:\n\n* AES-256-CFB (key = 32 bytes, iv = 16 bytes)\n* AES-192-CFB (key = 24 bytes, iv = 16 bytes)\n* AES-128-CFB (key = 16 bytes, iv = 16 bytes)\n* AES-256-OFB (key = 32 bytes, iv = 16 bytes)\n* AES-192-OFB  (key = 24 bytes, iv = 16 bytes)\n* AES-128-OFB (key = 16 bytes, iv = 16 bytes)\n* Deprecated - AES-256-CTR (key = 32 bytes, iv = 16 bytes)\n* Deprecated - AES-192-CTR (key = 24 bytes, iv = 16 bytes)\n* Deprecated - AES-128-CTR (key = 16 bytes, iv = 16 bytes)\n* AES-256-CTR-LE (key = 32 bytes, iv = 16 bytes)\n* AES-192-CTR-LE (key = 24 bytes, iv = 16 bytes)\n* AES-128-CTR-LE (key = 16 bytes, iv = 16 bytes)\n* AES-256-CTR-BE (key = 32 bytes, iv = 16 bytes)\n* AES-192-CTR-BE (key = 24 bytes, iv = 16 bytes)\n* AES-128-CTR-BE (key = 16 bytes, iv = 16 bytes)\n* AES-256-CBC-PKCS7 (key = 32 bytes, iv = 16 bytes)\n* AES-192-CBC-PKCS7 (key = 24 bytes, iv = 16 bytes)\n* AES-128-CBC-PKCS7 (key = 16 bytes, iv = 16 bytes)\n* AES-256-CBC-ANSIX923 (key = 32 bytes, iv = 16 bytes)\n* AES-192-CBC-ANSIX923 (key = 24 bytes, iv = 16 bytes)\n* AES-128-CBC-ANSIX923 (key = 16 bytes, iv = 16 bytes)\n* AES-256-CBC-ISO7816 (key = 32 bytes, iv = 16 bytes)\n* AES-192-CBC-ISO7816 (key = 24 bytes, iv = 16 bytes)\n* AES-128-CBC-ISO7816 (key = 16 bytes, iv = 16 bytes)\n* AES-256-CBC-ISO10126 (key = 32 bytes, iv = 16 bytes)\n* AES-192-CBC-ISO10126 (key = 24 bytes, iv = 16 bytes)\n* AES-128-CBC-ISO10126 (key = 16 bytes, iv = 16 bytes)\n* CHACHA20-POLY1305 (key = 32 bytes, iv = 12 bytes)\n* XCHACHA20-POLY1305 (key = 32 bytes, iv = 24 bytes)\n* XSALSA20-POLY1305 (key = 32 bytes, iv = 24 bytes)",
      "notices": [],
      "arguments": [
        {
          "name": "plaintext",
          "description": "The string to encrypt.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "algorithm",
          "description": "The algorithm to use.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "key",
          "description": "The key for encryption. The should be raw bytes of the key (not encoded). The length must match the algorithm requested.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "iv",
          "description": "The IV for encryption. The should be raw bytes of the IV (not encoded). The length must match the algorithm requested.\nA new IV should be generated for every message. You can use `random_bytes` to generate a cryptographically secure random value.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`algorithm` isn't a supported algorithm",
        "`key` length doesn't match the key size required for the algorithm specified",
        "`iv` length doesn't match the iv size required for the algorithm specified"
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Encrypt value",
          "source": "plaintext = \"super secret message\"\niv = \"1234567890123456\" # typically you would call random_bytes(16)\nkey = \"16_byte_keyxxxxx\"\nencrypted_message = encrypt!(plaintext, \"AES-128-CBC-PKCS7\", key, iv: iv)\nencode_base64(encrypted_message)",
          "return": "\"GBw8Mu00v0Kc38+/PvsVtGgWuUJ+ZNLgF8Opy8ohIYE=\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "hmac",
      "name": "hmac",
      "category": "Cryptography",
      "description": "Calculates a [HMAC](https://en.wikipedia.org/wiki/HMAC) of the `value` using the given `key`.\nThe hashing `algorithm` used can be optionally specified.\n\nFor most use cases, the resulting bytestream should be encoded into a hex or base64\nstring using either [encode_base16](/docs/reference/vrl/functions/#encode_base16) or\n[encode_base64](/docs/reference/vrl/functions/#encode_base64).\n\nThis function is infallible if either the default `algorithm` value, or a recognized-valid compile-time\n`algorithm` string literal is used. Otherwise it is fallible.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to calculate the HMAC for.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "key",
          "description": "The string to use as the cryptographic key.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "algorithm",
          "description": "The hashing algorithm to use.",
          "enum": {
            "SHA1": "SHA1 algorithm",
            "SHA-224": "SHA-224 algorithm",
            "SHA-256": "SHA-256 algorithm",
            "SHA-384": "SHA-384 algorithm",
            "SHA-512": "SHA-512 algorithm"
          },
          "required": false,
          "default": "SHA-256",
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Calculate message HMAC (defaults: SHA-256), encoding to a base64 string",
          "source": "encode_base64(hmac(\"Hello there\", \"super-secret-key\"))",
          "return": "\"eLGE8YMviv85NPXgISRUZxstBNSU47JQdcXkUWcClmI=\""
        },
        {
          "title": "Calculate message HMAC using SHA-224, encoding to a hex-encoded string",
          "source": "encode_base16(hmac(\"Hello there\", \"super-secret-key\", algorithm: \"SHA-224\"))",
          "return": "\"42fccbc2b7d22a143b92f265a8046187558a94d11ddbb30622207e90\""
        },
        {
          "title": "Calculate message HMAC using a variable hash algorithm",
          "source": ".hash_algo = \"SHA-256\"\nhmac_bytes, err = hmac(\"Hello there\", \"super-secret-key\", algorithm: .hash_algo)\nif err == null {\n\t.hmac = encode_base16(hmac_bytes)\n}",
          "return": "\"78b184f1832f8aff3934f5e0212454671b2d04d494e3b25075c5e45167029662\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "md5",
      "name": "md5",
      "category": "Cryptography",
      "description": "Calculates an md5 hash of the `value`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to calculate the hash for.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Create md5 hash",
          "source": "md5(\"foo\")",
          "return": "\"acbd18db4cc2f85cedef654fccc4a4d8\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "seahash",
      "name": "seahash",
      "category": "Cryptography",
      "description": "Calculates a [Seahash](https://docs.rs/seahash/latest/seahash/) hash of the `value`.\nNote: Due to limitations in the underlying VRL data types, this function converts the unsigned 64-bit integer seahash result to a signed 64-bit integer. Results higher than the signed 64-bit integer maximum value wrap around to negative values.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to calculate the hash for.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "integer"
        ]
      },
      "examples": [
        {
          "title": "Calculate seahash",
          "source": "seahash(\"foobar\")",
          "return": "5348458858952426000"
        },
        {
          "title": "Calculate negative seahash",
          "source": "seahash(\"bar\")",
          "return": "-2796170501982571500"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "sha1",
      "name": "sha1",
      "category": "Cryptography",
      "description": "Calculates a [SHA-1](https://en.wikipedia.org/wiki/SHA-1) hash of the `value`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to calculate the hash for.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Calculate sha1 hash",
          "source": "sha1(\"foo\")",
          "return": "\"0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "sha2",
      "name": "sha2",
      "category": "Cryptography",
      "description": "Calculates a [SHA-2](https://en.wikipedia.org/wiki/SHA-2) hash of the `value`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to calculate the hash for.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "variant",
          "description": "The variant of the algorithm to use.",
          "enum": {
            "SHA-224": "SHA-224 algorithm",
            "SHA-256": "SHA-256 algorithm",
            "SHA-384": "SHA-384 algorithm",
            "SHA-512": "SHA-512 algorithm",
            "SHA-512/224": "SHA-512/224 algorithm",
            "SHA-512/256": "SHA-512/256 algorithm"
          },
          "required": false,
          "default": "SHA-512/256",
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Calculate sha2 hash",
          "source": "sha2(\"foo\", variant: \"SHA-512/224\")",
          "return": "\"d68f258d37d670cfc1ec1001a0394784233f88f056994f9a7e5e99be\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "sha3",
      "name": "sha3",
      "category": "Cryptography",
      "description": "Calculates a [SHA-3](https://en.wikipedia.org/wiki/SHA-3) hash of the `value`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to calculate the hash for.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "variant",
          "description": "The variant of the algorithm to use.",
          "enum": {
            "SHA3-224": "SHA3-224 algorithm",
            "SHA3-256": "SHA3-256 algorithm",
            "SHA3-384": "SHA3-384 algorithm",
            "SHA3-512": "SHA3-512 algorithm"
          },
          "required": false,
          "default": "SHA3-512",
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Calculate sha3 hash",
          "source": "sha3(\"foo\", variant: \"SHA3-224\")",
          "return": "\"f4f6779e153c391bbd29c95e72b0708e39d9166c7cea51d1f10ef58a\""
        }
      ],
      "deprecated": false
    }
  ],
  "Path": [
    {
      "anchor": "del",
      "name": "del",
      "category": "Path",
      "description": "Removes the field specified by the static `path` from the target.\n\nFor dynamic path deletion, see the `remove` function.",
      "arguments": [
        {
          "name": "path",
          "description": "The path of the field to delete.",
          "required": true,
          "type": [
            "path"
          ]
        },
        {
          "name": "compact",
          "description": "If compact is true, after deletion, if an empty object or array is left\nbehind, it should be removed as well, cascading up to the root. This only\napplies to the path being deleted, and any parent paths.",
          "required": false,
          "default": false,
          "type": [
            "boolean"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "notices": [
        "The `del` function _modifies the current event in place_ and returns the value of the deleted field."
      ],
      "return": {
        "types": [
          "any"
        ],
        "rules": [
          "Returns the value of the field being deleted. Returns `null` if the field doesn't exist."
        ]
      },
      "examples": [
        {
          "title": "Delete a field",
          "input": {
            "log": {
              "field1": 1,
              "field2": 2
            }
          },
          "source": "del(.field1)",
          "output": {
            "log": {
              "field2": 2
            }
          }
        },
        {
          "title": "Rename a field",
          "input": {
            "log": {
              "old_field": "please rename me"
            }
          },
          "source": ".new_field = del(.old_field)",
          "output": {
            "log": {
              "new_field": "please rename me"
            }
          }
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "exists",
      "name": "exists",
      "category": "Path",
      "description": "Checks whether the `path` exists for the target.\n\nThis function allows you to distinguish between a missing path,\nor a path with a `null` value, something a regular path lookup\nsuch as `.foo` would not allow, since that always returns `null`\nif the path doesn't exist.",
      "notices": [],
      "arguments": [
        {
          "name": "path",
          "description": "The path of the field to check.",
          "required": true,
          "type": [
            "path"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ]
      },
      "examples": [
        {
          "title": "Exists (field)",
          "input": {
            "log": {
              "field": 1
            }
          },
          "source": "exists(.field)",
          "return": "true"
        },
        {
          "title": "Exists (array element)",
          "input": {
            "log": {
              "array": [
                1,
                2,
                3
              ]
            }
          },
          "source": "exists(.array[2])",
          "return": "true"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "get",
      "name": "get",
      "category": "Path",
      "description": "Dynamically get the value of a given path.\n\nWhen you know the path you want to look up, you should use\nstatic paths such as `.foo.bar[1]` to get the value of that\npath. However, when you don't know the path names in advance,\nyou can use this dynamic get function to get at the requested\nvalue.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The object or array to query.",
          "required": true,
          "type": [
            "object",
            "array"
          ]
        },
        {
          "name": "path",
          "description": "An array of path segments to look up the value for.",
          "required": true,
          "type": [
            "array"
          ]
        }
      ],
      "internal_failure_reasons": [
        "path segment must be either \"string\" or \"integer\""
      ],
      "return": {
        "types": [
          "any"
        ]
      },
      "examples": [
        {
          "title": "single-segment top-level field",
          "source": "get!(value: { \"foo\": \"bar\" }, path: [\"foo\"])",
          "return": "\"bar\""
        },
        {
          "title": "multi-segment nested field",
          "source": "get!(value: { \"foo\": { \"bar\": \"baz\" } }, path: [\"foo\", \"bar\"])",
          "return": "\"baz\""
        },
        {
          "title": "array indexing",
          "source": "get!(value: [\"foo\", \"bar\", \"baz\"], path: [-2])",
          "return": "\"bar\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "remove",
      "name": "remove",
      "category": "Path",
      "description": "Dynamically remove the value for a given path.\n\nWhen you know the path you want to remove, you should use\nthe `del` function and static paths such as `del(.foo.bar[1])`\nto remove the value at that path. The `del` function returns the\ndeleted value, and is more performant than this function.\nHowever, when you don't know the path names in advance, you can\nuse this dynamic remove function to remove the value at the\nprovided path.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The object or array to remove data from.",
          "required": true,
          "type": [
            "object",
            "array"
          ]
        },
        {
          "name": "path",
          "description": "An array of path segments to remove the value at.",
          "required": true,
          "type": [
            "array"
          ]
        },
        {
          "name": "compact",
          "description": "Whether — after deletion — empty objects or arrays should be removed.",
          "required": false,
          "default": false,
          "type": [
            "boolean"
          ]
        }
      ],
      "internal_failure_reasons": [
        "path segment must be either \"string\" or \"integer\""
      ],
      "return": {
        "types": [
          "object",
          "array"
        ]
      },
      "examples": [
        {
          "title": "single-segment top-level field",
          "source": "remove!(value: { \"foo\": \"bar\" }, path: [\"foo\"])",
          "return": "{}"
        },
        {
          "title": "multi-segment nested field",
          "source": "remove!(value: { \"foo\": { \"bar\": \"baz\" } }, path: [\"foo\", \"bar\"])",
          "return": "{\"foo\":{}}"
        },
        {
          "title": "array indexing",
          "source": "remove!(value: [\"foo\", \"bar\", \"baz\"], path: [-2])",
          "return": "[\"foo\",\"baz\"]"
        },
        {
          "title": "compaction",
          "source": "remove!(value: { \"foo\": { \"bar\": [42], \"baz\": true } }, path: [\"foo\", \"bar\", 0], compact: true)",
          "return": "{\"foo\":{\"baz\":true}}"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "set",
      "name": "set",
      "category": "Path",
      "description": "Dynamically insert data into the path of a given object or array.\n\nWhen you know the path you want to assign a value to, you should\nuse static path assignments such as `.foo.bar[1] = true` for\nimproved performance and readability. However, when you don't\nknow the path names in advance, you can use this dynamic\ninsertion function to insert the data into the object or array.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The object or array to insert data into.",
          "required": true,
          "type": [
            "object",
            "array"
          ]
        },
        {
          "name": "path",
          "description": "An array of path segments to insert the value to.",
          "required": true,
          "type": [
            "array"
          ]
        },
        {
          "name": "data",
          "description": "The data to be inserted.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [
        "path segment must be either \"string\" or \"integer\""
      ],
      "return": {
        "types": [
          "object",
          "array"
        ]
      },
      "examples": [
        {
          "title": "single-segment top-level field",
          "source": "set!(value: { \"foo\": \"bar\" }, path: [\"foo\"], data: \"baz\")",
          "return": "{\"foo\":\"baz\"}"
        },
        {
          "title": "multi-segment nested field",
          "source": "set!(value: { \"foo\": { \"bar\": \"baz\" } }, path: [\"foo\", \"bar\"], data: \"qux\")",
          "return": "{\"foo\":{\"bar\":\"qux\"}}"
        },
        {
          "title": "array",
          "source": "set!(value: [\"foo\", \"bar\", \"baz\"], path: [-2], data: 42)",
          "return": "[\"foo\",42,\"baz\"]"
        }
      ],
      "deprecated": false
    }
  ],
  "Enrichment": [
    {
      "anchor": "find_enrichment_table_records",
      "name": "find_enrichment_table_records",
      "category": "Enrichment",
      "description": "Searches an [enrichment table](/docs/reference/glossary/#enrichment-tables) for rows that match the\nprovided condition.\n\nFor `file` enrichment tables this condition needs to be a VRL object in which\nthe key-value pairs indicate a field to\tsearch mapped to a value to search in that field.\nThis function returns the rows that match the provided condition(s). _All_ fields need to\nmatch for rows to be returned; if any fields don't match, no rows are returned.\n\nThere are currently two forms of search criteria:\n\n1. **Exact match search**. The given field must match the value exactly. Case sensitivity\n   can be specified using the `case_sensitive` argument. An exact match search can use an\n   index directly into the dataset, which should make this search fairly \"cheap\" from a\n   performance perspective.\n\n2. **Date range search**. The given field must be greater than or equal to the `from` date\n   and less than or equal to the `to` date. Note that a date range search involves\n   sequentially scanning through the rows that have been located via any exact match\n   criteria. This can be an expensive operation if there are many rows returned by any exact\n   match criteria. We recommend using date ranges as the _only_ criteria when the enrichment\n   data set is very small.\n\nFor `geoip` enrichment tables this condition needs to be a VRL object with a single key-value pair\nwhose value needs to be a valid IP address. Example: `{\"ip\": .ip }`. If a return field is expected\nand without a value, `null` will be used. This table can return following fields:\n\n* ISP databases:\n\t* `autonomous_system_number`\n\t* `autonomous_system_organization`\n\t* `isp`\n\t* `organization`\n\n* City databases:\n\t* `city_name`\n\t* `continent_code`\n\t* `country_code`\n\t* `country_name`\n\t* `region_code`\n\t* `region_name`\n\t* `metro_code`\n\t* `latitude`\n\t* `longitude`\n\t* `postal_code`\n\t* `timezone`\n\n* Connection-Type databases:\n\t* `connection_type`\n\nTo use this function, you need to update your Vector configuration to\ninclude an\n[`enrichment_tables`](/docs/reference/configuration/global-options/#enrichment_tables)\nparameter.",
      "notices": [],
      "arguments": [
        {
          "name": "table",
          "description": "The [enrichment table](/docs/reference/glossary/#enrichment-tables) to search.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "condition",
          "description": "The condition to search on. Since the condition is used at boot time to create\nindices into the data, these conditions must be statically defined.",
          "required": true,
          "type": [
            "object"
          ]
        },
        {
          "name": "select",
          "description": "A subset of fields from the enrichment table to return. If not specified,\nall fields are returned.",
          "required": false,
          "type": [
            "array"
          ]
        },
        {
          "name": "case_sensitive",
          "description": "Whether text fields need to match cases exactly.",
          "required": false,
          "type": [
            "boolean"
          ],
          "default": true
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "array"
        ]
      },
      "examples": [
        {
          "title": "Exact match",
          "source": "find_enrichment_table_records!(\"test\",\n  {\n\t\"surname\": \"smith\",\n  },\n  case_sensitive: false)",
          "return": "[{\"id\":1,\"firstname\":\"Bob\",\"surname\":\"Smith\"},{\"id\":2,\"firstname\":\"Fred\",\"surname\":\"Smith\"}]"
        },
        {
          "title": "Date range search",
          "source": "find_enrichment_table_records!(\"test\",\n  {\n\t\"surname\": \"Smith\",\n\t\"date_of_birth\": {\n\t  \"from\": t'1985-01-01T00:00:00Z',\n\t  \"to\": t'1985-12-31T00:00:00Z'\n\t}\n  })",
          "return": "[{\"id\":1,\"firstname\":\"Bob\",\"surname\":\"Smith\"},{\"id\":2,\"firstname\":\"Fred\",\"surname\":\"Smith\"}]"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "get_enrichment_table_record",
      "name": "get_enrichment_table_record",
      "category": "Enrichment",
      "description": "Searches an [enrichment table](/docs/reference/glossary/#enrichment-tables) for a row that matches the\nprovided condition. A single row must be matched. If either no rows or more than one row is\nfound, an error is returned.\n\nFor `file` enrichment tables this condition needs to be a VRL object in which\nthe key-value pairs indicate a field to\tsearch mapped to a value to search in that field.\nThis function returns the rows that match the provided condition(s). _All_ fields need to\nmatch for rows to be returned; if any fields don't match, no rows are returned.\n\nThere are currently two forms of search criteria:\n\n1. **Exact match search**. The given field must match the value exactly. Case sensitivity\n   can be specified using the `case_sensitive` argument. An exact match search can use an\n   index directly into the dataset, which should make this search fairly \"cheap\" from a\n   performance perspective.\n\n2. **Date range search**. The given field must be greater than or equal to the `from` date\n   and less than or equal to the `to` date. Note that a date range search involves\n   sequentially scanning through the rows that have been located via any exact match\n   criteria. This can be an expensive operation if there are many rows returned by any exact\n   match criteria. We recommend using date ranges as the _only_ criteria when the enrichment\n   data set is very small.\n\nFor `geoip` enrichment tables this condition needs to be a VRL object with a single key-value pair\nwhose value needs to be a valid IP address. Example: `{\"ip\": .ip }`. If a return field is expected\nand without a value, `null` will be used. This table can return following fields:\n\n* ISP databases:\n\t* `autonomous_system_number`\n\t* `autonomous_system_organization`\n\t* `isp`\n\t* `organization`\n\n* City databases:\n\t* `city_name`\n\t* `continent_code`\n\t* `country_code`\n\t* `country_name`\n\t* `region_code`\n\t* `region_name`\n\t* `metro_code`\n\t* `latitude`\n\t* `longitude`\n\t* `postal_code`\n\t* `timezone`\n\n* Connection-Type databases:\n\t* `connection_type`\n\nTo use this function, you need to update your Vector configuration to\ninclude an\n[`enrichment_tables`](/docs/reference/configuration/global-options/#enrichment_tables)\nparameter.",
      "notices": [],
      "arguments": [
        {
          "name": "table",
          "description": "The [enrichment table](/docs/reference/glossary/#enrichment-tables) to search.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "condition",
          "description": "The condition to search on. Since the condition is used at boot time to create\nindices into the data, these conditions must be statically defined.",
          "required": true,
          "type": [
            "object"
          ]
        },
        {
          "name": "select",
          "description": "A subset of fields from the enrichment table to return. If not specified,\nall fields are returned.",
          "required": false,
          "type": [
            "array"
          ]
        },
        {
          "name": "case_sensitive",
          "description": "Should text fields match case exactly.",
          "required": false,
          "type": [
            "boolean"
          ],
          "default": true
        }
      ],
      "internal_failure_reasons": [
        "The row isn't found",
        "Multiple rows are found that match the condition"
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Exact match",
          "source": "get_enrichment_table_record!(\"test\",\n  {\n    \"surname\": \"bob\",\n    \"firstname\": \"John\"\n  },\n  case_sensitive: false)",
          "return": "{\"id\":1,\"firstname\":\"Bob\",\"surname\":\"Smith\"}"
        },
        {
          "title": "Date range search",
          "source": "get_enrichment_table_record!(\"test\",\n  {\n    \"surname\": \"Smith\",\n    \"date_of_birth\": {\n      \"from\": t'1985-01-01T00:00:00Z',\n      \"to\": t'1985-12-31T00:00:00Z'\n    }\n  })",
          "return": "{\"id\":1,\"firstname\":\"Bob\",\"surname\":\"Smith\"}"
        }
      ],
      "deprecated": false
    }
  ],
  "Timestamp": [
    {
      "anchor": "format_timestamp",
      "name": "format_timestamp",
      "category": "Timestamp",
      "description": "Formats the `value` into a string representation of the timestamp.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The timestamp to format as text.",
          "required": true,
          "type": [
            "timestamp"
          ]
        },
        {
          "name": "format",
          "description": "The format string as described by the [Chrono library](https://docs.rs/chrono/latest/chrono/format/strftime/index.html#specifiers).",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "timezone",
          "description": "The timezone to use when formatting the timestamp. The uses the TZ identifier, or 'local'",
          "required": false,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Format a timestamp (ISO8601/RFC 3339)",
          "source": "format_timestamp!(t'2020-10-21T16:00:00Z', format: \"%+\")",
          "return": "\"2020-10-21T16:00:00+00:00\""
        },
        {
          "title": "Format a timestamp (custom)",
          "source": "format_timestamp!(t'2020-10-21T16:00:00Z', format: \"%v %R\")",
          "return": "\"21-Oct-2020 16:00\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "now",
      "name": "now",
      "category": "Timestamp",
      "description": "Returns the current timestamp in the UTC timezone with nanosecond precision.",
      "notices": [],
      "arguments": [],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "timestamp"
        ]
      },
      "examples": [
        {
          "title": "Generate a current timestamp",
          "source": "now()",
          "return": "\"2021-03-04T10:51:15.928937Z\""
        }
      ],
      "deprecated": false
    }
  ],
  "Convert": [
    {
      "anchor": "from_unix_timestamp",
      "name": "from_unix_timestamp",
      "category": "Convert",
      "description": "Converts the `value` integer from a [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time) to a VRL `timestamp`.\n\nConverts from the number of seconds since the Unix epoch by default, but milliseconds or nanoseconds can also be\nspecified by `unit`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The Unix timestamp to convert.",
          "required": true,
          "type": [
            "integer"
          ]
        },
        {
          "name": "unit",
          "description": "The time unit.",
          "type": [
            "string"
          ],
          "required": false,
          "enum": {
            "seconds": "Express Unix time in seconds",
            "milliseconds": "Express Unix time in milliseconds",
            "nanoseconds": "Express Unix time in nanoseconds"
          },
          "default": "seconds"
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "timestamp"
        ]
      },
      "examples": [
        {
          "title": "Convert from a Unix timestamp (seconds)",
          "source": "from_unix_timestamp!(5)",
          "return": "\"1970-01-01T00:00:05Z\""
        },
        {
          "title": "Convert from a Unix timestamp (milliseconds)",
          "source": "from_unix_timestamp!(5000, unit: \"milliseconds\")",
          "return": "\"1970-01-01T00:00:05Z\""
        },
        {
          "title": "Convert from a Unix timestamp (nanoseconds)",
          "source": "from_unix_timestamp!(5000, unit: \"nanoseconds\")",
          "return": "\"1970-01-01T00:00:00.000005Z\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "to_syslog_facility",
      "name": "to_syslog_facility",
      "category": "Convert",
      "description": "Converts the `value`, a Syslog [facility code](https://en.wikipedia.org/wiki/Syslog#Facility), into its corresponding\nSyslog keyword. i.e. 0 into `\"kern\"`, 1 into `\"user\"`, etc.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The facility code.",
          "required": true,
          "type": [
            "integer"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a valid Syslog [facility code](https://en.wikipedia.org/wiki/Syslog#Facility)."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Coerce to a Syslog facility",
          "source": "to_syslog_facility!(4)",
          "return": "\"auth\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "to_syslog_level",
      "name": "to_syslog_level",
      "category": "Convert",
      "description": "Converts the `value`, a Syslog [severity level](https://en.wikipedia.org/wiki/Syslog#Severity_level), into its corresponding keyword,\ni.e. 0 into `\"emerg\"`, 1 into `\"alert\"`, etc.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The severity level.",
          "required": true,
          "type": [
            "integer"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a valid Syslog [severity level](https://en.wikipedia.org/wiki/Syslog#Severity_level)."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Coerce to a Syslog level",
          "source": "to_syslog_level!(5)",
          "return": "\"notice\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "to_syslog_severity",
      "name": "to_syslog_severity",
      "category": "Convert",
      "description": "Converts the `value`, a Syslog [log level keyword](https://en.wikipedia.org/wiki/Syslog#Severity_level), into a Syslog integer\nseverity level (`0` to `7`).",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The Syslog level keyword to convert.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a valid Syslog level keyword"
      ],
      "return": {
        "types": [
          "integer"
        ],
        "rules": [
          "The now-deprecated keywords `panic`, `error`, and `warn` are converted to `0`, `3`, and `4` respectively."
        ]
      },
      "examples": [
        {
          "title": "Coerce to Syslog severity",
          "source": "to_syslog_severity!(\"alert\")",
          "return": "1"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "to_unix_timestamp",
      "name": "to_unix_timestamp",
      "category": "Convert",
      "description": "Converts the `value` timestamp into a [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time).\n\nReturns the number of seconds since the Unix epoch by default, but milliseconds or nanoseconds can also be\nspecified by `unit`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The timestamp to convert to Unix.",
          "required": true,
          "type": [
            "timestamp"
          ]
        },
        {
          "name": "unit",
          "description": "The time unit.",
          "type": [
            "string"
          ],
          "required": false,
          "enum": {
            "seconds": "Express Unix time in seconds",
            "milliseconds": "Express Unix time in milliseconds",
            "nanoseconds": "Express Unix time in nanoseconds"
          },
          "default": "seconds"
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "integer"
        ]
      },
      "examples": [
        {
          "title": "Convert to a Unix timestamp (seconds)",
          "source": "to_unix_timestamp(t'2021-01-01T00:00:00+00:00')",
          "return": "1609459200"
        },
        {
          "title": "Convert to a Unix timestamp (milliseconds)",
          "source": "to_unix_timestamp(t'2021-01-01T00:00:00Z', unit: \"milliseconds\")",
          "return": "1609459200000"
        },
        {
          "title": "Convert to a Unix timestamp (nanoseconds)",
          "source": "to_unix_timestamp(t'2021-01-01T00:00:00Z', unit: \"nanoseconds\")",
          "return": "1609459200000000000"
        }
      ],
      "deprecated": false
    }
  ],
  "System": [
    {
      "anchor": "get_env_var",
      "name": "get_env_var",
      "category": "System",
      "description": "Returns the value of the environment variable specified by `name`.",
      "notices": [],
      "arguments": [
        {
          "name": "name",
          "description": "The name of the environment variable.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "Environment variable `name` doesn't exist",
        "Value of environment variable `name` isn't valid Unicode"
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Get an environment variable",
          "source": "get_env_var!(\"HOME\")",
          "return": "\"/root\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "get_hostname",
      "name": "get_hostname",
      "category": "System",
      "description": "Returns the local system's hostname.",
      "notices": [],
      "arguments": [],
      "internal_failure_reasons": [
        "Internal hostname resolution failed."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Get hostname",
          "input": {
            "log": {}
          },
          "source": ".hostname = get_hostname!()",
          "output": {
            "log": {
              "hostname": "localhost.localdomain"
            }
          }
        }
      ],
      "deprecated": false
    }
  ],
  "Event": [
    {
      "anchor": "get_secret",
      "name": "get_secret",
      "category": "Event",
      "description": "Returns the value of the given secret from an event.",
      "notices": [],
      "arguments": [
        {
          "name": "key",
          "description": "The name of the secret.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Get the Datadog API key from the event metadata.",
          "source": "get_secret(\"datadog_api_key\")",
          "return": "\"secret value\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "remove_secret",
      "name": "remove_secret",
      "category": "Event",
      "description": "Removes a secret from an event.",
      "notices": [],
      "arguments": [
        {
          "name": "key",
          "description": "The name of the secret to remove.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "null"
        ]
      },
      "examples": [
        {
          "title": "Removes the Datadog API key from the event.",
          "source": "remove_secret(\"datadog_api_key\")",
          "return": "null"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "set_secret",
      "name": "set_secret",
      "category": "Event",
      "description": "Sets the given secret in the event.",
      "notices": [],
      "arguments": [
        {
          "name": "key",
          "description": "The name of the secret.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "secret",
          "description": "The secret value.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "null"
        ]
      },
      "examples": [
        {
          "title": "Set the Datadog API key to the given value.",
          "source": "set_secret(\"datadog_api_key\", \"abc122\")",
          "return": "null"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "set_semantic_meaning",
      "name": "set_semantic_meaning",
      "category": "Event",
      "description": "Sets a semantic meaning for an event. Note that this function assigns\nmeaning at Vector startup, and has _no_ runtime behavior. It is suggested\nto put all calls to this function at the beginning of a VRL function. The function\ncannot be conditionally called (eg: using an if statement cannot stop the meaning\nfrom being assigned).",
      "notices": [],
      "arguments": [
        {
          "name": "target",
          "description": "The path of the value that will be assigned a meaning.",
          "required": true,
          "type": [
            "path"
          ]
        },
        {
          "name": "meaning",
          "description": "The name of the meaning to assign.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "null"
        ]
      },
      "examples": [
        {
          "title": "Sets custom field semantic meaning",
          "source": "set_semantic_meaning(.foo, \"bar\")",
          "return": "null"
        }
      ],
      "deprecated": false
    }
  ],
  "IP": [
    {
      "anchor": "ip_aton",
      "name": "ip_aton",
      "category": "IP",
      "description": "Converts IPv4 address in numbers-and-dots notation into network-order\nbytes represented as an integer.\n\nThis behavior mimics [inet_aton](https://linux.die.net/man/3/inet_aton).",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The IP address to convert to binary.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a valid IPv4 address"
      ],
      "return": {
        "types": [
          "integer"
        ]
      },
      "examples": [
        {
          "title": "IPv4 to integer",
          "source": "ip_aton!(\"1.2.3.4\")",
          "return": "16909060"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "ip_cidr_contains",
      "name": "ip_cidr_contains",
      "category": "IP",
      "description": "Determines whether the `ip` is contained in the block referenced by the `cidr`.",
      "notices": [],
      "arguments": [
        {
          "name": "cidr",
          "description": "The CIDR mask (v4 or v6).",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "ip",
          "description": "The IP address (v4 or v6).",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`cidr` isn't a valid CIDR",
        "`ip` isn't a valid IP address"
      ],
      "return": {
        "types": [
          "boolean"
        ]
      },
      "examples": [
        {
          "title": "IPv4 contains CIDR",
          "source": "ip_cidr_contains!(\"192.168.0.0/16\", \"192.168.10.32\")",
          "return": "true"
        },
        {
          "title": "IPv6 contains CIDR",
          "source": "ip_cidr_contains!(\"2001:4f8:4:ba::/64\", \"2001:4f8:4:ba:2e0:81ff:fe22:d1f1\")",
          "return": "true"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "ip_ntoa",
      "name": "ip_ntoa",
      "category": "IP",
      "description": "Converts numeric representation of IPv4 address in network-order bytes\nto numbers-and-dots notation..\n\nThis behavior mimics [inet_ntoa](https://linux.die.net/man/3/inet_ntoa).",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The integer representation of an IPv4 address.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` cannot fit in u32"
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Integer to IPv4",
          "source": "ip_ntoa!(16909060)",
          "return": "\"1.2.3.4\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "ip_ntop",
      "name": "ip_ntop",
      "category": "IP",
      "description": "Converts IPv4 and IPv6 addresses from binary to text form.\n\nThis behavior mimics [inet_ntop](https://linux.die.net/man/3/inet_ntop).",
      "notices": [
        "The binary data for this function is not easily printable.\nHowever, the results from functions such as `decode_base64` or\n`decode_percent` can still be used correctly."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The binary data to convert from.\nFor IPv4 addresses, it must be 4 bytes (32 bits) long.\nFor IPv6 addresses, it must be 16 bytes (128 bits) long.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` must be of length 4 or 16 bytes"
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Convert IPv4 address from bytes after decoding from Base64",
          "source": "ip_ntop!(decode_base64!(\"wKgAAQ==\"))",
          "return": "\"192.168.0.1\""
        },
        {
          "title": "Convert IPv6 address from bytes after decoding from Base64",
          "source": "ip_ntop!(decode_base64!(\"IAENuIWjAAAAAIouA3BzNA==\"))",
          "return": "\"2001:db8:85a3::8a2e:370:7334\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "ip_pton",
      "name": "ip_pton",
      "category": "IP",
      "description": "Converts IPv4 and IPv6 addresses from text to binary form.\n\n* The binary form of IPv4 addresses is 4 bytes (32 bits) long.\n* The binary form of IPv6 addresses is 16 bytes (128 bits) long.\n\nThis behavior mimics [inet_pton](https://linux.die.net/man/3/inet_pton).",
      "notices": [
        "The binary data from this function is not easily printable.\nHowever, functions such as `encode_base64` or `encode_percent` can\nstill process it correctly."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The IP address (v4 or v6) to convert to binary form.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a valid IP (v4 or v6) address in text form"
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Convert IPv4 address to bytes and encode to Base64",
          "source": "encode_base64(ip_pton!(\"192.168.0.1\"))",
          "return": "\"wKgAAQ==\""
        },
        {
          "title": "Convert IPv6 address to bytes and encode to Base64",
          "source": "encode_base64(ip_pton!(\"2001:db8:85a3::8a2e:370:7334\"))",
          "return": "\"IAENuIWjAAAAAIouA3BzNA==\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "ip_subnet",
      "name": "ip_subnet",
      "category": "IP",
      "description": "Extracts the subnet address from the `ip` using the supplied `subnet`.",
      "notices": [
        "Works with both IPv4 and IPv6 addresses. The IP version for the mask must be the same as the supplied\naddress."
      ],
      "arguments": [
        {
          "name": "ip",
          "description": "The IP address (v4 or v6).",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "subnet",
          "description": "The subnet to extract from the IP address. This can be either a prefix length like `/8` or a net mask\nlike `255.255.0.0`. The net mask can be either an IPv4 or IPv6 address.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`ip` isn't a valid IP address",
        "`subnet` isn't a valid subnet."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "IPv4 subnet",
          "source": "ip_subnet!(\"192.168.10.32\", \"255.255.255.0\")",
          "return": "\"192.168.10.0\""
        },
        {
          "title": "IPv6 subnet",
          "source": "ip_subnet!(\"2404:6800:4003:c02::64\", \"/32\")",
          "return": "\"2404:6800::\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "ip_to_ipv6",
      "name": "ip_to_ipv6",
      "category": "IP",
      "description": "Converts the `ip` to an IPv6 address.",
      "notices": [],
      "arguments": [
        {
          "name": "ip",
          "description": "The IP address to convert to IPv6.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`ip` isn't a valid IP address"
      ],
      "return": {
        "types": [
          "string"
        ],
        "rules": [
          "The `ip` is returned unchanged if it's already an IPv6 address.",
          "The `ip` is converted to an IPv6 address if it's an IPv4 address."
        ]
      },
      "examples": [
        {
          "title": "IPv4 to IPv6",
          "source": "ip_to_ipv6!(\"192.168.10.32\")",
          "return": "\"::ffff:192.168.10.32\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "ipv6_to_ipv4",
      "name": "ipv6_to_ipv4",
      "category": "IP",
      "description": "Converts the `ip` to an IPv4 address. `ip` is returned unchanged if it's already an IPv4 address. If `ip` is\ncurrently an IPv6 address then it needs to be IPv4 compatible, otherwise an error is thrown.",
      "notices": [],
      "arguments": [
        {
          "name": "ip",
          "description": "The IPv4-mapped IPv6 address to convert.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`ip` isn't a valid IP address",
        "`ip` is an IPv6 address that isn't compatible with IPv4"
      ],
      "return": {
        "types": [
          "string"
        ],
        "rules": [
          "The `ip` is returned unchanged if it's already an IPv4 address. If it's an IPv6 address it must be IPv4\ncompatible, otherwise an error is thrown."
        ]
      },
      "examples": [
        {
          "title": "IPv6 to IPv4",
          "source": "ipv6_to_ipv4!(\"::ffff:192.168.0.1\")",
          "return": "\"192.168.0.1\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "is_ipv4",
      "name": "is_ipv4",
      "category": "IP",
      "description": "Check if the string is a valid IPv4 address or not.\n\nAn [IPv4-mapped][https://datatracker.ietf.org/doc/html/rfc6890] or\n[IPv4-compatible][https://datatracker.ietf.org/doc/html/rfc6890] IPv6 address is not considered\nvalid for the purpose of this function.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The IP address to check",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ],
        "rules": [
          "Returns `true` if `value` is a valid IPv4 address.",
          "Returns `false` if `value` is anything else."
        ]
      },
      "examples": [
        {
          "title": "Valid IPv4 address",
          "source": "is_ipv4(\"10.0.102.37\")",
          "return": "true"
        },
        {
          "title": "Valid IPv6 address",
          "source": "is_ipv4(\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\")",
          "return": "false"
        },
        {
          "title": "Arbitrary string",
          "source": "is_ipv4(\"foobar\")",
          "return": "false"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "is_ipv6",
      "name": "is_ipv6",
      "category": "IP",
      "description": "Check if the string is a valid IPv6 address or not.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The IP address to check",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ],
        "rules": [
          "Returns `true` if `value` is a valid IPv6 address.",
          "Returns `false` if `value` is anything else."
        ]
      },
      "examples": [
        {
          "title": "Valid IPv6 address",
          "source": "is_ipv6(\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\")",
          "return": "true"
        },
        {
          "title": "Valid IPv4 address",
          "source": "is_ipv6(\"10.0.102.37\")",
          "return": "false"
        },
        {
          "title": "Arbitrary string",
          "source": "is_ipv6(\"foobar\")",
          "return": "false"
        }
      ],
      "deprecated": false
    }
  ],
  "Object": [
    {
      "anchor": "match_datadog_query",
      "name": "match_datadog_query",
      "category": "Object",
      "description": "Matches an object against a [Datadog Search Syntax](https://docs.datadoghq.com/logs/explorer/search_syntax/) query.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The object.",
          "required": true,
          "type": [
            "object"
          ]
        },
        {
          "name": "query",
          "description": "The Datadog Search Syntax query.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ]
      },
      "examples": [
        {
          "title": "OR query",
          "source": "match_datadog_query({\"message\": \"contains this and that\"}, \"this OR that\")",
          "return": "true"
        },
        {
          "title": "AND query",
          "source": "match_datadog_query({\"message\": \"contains only this\"}, \"this AND that\")",
          "return": "false"
        },
        {
          "title": "Facet wildcard",
          "source": "match_datadog_query({\"custom\": {\"name\": \"vector\"}}, \"@name:vec*\")",
          "return": "true"
        },
        {
          "title": "Tag range",
          "source": "match_datadog_query({\"tags\": [\"a:x\", \"b:y\", \"c:z\"]}, s'b:[\"x\" TO \"z\"]')",
          "return": "true"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "merge",
      "name": "merge",
      "category": "Object",
      "description": "Merges the `from` object into the `to` object.",
      "notices": [],
      "arguments": [
        {
          "name": "to",
          "description": "The object to merge into.",
          "required": true,
          "type": [
            "object"
          ]
        },
        {
          "name": "from",
          "description": "The object to merge from.",
          "required": true,
          "type": [
            "object"
          ]
        },
        {
          "name": "deep",
          "description": "A deep merge is performed if `true`, otherwise only top-level fields are merged.",
          "required": false,
          "default": false,
          "type": [
            "boolean"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "object"
        ],
        "rules": [
          "The field from the `from` object is chosen if a key exists in both objects.",
          "Objects are merged recursively if `deep` is specified, a key exists in both objects, and both of those\nfields are also objects."
        ]
      },
      "examples": [
        {
          "title": "Object merge (shallow)",
          "source": "merge(\n\t{\n\t\t\"parent1\": {\n\t\t\t\"child1\": 1,\n\t\t\t\"child2\": 2\n\t\t},\n\t\t\"parent2\": {\n\t\t\t\"child3\": 3\n\t\t}\n\t},\n\t{\n\t\t\"parent1\": {\n\t\t\t\"child2\": 4,\n\t\t\t\"child5\": 5\n\t\t}\n\t}\n)",
          "return": "{\"parent1\":{\"child2\":4,\"child5\":5},\"parent2\":{\"child3\":3}}"
        },
        {
          "title": "Object merge (deep)",
          "source": "merge(\n\t{\n\t\t\"parent1\": {\n\t\t\t\"child1\": 1,\n\t\t\t\"child2\": 2\n\t\t},\n\t\t\"parent2\": {\n\t\t\t\"child3\": 3\n\t\t}\n\t},\n\t{\n\t\t\"parent1\": {\n\t\t\t\"child2\": 4,\n\t\t\t\"child5\": 5\n\t\t}\n\t},\n\tdeep: true\n)",
          "return": "{\"parent1\":{\"child1\":1,\"child2\":4,\"child5\":5},\"parent2\":{\"child3\":3}}"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "unnest",
      "name": "unnest",
      "category": "Object",
      "description": "Unnest an array field from an object to create an array of objects using that field; keeping all other fields.\n\nAssigning the array result of this to `.` will result in multiple events being emitted from `remap`. See the\n[`remap` transform docs](/docs/reference/configuration/transforms/remap/#emitting-multiple-log-events) for more details.\n\nThis is also referred to as `explode`ing in some languages.",
      "arguments": [
        {
          "name": "path",
          "description": "The path of the field to unnest.",
          "required": true,
          "type": [
            "path"
          ]
        }
      ],
      "internal_failure_reasons": [
        "Field path refers to is not an array"
      ],
      "notices": [],
      "return": {
        "types": [
          "array"
        ],
        "rules": [
          "Returns an array of objects that matches the original object, but each with the specified path replaced with a single element from the original path."
        ]
      },
      "examples": [
        {
          "title": "Unnest an array field",
          "input": {
            "log": {
              "hostname": "localhost",
              "messages": [
                "message 1",
                "message 2"
              ]
            }
          },
          "source": ". = unnest!(.messages)",
          "output": [
            {
              "log": {
                "hostname": "localhost",
                "messages": "message 1"
              }
            },
            {
              "log": {
                "hostname": "localhost",
                "messages": "message 2"
              }
            }
          ]
        },
        {
          "title": "Unnest nested an array field",
          "input": {
            "log": {
              "hostname": "localhost",
              "event": {
                "messages": [
                  "message 1",
                  "message 2"
                ]
              }
            }
          },
          "source": ". = unnest!(.event.messages)",
          "output": [
            {
              "log": {
                "hostname": "localhost",
                "event": {
                  "messages": "message 1"
                }
              }
            },
            {
              "log": {
                "hostname": "localhost",
                "event": {
                  "messages": "message 2"
                }
              }
            }
          ]
        }
      ],
      "deprecated": false
    }
  ],
  "Parse": [
    {
      "anchor": "parse_apache_log",
      "name": "parse_apache_log",
      "category": "Parse",
      "description": "Parses Apache access and error log lines. Lines can be in [`common`](https://httpd.apache.org/docs/current/logs.html#common),\n[`combined`](https://httpd.apache.org/docs/current/logs.html#combined), or default [`error`](https://httpd.apache.org/docs/current/logs.html#errorlog) format.",
      "notices": [
        "Missing information in the log message may be indicated by `-`. These fields are omitted in the result."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string to parse.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "timestamp_format",
          "description": "The [date/time format](https://docs.rs/chrono/latest/chrono/format/strftime/index.html) to use for\nencoding the timestamp. The time is parsed in local time if the timestamp doesn't specify a timezone.",
          "required": false,
          "default": "%d/%b/%Y:%T %z",
          "type": [
            "string"
          ]
        },
        {
          "name": "format",
          "description": "The format to use for parsing the log.",
          "required": true,
          "enum": {
            "common": "Common format",
            "combined": "Apache combined format",
            "error": "Default Apache error format"
          },
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` doesn't match the specified format",
        "`timestamp_format` isn't a valid format string",
        "The timestamp in `value` fails to parse using the provided `timestamp_format`"
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse via Apache log format (common)",
          "source": "parse_apache_log!(\"127.0.0.1 bob frank [10/Oct/2000:13:55:36 -0700] \\\"GET /apache_pb.gif HTTP/1.0\\\" 200 2326\", format: \"common\")",
          "return": "{\"host\":\"127.0.0.1\",\"identity\":\"bob\",\"user\":\"frank\",\"timestamp\":\"2000-10-10T20:55:36Z\",\"message\":\"GET /apache_pb.gif HTTP/1.0\",\"method\":\"GET\",\"path\":\"/apache_pb.gif\",\"protocol\":\"HTTP/1.0\",\"status\":200,\"size\":2326}"
        },
        {
          "title": "Parse via Apache log format (combined)",
          "source": "parse_apache_log!(\n\ts'127.0.0.1 bob frank [10/Oct/2000:13:55:36 -0700] \"GET /apache_pb.gif HTTP/1.0\" 200 2326 \"http://www.seniorinfomediaries.com/vertical/channels/front-end/bandwidth\" \"Mozilla/5.0 (X11; Linux i686; rv:5.0) Gecko/1945-10-12 Firefox/37.0\"',\n\t\"combined\",\n)",
          "return": "{\"host\":\"127.0.0.1\",\"identity\":\"bob\",\"user\":\"frank\",\"timestamp\":\"2000-10-10T20:55:36Z\",\"message\":\"GET /apache_pb.gif HTTP/1.0\",\"method\":\"GET\",\"path\":\"/apache_pb.gif\",\"protocol\":\"HTTP/1.0\",\"status\":200,\"size\":2326,\"referrer\":\"http://www.seniorinfomediaries.com/vertical/channels/front-end/bandwidth\",\"agent\":\"Mozilla/5.0 (X11; Linux i686; rv:5.0) Gecko/1945-10-12 Firefox/37.0\"}"
        },
        {
          "title": "Parse via Apache log format (error)",
          "source": "parse_apache_log!(\n\ts'[01/Mar/2021:12:00:19 +0000] [ab:alert] [pid 4803:tid 3814] [client 147.159.108.175:24259] I will bypass the haptic COM bandwidth, that should matrix the CSS driver!',\n\t\"error\"\n)",
          "return": "{\"client\":\"147.159.108.175\",\"message\":\"I will bypass the haptic COM bandwidth, that should matrix the CSS driver!\",\"module\":\"ab\",\"pid\":4803,\"port\":24259,\"severity\":\"alert\",\"thread\":\"3814\",\"timestamp\":\"2021-03-01T12:00:19Z\"}"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "parse_aws_alb_log",
      "name": "parse_aws_alb_log",
      "category": "Parse",
      "description": "Parses `value` in the [Elastic Load Balancer Access format](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-access-logs.html#access-log-entry-examples).",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "Access log of the Application Load Balancer.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a properly formatted AWS ALB log"
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse AWS ALB log",
          "source": "parse_aws_alb_log!(\n\t\"http 2018-11-30T22:23:00.186641Z app/my-loadbalancer/50dc6c495c0c9188 192.168.131.39:2817 - 0.000 0.001 0.000 200 200 34 366 \\\"GET http://www.example.com:80/ HTTP/1.1\\\" \\\"curl/7.46.0\\\" - - arn:aws:elasticloadbalancing:us-east-2:123456789012:targetgroup/my-targets/73e2d6bc24d8a067 \\\"Root=1-58337364-23a8c76965a2ef7629b185e3\\\" \\\"-\\\" \\\"-\\\" 0 2018-11-30T22:22:48.364000Z \\\"forward\\\" \\\"-\\\" \\\"-\\\" \\\"-\\\" \\\"-\\\" \\\"-\\\" \\\"-\\\"\"\n)",
          "return": "{\"type\":\"http\",\"timestamp\":\"2018-11-30T22:23:00.186641Z\",\"elb\":\"app/my-loadbalancer/50dc6c495c0c9188\",\"client_host\":\"192.168.131.39:2817\",\"target_host\":null,\"request_processing_time\":0,\"target_processing_time\":0.001,\"response_processing_time\":0,\"elb_status_code\":\"200\",\"target_status_code\":\"200\",\"received_bytes\":34,\"sent_bytes\":366,\"request_method\":\"GET\",\"request_url\":\"http://www.example.com:80/\",\"request_protocol\":\"HTTP/1.1\",\"user_agent\":\"curl/7.46.0\",\"ssl_cipher\":null,\"ssl_protocol\":null,\"target_group_arn\":\"arn:aws:elasticloadbalancing:us-east-2:123456789012:targetgroup/my-targets/73e2d6bc24d8a067\",\"trace_id\":\"Root=1-58337364-23a8c76965a2ef7629b185e3\",\"domain_name\":null,\"chosen_cert_arn\":null,\"matched_rule_priority\":\"0\",\"request_creation_time\":\"2018-11-30T22:22:48.364000Z\",\"actions_executed\":\"forward\",\"redirect_url\":null,\"error_reason\":null,\"target_port_list\":[],\"target_status_code_list\":[],\"classification\":null,\"classification_reason\":null}"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "parse_aws_cloudwatch_log_subscription_message",
      "name": "parse_aws_cloudwatch_log_subscription_message",
      "category": "Parse",
      "description": "Parses AWS CloudWatch Logs events (configured through AWS Cloudwatch subscriptions) from the\n`aws_kinesis_firehose` source.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string representation of the message to parse.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a properly formatted AWS Cloudwatch Log subscription message"
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse AWS Cloudwatch Log subscription message",
          "input": {
            "log": {
              "message": "{\n  \"messageType\": \"DATA_MESSAGE\",\n  \"owner\": \"111111111111\",\n  \"logGroup\": \"test\",\n  \"logStream\": \"test\",\n  \"subscriptionFilters\": [\n\t\"Destination\"\n  ],\n  \"logEvents\": [\n\t{\n\t  \"id\": \"35683658089614582423604394983260738922885519999578275840\",\n\t  \"timestamp\": 1600110569039,\n\t  \"message\": \"{\\\"bytes\\\":26780,\\\"datetime\\\":\\\"14/Sep/2020:11:45:41 -0400\\\",\\\"host\\\":\\\"157.130.216.193\\\",\\\"method\\\":\\\"PUT\\\",\\\"protocol\\\":\\\"HTTP/1.0\\\",\\\"referer\\\":\\\"https://www.principalcross-platform.io/markets/ubiquitous\\\",\\\"request\\\":\\\"/expedite/convergence\\\",\\\"source_type\\\":\\\"stdin\\\",\\\"status\\\":301,\\\"user-identifier\\\":\\\"-\\\"}\"\n\t}\n  ]\n}"
            }
          },
          "source": "parse_aws_cloudwatch_log_subscription_message!(.message)",
          "return": "{\"owner\":\"111111111111\",\"message_type\":\"DATA_MESSAGE\",\"log_group\":\"test\",\"log_stream\":\"test\",\"subscription_filters\":[\"Destination\"],\"log_events\":[{\"id\":\"35683658089614582423604394983260738922885519999578275840\",\"message\":\"{\\\"bytes\\\":26780,\\\"datetime\\\":\\\"14/Sep/2020:11:45:41 -0400\\\",\\\"host\\\":\\\"157.130.216.193\\\",\\\"method\\\":\\\"PUT\\\",\\\"protocol\\\":\\\"HTTP/1.0\\\",\\\"referer\\\":\\\"https://www.principalcross-platform.io/markets/ubiquitous\\\",\\\"request\\\":\\\"/expedite/convergence\\\",\\\"source_type\\\":\\\"stdin\\\",\\\"status\\\":301,\\\"user-identifier\\\":\\\"-\\\"}\",\"timestamp\":\"2020-09-14T19:09:29.039Z\"}]}"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "parse_aws_vpc_flow_log",
      "name": "parse_aws_vpc_flow_log",
      "category": "Parse",
      "description": "Parses `value` in the [VPC Flow Logs format](https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html).",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "VPC Flow Log.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "format",
          "description": "VPC Flow Log format.",
          "required": false,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a properly formatted AWS VPC Flow log"
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse AWS VPC Flow log (default format)",
          "source": "parse_aws_vpc_flow_log!(\"2 123456789010 eni-1235b8ca123456789 - - - - - - - 1431280876 1431280934 - NODATA\")",
          "return": "{\"version\":2,\"account_id\":123456789010,\"interface_id\":\"eni-1235b8ca123456789\",\"srcaddr\":null,\"dstaddr\":null,\"srcport\":null,\"dstport\":null,\"protocol\":null,\"packets\":null,\"bytes\":null,\"start\":1431280876,\"end\":1431280934,\"action\":null,\"log_status\":\"NODATA\"}"
        },
        {
          "title": "Parse AWS VPC Flow log (custom format)",
          "source": "parse_aws_vpc_flow_log!(\n\t\"- eni-1235b8ca123456789 10.0.1.5 10.0.0.220 10.0.1.5 203.0.113.5\",\n\t\"instance_id interface_id srcaddr dstaddr pkt_srcaddr pkt_dstaddr\"\n)",
          "return": "{\"instance_id\":null,\"interface_id\":\"eni-1235b8ca123456789\",\"srcaddr\":\"10.0.1.5\",\"dstaddr\":\"10.0.0.220\",\"pkt_srcaddr\":\"10.0.1.5\",\"pkt_dstaddr\":\"203.0.113.5\"}"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "parse_cef",
      "name": "parse_cef",
      "category": "Parse",
      "description": "Parses the `value` in CEF (Common Event Format) format. Ignores everything up to CEF header. Empty values are returned as empty strings. Surrounding quotes are removed from values.",
      "notices": [
        "All values are returned as strings. We recommend manually coercing values to desired types as you see fit."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string to parse.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "translate_custom_fields",
          "description": "Toggles translation of custom field pairs to `key: value`.",
          "required": false,
          "type": [
            "boolean"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a properly formatted CEF string"
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse output generated by PTA",
          "source": "parse_cef!(\n\t\"CEF:0|CyberArk|PTA|12.6|1|Suspected credentials theft|8|suser=mike2@prod1.domain.com shost=prod1.domain.com src=1.1.1.1 duser=andy@dev1.domain.com dhost=dev1.domain.com dst=2.2.2.2 cs1Label=ExtraData cs1=None cs2Label=EventID cs2=52b06812ec3500ed864c461e deviceCustomDate1Label=detectionDate deviceCustomDate1=1388577900000 cs3Label=PTAlink cs3=https://1.1.1.1/incidents/52b06812ec3500ed864c461e cs4Label=ExternalLink cs4=None\"\n)",
          "return": "{\"cefVersion\":\"0\",\"deviceVendor\":\"CyberArk\",\"deviceProduct\":\"PTA\",\"deviceVersion\":\"12.6\",\"deviceEventClassId\":\"1\",\"name\":\"Suspected credentials theft\",\"severity\":\"8\",\"suser\":\"mike2@prod1.domain.com\",\"shost\":\"prod1.domain.com\",\"src\":\"1.1.1.1\",\"duser\":\"andy@dev1.domain.com\",\"dhost\":\"dev1.domain.com\",\"dst\":\"2.2.2.2\",\"cs1Label\":\"ExtraData\",\"cs1\":\"None\",\"cs2Label\":\"EventID\",\"cs2\":\"52b06812ec3500ed864c461e\",\"deviceCustomDate1Label\":\"detectionDate\",\"deviceCustomDate1\":\"1388577900000\",\"cs3Label\":\"PTAlink\",\"cs3\":\"https://1.1.1.1/incidents/52b06812ec3500ed864c461e\",\"cs4Label\":\"ExternalLink\",\"cs4\":\"None\"}"
        },
        {
          "title": "Ignore syslog header",
          "source": "parse_cef!(\n\t\"Sep 29 08:26:10 host CEF:1|Security|threatmanager|1.0|100|worm successfully stopped|10|src=10.0.0.1 dst=2.1.2.2 spt=1232\"\n)",
          "return": "{\"cefVersion\":\"1\",\"deviceVendor\":\"Security\",\"deviceProduct\":\"threatmanager\",\"deviceVersion\":\"1.0\",\"deviceEventClassId\":\"100\",\"name\":\"worm successfully stopped\",\"severity\":\"10\",\"src\":\"10.0.0.1\",\"dst\":\"2.1.2.2\",\"spt\":\"1232\"}"
        },
        {
          "title": "Translate custom fields",
          "source": "parse_cef!(\n\t\"CEF:0|Dev|firewall|2.2|1|Connection denied|5|c6a1=2345:0425:2CA1:0000:0000:0567:5673:23b5 c6a1Label=Device IPv6 Address\",\n\ttranslate_custom_fields: true\n)",
          "return": "{\"cefVersion\":\"0\",\"deviceVendor\":\"Dev\",\"deviceProduct\":\"firewall\",\"deviceVersion\":\"2.2\",\"deviceEventClassId\":\"1\",\"name\":\"Connection denied\",\"severity\":\"5\",\"Device IPv6 Address\":\"2345:0425:2CA1:0000:0000:0567:5673:23b5\"}"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "parse_common_log",
      "name": "parse_common_log",
      "category": "Parse",
      "description": "Parses the `value` using the [Common Log Format](https://httpd.apache.org/docs/current/logs.html#common) (CLF).",
      "notices": [
        "Missing information in the log message may be indicated by `-`. These fields are omitted in the result."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string to parse.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "timestamp_format",
          "description": "The [date/time format](https://docs.rs/chrono/latest/chrono/format/strftime/index.html) to use for\nencoding the timestamp.",
          "required": false,
          "default": "%d/%b/%Y:%T %z",
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` doesn't match the Common Log Format",
        "`timestamp_format` isn't a valid format string",
        "The timestamp in `value` fails to parse using the provided `timestamp_format`"
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse via Common Log Format (with default timestamp format)",
          "source": "parse_common_log!(\"127.0.0.1 bob frank [10/Oct/2000:13:55:36 -0700] \\\"GET /apache_pb.gif HTTP/1.0\\\" 200 2326\")",
          "return": "{\"host\":\"127.0.0.1\",\"identity\":\"bob\",\"user\":\"frank\",\"timestamp\":\"2000-10-10T20:55:36Z\",\"message\":\"GET /apache_pb.gif HTTP/1.0\",\"method\":\"GET\",\"path\":\"/apache_pb.gif\",\"protocol\":\"HTTP/1.0\",\"status\":200,\"size\":2326}"
        },
        {
          "title": "Parse via Common Log Format (with custom timestamp format)",
          "source": "parse_common_log!(\n\t\"127.0.0.1 bob frank [2000-10-10T20:55:36Z] \\\"GET /apache_pb.gif HTTP/1.0\\\" 200 2326\",\n\t\"%+\"\n)",
          "return": "{\"host\":\"127.0.0.1\",\"identity\":\"bob\",\"user\":\"frank\",\"timestamp\":\"2000-10-10T20:55:36Z\",\"message\":\"GET /apache_pb.gif HTTP/1.0\",\"method\":\"GET\",\"path\":\"/apache_pb.gif\",\"protocol\":\"HTTP/1.0\",\"status\":200,\"size\":2326}"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "parse_csv",
      "name": "parse_csv",
      "category": "Parse",
      "description": "Parses a single CSV formatted row. Only the first row is parsed in case of multiline input value.",
      "notices": [
        "All values are returned as strings. We recommend manually coercing values to desired types as you see fit."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string to parse.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "delimiter",
          "description": "The field delimiter to use when parsing. Must be a single-byte utf8 character.",
          "required": false,
          "default": ",",
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "delimiter must be a single-byte utf8 character",
        "`value` isn't a valid CSV string"
      ],
      "return": {
        "types": [
          "array"
        ]
      },
      "examples": [
        {
          "title": "Parse a single CSV formatted row",
          "source": "parse_csv!(\"foo,bar,\\\"foo \\\"\\\", bar\\\"\")",
          "return": "[\"foo\",\"bar\",\"foo \\\", bar\"]"
        },
        {
          "title": "Parse a single CSV formatted row with custom delimiter",
          "source": "parse_csv!(\"foo bar\", delimiter: \" \")",
          "return": "[\"foo\",\"bar\"]"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "parse_duration",
      "name": "parse_duration",
      "category": "Parse",
      "description": "Parses the `value` into a human-readable duration format specified by `unit`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string of the duration.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "unit",
          "description": "The output units for the duration.",
          "required": true,
          "type": [
            "string"
          ],
          "enum": {
            "ns": "Nanoseconds (1 billion nanoseconds in a second)",
            "us": "Microseconds (1 million microseconds in a second)",
            "µs": "Microseconds (1 million microseconds in a second)",
            "ms": "Milliseconds (1 thousand microseconds in a second)",
            "cs": "Centiseconds (100 centiseconds in a second)",
            "ds": "Deciseconds (10 deciseconds in a second)",
            "s": "Seconds",
            "m": "Minutes (60 seconds in a minute)",
            "h": "Hours (60 minutes in an hour)",
            "d": "Days (24 hours in a day)"
          }
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a properly formatted duration"
      ],
      "return": {
        "types": [
          "float"
        ]
      },
      "examples": [
        {
          "title": "Parse duration (milliseconds)",
          "source": "parse_duration!(\"1005ms\", unit: \"s\")",
          "return": "1.005"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "parse_glog",
      "name": "parse_glog",
      "category": "Parse",
      "description": "Parses the `value` using the [glog (Google Logging Library)](https://github.com/google/glog) format.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to parse.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` doesn't match the `glog` format"
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse via glog",
          "source": "parse_glog!(\"I20210131 14:48:54.411655 15520 main.c++:9] Hello world!\")",
          "return": "{\"level\":\"info\",\"timestamp\":\"2021-01-31T14:48:54.411655Z\",\"id\":15520,\"file\":\"main.c++\",\"line\":9,\"message\":\"Hello world!\"}"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "parse_grok",
      "name": "parse_grok",
      "category": "Parse",
      "description": "Parses the `value` using the [`grok` format](https://grokdebug.herokuapp.com/). All patterns [listed here](https://github.com/daschl/grok/tree/master/patterns)\nare supported.",
      "notices": [
        "We recommend using community-maintained Grok patterns when possible, as they're more likely to be properly\nvetted and improved over time than bespoke patterns."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string to parse.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "pattern",
          "description": "The [Grok pattern](https://github.com/daschl/grok/tree/master/patterns).",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` fails to parse using the provided `pattern`"
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse using Grok",
          "source": "parse_grok!(\n\t\"2020-10-02T23:22:12.223222Z info Hello world\",\n\t\"%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{GREEDYDATA:message}\"\n)",
          "return": "{\"timestamp\":\"2020-10-02T23:22:12.223222Z\",\"level\":\"info\",\"message\":\"Hello world\"}"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "parse_groks",
      "name": "parse_groks",
      "category": "Parse",
      "description": "Parses the `value` using multiple [`grok`](https://grokdebug.herokuapp.com/) patterns. All patterns [listed here](https://github.com/daschl/grok/tree/master/patterns)\nare supported.",
      "notices": [
        "We recommend using community-maintained Grok patterns when possible, as they're more likely to be properly\nvetted and improved over time than bespoke patterns."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string to parse.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "patterns",
          "description": "The [Grok patterns](https://github.com/daschl/grok/tree/master/patterns), which are tried in order until the first match.",
          "required": true,
          "type": [
            "array"
          ]
        },
        {
          "name": "aliases",
          "description": "The shared set of grok aliases that can be referenced in the patterns to simplify them.",
          "required": false,
          "default": true,
          "type": [
            "object"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` fails to parse using the provided `pattern`"
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse using multiple Grok patterns",
          "source": "parse_groks!(\n\t\"2020-10-02T23:22:12.223222Z info Hello world\",\n\tpatterns: [\n\t\t\"%{common_prefix} %{_status} %{_message}\",\n\t\t\"%{common_prefix} %{_message}\",\n\t],\n\taliases: {\n\t\t\"common_prefix\": \"%{_timestamp} %{_loglevel}\",\n\t\t\"_timestamp\": \"%{TIMESTAMP_ISO8601:timestamp}\",\n\t\t\"_loglevel\": \"%{LOGLEVEL:level}\",\n\t\t\"_status\": \"%{POSINT:status}\",\n\t\t\"_message\": \"%{GREEDYDATA:message}\"\n\t}\n)",
          "return": "{\"timestamp\":\"2020-10-02T23:22:12.223222Z\",\"level\":\"info\",\"message\":\"Hello world\"}"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "parse_int",
      "name": "parse_int",
      "category": "Parse",
      "description": "Parses the string `value` representing a number in an optional base/radix to an integer.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to parse.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "base",
          "description": "The base the number is in. Must be between 2 and 36 (inclusive).\n\nIf unspecified, will use the string prefix to try to\ndetermine the base: \"0b\", 8 for \"0\" or \"0o\", 16 for \"0x\",\nand 10 otherwise",
          "required": false,
          "type": [
            "integer"
          ]
        }
      ],
      "internal_failure_reasons": [
        "base is not between 2 and 36",
        "number cannot be parsed in the base"
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Parse decimal",
          "source": "parse_int!(\"-42\")",
          "return": "-42"
        },
        {
          "title": "Parse binary",
          "source": "parse_int!(\"0b1001\")",
          "return": "9"
        },
        {
          "title": "Parse octal",
          "source": "parse_int!(\"0o42\")",
          "return": "34"
        },
        {
          "title": "Parse hexadecimal",
          "source": "parse_int!(\"0x2a\")",
          "return": "42"
        },
        {
          "title": "Parse explicit base",
          "source": "parse_int!(\"2a\", 17)",
          "return": "44"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "parse_json",
      "name": "parse_json",
      "category": "Parse",
      "description": "Parses the `value` as JSON.",
      "notices": [
        "Only JSON types are returned. If you need to convert a `string` into a `timestamp`, consider the\n[`parse_timestamp`](#parse_timestamp) function."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string representation of the JSON to parse.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "max_depth",
          "description": "Number of layers to parse for nested JSON-formatted documents.\nThe value must be in range 1..128.",
          "required": false,
          "type": [
            "integer"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a valid JSON-formatted payload"
      ],
      "return": {
        "types": [
          "boolean",
          "integer",
          "float",
          "string",
          "object",
          "array",
          "null"
        ]
      },
      "examples": [
        {
          "title": "Parse JSON",
          "source": "parse_json!(\"{\\\"key\\\": \\\"val\\\"}\")",
          "return": "{\"key\":\"val\"}"
        },
        {
          "title": "Parse JSON with max_depth",
          "source": "parse_json!(\"{\\\"top_level\\\":{\\\"key\\\": \\\"val\\\"}}\", max_depth: 1)",
          "return": "{\"top_level\":\"{\\\"key\\\": \\\"val\\\"}\"}"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "parse_key_value",
      "name": "parse_key_value",
      "category": "Parse",
      "description": "Parses the `value` in key/value format. Also known as [logfmt](https://brandur.org/logfmt).\n\n* Keys and values can be wrapped with `\"`.\n* `\"` characters can be escaped using `\\`.",
      "notices": [
        "All values are returned as strings or as an array of strings for duplicate keys. We recommend manually coercing values to desired types as you see fit."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string to parse.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "key_value_delimiter",
          "description": "The string that separates the key from the value.",
          "required": false,
          "default": "=",
          "type": [
            "string"
          ]
        },
        {
          "name": "field_delimiter",
          "description": "The string that separates each key/value pair.",
          "required": false,
          "default": " ",
          "type": [
            "string"
          ]
        },
        {
          "name": "whitespace",
          "description": "Defines the acceptance of unnecessary whitespace surrounding the configured `key_value_delimiter`.",
          "required": false,
          "enum": {
            "lenient": "Ignore whitespace.",
            "strict": "Parse whitespace as normal character."
          },
          "default": "lenient",
          "type": [
            "string"
          ]
        },
        {
          "name": "accept_standalone_key",
          "description": "Whether a standalone key should be accepted, the resulting object will associate such keys with boolean value `true`",
          "required": false,
          "type": [
            "boolean"
          ],
          "default": true
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a properly formatted key/value string"
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse logfmt log",
          "source": "parse_key_value!(\n\t\"@timestamp=\\\"Sun Jan 10 16:47:39 EST 2021\\\" level=info msg=\\\"Stopping all fetchers\\\" tag#production=stopping_fetchers id=ConsumerFetcherManager-1382721708341 module=kafka.consumer.ConsumerFetcherManager\"\n)",
          "return": "{\"@timestamp\":\"Sun Jan 10 16:47:39 EST 2021\",\"level\":\"info\",\"msg\":\"Stopping all fetchers\",\"tag#production\":\"stopping_fetchers\",\"id\":\"ConsumerFetcherManager-1382721708341\",\"module\":\"kafka.consumer.ConsumerFetcherManager\"}"
        },
        {
          "title": "Parse comma delimited log",
          "source": "parse_key_value!(\n\t\"path:\\\"/cart_link\\\", host:store.app.com, fwd: \\\"102.30.171.16\\\", dyno: web.1, connect:0ms, service:87ms, status:304, bytes:632, protocol:https\",\n\tfield_delimiter: \",\",\n\tkey_value_delimiter: \":\"\n)",
          "return": "{\"path\":\"/cart_link\",\"host\":\"store.app.com\",\"fwd\":\"102.30.171.16\",\"dyno\":\"web.1\",\"connect\":\"0ms\",\"service\":\"87ms\",\"status\":\"304\",\"bytes\":\"632\",\"protocol\":\"https\"}"
        },
        {
          "title": "Parse comma delimited log with standalone keys",
          "source": "parse_key_value!(\n\t\"env:prod,service:backend,region:eu-east1,beta\",\n\tfield_delimiter: \",\",\n\tkey_value_delimiter: \":\",\n)",
          "return": "{\"env\":\"prod\",\"service\":\"backend\",\"region\":\"eu-east1\",\"beta\":true}"
        },
        {
          "title": "Parse duplicate keys",
          "source": "parse_key_value!(\n\t\"at=info,method=GET,path=\\\"/index\\\",status=200,tags=dev,tags=dummy\",\n\tfield_delimiter: \",\",\n\tkey_value_delimiter: \"=\",\n)",
          "return": "{\"at\":\"info\",\"method\":\"GET\",\"path\":\"/index\",\"status\":\"200\",\"tags\":[\"dev\",\"dummy\"]}"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "parse_klog",
      "name": "parse_klog",
      "category": "Parse",
      "description": "Parses the `value` using the [klog](https://github.com/kubernetes/klog) format used by Kubernetes components.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to parse.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` doesn't match the `klog` format"
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse via klog",
          "source": "parse_klog!(\"I0505 17:59:40.692994   28133 klog.go:70] hello from klog\")",
          "return": "{\"file\":\"klog.go\",\"id\":28133,\"level\":\"info\",\"line\":70,\"message\":\"hello from klog\",\"timestamp\":\"2023-05-05T17:59:40.692994Z\"}"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "parse_linux_authorization",
      "name": "parse_linux_authorization",
      "category": "Parse",
      "description": "Parses Linux authorization logs usually found under either `/var/log/auth.log` (for Debian-based systems) or\n`/var/log/secure` (for RedHat-based systems) according to [Syslog](https://en.wikipedia.org/wiki/Syslog) format.",
      "notices": [
        "The function resolves the year for messages that don't include it. If the current month is January, and the message is for\nDecember, it will take the previous year. Otherwise, take the current year."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The text containing the message to parse.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a properly formatted Syslog message"
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse Linux authorization event",
          "source": "parse_linux_authorization!(\n\ts'Mar 23 01:49:58 localhost sshd[1111]: Accepted publickey for eng from 10.1.1.1 port 8888 ssh2: RSA SHA256:foobar'\n)",
          "return": "{\"appname\":\"sshd\",\"hostname\":\"localhost\",\"message\":\"Accepted publickey for eng from 10.1.1.1 port 8888 ssh2: RSA SHA256:foobar\",\"procid\":1111,\"timestamp\":\"2023-03-23T01:49:58Z\"}"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "parse_logfmt",
      "name": "parse_logfmt",
      "category": "Parse",
      "description": "Parses the `value` in [logfmt](https://brandur.org/logfmt).\n\n* Keys and values can be wrapped using the `\"` character.\n* `\"` characters can be escaped by the `\\` character.\n* As per this [logfmt specification](https://pkg.go.dev/github.com/kr/logfmt#section-documentation), the `parse_logfmt` function\n  accepts standalone keys and assigns them a Boolean value of `true`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to parse.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a properly formatted key/value string"
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse logfmt log",
          "source": "parse_logfmt!(\n\t\"@timestamp=\\\"Sun Jan 10 16:47:39 EST 2021\\\" level=info msg=\\\"Stopping all fetchers\\\" tag#production=stopping_fetchers id=ConsumerFetcherManager-1382721708341 module=kafka.consumer.ConsumerFetcherManager\"\n)",
          "return": "{\"@timestamp\":\"Sun Jan 10 16:47:39 EST 2021\",\"level\":\"info\",\"msg\":\"Stopping all fetchers\",\"tag#production\":\"stopping_fetchers\",\"id\":\"ConsumerFetcherManager-1382721708341\",\"module\":\"kafka.consumer.ConsumerFetcherManager\"}"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "parse_nginx_log",
      "name": "parse_nginx_log",
      "category": "Parse",
      "description": "Parses Nginx access and error log lines. Lines can be in [`combined`](https://nginx.org/en/docs/http/ngx_http_log_module.html),\n[`ingress_upstreaminfo`](https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/log-format/) or [`error`](https://github.com/nginx/nginx/blob/branches/stable-1.18/src/core/ngx_log.c#L102) format.",
      "notices": [
        "Missing information in the log message may be indicated by `-`. These fields are omitted in the result."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string to parse.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "timestamp_format",
          "description": "\nThe [date/time format](https://docs.rs/chrono/latest/chrono/format/strftime/index.html#specifiers) to use for encoding the timestamp. The time is parsed\nin local time if the timestamp doesn't specify a timezone. The default format is `%d/%b/%Y:%T %z` for\ncombined logs and `%Y/%m/%d %H:%M:%S` for error logs.",
          "required": false,
          "default": "%d/%b/%Y:%T %z",
          "type": [
            "string"
          ]
        },
        {
          "name": "format",
          "description": "The format to use for parsing the log.",
          "required": true,
          "enum": {
            "combined": "Nginx combined format",
            "error": "Default Nginx error format",
            "ingress_upstreaminfo": "Provides detailed upstream information (Nginx Ingress Controller)"
          },
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` doesn't match the specified format",
        "`timestamp_format` isn't a valid format string",
        "The timestamp in `value` fails to parse using the provided `timestamp_format`"
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse via Nginx log format (combined)",
          "source": "parse_nginx_log!(\n    s'172.17.0.1 - alice [01/Apr/2021:12:02:31 +0000] \"POST /not-found HTTP/1.1\" 404 153 \"http://localhost/somewhere\" \"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.119 Safari/537.36\" \"2.75\"',\n    \"combined\",\n)",
          "return": "{\"agent\":\"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.119 Safari/537.36\",\"client\":\"172.17.0.1\",\"compression\":\"2.75\",\"referer\":\"http://localhost/somewhere\",\"request\":\"POST /not-found HTTP/1.1\",\"size\":153,\"status\":404,\"timestamp\":\"2021-04-01T12:02:31Z\",\"user\":\"alice\"}"
        },
        {
          "title": "Parse via Nginx log format (error)",
          "source": "parse_nginx_log!(\n    s'2021/04/01 13:02:31 [error] 31#31: *1 open() \"/usr/share/nginx/html/not-found\" failed (2: No such file or directory), client: 172.17.0.1, server: localhost, request: \"POST /not-found HTTP/1.1\", host: \"localhost:8081\"',\n    \"error\"\n)",
          "return": "{\"timestamp\":\"2021-04-01T13:02:31Z\",\"severity\":\"error\",\"pid\":31,\"tid\":31,\"cid\":1,\"message\":\"open() \\\"/usr/share/nginx/html/not-found\\\" failed (2: No such file or directory)\",\"client\":\"172.17.0.1\",\"server\":\"localhost\",\"request\":\"POST /not-found HTTP/1.1\",\"host\":\"localhost:8081\"}"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "parse_query_string",
      "name": "parse_query_string",
      "category": "Parse",
      "description": "Parses the `value` as a query string.",
      "notices": [
        "All values are returned as strings. We recommend manually coercing values to desired types as you see fit. Empty keys and values are allowed."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string to parse.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse query string",
          "source": "parse_query_string(\"foo=%2B1&bar=2&bar=3&xyz\")",
          "return": "{\"foo\":\"+1\",\"bar\":[\"2\",\"3\"],\"xyz\":\"\"}"
        },
        {
          "title": "Parse Ruby on Rails' query string",
          "source": "parse_query_string(\"?foo%5b%5d=1&foo%5b%5d=2\")",
          "return": "{\"foo[]\":[\"1\",\"2\"]}"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "parse_regex",
      "name": "parse_regex",
      "category": "Parse",
      "description": "Parses the `value` via the provided [Regex](https://en.wikipedia.org/wiki/Regular_expression) `pattern`.\n\nThis function differs from the `parse_regex_all` function in that it returns only the first match.",
      "notices": [
        "VRL aims to provide purpose-specific [parsing functions](/docs/reference/vrl/functions/#parse-functions) for common log formats.\nBefore reaching for the `parse_regex` function, see if a VRL [`parse_*` function](/docs/reference/vrl/functions/#parse-functions)\nalready exists for your format. If not, we recommend [opening an issue](https://github.com/vectordotdev/vector/issues/new?labels=type%3A+new+feature) to request\nsupport for the desired format.",
        "All values are returned as strings. We recommend manually coercing values to desired types as you see fit."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string to search.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "pattern",
          "description": "The regular expression pattern to search against.",
          "required": true,
          "type": [
            "regex"
          ]
        },
        {
          "name": "numeric_groups",
          "description": "If true, the index of each group in the regular expression is also captured. The 0th index\nwill contain the whole match.",
          "required": false,
          "default": false,
          "type": [
            "regex"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` fails to parse using the provided `pattern`"
      ],
      "return": {
        "types": [
          "object"
        ],
        "rules": [
          "Matches return all capture groups corresponding to the leftmost matches in the text.",
          "Raises an error if no match is found."
        ]
      },
      "examples": [
        {
          "title": "Parse using Regex (with capture groups)",
          "source": "parse_regex!(\"first group and second group.\", r'(?P<number>.*?) group')",
          "return": "{\"number\":\"first\"}"
        },
        {
          "title": "Parse using Regex (without capture groups)",
          "source": "parse_regex!(\"first group and second group.\", r'(\\w+) group', numeric_groups: true)",
          "return": "{\"0\":\"first group\",\"1\":\"first\"}"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "parse_regex_all",
      "name": "parse_regex_all",
      "category": "Parse",
      "description": "Parses the `value` via the provided [Regex](https://en.wikipedia.org/wiki/Regular_expression) `pattern`.\n\nThis function differs from the `parse_regex` function in that it returns _all_ matches, not just the first.",
      "notices": [
        "VRL aims to provide purpose-specific [parsing functions](/docs/reference/vrl/functions/#parse-functions) for common log formats.\nBefore reaching for the `parse_regex` function, see if a VRL [`parse_*` function](/docs/reference/vrl/functions/#parse-functions)\nalready exists for your format. If not, we recommend [opening an issue](https://github.com/vectordotdev/vector/issues/new?labels=type%3A+new+feature) to request\nsupport for the desired format.",
        "All values are returned as strings. We recommend manually coercing values to desired types as you see fit."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string to search.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "pattern",
          "description": "The regular expression pattern to search against.",
          "required": true,
          "type": [
            "regex"
          ]
        },
        {
          "name": "numeric_groups",
          "description": "If `true`, the index of each group in the regular expression is also captured. The 0th index\ncontains the whole match.",
          "required": false,
          "default": false,
          "type": [
            "regex"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` fails to parse via the provided `pattern`"
      ],
      "return": {
        "types": [
          "array"
        ],
        "rules": [
          "Matches return all capture groups corresponding to the leftmost matches in the text.",
          "Raises an error if no match is found."
        ]
      },
      "examples": [
        {
          "title": "Parse using Regex (all matches)",
          "source": "parse_regex_all!(\"first group and second group.\", r'(?P<number>\\w+) group', numeric_groups: true)",
          "return": "[{\"0\":\"first group\",\"1\":\"first\",\"number\":\"first\"},{\"0\":\"second group\",\"1\":\"second\",\"number\":\"second\"}]"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "parse_ruby_hash",
      "name": "parse_ruby_hash",
      "category": "Parse",
      "description": "Parses the `value` as ruby hash.",
      "notices": [
        "Only ruby types are returned. If you need to convert a `string` into a `timestamp`, consider the\n[`parse_timestamp`](#parse_timestamp) function."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string representation of the ruby hash to parse.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a valid ruby hash formatted payload"
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse ruby hash",
          "source": "parse_ruby_hash!(s'{ \"test\" => \"value\", \"testNum\" => 0.2, \"testObj\" => { \"testBool\" => true, \"testNull\" => nil } }')",
          "return": "{\"test\":\"value\",\"testNum\":0.2,\"testObj\":{\"testBool\":true,\"testNull\":null}}"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "parse_syslog",
      "name": "parse_syslog",
      "category": "Parse",
      "description": "Parses the `value` in [Syslog](https://en.wikipedia.org/wiki/Syslog) format.",
      "notices": [
        "The function makes a best effort to parse the various Syslog formats that exists out in the wild. This includes\n[RFC 6587](https://tools.ietf.org/html/rfc6587), [RFC 5424](https://tools.ietf.org/html/rfc5424), [RFC 3164](https://tools.ietf.org/html/rfc3164), and other\ncommon variations (such as the Nginx Syslog style).",
        "All values are returned as strings. We recommend manually coercing values to desired types as you see fit."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The text containing the Syslog message to parse.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a properly formatted Syslog message"
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse Syslog log (5424)",
          "source": "parse_syslog!(\n\ts'<13>1 2020-03-13T20:45:38.119Z dynamicwireless.name non 2426 ID931 [exampleSDID@32473 iut=\"3\" eventSource= \"Application\" eventID=\"1011\"] Try to override the THX port, maybe it will reboot the neural interface!'\n)",
          "return": "{\"severity\":\"notice\",\"facility\":\"user\",\"timestamp\":\"2020-03-13T20:45:38.119Z\",\"hostname\":\"dynamicwireless.name\",\"appname\":\"non\",\"procid\":2426,\"msgid\":\"ID931\",\"message\":\"Try to override the THX port, maybe it will reboot the neural interface!\",\"exampleSDID@32473\":{\"eventID\":\"1011\",\"eventSource\":\"Application\",\"iut\":\"3\"},\"version\":1}"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "parse_timestamp",
      "name": "parse_timestamp",
      "category": "Parse",
      "description": "Parses the `value` in [strptime](https://docs.rs/chrono/latest/chrono/format/strftime/index.html#specifiers) `format`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The text of the timestamp.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "format",
          "description": "The [strptime](https://docs.rs/chrono/latest/chrono/format/strftime/index.html#specifiers) format.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` fails to parse using the provided `format`"
      ],
      "return": {
        "types": [
          "timestamp"
        ]
      },
      "examples": [
        {
          "title": "Parse timestamp",
          "source": "parse_timestamp!(\"10-Oct-2020 16:00+00:00\", format: \"%v %R %:z\")",
          "return": "\"2020-10-10T16:00:00Z\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "parse_tokens",
      "name": "parse_tokens",
      "category": "Parse",
      "description": "Parses the `value` in \"token\" format. A token is considered to be one of the following:\n\n* A word surrounded by whitespace.\n* Text delimited by double quotes: `\"..\"`. Quotes can be included in the token if they are escaped by a backslash (`\\`).\n* Text delimited by square brackets: `[..]`. Closing square brackets can be included in the token if they are escaped by a backslash (`\\`).",
      "notices": [
        "All token values are returned as strings. We recommend manually coercing values to desired types as you see fit."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string to tokenize.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a properly formatted tokenized string"
      ],
      "return": {
        "types": [
          "array"
        ]
      },
      "examples": [
        {
          "title": "Parse tokens",
          "source": "parse_tokens(\n\t\"A sentence \\\"with \\\\\\\"a\\\\\\\" sentence inside\\\" and [some brackets]\"\n)",
          "return": "[\"A\",\"sentence\",\"with \\\\\\\"a\\\\\\\" sentence inside\",\"and\",\"some brackets\"]"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "parse_url",
      "name": "parse_url",
      "category": "Parse",
      "description": "Parses the `value` in [URL](https://en.wikipedia.org/wiki/URL) format.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The text of the URL.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "default_known_ports",
          "description": "If true and the port number is not specified in the input URL\nstring (or matches the default port for the scheme), it will be\npopulated from well-known ports for the following schemes:\n`http`, `https`, `ws`, `wss`, and `ftp`.",
          "required": false,
          "type": [
            "boolean"
          ],
          "default": false
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a properly formatted URL"
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse URL",
          "source": "parse_url!(\"ftp://foo:bar@vector.dev:4343/foobar?hello=world#123\")",
          "return": "{\"scheme\":\"ftp\",\"username\":\"foo\",\"password\":\"bar\",\"host\":\"vector.dev\",\"port\":4343,\"path\":\"/foobar\",\"query\":{\"hello\":\"world\"},\"fragment\":\"123\"}"
        },
        {
          "title": "Parse URL with default port",
          "source": "parse_url!(\"https://vector.dev\", default_known_ports: true)",
          "return": "{\"scheme\":\"https\",\"username\":\"\",\"password\":\"\",\"host\":\"vector.dev\",\"port\":443,\"path\":\"/\",\"query\":{},\"fragment\":null}"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "parse_user_agent",
      "name": "parse_user_agent",
      "category": "Parse",
      "description": "Parses the `value` as a user agent string. Which has [a loosely defined format](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent)\nso this parser only provides best effort guarantee.",
      "notices": [
        "All values are returned as strings or as null. We recommend manually coercing values to desired types as you see fit.",
        "Different modes return different schema.",
        "Field which were not parsed out are set as `null`."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string to parse.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "mode",
          "description": "Determines performance and reliability characteristics.",
          "required": false,
          "enum": {
            "fast": "Fastest mode but most unreliable. Uses parser from project [Woothee](https://github.com/woothee/woothee).",
            "reliable": "Provides greater reliability than `fast` and retains it's speed in common cases.\nParses with [Woothee](https://github.com/woothee/woothee) parser and with parser from [uap project](https://github.com/ua-parser/uap-core) if\nthere are some missing fields that the first parser wasn't able to parse out\nbut the second one maybe can.",
            "enriched": "Parses with both parser from [Woothee](https://github.com/woothee/woothee) and parser from [uap project](https://github.com/ua-parser/uap-core)\nand combines results. Result has the full schema."
          },
          "default": "fast",
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Fast mode",
          "source": "parse_user_agent(\n\t\"Mozilla Firefox 1.0.1 Mozilla/5.0 (X11; U; Linux i686; de-DE; rv:1.7.6) Gecko/20050223 Firefox/1.0.1\"\n)",
          "return": "{\"browser\":{\"family\":\"Firefox\",\"version\":\"1.0.1\"},\"device\":{\"category\":\"pc\"},\"os\":{\"family\":\"Linux\",\"version\":null}}"
        },
        {
          "title": "Reliable mode",
          "source": "parse_user_agent(\n\t\"Mozilla/4.0 (compatible; MSIE 7.66; Windows NT 5.1; SV1; .NET CLR 1.1.4322)\",\n\tmode: \"reliable\"\n)",
          "return": "{\"browser\":{\"family\":\"Internet Explorer\",\"version\":\"7.66\"},\"device\":{\"category\":\"pc\"},\"os\":{\"family\":\"Windows XP\",\"version\":\"NT 5.1\"}}"
        },
        {
          "title": "Enriched mode",
          "source": "parse_user_agent(\n\t\"Opera/9.80 (J2ME/MIDP; Opera Mini/4.3.24214; iPhone; CPU iPhone OS 4_2_1 like Mac OS X; AppleWebKit/24.783; U; en) Presto/2.5.25 Version/10.54\",\n\tmode: \"enriched\"\n)",
          "return": "{\"browser\":{\"family\":\"Opera Mini\",\"major\":\"4\",\"minor\":\"3\",\"patch\":\"24214\",\"version\":\"10.54\"},\"device\":{\"brand\":\"Apple\",\"category\":\"smartphone\",\"family\":\"iPhone\",\"model\":\"iPhone\"},\"os\":{\"family\":\"iOS\",\"major\":\"4\",\"minor\":\"2\",\"patch\":\"1\",\"patch_minor\":null,\"version\":\"4.2.1\"}}"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "parse_xml",
      "name": "parse_xml",
      "category": "Parse",
      "description": "Parses the `value` as XML.",
      "notices": [
        "Valid XML must contain exactly one root node. Always returns an object."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string representation of the XML document to parse.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "include_attr",
          "description": "Include XML tag attributes in the returned object.",
          "required": false,
          "default": true,
          "type": [
            "boolean"
          ]
        },
        {
          "name": "attr_prefix",
          "description": "String prefix to use for XML tag attribute keys.",
          "required": false,
          "default": "@",
          "type": [
            "string"
          ]
        },
        {
          "name": "text_key",
          "description": "Key name to use for expanded text nodes.",
          "required": false,
          "default": "text",
          "type": [
            "string"
          ]
        },
        {
          "name": "always_use_text_key",
          "description": "Always return text nodes as `{\"<text_key>\": \"value\"}.`",
          "required": false,
          "default": false,
          "type": [
            "boolean"
          ]
        },
        {
          "name": "parse_bool",
          "description": "Parse \"true\" and \"false\" as boolean.",
          "required": false,
          "default": true,
          "type": [
            "boolean"
          ]
        },
        {
          "name": "parse_null",
          "description": "Parse \"null\" as null.",
          "required": false,
          "default": true,
          "type": [
            "boolean"
          ]
        },
        {
          "name": "parse_number",
          "description": "Parse numbers as integers/floats.",
          "required": false,
          "default": true,
          "type": [
            "boolean"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a valid XML document"
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse XML",
          "source": "value = s'<book category=\"CHILDREN\"><title lang=\"en\">Harry Potter</title><author>J K. Rowling</author><year>2005</year></book>';\n\nparse_xml!(value, text_key: \"value\", parse_number: false)",
          "return": "{\"book\":{\"@category\":\"CHILDREN\",\"author\":\"J K. Rowling\",\"title\":{\"@lang\":\"en\",\"value\":\"Harry Potter\"},\"year\":\"2005\"}}"
        }
      ],
      "deprecated": false
    }
  ],
  "Random": [
    {
      "anchor": "random_bool",
      "name": "random_bool",
      "category": "Random",
      "description": "Returns a random boolean.",
      "notices": [],
      "arguments": [],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ]
      },
      "examples": [
        {
          "title": "Random boolean",
          "source": "is_boolean(random_bool())",
          "return": "true"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "random_bytes",
      "name": "random_bytes",
      "category": "Random",
      "description": "A cryptographically secure random number generator. Returns a string value containing the number of\nrandom bytes requested.",
      "notices": [],
      "arguments": [
        {
          "name": "length",
          "description": "The number of bytes to generate. Must not be larger than 64k",
          "required": true,
          "type": [
            "integer"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`length` is negative",
        "`length` is larger than the maximum value (64k)"
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Generate random base 64 encoded bytes",
          "source": "encode_base64(random_bytes(16))",
          "return": "\"LNu0BBgUbh7XAlXbjSOomQ==\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "random_float",
      "name": "random_float",
      "category": "Random",
      "description": "Returns a random float between [min, max).",
      "notices": [],
      "arguments": [
        {
          "name": "min",
          "description": "Minimum value (inclusive)",
          "required": true,
          "type": [
            "float"
          ]
        },
        {
          "name": "max",
          "description": "Maximum value (exclusive)",
          "required": true,
          "type": [
            "float"
          ]
        }
      ],
      "internal_failure_reasons": [
        "max is not greater than min"
      ],
      "return": {
        "types": [
          "float"
        ]
      },
      "examples": [
        {
          "title": "Random float from 0.0 to 10.0, not including 10.0",
          "source": "f = random_float(0.0, 10.0)\nf >= 0 && f < 10",
          "return": "true"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "random_int",
      "name": "random_int",
      "category": "Random",
      "description": "Returns a random integer between [min, max).",
      "notices": [],
      "arguments": [
        {
          "name": "min",
          "description": "Minimum value (inclusive)",
          "required": true,
          "type": [
            "integer"
          ]
        },
        {
          "name": "max",
          "description": "Maximum value (exclusive)",
          "required": true,
          "type": [
            "integer"
          ]
        }
      ],
      "internal_failure_reasons": [
        "max is not greater than min"
      ],
      "return": {
        "types": [
          "integer"
        ]
      },
      "examples": [
        {
          "title": "Random integer from 0 to 10, not including 10",
          "source": "i = random_int(0, 10)\ni >= 0 && i < 10",
          "return": "true"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "uuid_v4",
      "name": "uuid_v4",
      "category": "Random",
      "description": "Generates a random [UUIDv4](https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random)) string.",
      "notices": [],
      "arguments": [],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Create a UUIDv4",
          "source": "uuid_v4()",
          "return": "\"1d262f4f-199b-458d-879f-05fd0a5f0683\""
        }
      ],
      "deprecated": false
    }
  ],
  "Coerce": [
    {
      "anchor": "to_bool",
      "name": "to_bool",
      "category": "Coerce",
      "description": "Coerces the `value` into a boolean.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to convert to a Boolean.",
          "required": true,
          "type": [
            "boolean",
            "integer",
            "float",
            "null",
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a supported boolean representation"
      ],
      "return": {
        "types": [
          "boolean"
        ],
        "rules": [
          "If `value` is `\"true\"`, `\"t\"`, `\"yes\"`, or `\"y\"`, `true` is returned.",
          "If `value` is `\"false\"`, `\"f\"`, `\"no\"`, `\"n\"`, or `\"0\"`, `false` is returned.",
          "If `value` is `0.0`, `false` is returned, otherwise `true` is returned.",
          "If `value` is `0`, `false` is returned, otherwise `true` is returned.",
          "If `value` is `null`, `false` is returned.",
          "If `value` is a Boolean, it's returned unchanged."
        ]
      },
      "examples": [
        {
          "title": "Coerce to a Boolean (string)",
          "source": "to_bool!(\"yes\")",
          "return": "true"
        },
        {
          "title": "Coerce to a Boolean (float)",
          "source": "to_bool(0.0)",
          "return": "false"
        },
        {
          "title": "Coerce to a Boolean (int)",
          "source": "to_bool(0)",
          "return": "false"
        },
        {
          "title": "Coerce to a Boolean (null)",
          "source": "to_bool(null)",
          "return": "false"
        },
        {
          "title": "Coerce to a Boolean (Boolean)",
          "source": "to_bool(true)",
          "return": "true"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "to_float",
      "name": "to_float",
      "category": "Coerce",
      "description": "Coerces the `value` into a float.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to convert to a float. Must be convertible to a float, otherwise an error is raised.",
          "required": true,
          "type": [
            "integer",
            "float",
            "boolean",
            "string",
            "timestamp"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a supported float representation"
      ],
      "return": {
        "types": [
          "float"
        ],
        "rules": [
          "If `value` is a float, it will be returned as-is.",
          "If `value` is an integer, it will be returned as as a float.",
          "If `value` is a string, it must be the string representation of an float or else an error is raised.",
          "If `value` is a boolean, `0.0` is returned for `false` and `1.0` is returned for `true`.",
          "If `value` is a timestamp, a [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time) with fractional seconds is returned."
        ]
      },
      "examples": [
        {
          "title": "Coerce to a float",
          "source": "to_float!(\"3.145\")",
          "return": "3.145"
        },
        {
          "title": "Coerce to a float (timestamp)",
          "source": "to_float(t'2020-12-30T22:20:53.824727Z')",
          "return": "1609366853.824727"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "to_int",
      "name": "to_int",
      "category": "Coerce",
      "description": "Coerces the `value` into an integer.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to convert to an integer.",
          "required": true,
          "type": [
            "integer",
            "float",
            "boolean",
            "string",
            "timestamp"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is a string but the text is not an integer",
        "`value` is not a string, int, or timestamp"
      ],
      "return": {
        "types": [
          "integer"
        ],
        "rules": [
          "If `value` is an integer, it will be returned as-is.",
          "If `value` is a float, it will be truncated to its integer portion.",
          "If `value` is a string, it must be the string representation of an integer or else an error is raised.",
          "If `value` is a boolean, `0` is returned for `false` and `1` is returned for `true`.",
          "If `value` is a timestamp, a [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time) (in seconds) is returned."
        ]
      },
      "examples": [
        {
          "title": "Coerce to an int (string)",
          "source": "to_int!(\"2\")",
          "return": "2"
        },
        {
          "title": "Coerce to an int (timestamp)",
          "source": "to_int(t'2020-12-30T22:20:53.824727Z')",
          "return": "1609366853"
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "to_regex",
      "name": "to_regex",
      "category": "Coerce",
      "description": "Coerces the `value` into a regex.",
      "notices": [
        "Compiling a regular expression is an expensive operation and can limit Vector throughput. Don't use this function unless you are absolutely sure there is no other way!"
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The value to convert to a regex.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a string."
      ],
      "return": {
        "types": [
          "regex"
        ],
        "rules": [
          "If `value` is a string that contains a valid regex, returns the regex constructed with this string."
        ]
      },
      "examples": [
        {
          "title": "Coerce to a regex",
          "source": "to_regex(\"^foo$\") ?? r''",
          "return": "\"^foo$\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "to_string",
      "name": "to_string",
      "category": "Coerce",
      "description": "Coerces the `value` into a string.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to convert to a string.",
          "required": true,
          "type": [
            "integer",
            "float",
            "boolean",
            "string",
            "timestamp",
            "null"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not an integer, float, boolean, string, timestamp, or null"
      ],
      "return": {
        "types": [
          "string"
        ],
        "rules": [
          "If `value` is an integer or float, returns the string representation.",
          "If `value` is a boolean, returns `\"true\"` or `\"false\"`.",
          "If `value` is a timestamp, returns an [RFC 3339](\\(urls.rfc3339)) representation.",
          "If `value` is a null, returns `\"\"`."
        ]
      },
      "examples": [
        {
          "title": "Coerce to a string (Boolean)",
          "source": "to_string(true)",
          "return": "\"true\""
        },
        {
          "title": "Coerce to a string (int)",
          "source": "to_string(52)",
          "return": "\"52\""
        },
        {
          "title": "Coerce to a string (float)",
          "source": "to_string(52.2)",
          "return": "\"52.2\""
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "to_timestamp",
      "name": "to_timestamp",
      "category": "Coerce",
      "description": "This function is deprecated.\nFor integer values, use `from_unix_timestamp`, otherwise use `parse_timestamp`.\nCoerces the `value` into a timestamp.",
      "notices": [
        "There is the possibility of precision loss due to float arithmetic when coercing floats."
      ],
      "deprecated": true,
      "arguments": [
        {
          "name": "value",
          "description": "The value that is to be converted to a timestamp. If a string, must be a valid representation of a `timestamp` otherwise an `ArgumentError` will be raised.",
          "required": true,
          "type": [
            "string",
            "float",
            "integer",
            "timestamp"
          ]
        },
        {
          "name": "unit",
          "description": "The time unit.",
          "type": [
            "string"
          ],
          "required": false,
          "enum": {
            "seconds": "Express Unix time in seconds",
            "milliseconds": "Express Unix time in milliseconds",
            "nanoseconds": "Express Unix time in nanoseconds"
          },
          "default": "seconds"
        }
      ],
      "internal_failure_reasons": [
        "When `value` is a `string`, it is not a valid timestamp format",
        "When `value` is an `int`, it is not within the Unix timestamp range",
        "When `value` is a `float`, it is not within the Unix timestamp range"
      ],
      "return": {
        "types": [
          "timestamp"
        ],
        "rules": [
          "If `value` is a `string`, the timestamp is parsed in these formats.",
          "If `value` is an `integer`, it is assumed to be a Unix representation of the timestamp (the number of seconds after January 1st, 1970).",
          "If `value` is a `float`, it s assumed to be a Unix representation of the timestamp (the number of seconds after January 1st, 1970) with fractional seconds."
        ]
      },
      "examples": [
        {
          "title": "Coerce a string to a timestamp",
          "source": "to_timestamp!(\"2020-10-21T16:00:00Z\")",
          "return": "\"2020-10-21T16:00:00Z\"",
          "skip_test": true
        },
        {
          "title": "Coerce a unix timestamp (integer) to a timestamp",
          "source": "to_timestamp!(1675968923)",
          "return": "\"2023-02-09T18:55:23Z\"",
          "skip_test": true
        },
        {
          "title": "Coerce a unix timestamp (float) to a timestamp",
          "source": "to_timestamp!(1675968923.567)",
          "return": "\"2023-02-09T18:55:23.566999912Z\"",
          "skip_test": true
        },
        {
          "title": "Coerce a unix timestamp, in milliseconds, to a timestamp",
          "source": "to_timestamp!(1676478566639, unit: \"milliseconds\")",
          "return": "\"2023-02-15T16:29:26.639Z\"",
          "skip_test": true
        },
        {
          "title": "Coerce a unix timestamp, in nanoseconds, to a timestamp",
          "source": "to_timestamp!(1675968923012312311, unit: \"nanoseconds\")",
          "return": "\"2023-02-09T18:55:23.012312311Z\"",
          "skip_test": true
        }
      ]
    }
  ]
}
{
  "Number": [
    {
      "anchor": "abs",
      "name": "abs",
      "category": "Number",
      "description": "Computes the absolute value of `value`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The number to calculate the absolute value.",
          "required": true,
          "type": [
            "integer",
            "float"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "integer",
          "float"
        ],
        "rules": [
          "Returns the absolute value."
        ]
      },
      "examples": [
        {
          "title": "Computes the absolute value of the integer",
          "source": "abs(-42)",
          "return": "42"
        },
        {
          "title": "Computes the absolute value of the float",
          "source": "abs(-42.2)",
          "return": "42.2"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "ceil",
      "name": "ceil",
      "category": "Number",
      "description": "Rounds the `value` up to the specified `precision`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The number to round up.",
          "required": true,
          "type": [
            "integer",
            "float"
          ]
        },
        {
          "name": "precision",
          "description": "The number of decimal places to round to.",
          "required": false,
          "default": 0,
          "type": [
            "integer"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "integer",
          "float"
        ],
        "rules": [
          "Returns an integer if `precision` is `0` (this is the default). Returns a float otherwise."
        ]
      },
      "examples": [
        {
          "title": "Round a number up (without precision)",
          "source": "ceil(4.345)",
          "return": "5"
        },
        {
          "title": "Round a number up (with precision)",
          "source": "ceil(4.345, precision: 2)",
          "return": "4.35"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "floor",
      "name": "floor",
      "category": "Number",
      "description": "Rounds the `value` down to the specified `precision`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The number to round down.",
          "required": true,
          "type": [
            "integer",
            "float"
          ]
        },
        {
          "name": "precision",
          "description": "The number of decimal places to round to.",
          "required": false,
          "default": 0,
          "type": [
            "integer"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "integer",
          "float"
        ],
        "rules": [
          "Returns an integer if `precision` is `0` (this is the default). Returns a float otherwise."
        ]
      },
      "examples": [
        {
          "title": "Round a number down (without precision)",
          "source": "floor(4.345)",
          "return": "4"
        },
        {
          "title": "Round a number down (with precision)",
          "source": "floor(4.345, precision: 2)",
          "return": "4.34"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "format_int",
      "name": "format_int",
      "category": "Number",
      "description": "Formats the integer `value` into a string representation using the given base/radix.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The number to format.",
          "required": true,
          "type": [
            "integer"
          ]
        },
        {
          "name": "base",
          "description": "The base to format the number in. Must be between 2 and 36 (inclusive).",
          "required": false,
          "type": [
            "integer"
          ],
          "default": 10
        }
      ],
      "internal_failure_reasons": [
        "The base is not between 2 and 36."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Format as a hexadecimal integer",
          "source": "format_int!(42, 16)",
          "return": "\"2a\""
        },
        {
          "title": "Format as a negative hexadecimal integer",
          "source": "format_int!(-42, 16)",
          "return": "\"-2a\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "format_number",
      "name": "format_number",
      "category": "Number",
      "description": "Formats the `value` into a string representation of the number.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The number to format as a string.",
          "required": true,
          "type": [
            "integer",
            "float"
          ]
        },
        {
          "name": "scale",
          "description": "The number of decimal places to display.",
          "required": false,
          "type": [
            "integer"
          ]
        },
        {
          "name": "decimal_separator",
          "description": "The character to use between the whole and decimal parts of the number.",
          "required": false,
          "type": [
            "string"
          ],
          "default": "."
        },
        {
          "name": "grouping_separator",
          "description": "The character to use between each thousands part of the number.",
          "required": false,
          "type": [
            "string"
          ],
          "default": ","
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Format a number (3 decimals)",
          "source": "format_number(1234567.89, 3, decimal_separator: \".\", grouping_separator: \",\")",
          "return": "\"1,234,567.890\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "mod",
      "name": "mod",
      "category": "Number",
      "description": "Calculates the remainder of `value` divided by `modulus`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value the `modulus` is applied to.",
          "required": true,
          "type": [
            "integer",
            "float"
          ]
        },
        {
          "name": "modulus",
          "description": "The `modulus` value.",
          "required": true,
          "type": [
            "integer",
            "float"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not an integer or float.",
        "`modulus` is not an integer or float.",
        "`modulus` is equal to 0."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Calculate the remainder of two integers",
          "source": "mod(5, 2)",
          "return": "1"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "round",
      "name": "round",
      "category": "Number",
      "description": "Rounds the `value` to the specified `precision`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The number to round.",
          "required": true,
          "type": [
            "integer",
            "float"
          ]
        },
        {
          "name": "precision",
          "description": "The number of decimal places to round to.",
          "required": false,
          "default": 0,
          "type": [
            "integer"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "integer",
          "float"
        ],
        "rules": [
          "If `precision` is `0`, then an integer is returned, otherwise a float is returned."
        ]
      },
      "examples": [
        {
          "title": "Round a number (without precision)",
          "source": "round(4.345)",
          "return": "4"
        },
        {
          "title": "Round a number (with precision)",
          "source": "round(4.345, precision: 2)",
          "return": "4.35"
        }
      ],
      "deprecated": false,
      "pure": true
    }
  ],
  "Array": [
    {
      "anchor": "append",
      "name": "append",
      "category": "Array",
      "description": "Appends each item in the `items` array to the end of the `value` array.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The initial array.",
          "required": true,
          "type": [
            "array"
          ]
        },
        {
          "name": "items",
          "description": "The items to append.",
          "required": true,
          "type": [
            "array"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "array"
        ]
      },
      "examples": [
        {
          "title": "Append to an array",
          "source": "append([1, 2], [3, 4])",
          "return": "[1,2,3,4]"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "chunks",
      "name": "chunks",
      "category": "Array",
      "description": "Chunks `value` into slices of length `chunk_size` bytes.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The array of bytes to split.",
          "required": true,
          "type": [
            "array",
            "string"
          ]
        },
        {
          "name": "chunk_size",
          "description": "The desired length of each chunk in bytes. This may be constrained by the host platform architecture.",
          "required": true,
          "type": [
            "integer"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`chunk_size` must be at least 1 byte.",
        "`chunk_size` is too large."
      ],
      "return": {
        "types": [
          "array"
        ],
        "rules": [
          "`chunks` is considered fallible if the supplied `chunk_size` is an expression, and infallible if it's a literal integer."
        ]
      },
      "examples": [
        {
          "title": "Split a string into chunks",
          "source": "chunks(\"abcdefgh\", 4)",
          "return": "[\"abcd\",\"efgh\"]"
        },
        {
          "title": "Chunks do not respect unicode code point boundaries",
          "source": "chunks(\"ab你好\", 4)",
          "return": "[\"ab�\",\"�好\"]"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "push",
      "name": "push",
      "category": "Array",
      "description": "Adds the `item` to the end of the `value` array.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The target array.",
          "required": true,
          "type": [
            "array"
          ]
        },
        {
          "name": "item",
          "description": "The item to push.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "array"
        ],
        "rules": [
          "Returns a new array. The `value` is _not_ modified in place."
        ]
      },
      "examples": [
        {
          "title": "Push an item onto an array",
          "source": "push([1, 2], 3)",
          "return": "[1,2,3]"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "zip",
      "name": "zip",
      "category": "Array",
      "description": "Iterate over several arrays in parallel, producing a new array containing arrays of items from each source.\nThe resulting array will be as long as the shortest input array, with all the remaining elements dropped.\nThis function is modeled from the `zip` function [in Python](https://docs.python.org/3/library/functions.html#zip),\nbut similar methods can be found in [Ruby](https://docs.ruby-lang.org/en/master/Array.html#method-i-zip)\nand [Rust](https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.zip).\n\nIf a single parameter is given, it must contain an array of all the input arrays.",
      "notices": [],
      "arguments": [
        {
          "name": "array_0",
          "description": "The first array of elements, or the array of input arrays if no other parameter is present.",
          "required": true,
          "type": [
            "array"
          ]
        },
        {
          "name": "array_1",
          "description": "The second array of elements. If not present, the first parameter contains all the arrays.",
          "required": false,
          "type": [
            "array"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`array_0` and `array_1` must be arrays."
      ],
      "return": {
        "types": [
          "array"
        ],
        "rules": [
          "`zip` is considered fallible if any of the parameters is not an array, or if only the first parameter is present and it is not an array of arrays."
        ]
      },
      "examples": [
        {
          "title": "Merge two arrays",
          "source": "zip([1, 2, 3], [4, 5, 6, 7])",
          "return": "[[1,4],[2,5],[3,6]]"
        },
        {
          "title": "Merge three arrays",
          "source": "zip([[1, 2], [3, 4], [5, 6]])",
          "return": "[[1,3,5],[2,4,6]]"
        }
      ],
      "deprecated": false,
      "pure": true
    }
  ],
  "Type": [
    {
      "anchor": "array",
      "name": "array",
      "category": "Type",
      "description": "Returns `value` if it is an array, otherwise returns an error. This enables the type checker to guarantee that the\nreturned value is an array and can be used in any function that expects an array.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to check if it is an array.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not an array."
      ],
      "return": {
        "types": [
          "array"
        ],
        "rules": [
          "Returns the `value` if it's an array.",
          "Raises an error if not an array."
        ]
      },
      "examples": [
        {
          "title": "Declare an array type",
          "input": {
            "log": {
              "value": [
                1,
                2,
                3
              ]
            }
          },
          "source": "array!(.value)",
          "return": "[1,2,3]"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "bool",
      "name": "bool",
      "category": "Type",
      "description": "Returns `value` if it is a Boolean, otherwise returns an error. This enables the type checker to guarantee that the\nreturned value is a Boolean and can be used in any function that expects a Boolean.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to check if it is a Boolean.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a Boolean."
      ],
      "return": {
        "types": [
          "boolean"
        ],
        "rules": [
          "Returns `value` if it's a Boolean.",
          "Raises an error if not a Boolean."
        ]
      },
      "examples": [
        {
          "title": "Declare a Boolean type",
          "input": {
            "log": {
              "value": false
            }
          },
          "source": "bool!(.value)",
          "return": "false"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "float",
      "name": "float",
      "category": "Type",
      "description": "Returns `value` if it is a float, otherwise returns an error. This enables the type checker to guarantee that the\nreturned value is a float and can be used in any function that expects a float.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to check if it is a float.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a float."
      ],
      "return": {
        "types": [
          "float"
        ],
        "rules": [
          "Returns the `value` if it's a float.",
          "Raises an error if not a float."
        ]
      },
      "examples": [
        {
          "title": "Declare a float type",
          "input": {
            "log": {
              "value": 42
            }
          },
          "source": "float!(.value)",
          "return": "42"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "int",
      "name": "int",
      "category": "Type",
      "description": "Returns `value` if it is an integer, otherwise returns an error. This enables the type checker to guarantee that the\nreturned value is an integer and can be used in any function that expects an integer.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to check if it is an integer.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not an integer."
      ],
      "return": {
        "types": [
          "integer"
        ],
        "rules": [
          "Returns the `value` if it's an integer.",
          "Raises an error if not an integer."
        ]
      },
      "examples": [
        {
          "title": "Declare an integer type",
          "input": {
            "log": {
              "value": 42
            }
          },
          "source": "int!(.value)",
          "return": "42"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "is_array",
      "name": "is_array",
      "category": "Type",
      "description": "Check if the `value`'s type is an array.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to check if it is an array.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ],
        "rules": [
          "Returns `true` if `value` is an array.",
          "Returns `false` if `value` is anything else."
        ]
      },
      "examples": [
        {
          "title": "Valid array",
          "source": "is_array([1, 2, 3])",
          "return": "true"
        },
        {
          "title": "Non-matching type",
          "source": "is_array(\"a string\")",
          "return": "false"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "is_boolean",
      "name": "is_boolean",
      "category": "Type",
      "description": "Check if the `value`'s type is a boolean.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to check if it is a Boolean.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ],
        "rules": [
          "Returns `true` if `value` is a boolean.",
          "Returns `false` if `value` is anything else."
        ]
      },
      "examples": [
        {
          "title": "Valid boolean",
          "source": "is_boolean(false)",
          "return": "true"
        },
        {
          "title": "Non-matching type",
          "source": "is_boolean(\"a string\")",
          "return": "false"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "is_empty",
      "name": "is_empty",
      "category": "Type",
      "description": "Check if the object, array, or string has a length of `0`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to check.",
          "required": true,
          "type": [
            "object",
            "array",
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ],
        "rules": [
          "Returns `true` if `value` is empty.",
          "Returns `false` if `value` is non-empty."
        ]
      },
      "examples": [
        {
          "title": "Empty array",
          "source": "is_empty([])",
          "return": "true"
        },
        {
          "title": "Non-empty string",
          "source": "is_empty(\"a string\")",
          "return": "false"
        },
        {
          "title": "Non-empty object",
          "source": "is_empty({\"foo\": \"bar\"})",
          "return": "false"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "is_float",
      "name": "is_float",
      "category": "Type",
      "description": "Check if the `value`'s type is a float.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to check if it is a float.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ],
        "rules": [
          "Returns `true` if `value` is a float.",
          "Returns `false` if `value` is anything else."
        ]
      },
      "examples": [
        {
          "title": "Valid float",
          "source": "is_float(0.577)",
          "return": "true"
        },
        {
          "title": "Non-matching type",
          "source": "is_float(\"a string\")",
          "return": "false"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "is_integer",
      "name": "is_integer",
      "category": "Type",
      "description": "Check if the value`'s type is an integer.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to check if it is an integer.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ],
        "rules": [
          "Returns `true` if `value` is an integer.",
          "Returns `false` if `value` is anything else."
        ]
      },
      "examples": [
        {
          "title": "Valid integer",
          "source": "is_integer(1)",
          "return": "true"
        },
        {
          "title": "Non-matching type",
          "source": "is_integer(\"a string\")",
          "return": "false"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "is_json",
      "name": "is_json",
      "category": "Type",
      "description": "Check if the string is a valid JSON document.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to check if it is a valid JSON document.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "variant",
          "description": "The variant of the JSON type to explicitly check for.",
          "enum": {
            "object": "JSON object - {}",
            "array": "JSON array - []",
            "string": "JSON-formatted string values wrapped with quote marks",
            "number": "Integer or float numbers",
            "bool": "True or false",
            "null": "Exact null value"
          },
          "required": false,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ],
        "rules": [
          "Returns `true` if `value` is a valid JSON document.",
          "Returns `false` if `value` is not JSON-formatted."
        ]
      },
      "examples": [
        {
          "title": "Valid JSON object",
          "source": "is_json(\"{}\")",
          "return": "true"
        },
        {
          "title": "Non-valid value",
          "source": "is_json(\"{\")",
          "return": "false"
        },
        {
          "title": "Exact variant",
          "source": "is_json(\"{}\", variant: \"object\")",
          "return": "true"
        },
        {
          "title": "Non-valid exact variant",
          "source": "is_json(\"{}\", variant: \"array\")",
          "return": "false"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "is_null",
      "name": "is_null",
      "category": "Type",
      "description": "Check if `value`'s type is `null`. For a more relaxed function,\nsee [`is_nullish`](/docs/reference/vrl/functions#is_nullish).",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to check if it is `null`.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ],
        "rules": [
          "Returns `true` if `value` is null.",
          "Returns `false` if `value` is anything else."
        ]
      },
      "examples": [
        {
          "title": "Null value",
          "source": "is_null(null)",
          "return": "true"
        },
        {
          "title": "Non-matching type",
          "source": "is_null(\"a string\")",
          "return": "false"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "is_nullish",
      "name": "is_nullish",
      "category": "Type",
      "description": "Determines whether `value` is nullish. Returns `true` if the specified `value` is `null`,\nan empty string, a string containing only whitespace, or the string `\"-\"`. Returns `false` otherwise.",
      "notices": [
        "This function behaves inconsistently: it returns `false` for empty arrays (`[]`) and objects (`{}`),\nbut `true` for empty strings (`\"\"`) and `null`."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The value to check for nullishness, for example, a useless value.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ],
        "rules": [
          "Returns `true` if `value` is `null`.",
          "Returns `true` if `value` is `\"-\"`.",
          "Returns `true` if `value` is whitespace as defined by [Unicode `White_Space` property](https://en.wikipedia.org/wiki/Unicode_character_property#Whitespace).",
          "Returns `false` if `value` is anything else."
        ]
      },
      "examples": [
        {
          "title": "Null detection (blank string)",
          "source": "is_nullish(\"\")",
          "return": "true"
        },
        {
          "title": "Null detection (dash string)",
          "source": "is_nullish(\"-\")",
          "return": "true"
        },
        {
          "title": "Null detection (whitespace)",
          "source": "is_nullish(\"\n  \n\")",
          "return": "true"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "is_object",
      "name": "is_object",
      "category": "Type",
      "description": "Check if `value`'s type is an object.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to check if it is an object.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ],
        "rules": [
          "Returns `true` if `value` is an object.",
          "Returns `false` if `value` is anything else."
        ]
      },
      "examples": [
        {
          "title": "Valid object",
          "source": "is_object({\"foo\": \"bar\"})",
          "return": "true"
        },
        {
          "title": "Non-matching type",
          "source": "is_object(\"a string\")",
          "return": "false"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "is_regex",
      "name": "is_regex",
      "category": "Type",
      "description": "Check if `value`'s type is a regex.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to check if it is a regex.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ],
        "rules": [
          "Returns `true` if `value` is a regex.",
          "Returns `false` if `value` is anything else."
        ]
      },
      "examples": [
        {
          "title": "Valid regex",
          "source": "is_regex(r'pattern')",
          "return": "true"
        },
        {
          "title": "Non-matching type",
          "source": "is_regex(\"a string\")",
          "return": "false"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "is_string",
      "name": "is_string",
      "category": "Type",
      "description": "Check if `value`'s type is a string.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to check if it is a string.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ],
        "rules": [
          "Returns `true` if `value` is a string.",
          "Returns `false` if `value` is anything else."
        ]
      },
      "examples": [
        {
          "title": "Valid string",
          "source": "is_string(\"a string\")",
          "return": "true"
        },
        {
          "title": "Non-matching type",
          "source": "is_string([1, 2, 3])",
          "return": "false"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "is_timestamp",
      "name": "is_timestamp",
      "category": "Type",
      "description": "Check if `value`'s type is a timestamp.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to check if it is a timestamp.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ],
        "rules": [
          "Returns `true` if `value` is a timestamp.",
          "Returns `false` if `value` is anything else."
        ]
      },
      "examples": [
        {
          "title": "Valid timestamp",
          "source": "is_timestamp(t'2021-03-26T16:00:00Z')",
          "return": "true"
        },
        {
          "title": "Non-matching type",
          "source": "is_timestamp(\"a string\")",
          "return": "false"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "object",
      "name": "object",
      "category": "Type",
      "description": "Returns `value` if it is an object, otherwise returns an error. This enables the type checker to guarantee that the\nreturned value is an object and can be used in any function that expects an object.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to check if it is an object.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not an object."
      ],
      "return": {
        "types": [
          "object"
        ],
        "rules": [
          "Returns the `value` if it's an object.",
          "Raises an error if not an object."
        ]
      },
      "examples": [
        {
          "title": "Declare an object type",
          "input": {
            "log": {
              "value": {
                "field1": "value1",
                "field2": "value2"
              }
            }
          },
          "source": "object!(.value)",
          "return": "{\"field1\":\"value1\",\"field2\":\"value2\"}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "string",
      "name": "string",
      "category": "Type",
      "description": "Returns `value` if it is a string, otherwise returns an error. This enables the type checker to guarantee that the\nreturned value is a string and can be used in any function that expects a string.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to check if it is a string.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a string."
      ],
      "return": {
        "types": [
          "string"
        ],
        "rules": [
          "Returns the `value` if it's a string.",
          "Raises an error if not a string."
        ]
      },
      "examples": [
        {
          "title": "Declare a string type",
          "input": {
            "log": {
              "message": "{\"field\": \"value\"}"
            }
          },
          "source": "string!(.message)",
          "return": "\"{\\\"field\\\": \\\"value\\\"}\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "tag_types_externally",
      "name": "tag_types_externally",
      "category": "Type",
      "description": "Adds type information to all (nested) scalar values in the provided `value`.\n\nThe type information is added externally, meaning that `value` has the form of `\"type\": value` after this\ntransformation.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to tag with types.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "object",
          "array",
          "null"
        ]
      },
      "examples": [
        {
          "title": "Tag types externally (scalar)",
          "source": "tag_types_externally(123)",
          "return": "{\"integer\":123}"
        },
        {
          "title": "Tag types externally (object)",
          "source": "tag_types_externally({\n\t\"message\": \"Hello world\",\n\t\"request\": {\n\t\t\"duration_ms\": 67.9\n\t}\n})",
          "return": "{\"message\":{\"string\":\"Hello world\"},\"request\":{\"duration_ms\":{\"float\":67.9}}}"
        },
        {
          "title": "Tag types externally (array)",
          "source": "tag_types_externally([\"foo\", \"bar\"])",
          "return": "[{\"string\":\"foo\"},{\"string\":\"bar\"}]"
        },
        {
          "title": "Tag types externally (null)",
          "source": "tag_types_externally(null)",
          "return": "null"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "timestamp",
      "name": "timestamp",
      "category": "Type",
      "description": "Returns `value` if it is a timestamp, otherwise returns an error. This enables the type checker to guarantee that\nthe returned value is a timestamp and can be used in any function that expects a timestamp.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to check if it is a timestamp.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a timestamp."
      ],
      "return": {
        "types": [
          "timestamp"
        ],
        "rules": [
          "Returns the `value` if it's a timestamp.",
          "Raises an error if not a timestamp."
        ]
      },
      "examples": [
        {
          "title": "Declare a timestamp type",
          "input": {
            "log": {
              "timestamp": "2020-10-10T16:00:00Z"
            }
          },
          "source": "timestamp(t'2020-10-10T16:00:00Z')",
          "return": "\"2020-10-10T16:00:00Z\""
        }
      ],
      "deprecated": false,
      "pure": true
    }
  ],
  "Debug": [
    {
      "anchor": "assert",
      "name": "assert",
      "category": "Debug",
      "description": "Asserts the `condition`, which must be a Boolean expression. The program is aborted with\n`message` if the condition evaluates to `false`.",
      "notices": [
        "The `assert` function should be used in a standalone fashion and only when you want to abort the program. You\nshould avoid it in logical expressions and other situations in which you want the program to continue if the\ncondition evaluates to `false`."
      ],
      "pure": false,
      "arguments": [
        {
          "name": "condition",
          "description": "The condition to check.",
          "required": true,
          "type": [
            "boolean"
          ]
        },
        {
          "name": "message",
          "description": "An optional custom error message. If the equality assertion fails, `message` is\nappended to the default message prefix. See the [examples](#assert-examples) below\nfor a fully formed log message sample.",
          "required": false,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`condition` evaluates to `false`."
      ],
      "return": {
        "types": [
          "null"
        ]
      },
      "examples": [
        {
          "title": "Assertion (true)",
          "source": "assert!(\"foo\" == \"foo\", message: \"\\\"foo\\\" must be \\\"foo\\\"!\")",
          "return": "true"
        },
        {
          "title": "Assertion (false)",
          "source": "assert!(\"foo\" == \"bar\", message: \"\\\"foo\\\" must be \\\"foo\\\"!\")",
          "raises": {
            "runtime": "function call error for \"assert\" at (0:60): \"foo\" must be \"foo\"!"
          }
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "assert_eq",
      "name": "assert_eq",
      "category": "Debug",
      "description": "Asserts that two expressions, `left` and `right`, have the same value. The program is\naborted with `message` if they do not have the same value.",
      "notices": [
        "The `assert_eq` function should be used in a standalone fashion and only when you want to\nabort the program. You should avoid it in logical expressions and other situations in which\nyou want the program to continue if the condition evaluates to `false`."
      ],
      "pure": false,
      "arguments": [
        {
          "name": "left",
          "description": "The value to check for equality against `right`.",
          "required": true,
          "type": [
            "any"
          ]
        },
        {
          "name": "right",
          "description": "The value to check for equality against `left`.",
          "required": true,
          "type": [
            "any"
          ]
        },
        {
          "name": "message",
          "description": "An optional custom error message. If the equality assertion fails, `message` is\nappended to the default message prefix. See the [examples](#assert_eq-examples)\nbelow for a fully formed log message sample.",
          "required": false,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ]
      },
      "examples": [
        {
          "title": "Successful assertion",
          "source": "assert_eq!(1, 1)",
          "return": "true"
        },
        {
          "title": "Unsuccessful assertion",
          "source": "assert_eq!(127, [1, 2, 3])",
          "raises": {
            "runtime": "function call error for \"assert_eq\" at (0:26): assertion failed: 127 == [1, 2, 3]"
          }
        },
        {
          "title": "Unsuccessful assertion with custom log message",
          "source": " assert_eq!(1, 0, message: \"Unequal integers\")",
          "raises": {
            "runtime": "function call error for \"assert_eq\" at (1:46): Unequal integers"
          }
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "log",
      "name": "log",
      "category": "Debug",
      "description": "Logs the `value` to [stdout](https://en.wikipedia.org/wiki/Standard_streams#Standard_output_(stdout)) at the specified `level`.",
      "notices": [],
      "pure": false,
      "arguments": [
        {
          "name": "value",
          "description": "The value to log.",
          "required": true,
          "type": [
            "any"
          ]
        },
        {
          "name": "level",
          "description": "The log level.",
          "required": false,
          "type": [
            "string"
          ],
          "enum": {
            "trace": "Log at the `trace` level.",
            "debug": "Log at the `debug` level.",
            "info": "Log at the `info` level.",
            "warn": "Log at the `warn` level.",
            "error": "Log at the `error` level."
          },
          "default": "info"
        },
        {
          "name": "rate_limit_secs",
          "description": "Specifies that the log message is output no more than once per the given number of seconds.\nUse a value of `0` to turn rate limiting off.",
          "type": [
            "integer"
          ],
          "required": false,
          "default": 1
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "null"
        ]
      },
      "examples": [
        {
          "title": "Log a message",
          "source": "log(\"Hello, World!\", level: \"info\", rate_limit_secs: 60)",
          "return": "null"
        },
        {
          "title": "Log an error",
          "input": {
            "log": {
              "field": "not an integer"
            }
          },
          "source": "_, err = to_int(.field)\nif err != null {\n\tlog(err, level: \"error\")\n}",
          "return": "null"
        }
      ],
      "deprecated": false
    }
  ],
  "String": [
    {
      "anchor": "camelcase",
      "name": "camelcase",
      "category": "String",
      "description": "Takes the `value` string, and turns it into camelCase. Optionally, you can\npass in the existing case of the function, or else an attempt is made to determine the case automatically.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to convert to camelCase.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "original_case",
          "description": "Optional hint on the original case type. Must be one of: kebab-case, camelCase, PascalCase, SCREAMING_SNAKE, snake_case",
          "required": false,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "camelCase a string",
          "source": "camelcase(\"input-string\")",
          "return": "\"inputString\""
        },
        {
          "title": "camelCase a string",
          "source": "camelcase(\"input-string\", \"kebab-case\")",
          "return": "\"inputString\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "community_id",
      "name": "community_id",
      "category": "String",
      "description": "Generates an ID based on the [Community ID Spec](https://github.com/corelight/community-id-spec).",
      "notices": [],
      "arguments": [
        {
          "name": "source_ip",
          "description": "The source IP address.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "destination_ip",
          "description": "The destination IP address.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "protocol",
          "description": "The protocol number.",
          "required": true,
          "type": [
            "integer"
          ]
        },
        {
          "name": "source_port",
          "description": "The source port or ICMP type.",
          "required": false,
          "type": [
            "integer"
          ]
        },
        {
          "name": "destination_port",
          "description": "The destination port or ICMP code.",
          "required": false,
          "type": [
            "integer"
          ]
        },
        {
          "name": "seed",
          "description": "The custom seed number.",
          "required": false,
          "type": [
            "integer"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "TCP",
          "source": "community_id!(source_ip: \"1.2.3.4\", destination_ip: \"5.6.7.8\", source_port: 1122, destination_port: 3344, protocol: 6)",
          "return": "\"1:wCb3OG7yAFWelaUydu0D+125CLM=\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "contains",
      "name": "contains",
      "category": "String",
      "description": "Determines whether the `value` string contains the specified `substring`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The text to search.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "substring",
          "description": "The substring to search for in `value`.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "case_sensitive",
          "description": "Whether the match should be case sensitive.",
          "required": false,
          "type": [
            "boolean"
          ],
          "default": true
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ]
      },
      "examples": [
        {
          "title": "String contains (case sensitive)",
          "source": "contains(\"The Needle In The Haystack\", \"Needle\")",
          "return": "true"
        },
        {
          "title": "String contains (case insensitive)",
          "source": "contains(\"The Needle In The Haystack\", \"needle\", case_sensitive: false)",
          "return": "true"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "contains_all",
      "name": "contains_all",
      "category": "String",
      "description": "Determines whether the `value` string contains all the specified `substrings`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The text to search.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "substrings",
          "description": "An array of substrings to search for in `value`.",
          "required": true,
          "type": [
            "array"
          ]
        },
        {
          "name": "case_sensitive",
          "description": "Whether the match should be case sensitive.",
          "required": false,
          "type": [
            "boolean"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ]
      },
      "examples": [
        {
          "title": "String contains all",
          "source": "contains_all(\"The Needle In The Haystack\", [\"Needle\", \"Haystack\"])",
          "return": "true"
        },
        {
          "title": "String contains all (case sensitive)",
          "source": "contains_all(\"the NEEDLE in the haystack\", [\"needle\", \"haystack\"])",
          "return": "false"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "downcase",
      "name": "downcase",
      "category": "String",
      "description": "Downcases the `value` string, where downcase is defined according to the\nUnicode Derived Core Property Lowercase.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to convert to lowercase.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Downcase a string",
          "source": "downcase(\"Hello, World!\")",
          "return": "\"hello, world!\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "ends_with",
      "name": "ends_with",
      "category": "String",
      "description": "Determines whether the `value` string ends with the specified `substring`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to search.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "substring",
          "description": "The substring with which `value` must end.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "case_sensitive",
          "description": "Whether the match should be case sensitive.",
          "required": false,
          "type": [
            "boolean"
          ],
          "default": true
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ]
      },
      "examples": [
        {
          "title": "String ends with (case sensitive)",
          "source": "ends_with(\"The Needle In The Haystack\", \"The Haystack\")",
          "return": "true"
        },
        {
          "title": "String ends with (case insensitive)",
          "source": "ends_with(\"The Needle In The Haystack\", \"the haystack\", case_sensitive: false)",
          "return": "true"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "find",
      "name": "find",
      "category": "String",
      "description": "Determines from left to right the start position of the first found element in `value`\nthat matches `pattern`. Returns `-1` if not found.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to find the pattern in.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "pattern",
          "description": "The regular expression or string pattern to match against.",
          "required": true,
          "type": [
            "regex",
            "string"
          ]
        },
        {
          "name": "from",
          "description": "Offset to start searching.",
          "required": false,
          "default": 0,
          "type": [
            "integer"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "integer"
        ]
      },
      "examples": [
        {
          "title": "Match text",
          "source": "find(\"foobar\", \"foo\")",
          "return": "0"
        },
        {
          "title": "Match regex",
          "source": "find(\"foobar\", r'b.r')",
          "return": "3"
        },
        {
          "title": "No matches",
          "source": "find(\"foobar\", \"baz\")",
          "return": "-1"
        },
        {
          "title": "With an offset",
          "source": "find(\"foobarfoobarfoo\", \"bar\", 4)",
          "return": "9"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "join",
      "name": "join",
      "category": "String",
      "description": "Joins each string in the `value` array into a single string, with items optionally separated from one another\nby a `separator`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The array of strings to join together.",
          "required": true,
          "type": [
            "array"
          ]
        },
        {
          "name": "separator",
          "description": "The string separating each original element when joined.",
          "required": false,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Join array (no separator)",
          "source": "join!([\"bring\", \"us\", \"together\"])",
          "return": "\"bringustogether\""
        },
        {
          "title": "Join array (comma separator)",
          "source": "join!([\"sources\", \"transforms\", \"sinks\"], separator: \", \")",
          "return": "\"sources, transforms, sinks\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "kebabcase",
      "name": "kebabcase",
      "category": "String",
      "description": "Takes the `value` string, and turns it into kebab-case. Optionally, you can\npass in the existing case of the function, or else we will try to figure out the case automatically.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to convert to kebab-case.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "original_case",
          "description": "Optional hint on the original case type. Must be one of: kebab-case, camelCase, PascalCase, SCREAMING_SNAKE, snake_case",
          "required": false,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "kebab-case a string",
          "source": "kebabcase(\"InputString\")",
          "return": "\"input-string\""
        },
        {
          "title": "kebab-case a string",
          "source": "kebabcase(\"InputString\", \"PascalCase\")",
          "return": "\"input-string\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "match",
      "name": "match",
      "category": "String",
      "description": "Determines whether the `value` matches the `pattern`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to match.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "pattern",
          "description": "The regular expression pattern to match against.",
          "required": true,
          "type": [
            "regex"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ]
      },
      "examples": [
        {
          "title": "Regex match on a string",
          "source": "match(\"I'm a little teapot\", r'teapot')",
          "return": "true"
        },
        {
          "title": "String does not match the regular expression",
          "source": "match(\"I'm a little teapot\", r'.*balloon')",
          "return": "false"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "match_any",
      "name": "match_any",
      "category": "String",
      "description": "Determines whether `value` matches any of the given `patterns`. All\npatterns are checked in a single pass over the target string, giving this\nfunction a potential performance advantage over the multiple calls\nin the `match` function.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to match.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "patterns",
          "description": "The array of regular expression patterns to match against.",
          "required": true,
          "type": [
            "array"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ]
      },
      "examples": [
        {
          "title": "Regex match on a string",
          "source": "match_any(\"I'm a little teapot\", [r'frying pan', r'teapot'])",
          "return": "true"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_float",
      "name": "parse_float",
      "category": "String",
      "description": "Parses the string `value` representing a floating point number in base 10 to a float.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to parse.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a string."
      ],
      "return": {
        "types": [
          "float"
        ]
      },
      "examples": [
        {
          "title": "Parse negative integer",
          "source": "parse_float!(\"-42\")",
          "return": "-42"
        },
        {
          "title": "Parse negative integer",
          "source": "parse_float!(\"42.38\")",
          "return": "42.38"
        },
        {
          "title": "Scientific notation",
          "source": "parse_float!(\"2.5e3\")",
          "return": "2500"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "pascalcase",
      "name": "pascalcase",
      "category": "String",
      "description": "Takes the `value` string, and turns it into PascalCase. Optionally, you can\npass in the existing case of the function, or else we will try to figure out the case automatically.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to convert to PascalCase.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "original_case",
          "description": "Optional hint on the original case type. Must be one of: kebab-case, camelCase, PascalCase, SCREAMING_SNAKE, snake_case",
          "required": false,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "PascalCase a string",
          "source": "pascalcase(\"input-string\")",
          "return": "\"InputString\""
        },
        {
          "title": "PascalCase a string",
          "source": "pascalcase(\"input-string\", \"kebab-case\")",
          "return": "\"InputString\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "redact",
      "name": "redact",
      "category": "String",
      "description": "Redact sensitive data in `value` such as:\n\n- [US social security card numbers](https://www.ssa.gov/history/ssn/geocard.html)\n- Other forms of personally identifiable information with custom patterns\n\nThis can help achieve compliance by ensuring sensitive data does not leave your network.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to redact sensitive data from.\n\nThe function's behavior depends on `value`'s type:\n\n- For strings, the sensitive data is redacted and a new string is returned.\n- For arrays, the sensitive data is redacted in each string element.\n- For objects, the sensitive data in each string value is masked, but the keys are not masked.\n\nFor arrays and objects, the function recurses into any nested arrays or objects. Any non-string elements are\nskipped.\n\nRedacted text is replaced with `[REDACTED]`.",
          "required": true,
          "type": [
            "string",
            "object",
            "array"
          ]
        },
        {
          "name": "filters",
          "description": "List of filters applied to `value`.\n\nEach filter can be specified in the following ways:\n\n- As a regular expression, which is used to redact text that match it.\n- As an object with a `type` key that corresponds to a named filter and additional keys for customizing that filter.\n- As a named filter, if it has no required parameters.\n\nNamed filters can be a:\n\n- `pattern`: Redacts text matching any regular expressions specified in the `patterns`\n\tkey, which is required. This is the expanded version of just passing a regular expression as a filter.\n- `us_social_security_number`: Redacts US social security card numbers.\n\nSee examples for more details.\n\nThis parameter must be a static expression so that the argument can be validated at compile-time\nto avoid runtime errors. You cannot use variables or other dynamic expressions with it.",
          "required": true,
          "type": [
            "array"
          ]
        },
        {
          "name": "redactor",
          "description": "Specifies what to replace the redacted strings with.\n\nIt is given as an object with a \"type\" key specifying the type of redactor to use\nand additional keys depending on the type. The following types are supported:\n\n- `full`: The default. Replace with the string \"[REDACTED]\".\n- `text`: Replace with a custom string. The `replacement` key is required, and must\n  contain the string that is used as a replacement.\n- `sha2`: Hash the redacted text with SHA-2 as with [`sha2`](https://en.wikipedia.org/wiki/SHA-2). Supports two optional parameters:\n\t- `variant`: The variant of the algorithm to use. Defaults to SHA-512/256.\n\t- `encoding`: How to encode the hash as text. Can be base16 or base64.\n\t\tDefaults to base64.\n- `sha3`: Hash the redacted text with SHA-3 as with [`sha3`](https://en.wikipedia.org/wiki/SHA-3). Supports two optional parameters:\n\t- `variant`: The variant of the algorithm to use. Defaults to SHA3-512.\n\t- `encoding`: How to encode the hash as text. Can be base16 or base64.\n\t\tDefaults to base64.\n\n\nAs a convenience you can use a string as a shorthand for common redactor patterns:\n\n- `\"full\"` is equivalent to `{\"type\": \"full\"}`\n- `\"sha2\"` is equivalent to `{\"type\": \"sha2\", \"variant\": \"SHA-512/256\", \"encoding\": \"base64\"}`\n- `\"sha3\"` is equivalent to `{\"type\": \"sha3\", \"variant\": \"SHA3-512\", \"encoding\": \"base64\"}`\n\nThis parameter must be a static expression so that the argument can be validated at compile-time\nto avoid runtime errors. You cannot use variables or other dynamic expressions with it.",
          "required": false,
          "type": [
            "string",
            "object"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string",
          "object",
          "array"
        ]
      },
      "examples": [
        {
          "title": "Replace text using a regex",
          "source": "redact(\"my id is 123456\", filters: [r'\\d+'])",
          "return": "\"my id is [REDACTED]\""
        },
        {
          "title": "Replace us social security numbers in any field",
          "source": "redact({ \"name\": \"John Doe\", \"ssn\": \"123-12-1234\"}, filters: [\"us_social_security_number\"])",
          "return": "{\"name\":\"John Doe\",\"ssn\":\"[REDACTED]\"}"
        },
        {
          "title": "Replace with custom text",
          "source": "redact(\"my id is 123456\", filters: [r'\\d+'], redactor: {\"type\": \"text\", \"replacement\": \"***\"})",
          "return": "\"my id is ***\""
        },
        {
          "title": "Replace with SHA-2 hash",
          "source": "redact(\"my id is 123456\", filters: [r'\\d+'], redactor: \"sha2\")",
          "return": "\"my id is GEtTedW1p6tC094dDKH+3B8P+xSnZz69AmpjaXRd63I=\""
        },
        {
          "title": "Replace with SHA-3 hash",
          "source": "redact(\"my id is 123456\", filters: [r'\\d+'], redactor: \"sha3\")",
          "return": "\"my id is ZNCdmTDI7PeeUTFnpYjLdUObdizo+bIupZdl8yqnTKGdLx6X3JIqPUlUWUoFBikX+yTR+OcvLtAqWO11NPlNJw==\""
        },
        {
          "title": "Replace with SHA-256 hash using hex encoding",
          "source": "redact(\"my id is 123456\", filters: [r'\\d+'], redactor: {\"type\": \"sha2\", \"variant\": \"SHA-256\", \"encoding\": \"base16\"})",
          "return": "\"my id is 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "replace",
      "name": "replace",
      "category": "String",
      "description": "Replaces all matching instances of `pattern` in `value`.\n\nThe `pattern` argument accepts regular expression capture groups.\n\n**Note when using capture groups**:\n- You will need to escape the `$` by using `$$` to avoid Vector interpreting it as an\n  [environment variable when loading configuration](/docs/reference/configuration/#escaping)\n- If you want a literal `$` in the replacement pattern, you will also need to escape this\n  with `$$`. When combined with environment variable interpolation in config files this\n  means you will need to use `$$$$` to have a literal `$` in the replacement pattern.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The original string.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "pattern",
          "description": "Replace all matches of this pattern. Can be a static string or a regular expression.",
          "required": true,
          "type": [
            "regex",
            "string"
          ]
        },
        {
          "name": "with",
          "description": "The string that the matches are replaced with.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "count",
          "description": "The maximum number of replacements to perform. `-1` means replace all matches.",
          "required": false,
          "default": -1,
          "type": [
            "integer"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Replace literal text",
          "source": "replace(\"Apples and Bananas\", \"and\", \"not\")",
          "return": "\"Apples not Bananas\""
        },
        {
          "title": "Replace using regular expression",
          "source": "replace(\"Apples and Bananas\", r'(?i)bananas', \"Pineapples\")",
          "return": "\"Apples and Pineapples\""
        },
        {
          "title": "Replace first instance",
          "source": "replace(\"Bananas and Bananas\", \"Bananas\", \"Pineapples\", count: 1)",
          "return": "\"Pineapples and Bananas\""
        },
        {
          "title": "Replace with capture groups (Note: Use `$$num` in config files)",
          "source": "replace(\"foo123bar\", r'foo(?P<num>\\d+)bar', \"$num\")",
          "return": "\"123\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "screamingsnakecase",
      "name": "screamingsnakecase",
      "category": "String",
      "description": "Takes the `value` string, and turns it into SCREAMING_SNAKE case. Optionally, you can\npass in the existing case of the function, or else we will try to figure out the case automatically.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to convert to SCREAMING_SNAKE case.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "original_case",
          "description": "Optional hint on the original case type. Must be one of: kebab-case, camelCase, PascalCase, SCREAMING_SNAKE, snake_case",
          "required": false,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "SCREAMING_SNAKE a string",
          "source": "screamingsnakecase(\"input-string\")",
          "return": "\"INPUT_STRING\""
        },
        {
          "title": "SCREAMING_SNAKE a string",
          "source": "screamingsnakecase(\"input-string\", \"kebab-case\")",
          "return": "\"INPUT_STRING\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "shannon_entropy",
      "name": "shannon_entropy",
      "category": "String",
      "description": "Generates [Shannon entropy](https://en.wikipedia.org/wiki/Entropy_(information_theory)) from given string. It can generate it\nbased on string bytes, codepoints, or graphemes.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The input string.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "segmentation",
          "description": "Defines how to split the string to calculate entropy, based on occurrences of\nsegments.\n\nByte segmentation is the fastest, but it might give undesired results when handling\nUTF-8 strings, while grapheme segmentation is the slowest, but most correct in these\ncases.",
          "required": false,
          "type": [
            "string"
          ],
          "default": "byte",
          "enum": {
            "byte": "Considers individual bytes when calculating entropy",
            "codepoint": "Considers codepoints when calculating entropy",
            "grapheme": "Considers graphemes when calculating entropy"
          }
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "float"
        ]
      },
      "examples": [
        {
          "title": "Simple byte segmentation example",
          "source": "floor(shannon_entropy(\"vector.dev\"), precision: 4)",
          "return": "2.9219"
        },
        {
          "title": "UTF-8 string with bytes segmentation",
          "source": "floor(shannon_entropy(\"test123%456.فوائد.net.\"), precision: 4)",
          "return": "4.0784"
        },
        {
          "title": "UTF-8 string with grapheme segmentation",
          "source": "floor(shannon_entropy(\"test123%456.فوائد.net.\", segmentation: \"grapheme\"), precision: 4)",
          "return": "3.9362"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "sieve",
      "name": "sieve",
      "category": "String",
      "description": "Keeps only matches of `pattern` in `value`.\n\nThis can be used to define patterns that are allowed in the string and\nremove everything else.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The original string.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "pattern",
          "description": "Keep all matches of this pattern.",
          "required": true,
          "type": [
            "regex"
          ]
        },
        {
          "name": "replace_single",
          "description": "The string to use to replace single rejected characters.",
          "required": false,
          "default": "",
          "type": [
            "string"
          ]
        },
        {
          "name": "replace_repeated",
          "description": "The string to use to replace multiple sequential instances of rejected characters.",
          "required": false,
          "default": "",
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Sieve with regex",
          "source": "sieve(\"test123%456.فوائد.net.\", r'[a-z0-9.]')",
          "return": "\"test123456..net.\""
        },
        {
          "title": "Custom replacements",
          "source": "sieve(\"test123%456.فوائد.net.\", r'[a-z.0-9]', replace_single: \"X\", replace_repeated: \"<REMOVED>\")",
          "return": "\"test123X456.<REMOVED>.net.\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "slice",
      "name": "slice",
      "category": "String",
      "description": "Returns a slice of `value` between the `start` and `end` positions.\n\nIf the `start` and `end` parameters are negative, they refer to positions counting from the right of the\nstring or array. If `end` refers to a position that is greater than the length of the string or array,\na slice up to the end of the string or array is returned.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string or array to slice.",
          "required": true,
          "type": [
            "array",
            "string"
          ]
        },
        {
          "name": "start",
          "description": "The inclusive start position. A zero-based index that can be negative.",
          "required": true,
          "type": [
            "integer"
          ]
        },
        {
          "name": "end",
          "description": "The exclusive end position. A zero-based index that can be negative.",
          "required": false,
          "default": "String length",
          "type": [
            "integer"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Slice a string (positive index)",
          "source": "slice!(\"Supercalifragilisticexpialidocious\", start: 5, end: 13)",
          "return": "\"califrag\""
        },
        {
          "title": "Slice a string (negative index)",
          "source": "slice!(\"Supercalifragilisticexpialidocious\", start: 5, end: -14)",
          "return": "\"califragilistic\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "snakecase",
      "name": "snakecase",
      "category": "String",
      "description": "Takes the `value` string, and turns it into snake-case. Optionally, you can\npass in the existing case of the function, or else we will try to figure out the case automatically.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to convert to snake-case.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "original_case",
          "description": "Optional hint on the original case type. Must be one of: kebab-case, camelCase, PascalCase, SCREAMING_SNAKE, snake_case",
          "required": false,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "snake-case a string",
          "source": "snakecase(\"input-string\")",
          "return": "\"input_string\""
        },
        {
          "title": "snake-case a string",
          "source": "snakecase(\"input-string\", \"kebab-case\")",
          "return": "\"input_string\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "split",
      "name": "split",
      "category": "String",
      "description": "Splits the `value` string using `pattern`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to split.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "pattern",
          "description": "The string is split whenever this pattern is matched.",
          "required": true,
          "type": [
            "string",
            "regex"
          ]
        },
        {
          "name": "limit",
          "description": "The maximum number of substrings to return.",
          "required": false,
          "type": [
            "integer"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "array"
        ],
        "rules": [
          "If `limit` is specified, the remainder of the string is returned unsplit after `limit` has been reached."
        ]
      },
      "examples": [
        {
          "title": "Split a string (no limit)",
          "source": "split(\"apples and pears and bananas\", \" and \")",
          "return": "[\"apples\",\"pears\",\"bananas\"]"
        },
        {
          "title": "Split a string (with a limit)",
          "source": "split(\"apples and pears and bananas\", \" and \", limit: 2)",
          "return": "[\"apples\",\"pears and bananas\"]"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "starts_with",
      "name": "starts_with",
      "category": "String",
      "description": "Determines whether `value` begins with `substring`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to search.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "substring",
          "description": "The substring that the `value` must start with.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "case_sensitive",
          "description": "Whether the match should be case sensitive.",
          "required": false,
          "type": [
            "boolean"
          ],
          "default": true
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ]
      },
      "examples": [
        {
          "title": "String starts with (case sensitive)",
          "source": "starts_with(\"The Needle In The Haystack\", \"The Needle\")",
          "return": "true"
        },
        {
          "title": "String starts with (case insensitive)",
          "source": "starts_with(\"The Needle In The Haystack\", \"the needle\", case_sensitive: false)",
          "return": "true"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "strip_ansi_escape_codes",
      "name": "strip_ansi_escape_codes",
      "category": "String",
      "description": "Strips [ANSI escape codes](https://en.wikipedia.org/wiki/ANSI_escape_code) from `value`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to strip.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Strip ANSI escape codes",
          "source": "strip_ansi_escape_codes(\"\\e[46mfoo\\e[0m bar\")",
          "return": "\"foo bar\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "strip_whitespace",
      "name": "strip_whitespace",
      "category": "String",
      "description": "Strips whitespace from the start and end of `value`, where whitespace is defined by the [Unicode\n`White_Space` property](https://en.wikipedia.org/wiki/Unicode_character_property#Whitespace).",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to trim.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Strip whitespace",
          "source": "strip_whitespace(\"  A sentence.  \")",
          "return": "\"A sentence.\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "truncate",
      "name": "truncate",
      "category": "String",
      "description": "Truncates the `value` string up to the `limit` number of characters.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to truncate.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "limit",
          "description": "The number of characters to truncate the string after.",
          "required": true,
          "type": [
            "integer",
            "float"
          ]
        },
        {
          "name": "ellipsis",
          "description": "This argument is deprecated. An ellipsis (`...`) is appended if the parameter is set to `true` _and_ the `value` string\nis truncated because it exceeded the `limit`.",
          "required": false,
          "type": [
            "boolean"
          ]
        },
        {
          "name": "suffix",
          "description": "A custom suffix (`...`) is appended to truncated strings.\nIf `ellipsis` is set to `true`, this parameter is ignored for backwards compatibility.",
          "required": false,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ],
        "rules": [
          "The string is returned unchanged its length is less than `limit`.",
          "If `ellipsis` is `true`, then an ellipsis (`...`) is appended to the string (beyond the specified `limit`)."
        ]
      },
      "examples": [
        {
          "title": "Truncate a string",
          "source": "truncate(\"A rather long sentence.\", limit: 11, suffix: \"...\")",
          "return": "\"A rather lo...\""
        },
        {
          "title": "Truncate a string",
          "source": "truncate(\"A rather long sentence.\", limit: 11, suffix: \"[TRUNCATED]\")",
          "return": "\"A rather lo[TRUNCATED]\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "upcase",
      "name": "upcase",
      "description": "Upcases `value`, where upcase is defined according to the Unicode Derived Core Property\nUppercase.",
      "arguments": [
        {
          "name": "value",
          "description": "The string to convert to uppercase.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "category": "String",
      "notices": [],
      "examples": [
        {
          "title": "Upcase a string",
          "source": "upcase(\"Hello, World!\")",
          "return": "\"HELLO, WORLD!\""
        }
      ],
      "deprecated": false,
      "pure": true
    }
  ],
  "Enumerate": [
    {
      "anchor": "compact",
      "name": "compact",
      "category": "Enumerate",
      "description": "Compacts the `value` by removing empty values, where empty values are defined using the\navailable parameters.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The object or array to compact.",
          "required": true,
          "type": [
            "array",
            "object"
          ]
        },
        {
          "name": "recursive",
          "description": "Whether the compaction be recursive.",
          "required": false,
          "default": true,
          "type": [
            "boolean"
          ]
        },
        {
          "name": "null",
          "description": "Whether null should be treated as an empty value.",
          "required": false,
          "default": true,
          "type": [
            "boolean"
          ]
        },
        {
          "name": "string",
          "description": "Whether an empty string should be treated as an empty value.",
          "required": false,
          "default": true,
          "type": [
            "boolean"
          ]
        },
        {
          "name": "object",
          "description": "Whether an empty object should be treated as an empty value.",
          "required": false,
          "default": true,
          "type": [
            "boolean"
          ]
        },
        {
          "name": "array",
          "description": "Whether an empty array should be treated as an empty value.",
          "required": false,
          "default": true,
          "type": [
            "boolean"
          ]
        },
        {
          "name": "nullish",
          "description": "Tests whether the value is \"nullish\" as defined by the [`is_nullish`](#is_nullish) function.",
          "required": false,
          "default": false,
          "type": [
            "boolean"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "array",
          "object"
        ],
        "rules": [
          "The return type matches the `value` type."
        ]
      },
      "examples": [
        {
          "title": "Compact an array",
          "source": "compact([\"foo\", \"bar\", \"\", null, [], \"buzz\"], string: true, array: true, null: true)",
          "return": "[\"foo\",\"bar\",\"buzz\"]"
        },
        {
          "title": "Compact an object",
          "source": "compact({\"field1\": 1, \"field2\": \"\", \"field3\": [], \"field4\": null}, string: true, array: true, null: true)",
          "return": "{\"field1\":1}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "filter",
      "name": "filter",
      "category": "Enumerate",
      "description": "Filter elements from a collection.\n\nThis function currently *does not* support recursive iteration.\n\nThe function uses the function closure syntax to allow reading\nthe key-value or index-value combination for each item in the\ncollection.\n\nThe same scoping rules apply to closure blocks as they do for\nregular blocks. This means that any variable defined in parent scopes\nis accessible, and mutations to those variables are preserved,\nbut any new variables instantiated in the closure block are\nunavailable outside of the block.\n\nSee the examples below to learn about the closure syntax.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The array or object to filter.",
          "required": true,
          "type": [
            "array",
            "object"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "array",
          "object"
        ]
      },
      "examples": [
        {
          "title": "Filter elements",
          "input": {
            "log": {
              "tags": [
                "foo",
                "bar",
                "foo",
                "baz"
              ]
            }
          },
          "source": "filter(array!(.tags)) -> |_index, value| {\n    # keep any elements that aren't equal to \"foo\"\n    value != \"foo\"\n}",
          "return": "[\"bar\",\"baz\"]"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "flatten",
      "name": "flatten",
      "category": "Enumerate",
      "description": "Flattens the `value` into a single-level representation.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The array or object to flatten.",
          "required": true,
          "type": [
            "array",
            "object"
          ]
        },
        {
          "name": "separator",
          "description": "The separator to join nested keys",
          "required": false,
          "default": ".",
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "array",
          "object"
        ],
        "rules": [
          "The return type matches the `value` type."
        ]
      },
      "examples": [
        {
          "title": "Flatten array",
          "source": "flatten([1, [2, 3, 4], [5, [6, 7], 8], 9])",
          "return": "[1,2,3,4,5,6,7,8,9]"
        },
        {
          "title": "Flatten object",
          "source": "flatten({\n\t\"parent1\": {\n\t\t\"child1\": 1,\n\t\t\"child2\": 2\n\t},\n\t\"parent2\": {\n\t\t\"child3\": 3\n\t}\n})",
          "return": "{\"parent1.child1\":1,\"parent1.child2\":2,\"parent2.child3\":3}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "for_each",
      "name": "for_each",
      "category": "Enumerate",
      "description": "Iterate over a collection.\n\nThis function currently *does not* support recursive iteration.\n\nThe function uses the \"function closure syntax\" to allow reading\nthe key/value or index/value combination for each item in the\ncollection.\n\nThe same scoping rules apply to closure blocks as they do for\nregular blocks. This means that any variable defined in parent scopes\nis accessible, and mutations to those variables are preserved,\nbut any new variables instantiated in the closure block are\nunavailable outside of the block.\n\nSee the examples below to learn about the closure syntax.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The array or object to iterate.",
          "required": true,
          "type": [
            "array",
            "object"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "null"
        ]
      },
      "examples": [
        {
          "title": "Tally elements",
          "input": {
            "log": {
              "tags": [
                "foo",
                "bar",
                "foo",
                "baz"
              ]
            }
          },
          "source": "tally = {}\nfor_each(array!(.tags)) -> |_index, value| {\n    # Get the current tally for the `value`, or\n    # set to `0`.\n    count = int(get!(tally, [value])) ?? 0\n\n    # Increment the tally for the value by `1`.\n    tally = set!(tally, [value], count + 1)\n}\n\ntally",
          "return": "{\"foo\":2,\"bar\":1,\"baz\":1}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "includes",
      "name": "includes",
      "category": "Enumerate",
      "description": "Determines whether the `value` array includes the specified `item`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The array.",
          "required": true,
          "type": [
            "array"
          ]
        },
        {
          "name": "item",
          "description": "The item to check.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ]
      },
      "examples": [
        {
          "title": "Array includes",
          "source": "includes([\"apple\", \"orange\", \"banana\"], \"banana\")",
          "return": "true"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "keys",
      "name": "keys",
      "category": "Enumerate",
      "description": "Returns the keys from the object passed into the function.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The object to extract keys from.",
          "required": true,
          "type": [
            "object"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "array"
        ],
        "rules": [
          "Returns an array of all the keys"
        ]
      },
      "examples": [
        {
          "title": "Get keys from the object",
          "input": {
            "log": {
              "key1": "val1",
              "key2": "val2"
            }
          },
          "source": "keys({\"key1\": \"val1\", \"key2\": \"val2\"})",
          "return": "[\"key1\",\"key2\"]"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "length",
      "name": "length",
      "category": "Enumerate",
      "description": "Returns the length of the `value`.\n\n* If `value` is an array, returns the number of elements.\n* If `value` is an object, returns the number of top-level keys.\n* If `value` is a string, returns the number of bytes in the string. If\n  you want the number of characters, see `strlen`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The array or object.",
          "required": true,
          "type": [
            "array",
            "object",
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "integer"
        ],
        "rules": [
          "If `value` is an array, returns the number of elements.",
          "If `value` is an object, returns the number of top-level keys.",
          "If `value` is a string, returns the number of bytes in the string."
        ]
      },
      "examples": [
        {
          "title": "Length (object)",
          "source": "length({\n\t\"portland\": \"Trail Blazers\",\n\t\"seattle\":  \"Supersonics\"\n})",
          "return": "2"
        },
        {
          "title": "Length (nested object)",
          "source": "length({\n\t\"home\": {\n\t\t\"city\":  \"Portland\",\n\t\t\"state\": \"Oregon\"\n\t},\n\t\"name\": \"Trail Blazers\",\n\t\"mascot\": {\n\t\t\"name\": \"Blaze the Trail Cat\"\n\t}\n})",
          "return": "3"
        },
        {
          "title": "Length (array)",
          "source": "length([\"Trail Blazers\", \"Supersonics\", \"Grizzlies\"])",
          "return": "3"
        },
        {
          "title": "Length (string)",
          "source": "length(\"The Planet of the Apes Musical\")",
          "return": "30"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "map_keys",
      "name": "map_keys",
      "category": "Enumerate",
      "description": "Map the keys within an object.\n\nIf `recursive` is enabled, the function iterates into nested\nobjects, using the following rules:\n\n1. Iteration starts at the root.\n2. For every nested object type:\n   - First return the key of the object type itself.\n   - Then recurse into the object, and loop back to item (1)\n     in this list.\n   - Any mutation done on a nested object *before* recursing into\n     it, are preserved.\n3. For every nested array type:\n   - First return the key of the array type itself.\n   - Then find all objects within the array, and apply item (2)\n     to each individual object.\n\nThe above rules mean that `map_keys` with\n`recursive` enabled finds *all* keys in the target,\nregardless of whether nested objects are nested inside arrays.\n\nThe function uses the function closure syntax to allow reading\nthe key for each item in the object.\n\nThe same scoping rules apply to closure blocks as they do for\nregular blocks. This means that any variable defined in parent scopes\nis accessible, and mutations to those variables are preserved,\nbut any new variables instantiated in the closure block are\nunavailable outside of the block.\n\nSee the examples below to learn about the closure syntax.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The object to iterate.",
          "required": true,
          "type": [
            "object"
          ]
        },
        {
          "name": "recursive",
          "description": "Whether to recursively iterate the collection.",
          "required": false,
          "default": false,
          "type": [
            "boolean"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Upcase keys",
          "input": {
            "log": {
              "foo": "foo",
              "bar": "bar"
            }
          },
          "source": "map_keys(.) -> |key| { upcase(key) }",
          "return": "{\"FOO\":\"foo\",\"BAR\":\"bar\"}"
        },
        {
          "title": "De-dot keys",
          "input": {
            "log": {
              "labels": {
                "app.kubernetes.io/name": "mysql"
              }
            }
          },
          "source": "map_keys(., recursive: true) -> |key| { replace(key, \".\", \"_\") }",
          "return": "{\"labels\":{\"app_kubernetes_io/name\":\"mysql\"}}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "map_values",
      "name": "map_values",
      "category": "Enumerate",
      "description": "Map the values within a collection.\n\nIf `recursive` is enabled, the function iterates into nested\ncollections, using the following rules:\n\n1. Iteration starts at the root.\n2. For every nested collection type:\n   - First return the collection type itself.\n   - Then recurse into the collection, and loop back to item (1)\n     in the list\n   - Any mutation done on a collection *before* recursing into it,\n     are preserved.\n\nThe function uses the function closure syntax to allow mutating\nthe value for each item in the collection.\n\nThe same scoping rules apply to closure blocks as they do for\nregular blocks, meaning, any variable defined in parent scopes\nare accessible, and mutations to those variables are preserved,\nbut any new variables instantiated in the closure block are\nunavailable outside of the block.\n\nCheck out the examples below to learn about the closure syntax.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The object or array to iterate.",
          "required": true,
          "type": [
            "array",
            "object"
          ]
        },
        {
          "name": "recursive",
          "description": "Whether to recursively iterate the collection.",
          "required": false,
          "default": false,
          "type": [
            "boolean"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "array",
          "object"
        ]
      },
      "examples": [
        {
          "title": "Upcase values",
          "input": {
            "log": {
              "foo": "foo",
              "bar": "bar"
            }
          },
          "source": "map_values(.) -> |value| { upcase!(value) }",
          "return": "{\"foo\":\"FOO\",\"bar\":\"BAR\"}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "match_array",
      "name": "match_array",
      "category": "Enumerate",
      "description": "Determines whether the elements in the `value` array matches the `pattern`. By default, it checks that at least one element matches, but can be set to determine if all the elements match.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The array.",
          "required": true,
          "type": [
            "array"
          ]
        },
        {
          "name": "pattern",
          "description": "The regular expression pattern to match against.",
          "required": true,
          "type": [
            "regex"
          ]
        },
        {
          "name": "all",
          "description": "Whether to match on all elements of `value`.",
          "required": false,
          "default": false,
          "type": [
            "boolean"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ]
      },
      "examples": [
        {
          "title": "Match at least one element",
          "source": "match_array([\"foobar\", \"bazqux\"], r'foo')",
          "return": "true"
        },
        {
          "title": "Match all elements",
          "source": "match_array([\"foo\", \"foobar\", \"barfoo\"], r'foo', all: true)",
          "return": "true"
        },
        {
          "title": "No matches",
          "source": "match_array([\"bazqux\", \"xyz\"], r'foo')",
          "return": "false"
        },
        {
          "title": "Not all elements match",
          "source": "match_array([\"foo\", \"foobar\", \"baz\"], r'foo', all: true)",
          "return": "false"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "strlen",
      "name": "strlen",
      "category": "Enumerate",
      "description": "Returns the number of UTF-8 characters in `value`. This differs from\n`length` which counts the number of bytes of a string.\n\n**Note**: This is the count of [Unicode scalar values](https://www.unicode.org/glossary/#unicode_scalar_value)\nwhich can sometimes differ from [Unicode code points](https://www.unicode.org/glossary/#code_point).",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "integer"
        ]
      },
      "examples": [
        {
          "title": "strlen",
          "source": "strlen(\"ñandú\")",
          "return": "5"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "unflatten",
      "name": "unflatten",
      "category": "Enumerate",
      "description": "Unflattens the `value` into a nested representation.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The array or object to unflatten.",
          "required": true,
          "type": [
            "object"
          ]
        },
        {
          "name": "separator",
          "description": "The separator to split flattened keys.",
          "required": false,
          "default": ".",
          "type": [
            "string"
          ]
        },
        {
          "name": "recursive",
          "description": "Whether to recursively unflatten the object values.",
          "required": false,
          "default": "true",
          "type": [
            "boolean"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Unflatten",
          "source": "unflatten({\n    \"foo.bar.baz\": true,\n    \"foo.bar.qux\": false,\n\t\"foo.quux\": 42\n})",
          "return": "{\"foo\":{\"bar\":{\"baz\":true,\"qux\":false},\"quux\":42}}"
        },
        {
          "title": "Unflatten recursively",
          "source": "unflatten({\n    \"flattened.parent\": {\n\t\t\"foo.bar\": true,\n\t\t\"foo.baz\": false\n\t}\n})",
          "return": "{\"flattened\":{\"parent\":{\"foo\":{\"bar\":true,\"baz\":false}}}}"
        },
        {
          "title": "Unflatten non-recursively",
          "source": "unflatten({\n    \"flattened.parent\": {\n\t\t\"foo.bar\": true,\n\t\t\"foo.baz\": false\n\t}\n}, recursive: false)",
          "return": "{\"flattened\":{\"parent\":{\"foo.bar\":true,\"foo.baz\":false}}}"
        },
        {
          "title": "Ignore inconsistent keys values",
          "source": "unflatten({\n\t\"a\": 3,\n\t\"a.b\": 2,\n\t\"a.c\": 4\n})",
          "return": "{\"a\":{\"b\":2,\"c\":4}}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "unique",
      "name": "unique",
      "category": "Enumerate",
      "description": "Returns the unique values for an array.\n\nThe first occurrence of each element is kept.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The array to return unique elements from.",
          "required": true,
          "type": [
            "array"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "array"
        ]
      },
      "examples": [
        {
          "title": "Unique",
          "source": "unique([\"foo\", \"bar\", \"foo\", \"baz\"])",
          "return": "[\"foo\",\"bar\",\"baz\"]"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "values",
      "name": "values",
      "category": "Enumerate",
      "description": "Returns the values from the object passed into the function.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The object to extract values from.",
          "required": true,
          "type": [
            "object"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "array"
        ],
        "rules": [
          "Returns an array of all the values."
        ]
      },
      "examples": [
        {
          "title": "Get values from the object",
          "input": {
            "log": {
              "key1": "val1",
              "key2": "val2"
            }
          },
          "source": "values({\"key1\": \"val1\", \"key2\": \"val2\"})",
          "return": "[\"val1\",\"val2\"]"
        }
      ],
      "deprecated": false,
      "pure": true
    }
  ],
  "Checksum": [
    {
      "anchor": "crc",
      "name": "crc",
      "category": "Checksum",
      "description": "Calculates a CRC of the `value`.\nThe CRC `algorithm` used can be optionally specified.\n\nThis function is infallible if either the default `algorithm` value or a recognized-valid compile-time\n`algorithm` string literal is used. Otherwise, it is fallible.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to calculate the checksum for.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "algorithm",
          "description": "The CRC algorithm to use.",
          "enum": {
            "CRC_3_GSM": "3-bit CRC used in GSM telecommunications for error detection",
            "CRC_3_ROHC": "3-bit CRC used in Robust Header Compression (ROHC) protocol",
            "CRC_4_G_704": "4-bit CRC specified in ITU-T G.704 for synchronous communication systems",
            "CRC_4_INTERLAKEN": "4-bit CRC used in Interlaken high-speed serial communication protocol",
            "CRC_5_EPC_C1G2": "5-bit CRC used in EPC Gen 2 RFID (Radio-Frequency Identification) standard",
            "CRC_5_G_704": "5-bit CRC variant in ITU-T G.704 telecommunication standard",
            "CRC_5_USB": "5-bit CRC used in USB communication for detecting transmission errors",
            "CRC_6_CDMA2000_A": "6-bit CRC variant used in CDMA2000 network protocols",
            "CRC_6_CDMA2000_B": "Alternative 6-bit CRC variant for CDMA2000 network protocols",
            "CRC_6_DARC": "6-bit CRC used in DARC (Digital Audio Radio Channel) communication",
            "CRC_6_GSM": "6-bit CRC variant used in GSM telecommunications",
            "CRC_6_G_704": "6-bit CRC specified in ITU-T G.704 for synchronous communication",
            "CRC_7_MMC": "7-bit CRC used in MultiMediaCard (MMC) storage systems for error detection",
            "CRC_7_ROHC": "7-bit CRC used in Robust Header Compression (ROHC) protocol",
            "CRC_7_UMTS": "7-bit CRC used in UMTS (Universal Mobile Telecommunications System)",
            "CRC_8_AUTOSAR": "8-bit CRC used in AUTOSAR (Automotive Open System Architecture) standard",
            "CRC_8_BLUETOOTH": "8-bit CRC polynomial used in Bluetooth communication protocols",
            "CRC_8_CDMA2000": "8-bit CRC used in CDMA2000 cellular communication standard",
            "CRC_8_DARC": "8-bit CRC used in DARC (Digital Audio Radio Channel) communication",
            "CRC_8_DVB_S2": "8-bit CRC used in DVB-S2 (Digital Video Broadcasting Satellite Second Generation)",
            "CRC_8_GSM_A": "8-bit CRC variant A used in GSM telecommunications",
            "CRC_8_GSM_B": "8-bit CRC variant B used in GSM telecommunications",
            "CRC_8_HITAG": "8-bit CRC used in Hitag RFID and transponder systems",
            "CRC_8_I_432_1": "8-bit CRC specified in IEEE 1432.1 standard",
            "CRC_8_I_CODE": "8-bit CRC used in I-CODE RFID systems",
            "CRC_8_LTE": "8-bit CRC used in LTE (Long-Term Evolution) cellular networks",
            "CRC_8_MAXIM_DOW": "8-bit CRC used by Maxim/Dallas Semiconductor for 1-Wire and iButton devices",
            "CRC_8_MIFARE_MAD": "8-bit CRC used in MIFARE MAD (Multiple Application Directory) protocol",
            "CRC_8_NRSC_5": "8-bit CRC used in NRSC-5 digital radio broadcasting standard",
            "CRC_8_OPENSAFETY": "8-bit CRC used in OpenSAFETY industrial communication protocol",
            "CRC_8_ROHC": "8-bit CRC used in Robust Header Compression (ROHC) protocol",
            "CRC_8_SAE_J1850": "8-bit CRC used in SAE J1850 automotive communication protocol",
            "CRC_8_SMBUS": "8-bit CRC used in System Management Bus (SMBus) communication",
            "CRC_8_TECH_3250": "8-bit CRC used in SMPTE (Society of Motion Picture and Television Engineers) standard",
            "CRC_8_WCDMA": "8-bit CRC used in WCDMA (Wideband Code Division Multiple Access) networks",
            "CRC_10_ATM": "10-bit CRC used in ATM (Asynchronous Transfer Mode) cell headers",
            "CRC_10_CDMA2000": "10-bit CRC used in CDMA2000 cellular communication standard",
            "CRC_10_GSM": "10-bit CRC variant used in GSM telecommunications",
            "CRC_11_FLEXRAY": "11-bit CRC used in FlexRay automotive communication protocol",
            "CRC_11_UMTS": "11-bit CRC used in UMTS (Universal Mobile Telecommunications System)",
            "CRC_12_CDMA2000": "12-bit CRC used in CDMA2000 cellular communication standard",
            "CRC_12_DECT": "12-bit CRC used in DECT (Digital Enhanced Cordless Telecommunications) standards",
            "CRC_12_GSM": "12-bit CRC variant used in GSM telecommunications",
            "CRC_12_UMTS": "12-bit CRC used in UMTS (Universal Mobile Telecommunications System)",
            "CRC_13_BBC": "13-bit CRC used in BBC (British Broadcasting Corporation) digital transmission",
            "CRC_14_DARC": "14-bit CRC used in DARC (Digital Audio Radio Channel) communication",
            "CRC_14_GSM": "14-bit CRC variant used in GSM telecommunications",
            "CRC_15_CAN": "15-bit CRC used in CAN (Controller Area Network) automotive communication",
            "CRC_15_MPT1327": "15-bit CRC used in MPT 1327 radio trunking system",
            "CRC_16_ARC": "16-bit CRC used in ARC (Adaptive Routing Code) communication",
            "CRC_16_CDMA2000": "16-bit CRC used in CDMA2000 cellular communication standard",
            "CRC_16_CMS": "16-bit CRC used in Content Management Systems for data integrity",
            "CRC_16_DDS_110": "16-bit CRC used in DDS (Digital Data Storage) standard",
            "CRC_16_DECT_R": "16-bit CRC variant R used in DECT communication",
            "CRC_16_DECT_X": "16-bit CRC variant X used in DECT communication",
            "CRC_16_DNP": "16-bit CRC used in DNP3 (Distributed Network Protocol) for utilities",
            "CRC_16_EN_13757": "16-bit CRC specified in EN 13757 for meter communication",
            "CRC_16_GENIBUS": "16-bit CRC used in GENIBUS communication protocol",
            "CRC_16_GSM": "16-bit CRC variant used in GSM telecommunications",
            "CRC_16_IBM_3740": "16-bit CRC used in IBM 3740 data integrity checks",
            "CRC_16_IBM_SDLC": "16-bit CRC used in IBM SDLC (Synchronous Data Link Control)",
            "CRC_16_ISO_IEC_14443_3_A": "16-bit CRC used in ISO/IEC 14443-3 Type A contactless smart cards",
            "CRC_16_KERMIT": "16-bit CRC used in Kermit file transfer protocol",
            "CRC_16_LJ1200": "16-bit CRC used in LJ1200 communication system",
            "CRC_16_M17": "16-bit CRC used in M17 digital radio communication",
            "CRC_16_MAXIM_DOW": "16-bit CRC used by Maxim/Dallas Semiconductor for data integrity",
            "CRC_16_MCRF4XX": "16-bit CRC used in MCRF4XX RFID systems",
            "CRC_16_MODBUS": "16-bit CRC used in Modbus communication protocol for error detection",
            "CRC_16_NRSC_5": "16-bit CRC used in NRSC-5 digital radio broadcasting standard",
            "CRC_16_OPENSAFETY_A": "16-bit CRC variant A in OpenSAFETY industrial communication",
            "CRC_16_OPENSAFETY_B": "16-bit CRC variant B in OpenSAFETY industrial communication",
            "CRC_16_PROFIBUS": "16-bit CRC used in PROFIBUS industrial communication protocol",
            "CRC_16_RIELLO": "16-bit CRC used in Riello UPS communication",
            "CRC_16_SPI_FUJITSU": "16-bit CRC used in Fujitsu SPI (Serial Peripheral Interface) communication",
            "CRC_16_T10_DIF": "16-bit CRC used in T10 DIF (Data Integrity Field) standard",
            "CRC_16_TELEDISK": "16-bit CRC used in Teledisk disk image format",
            "CRC_16_TMS37157": "16-bit CRC used in TMS37157 microcontroller communication",
            "CRC_16_UMTS": "16-bit CRC used in UMTS (Universal Mobile Telecommunications System)",
            "CRC_16_USB": "16-bit CRC used in USB communication for error detection",
            "CRC_16_XMODEM": "16-bit CRC used in XMODEM file transfer protocol",
            "CRC_17_CAN_FD": "17-bit CRC used in CAN FD (Flexible Data-Rate) automotive communication protocol",
            "CRC_21_CAN_FD": "21-bit CRC variant used in CAN FD (Flexible Data-Rate) automotive communication",
            "CRC_24_BLE": "24-bit CRC used in Bluetooth Low Energy (BLE) packet error checking",
            "CRC_24_FLEXRAY_A": "24-bit CRC variant A used in FlexRay automotive communication protocol",
            "CRC_24_FLEXRAY_B": "24-bit CRC variant B used in FlexRay automotive communication protocol",
            "CRC_24_INTERLAKEN": "24-bit CRC used in Interlaken high-speed serial communication protocol",
            "CRC_24_LTE_A": "24-bit CRC variant A used in LTE (Long-Term Evolution) cellular networks",
            "CRC_24_LTE_B": "24-bit CRC variant B used in LTE (Long-Term Evolution) cellular networks",
            "CRC_24_OPENPGP": "24-bit CRC used in OpenPGP (Pretty Good Privacy) for data integrity",
            "CRC_24_OS_9": "24-bit CRC used in OS-9 operating system for error detection",
            "CRC_30_CDMA": "30-bit CRC used in CDMA (Code Division Multiple Access) communication standard",
            "CRC_31_PHILIPS": "31-bit CRC used in Philips communication protocols",
            "CRC_32_AIXM": "32-bit CRC used in Aeronautical Information Exchange Model (AIXM)",
            "CRC_32_AUTOSAR": "32-bit CRC used in AUTOSAR (Automotive Open System Architecture) standard",
            "CRC_32_BASE91_D": "32-bit CRC variant used in Base91 data encoding",
            "CRC_32_BZIP2": "32-bit CRC used in bzip2 compression algorithm",
            "CRC_32_CD_ROM_EDC": "32-bit CRC used for Error Detection Code in CD-ROM systems",
            "CRC_32_CKSUM": "32-bit CRC used in UNIX cksum command for file integrity",
            "CRC_32_ISCSI": "32-bit CRC used in iSCSI (Internet Small Computer Systems Interface)",
            "CRC_32_ISO_HDLC": "32-bit CRC used in ISO HDLC (High-Level Data Link Control)",
            "CRC_32_JAMCRC": "32-bit CRC variant used in JAM error detection",
            "CRC_32_MEF": "32-bit CRC used in Metro Ethernet Forum (MEF) standards",
            "CRC_32_MPEG_2": "32-bit CRC used in MPEG-2 transport streams for error detection",
            "CRC_32_XFER": "32-bit CRC used in data transfer protocols",
            "CRC_40_GSM": "40-bit CRC variant used in GSM telecommunications",
            "CRC_64_ECMA_182": "64-bit CRC specified in ECMA-182 standard",
            "CRC_64_GO_ISO": "64-bit CRC used in Go programming language and ISO standards",
            "CRC_64_MS": "64-bit CRC variant used in Microsoft systems",
            "CRC_64_REDIS": "64-bit CRC used in Redis key-value data store",
            "CRC_64_WE": "64-bit CRC variant for wide-area error detection",
            "CRC_64_XZ": "64-bit CRC used in the XZ compression format for integrity verification",
            "CRC_82_DARC": "82-bit CRC used in DARC (Digital Audio Radio Channel) communication"
          },
          "required": false,
          "default": "CRC_32_ISO_HDLC",
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a string.",
        "`algorithm` is not a supported algorithm."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Create CRC checksum using the default algorithm",
          "source": "crc(\"foo\")",
          "return": "\"2356372769\""
        },
        {
          "title": "Create CRC checksum using the CRC_32_CKSUM algorithm",
          "source": "crc(\"foo\", algorithm: \"CRC_32_CKSUM\")",
          "return": "\"4271552933\""
        }
      ],
      "deprecated": false,
      "pure": true
    }
  ],
  "Codec": [
    {
      "anchor": "decode_base16",
      "name": "decode_base16",
      "category": "Codec",
      "description": "Decodes the `value` (a [Base16](https://en.wikipedia.org/wiki/Hexadecimal) string) into its original string.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The [Base16](https://en.wikipedia.org/wiki/Hexadecimal) data to decode.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a valid encoded Base16 string."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Decode Base16 data",
          "source": "decode_base16!(\"796f752068617665207375636365737366756c6c79206465636f646564206d65\")",
          "return": "\"you have successfully decoded me\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "decode_base64",
      "name": "decode_base64",
      "category": "Codec",
      "description": "Decodes the `value` (a [Base64](https://en.wikipedia.org/wiki/Base64) string) into its original string.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The [Base64](https://en.wikipedia.org/wiki/Base64) data to decode.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "charset",
          "description": "The character set to use when decoding the data.",
          "required": false,
          "type": [
            "string"
          ],
          "default": "standard",
          "enum": {
            "standard": "[Standard](https://tools.ietf.org/html/rfc4648#section-4) Base64 format.",
            "url_safe": "Modified Base64 for [URL variants](https://en.wikipedia.org/wiki/Base64#URL_applications)."
          }
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a valid encoded Base64 string."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Decode Base64 data (default)",
          "source": "decode_base64!(\"eW91IGhhdmUgc3VjY2Vzc2Z1bGx5IGRlY29kZWQgbWU=\")",
          "return": "\"you have successfully decoded me\""
        },
        {
          "title": "Decode Base64 data (URL safe)",
          "source": "decode_base64!(\"eW91IGNhbid0IG1ha2UgeW91ciBoZWFydCBmZWVsIHNvbWV0aGluZyBpdCB3b24ndA==\", charset: \"url_safe\")",
          "return": "\"you can't make your heart feel something it won't\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "decode_charset",
      "name": "decode_charset",
      "category": "Codec",
      "description": "Decodes the `value` (a non-UTF8 string) to a UTF8 string using the specified [character set](https://encoding.spec.whatwg.org/#names-and-labels).",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The non-UTF8 string to decode.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "from_charset",
          "description": "The [character set](https://encoding.spec.whatwg.org/#names-and-labels) to use when decoding the data.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`from_charset` isn't a valid [character set](https://encoding.spec.whatwg.org/#names-and-labels)."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Decode EUC-KR string",
          "source": "decode_charset!(decode_base64!(\"vsiz58fPvLy/5A==\"), \"euc-kr\")",
          "return": "\"안녕하세요\""
        },
        {
          "title": "Decode EUC-JP string",
          "source": "decode_charset!(decode_base64!(\"pLOk86TLpMGkzw==\"), \"euc-jp\")",
          "return": "\"こんにちは\""
        },
        {
          "title": "Decode GB2312 string",
          "source": "decode_charset!(decode_base64!(\"xOO6ww==\"), \"gb2312\")",
          "return": "\"你好\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "decode_gzip",
      "name": "decode_gzip",
      "category": "Codec",
      "description": "Decodes the `value` (a [Gzip](https://www.gzip.org/) string) into its original string.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The [Gzip](https://www.gzip.org/) data to decode.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a valid encoded Gzip string."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Decode Gzip data",
          "source": "encoded_text = decode_base64!(\"H4sIAHEAymMAA6vML1XISCxLVSguTU5OLS5OK83JqVRISU3OT0lNUchNBQD7BGDaIAAAAA==\")\ndecode_gzip!(encoded_text)",
          "return": "\"you have successfully decoded me\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "decode_lz4",
      "name": "decode_lz4",
      "category": "Codec",
      "description": "Decodes the `value` (an lz4 string) into its original string.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The lz4 block data to decode.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` unable to decode value with lz4 decoder."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Decode Lz4 data",
          "source": "encoded_text = decode_base64!(\"LAAAAPAdVGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIDEzIGxhenkgZG9ncy4=\")\ndecode_lz4!(encoded_text)",
          "return": "\"The quick brown fox jumps over 13 lazy dogs.\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "decode_mime_q",
      "name": "decode_mime_q",
      "category": "Codec",
      "description": "Replaces q-encoded or base64-encoded [encoded-word](https://datatracker.ietf.org/doc/html/rfc2047#section-2) substrings in the `value` with their original string.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string with [encoded-words](https://datatracker.ietf.org/doc/html/rfc2047#section-2) to decode.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` has invalid encoded [encoded-word](https://datatracker.ietf.org/doc/html/rfc2047#section-2) string."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Decode single encoded-word",
          "source": "decode_mime_q!(\"=?utf-8?b?SGVsbG8sIFdvcmxkIQ==?=\")",
          "return": "\"Hello, World!\""
        },
        {
          "title": "Embedded",
          "source": "decode_mime_q!(\"From: =?utf-8?b?SGVsbG8sIFdvcmxkIQ==?= <=?utf-8?q?hello=5Fworld=40example=2ecom?=>\")",
          "return": "\"From: Hello, World! <hello_world@example.com>\""
        },
        {
          "title": "Without charset",
          "source": "decode_mime_q!(\"?b?SGVsbG8sIFdvcmxkIQ==\")",
          "return": "\"Hello, World!\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "decode_percent",
      "name": "decode_percent",
      "category": "Codec",
      "description": "Decodes a [percent-encoded](https://url.spec.whatwg.org/#percent-encoded-bytes) `value` like a URL.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to decode.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Percent decode a value",
          "source": "decode_percent(\"foo%20bar%3F\")",
          "return": "\"foo bar?\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "decode_punycode",
      "name": "decode_punycode",
      "category": "Codec",
      "description": "Decodes a [punycode](https://en.wikipedia.org/wiki/Punycode) encoded `value`, such as an internationalized domain name ([IDN](https://en.wikipedia.org/wiki/Internationalized_domain_name)). This function assumes that the value passed is meant to be used in IDN context and that it is either a domain name or a part of it.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to decode.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "validate",
          "description": "If enabled, checks if the input string is a valid domain name.",
          "required": false,
          "type": [
            "boolean"
          ],
          "default": true
        }
      ],
      "internal_failure_reasons": [
        "`value` is not valid `punycode`"
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Decode a punycode encoded internationalized domain name",
          "source": "decode_punycode!(\"www.xn--caf-dma.com\")",
          "return": "\"www.café.com\""
        },
        {
          "title": "Decode an ASCII only string",
          "source": "decode_punycode!(\"www.cafe.com\")",
          "return": "\"www.cafe.com\""
        },
        {
          "title": "Ignore validation",
          "source": "decode_punycode!(\"xn--8hbb.xn--fiba.xn--8hbf.xn--eib.\", validate: false)",
          "return": "\"١٠.٦٦.٣٠.٥.\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "decode_snappy",
      "name": "decode_snappy",
      "category": "Codec",
      "description": "Decodes the `value` (a Snappy string) into its original string.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The Snappy data to decode.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a valid encoded Snappy string."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Decode Snappy data",
          "source": "encoded_text = decode_base64!(\"LKxUaGUgcXVpY2sgYnJvd24gZm94IGp1bXBzIG92ZXIgMTMgbGF6eSBkb2dzLg==\")\ndecode_snappy!(encoded_text)",
          "return": "\"The quick brown fox jumps over 13 lazy dogs.\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "decode_zlib",
      "name": "decode_zlib",
      "category": "Codec",
      "description": "Decodes the `value` (a [Zlib](https://www.zlib.net) string) into its original string.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The [Zlib](https://www.zlib.net) data to decode.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a valid encoded Zlib string."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Decode Zlib data",
          "source": "encoded_text = decode_base64!(\"eJwNy4ENwCAIBMCNXIlQ/KqplUSgCdvXAS41qPMHshCB2R1zJlWIVlR6UURX2+wx2YcuK3kAb9C1wd6dn7Fa+QH9gRxr\")\ndecode_zlib!(encoded_text)",
          "return": "\"you_have_successfully_decoded_me.congratulations.you_are_breathtaking.\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "decode_zstd",
      "name": "decode_zstd",
      "category": "Codec",
      "description": "Decodes the `value` (a [Zstandard](https://facebook.github.io/zstd) string) into its original string.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The [Zstandard](https://facebook.github.io/zstd) data to decode.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a valid encoded Zstd string."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Decode Zstd data",
          "source": "encoded_text = decode_base64!(\"KLUv/QBY/QEAYsQOFKClbQBedqXsb96EWDax/f/F/z+gNU4ZTInaUeAj82KqPFjUzKqhcfDqAIsLvAsnY1bI/N2mHzDixRQA\")\ndecode_zstd!(encoded_text)",
          "return": "\"you_have_successfully_decoded_me.congratulations.you_are_breathtaking.\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "encode_base16",
      "name": "encode_base16",
      "category": "Codec",
      "description": "Encodes the `value` to [Base16](https://en.wikipedia.org/wiki/Hexadecimal).",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to encode.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Encode to Base16",
          "source": "encode_base16(\"please encode me\")",
          "return": "\"706c6561736520656e636f6465206d65\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "encode_base64",
      "name": "encode_base64",
      "category": "Codec",
      "description": "Encodes the `value` to [Base64](https://en.wikipedia.org/wiki/Base64).",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to encode.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "padding",
          "description": "Whether the Base64 output is [padded](https://en.wikipedia.org/wiki/Base64#Output_padding).",
          "required": false,
          "type": [
            "boolean"
          ],
          "default": true
        },
        {
          "name": "charset",
          "description": "The character set to use when encoding the data.",
          "required": false,
          "type": [
            "string"
          ],
          "default": "standard",
          "enum": {
            "standard": "[Standard](https://tools.ietf.org/html/rfc4648#section-4) Base64 format.",
            "url_safe": "Modified Base64 for [URL variants](https://en.wikipedia.org/wiki/Base64#URL_applications)."
          }
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Encode to Base64 (default)",
          "source": "encode_base64(\"please encode me\")",
          "return": "\"cGxlYXNlIGVuY29kZSBtZQ==\""
        },
        {
          "title": "Encode to Base64 (without padding)",
          "source": "encode_base64(\"please encode me, no padding though\", padding: false)",
          "return": "\"cGxlYXNlIGVuY29kZSBtZSwgbm8gcGFkZGluZyB0aG91Z2g\""
        },
        {
          "title": "Encode to Base64 (URL safe)",
          "source": "encode_base64(\"please encode me, but safe for URLs\", charset: \"url_safe\")",
          "return": "\"cGxlYXNlIGVuY29kZSBtZSwgYnV0IHNhZmUgZm9yIFVSTHM=\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "encode_charset",
      "name": "encode_charset",
      "category": "Codec",
      "description": "Encodes the `value` (a UTF8 string) to a non-UTF8 string using the specified [character set](https://encoding.spec.whatwg.org/#names-and-labels).",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The UTF8 string to encode.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "to_charset",
          "description": "The [character set](https://encoding.spec.whatwg.org/#names-and-labels) to use when encoding the data.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`to_charset` isn't a valid [character set](https://encoding.spec.whatwg.org/#names-and-labels)."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Encode UTF8 string to EUC-KR",
          "source": "encode_base64(encode_charset!(\"안녕하세요\", \"euc-kr\"))",
          "return": "\"vsiz58fPvLy/5A==\""
        },
        {
          "title": "Encode UTF8 string to EUC-JP",
          "source": "encode_base64(encode_charset!(\"こんにちは\", \"euc-jp\"))",
          "return": "\"pLOk86TLpMGkzw==\""
        },
        {
          "title": "Encode UTF8 string to GB2312",
          "source": "encode_base64(encode_charset!(\"你好\", \"gb2312\"))",
          "return": "\"xOO6ww==\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "encode_gzip",
      "name": "encode_gzip",
      "category": "Codec",
      "description": "Encodes the `value` to [Gzip](https://www.gzip.org/).",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to encode.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "compression_level",
          "description": "The default compression level.",
          "required": false,
          "type": [
            "integer"
          ],
          "default": 6
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Encode to Gzip",
          "source": "encoded_text = encode_gzip(\"please encode me\")\nencode_base64(encoded_text)",
          "return": "\"H4sIAAAAAAAA/yvISU0sTlVIzUvOT0lVyE0FAI4R4vcQAAAA\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "encode_json",
      "name": "encode_json",
      "category": "Codec",
      "description": "Encodes the `value` to JSON.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to convert to a JSON string.",
          "required": true,
          "type": [
            "any"
          ]
        },
        {
          "name": "pretty",
          "description": "Whether to pretty print the JSON string or not.",
          "required": false,
          "type": [
            "boolean"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Encode to JSON",
          "source": ".payload = encode_json({\"hello\": \"world\"})",
          "return": "\"{\\\"hello\\\":\\\"world\\\"}\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "encode_key_value",
      "name": "encode_key_value",
      "category": "Codec",
      "description": "Encodes the `value` into key-value format with customizable delimiters. Default delimiters match\nthe [logfmt](https://brandur.org/logfmt) format.",
      "notices": [
        "If `fields_ordering` is specified then the function is fallible else it is infallible."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The value to convert to a string.",
          "required": true,
          "type": [
            "object"
          ]
        },
        {
          "name": "fields_ordering",
          "description": "The ordering of fields to preserve. Any fields not in this list are listed unordered, after all ordered fields.",
          "required": false,
          "type": [
            "array"
          ]
        },
        {
          "name": "key_value_delimiter",
          "description": "The string that separates the key from the value.",
          "required": false,
          "default": "=",
          "type": [
            "string"
          ]
        },
        {
          "name": "field_delimiter",
          "description": "The string that separates each key-value pair.",
          "required": false,
          "default": " ",
          "type": [
            "string"
          ]
        },
        {
          "name": "flatten_boolean",
          "description": "Whether to encode key-value with a boolean value as a standalone key if `true` and nothing if `false`.",
          "required": false,
          "type": [
            "boolean"
          ],
          "default": false
        }
      ],
      "internal_failure_reasons": [
        "`fields_ordering` contains a non-string element."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Encode with default delimiters (no ordering)",
          "source": "encode_key_value({\"ts\": \"2021-06-05T17:20:00Z\", \"msg\": \"This is a message\", \"lvl\": \"info\"})",
          "return": "\"lvl=info msg=\\\"This is a message\\\" ts=2021-06-05T17:20:00Z\""
        },
        {
          "title": "Encode with default delimiters (fields ordering)",
          "source": "encode_key_value!({\"ts\": \"2021-06-05T17:20:00Z\", \"msg\": \"This is a message\", \"lvl\": \"info\", \"log_id\": 12345}, [\"ts\", \"lvl\", \"msg\"])",
          "return": "\"ts=2021-06-05T17:20:00Z lvl=info msg=\\\"This is a message\\\" log_id=12345\""
        },
        {
          "title": "Encode with default delimiters (nested fields)",
          "source": "encode_key_value({\"agent\": {\"name\": \"foo\"}, \"log\": {\"file\": {\"path\": \"my.log\"}}, \"event\": \"log\"})",
          "return": "\"agent.name=foo event=log log.file.path=my.log\""
        },
        {
          "title": "Encode with default delimiters (nested fields ordering)",
          "source": "encode_key_value!({\"agent\": {\"name\": \"foo\"}, \"log\": {\"file\": {\"path\": \"my.log\"}}, \"event\": \"log\"}, [\"event\", \"log.file.path\", \"agent.name\"])",
          "return": "\"event=log log.file.path=my.log agent.name=foo\""
        },
        {
          "title": "Encode with custom delimiters (no ordering)",
          "source": "encode_key_value(\n\t{\"ts\": \"2021-06-05T17:20:00Z\", \"msg\": \"This is a message\", \"lvl\": \"info\"},\n\tfield_delimiter: \",\",\n\tkey_value_delimiter: \":\"\n)",
          "return": "\"lvl:info,msg:\\\"This is a message\\\",ts:2021-06-05T17:20:00Z\""
        },
        {
          "title": "Encode with custom delimiters and flatten boolean",
          "source": "encode_key_value(\n\t{\"ts\": \"2021-06-05T17:20:00Z\", \"msg\": \"This is a message\", \"lvl\": \"info\", \"beta\": true, \"dropped\": false},\n\tfield_delimiter: \",\",\n\tkey_value_delimiter: \":\",\n\tflatten_boolean: true\n)",
          "return": "\"beta,lvl:info,msg:\\\"This is a message\\\",ts:2021-06-05T17:20:00Z\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "encode_logfmt",
      "name": "encode_logfmt",
      "category": "Codec",
      "description": "Encodes the `value` to [logfmt](https://brandur.org/logfmt).",
      "notices": [
        "If `fields_ordering` is specified then the function is fallible else it is infallible."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The value to convert to a logfmt string.",
          "required": true,
          "type": [
            "object"
          ]
        },
        {
          "name": "fields_ordering",
          "description": "The ordering of fields to preserve. Any fields not in this list are listed unordered, after all ordered fields.",
          "required": false,
          "type": [
            "array"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`fields_ordering` contains a non-string element."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Encode to logfmt (no ordering)",
          "source": "encode_logfmt({\"ts\": \"2021-06-05T17:20:00Z\", \"msg\": \"This is a message\", \"lvl\": \"info\"})",
          "return": "\"lvl=info msg=\\\"This is a message\\\" ts=2021-06-05T17:20:00Z\""
        },
        {
          "title": "Encode to logfmt (fields ordering)",
          "source": "encode_logfmt!({\"ts\": \"2021-06-05T17:20:00Z\", \"msg\": \"This is a message\", \"lvl\": \"info\", \"log_id\": 12345}, [\"ts\", \"lvl\", \"msg\"])",
          "return": "\"ts=2021-06-05T17:20:00Z lvl=info msg=\\\"This is a message\\\" log_id=12345\""
        },
        {
          "title": "Encode to logfmt (nested fields)",
          "source": "encode_logfmt({\"agent\": {\"name\": \"foo\"}, \"log\": {\"file\": {\"path\": \"my.log\"}}, \"event\": \"log\"})",
          "return": "\"agent.name=foo event=log log.file.path=my.log\""
        },
        {
          "title": "Encode to logfmt (nested fields ordering)",
          "source": "encode_logfmt!({\"agent\": {\"name\": \"foo\"}, \"log\": {\"file\": {\"path\": \"my.log\"}}, \"event\": \"log\"}, [\"event\", \"log.file.path\", \"agent.name\"])",
          "return": "\"event=log log.file.path=my.log agent.name=foo\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "encode_lz4",
      "name": "encode_lz4",
      "category": "Codec",
      "description": "Encodes the `value` to [Lz4](https://lz4.github.io/lz4/).",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to encode.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Encode to Lz4",
          "source": "encoded_text = encode_lz4!(\"The quick brown fox jumps over 13 lazy dogs.\")\nencode_base64(encoded_text)",
          "return": "\"LAAAAPAdVGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIDEzIGxhenkgZG9ncy4=\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "encode_percent",
      "name": "encode_percent",
      "category": "Codec",
      "description": "Encodes a `value` with [percent encoding](https://url.spec.whatwg.org/#percent-encoded-bytes) to safely be used in URLs.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to encode.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "ascii_set",
          "description": "The ASCII set to use when encoding the data.",
          "required": false,
          "type": [
            "string"
          ],
          "default": "NON_ALPHANUMERIC",
          "enum": {
            "NON_ALPHANUMERIC": "Encode any non-alphanumeric characters. This is the safest option.",
            "CONTROLS": "Encode only [control characters](https://infra.spec.whatwg.org/#c0-control).",
            "FRAGMENT": "Encode only [fragment characters](https://url.spec.whatwg.org/#fragment-percent-encode-set)",
            "QUERY": "Encode only [query characters](https://url.spec.whatwg.org/#query-percent-encode-set)",
            "SPECIAL": "Encode only [special characters](https://url.spec.whatwg.org/#special-percent-encode-set)",
            "PATH": "Encode only [path characters](https://url.spec.whatwg.org/#path-percent-encode-set)",
            "USERINFO": "Encode only [userinfo characters](https://url.spec.whatwg.org/#userinfo-percent-encode-set)",
            "COMPONENT": "Encode only [component characters](https://url.spec.whatwg.org/#component-percent-encode-set)",
            "WWW_FORM_URLENCODED": "Encode only [`application/x-www-form-urlencoded`](https://url.spec.whatwg.org/#application-x-www-form-urlencoded-percent-encode-set)"
          }
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Percent encode all non-alphanumeric characters (default)",
          "source": "encode_percent(\"foo bar?\")",
          "return": "\"foo%20bar%3F\""
        },
        {
          "title": "Percent encode only control characters",
          "source": "encode_percent(\"foo \tbar\", ascii_set: \"CONTROLS\")",
          "return": "\"foo %09bar\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "encode_proto",
      "name": "encode_proto",
      "category": "Codec",
      "description": "Encodes the `value` into a protocol buffer payload.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The object to convert to a protocol buffer payload.",
          "required": true,
          "type": [
            "object"
          ]
        },
        {
          "name": "desc_file",
          "description": "The path to the protobuf descriptor set file. Must be a literal string.\n\nThis file is the output of protoc -o <path> ...",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "message_type",
          "description": "The name of the message type to use for serializing.\n\nMust be a literal string.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`desc_file` file does not exist.",
        "`message_type` message type does not exist in the descriptor file."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Encode to proto",
          "source": ".payload = encode_base64(encode_proto!({\"name\": \"someone\", \"phones\": [{\"number\": \"123456\"}]}, \"resources/protobuf_descriptor_set.desc\", \"test_protobuf.Person\"))",
          "return": "\"Cgdzb21lb25lIggKBjEyMzQ1Ng==\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "encode_punycode",
      "name": "encode_punycode",
      "category": "Codec",
      "description": "Encodes a `value` to [punycode](https://en.wikipedia.org/wiki/Punycode). Useful for internationalized domain names ([IDN](https://en.wikipedia.org/wiki/Internationalized_domain_name)). This function assumes that the value passed is meant to be used in IDN context and that it is either a domain name or a part of it.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to encode.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "validate",
          "description": "Whether to validate the input string to check if it is a valid domain name.",
          "required": false,
          "type": [
            "boolean"
          ],
          "default": true
        }
      ],
      "internal_failure_reasons": [
        "`value` can not be encoded to `punycode`"
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Encode an internationalized domain name",
          "source": "encode_punycode!(\"www.café.com\")",
          "return": "\"www.xn--caf-dma.com\""
        },
        {
          "title": "Encode an internationalized domain name with mixed case",
          "source": "encode_punycode!(\"www.CAFé.com\")",
          "return": "\"www.xn--caf-dma.com\""
        },
        {
          "title": "Encode an ASCII only string",
          "source": "encode_punycode!(\"www.cafe.com\")",
          "return": "\"www.cafe.com\""
        },
        {
          "title": "Ignore validation",
          "source": "encode_punycode!(\"xn--8hbb.xn--fiba.xn--8hbf.xn--eib.\", validate: false)",
          "return": "\"xn--8hbb.xn--fiba.xn--8hbf.xn--eib.\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "encode_snappy",
      "name": "encode_snappy",
      "category": "Codec",
      "description": "Encodes the `value` to Snappy.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to encode.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` cannot be encoded into a Snappy string."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Encode to Snappy",
          "source": "encoded_text = encode_snappy!(\"The quick brown fox jumps over 13 lazy dogs.\")\nencode_base64(encoded_text)",
          "return": "\"LKxUaGUgcXVpY2sgYnJvd24gZm94IGp1bXBzIG92ZXIgMTMgbGF6eSBkb2dzLg==\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "encode_zlib",
      "name": "encode_zlib",
      "category": "Codec",
      "description": "Encodes the `value` to [Zlib](https://www.zlib.net).",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to encode.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "compression_level",
          "description": "The default compression level.",
          "required": false,
          "type": [
            "integer"
          ],
          "default": 6
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Encode to Zlib",
          "source": "encoded_text = encode_zlib(\"please encode me\")\nencode_base64(encoded_text)",
          "return": "\"eJwryElNLE5VSM1Lzk9JVchNBQA0RQX7\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "encode_zstd",
      "name": "encode_zstd",
      "category": "Codec",
      "description": "Encodes the `value` to [Zstandard](https://facebook.github.io/zstd).",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to encode.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "compression_level",
          "description": "The default compression level.",
          "required": false,
          "type": [
            "integer"
          ],
          "default": 3
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Encode to Zstd",
          "source": "encoded_text = encode_zstd(\"please encode me\")\nencode_base64(encoded_text)",
          "return": "\"KLUv/QBYgQAAcGxlYXNlIGVuY29kZSBtZQ==\""
        }
      ],
      "deprecated": false,
      "pure": true
    }
  ],
  "Cryptography": [
    {
      "anchor": "decrypt",
      "name": "decrypt",
      "category": "Cryptography",
      "description": "Decrypts a string with a symmetric encryption algorithm.\n\nSupported Algorithms:\n\n* AES-256-CFB (key = 32 bytes, iv = 16 bytes)\n* AES-192-CFB (key = 24 bytes, iv = 16 bytes)\n* AES-128-CFB (key = 16 bytes, iv = 16 bytes)\n* AES-256-OFB (key = 32 bytes, iv = 16 bytes)\n* AES-192-OFB  (key = 24 bytes, iv = 16 bytes)\n* AES-128-OFB (key = 16 bytes, iv = 16 bytes)\n* AES-128-SIV (key = 32 bytes, iv = 16 bytes)\n* AES-256-SIV (key = 64 bytes, iv = 16 bytes)\n* Deprecated - AES-256-CTR (key = 32 bytes, iv = 16 bytes)\n* Deprecated - AES-192-CTR (key = 24 bytes, iv = 16 bytes)\n* Deprecated - AES-128-CTR (key = 16 bytes, iv = 16 bytes)\n* AES-256-CTR-LE (key = 32 bytes, iv = 16 bytes)\n* AES-192-CTR-LE (key = 24 bytes, iv = 16 bytes)\n* AES-128-CTR-LE (key = 16 bytes, iv = 16 bytes)\n* AES-256-CTR-BE (key = 32 bytes, iv = 16 bytes)\n* AES-192-CTR-BE (key = 24 bytes, iv = 16 bytes)\n* AES-128-CTR-BE (key = 16 bytes, iv = 16 bytes)\n* AES-256-CBC-PKCS7 (key = 32 bytes, iv = 16 bytes)\n* AES-192-CBC-PKCS7 (key = 24 bytes, iv = 16 bytes)\n* AES-128-CBC-PKCS7 (key = 16 bytes, iv = 16 bytes)\n* AES-256-CBC-ANSIX923 (key = 32 bytes, iv = 16 bytes)\n* AES-192-CBC-ANSIX923 (key = 24 bytes, iv = 16 bytes)\n* AES-128-CBC-ANSIX923 (key = 16 bytes, iv = 16 bytes)\n* AES-256-CBC-ISO7816 (key = 32 bytes, iv = 16 bytes)\n* AES-192-CBC-ISO7816 (key = 24 bytes, iv = 16 bytes)\n* AES-128-CBC-ISO7816 (key = 16 bytes, iv = 16 bytes)\n* AES-256-CBC-ISO10126 (key = 32 bytes, iv = 16 bytes)\n* AES-192-CBC-ISO10126 (key = 24 bytes, iv = 16 bytes)\n* AES-128-CBC-ISO10126 (key = 16 bytes, iv = 16 bytes)\n* CHACHA20-POLY1305 (key = 32 bytes, iv = 12 bytes)\n* XCHACHA20-POLY1305 (key = 32 bytes, iv = 24 bytes)\n* XSALSA20-POLY1305 (key = 32 bytes, iv = 24 bytes)",
      "notices": [],
      "arguments": [
        {
          "name": "ciphertext",
          "description": "The string in raw bytes (not encoded) to decrypt.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "algorithm",
          "description": "The algorithm to use.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "key",
          "description": "The key in raw bytes (not encoded) for decryption. The length must match the algorithm requested.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "iv",
          "description": "The IV in raw bytes (not encoded) for decryption. The length must match the algorithm requested.\nA new IV should be generated for every message. You can use `random_bytes` to generate a cryptographically secure random value.\nThe value should match the one used during encryption.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`algorithm` is not a supported algorithm.",
        "`key` length does not match the key size required for the algorithm specified.",
        "`iv` length does not match the `iv` size required for the algorithm specified."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Decrypt value",
          "source": "ciphertext = decode_base64!(\"5fLGcu1VHdzsPcGNDio7asLqE1P43QrVfPfmP4i4zOU=\")\niv = decode_base64!(\"fVEIRkIiczCRWNxaarsyxA==\")\nkey = \"16_byte_keyxxxxx\"\ndecrypt!(ciphertext, \"AES-128-CBC-PKCS7\", key, iv: iv)",
          "return": "\"super_secret_message\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "encrypt",
      "name": "encrypt",
      "category": "Cryptography",
      "description": "Encrypts a string with a symmetric encryption algorithm.\n\nSupported Algorithms:\n\n* AES-256-CFB (key = 32 bytes, iv = 16 bytes)\n* AES-192-CFB (key = 24 bytes, iv = 16 bytes)\n* AES-128-CFB (key = 16 bytes, iv = 16 bytes)\n* AES-256-OFB (key = 32 bytes, iv = 16 bytes)\n* AES-192-OFB  (key = 24 bytes, iv = 16 bytes)\n* AES-128-OFB (key = 16 bytes, iv = 16 bytes)\n* AES-128-SIV (key = 32 bytes, iv = 16 bytes)\n* AES-256-SIV (key = 64 bytes, iv = 16 bytes)\n* Deprecated - AES-256-CTR (key = 32 bytes, iv = 16 bytes)\n* Deprecated - AES-192-CTR (key = 24 bytes, iv = 16 bytes)\n* Deprecated - AES-128-CTR (key = 16 bytes, iv = 16 bytes)\n* AES-256-CTR-LE (key = 32 bytes, iv = 16 bytes)\n* AES-192-CTR-LE (key = 24 bytes, iv = 16 bytes)\n* AES-128-CTR-LE (key = 16 bytes, iv = 16 bytes)\n* AES-256-CTR-BE (key = 32 bytes, iv = 16 bytes)\n* AES-192-CTR-BE (key = 24 bytes, iv = 16 bytes)\n* AES-128-CTR-BE (key = 16 bytes, iv = 16 bytes)\n* AES-256-CBC-PKCS7 (key = 32 bytes, iv = 16 bytes)\n* AES-192-CBC-PKCS7 (key = 24 bytes, iv = 16 bytes)\n* AES-128-CBC-PKCS7 (key = 16 bytes, iv = 16 bytes)\n* AES-256-CBC-ANSIX923 (key = 32 bytes, iv = 16 bytes)\n* AES-192-CBC-ANSIX923 (key = 24 bytes, iv = 16 bytes)\n* AES-128-CBC-ANSIX923 (key = 16 bytes, iv = 16 bytes)\n* AES-256-CBC-ISO7816 (key = 32 bytes, iv = 16 bytes)\n* AES-192-CBC-ISO7816 (key = 24 bytes, iv = 16 bytes)\n* AES-128-CBC-ISO7816 (key = 16 bytes, iv = 16 bytes)\n* AES-256-CBC-ISO10126 (key = 32 bytes, iv = 16 bytes)\n* AES-192-CBC-ISO10126 (key = 24 bytes, iv = 16 bytes)\n* AES-128-CBC-ISO10126 (key = 16 bytes, iv = 16 bytes)\n* CHACHA20-POLY1305 (key = 32 bytes, iv = 12 bytes)\n* XCHACHA20-POLY1305 (key = 32 bytes, iv = 24 bytes)\n* XSALSA20-POLY1305 (key = 32 bytes, iv = 24 bytes)",
      "notices": [],
      "arguments": [
        {
          "name": "plaintext",
          "description": "The string to encrypt.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "algorithm",
          "description": "The algorithm to use.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "key",
          "description": "The key in raw bytes (not encoded) for encryption. The length must match the algorithm requested.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "iv",
          "description": "The IV in raw bytes (not encoded) for encryption. The length must match the algorithm requested.\nA new IV should be generated for every message. You can use `random_bytes` to generate a cryptographically secure random value.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`algorithm` is not a supported algorithm.",
        "`key` length does not match the key size required for the algorithm specified.",
        "`iv` length does not match the `iv` size required for the algorithm specified."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Encrypt value",
          "source": "plaintext = \"super secret message\"\niv = \"1234567890123456\" # typically you would call random_bytes(16)\nkey = \"16_byte_keyxxxxx\"\nencrypted_message = encrypt!(plaintext, \"AES-128-CBC-PKCS7\", key, iv: iv)\nencode_base64(encrypted_message)",
          "return": "\"GBw8Mu00v0Kc38+/PvsVtGgWuUJ+ZNLgF8Opy8ohIYE=\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "hmac",
      "name": "hmac",
      "category": "Cryptography",
      "description": "Calculates a [HMAC](https://en.wikipedia.org/wiki/HMAC) of the `value` using the given `key`.\nThe hashing `algorithm` used can be optionally specified.\n\nFor most use cases, the resulting bytestream should be encoded into a hex or base64\nstring using either [encode_base16](/docs/reference/vrl/functions/#encode_base16) or\n[encode_base64](/docs/reference/vrl/functions/#encode_base64).\n\nThis function is infallible if either the default `algorithm` value or a recognized-valid compile-time\n`algorithm` string literal is used. Otherwise, it is fallible.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to calculate the HMAC for.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "key",
          "description": "The string to use as the cryptographic key.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "algorithm",
          "description": "The hashing algorithm to use.",
          "enum": {
            "SHA1": "SHA1 algorithm",
            "SHA-224": "SHA-224 algorithm",
            "SHA-256": "SHA-256 algorithm",
            "SHA-384": "SHA-384 algorithm",
            "SHA-512": "SHA-512 algorithm"
          },
          "required": false,
          "default": "SHA-256",
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Calculate message HMAC (defaults: SHA-256), encoding to a base64 string",
          "source": "encode_base64(hmac(\"Hello there\", \"super-secret-key\"))",
          "return": "\"eLGE8YMviv85NPXgISRUZxstBNSU47JQdcXkUWcClmI=\""
        },
        {
          "title": "Calculate message HMAC using SHA-224, encoding to a hex-encoded string",
          "source": "encode_base16(hmac(\"Hello there\", \"super-secret-key\", algorithm: \"SHA-224\"))",
          "return": "\"42fccbc2b7d22a143b92f265a8046187558a94d11ddbb30622207e90\""
        },
        {
          "title": "Calculate message HMAC using a variable hash algorithm",
          "source": ".hash_algo = \"SHA-256\"\nhmac_bytes, err = hmac(\"Hello there\", \"super-secret-key\", algorithm: .hash_algo)\nif err == null {\n\t.hmac = encode_base16(hmac_bytes)\n}",
          "return": "\"78b184f1832f8aff3934f5e0212454671b2d04d494e3b25075c5e45167029662\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "md5",
      "name": "md5",
      "category": "Cryptography",
      "description": "Calculates an md5 hash of the `value`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to calculate the hash for.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Create md5 hash",
          "source": "md5(\"foo\")",
          "return": "\"acbd18db4cc2f85cedef654fccc4a4d8\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "seahash",
      "name": "seahash",
      "category": "Cryptography",
      "description": "Calculates a [Seahash](https://docs.rs/seahash/latest/seahash/) hash of the `value`.\n**Note**: Due to limitations in the underlying VRL data types, this function converts the unsigned 64-bit integer SeaHash result to a signed 64-bit integer. Results higher than the signed 64-bit integer maximum value wrap around to negative values.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to calculate the hash for.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "integer"
        ]
      },
      "examples": [
        {
          "title": "Calculate seahash",
          "source": "seahash(\"foobar\")",
          "return": "5348458858952426000"
        },
        {
          "title": "Calculate negative seahash",
          "source": "seahash(\"bar\")",
          "return": "-2796170501982571500"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "sha1",
      "name": "sha1",
      "category": "Cryptography",
      "description": "Calculates a [SHA-1](https://en.wikipedia.org/wiki/SHA-1) hash of the `value`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to calculate the hash for.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Calculate sha1 hash",
          "source": "sha1(\"foo\")",
          "return": "\"0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "sha2",
      "name": "sha2",
      "category": "Cryptography",
      "description": "Calculates a [SHA-2](https://en.wikipedia.org/wiki/SHA-2) hash of the `value`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to calculate the hash for.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "variant",
          "description": "The variant of the algorithm to use.",
          "enum": {
            "SHA-224": "SHA-224 algorithm",
            "SHA-256": "SHA-256 algorithm",
            "SHA-384": "SHA-384 algorithm",
            "SHA-512": "SHA-512 algorithm",
            "SHA-512/224": "SHA-512/224 algorithm",
            "SHA-512/256": "SHA-512/256 algorithm"
          },
          "required": false,
          "default": "SHA-512/256",
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Calculate sha2 hash",
          "source": "sha2(\"foo\", variant: \"SHA-512/224\")",
          "return": "\"d68f258d37d670cfc1ec1001a0394784233f88f056994f9a7e5e99be\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "sha3",
      "name": "sha3",
      "category": "Cryptography",
      "description": "Calculates a [SHA-3](https://en.wikipedia.org/wiki/SHA-3) hash of the `value`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to calculate the hash for.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "variant",
          "description": "The variant of the algorithm to use.",
          "enum": {
            "SHA3-224": "SHA3-224 algorithm",
            "SHA3-256": "SHA3-256 algorithm",
            "SHA3-384": "SHA3-384 algorithm",
            "SHA3-512": "SHA3-512 algorithm"
          },
          "required": false,
          "default": "SHA3-512",
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Calculate sha3 hash",
          "source": "sha3(\"foo\", variant: \"SHA3-224\")",
          "return": "\"f4f6779e153c391bbd29c95e72b0708e39d9166c7cea51d1f10ef58a\""
        }
      ],
      "deprecated": false,
      "pure": true
    }
  ],
  "Path": [
    {
      "anchor": "del",
      "name": "del",
      "category": "Path",
      "description": "Removes the field specified by the static `path` from the target.\n\nFor dynamic path deletion, see the `remove` function.",
      "pure": false,
      "arguments": [
        {
          "name": "path",
          "description": "The path of the field to delete.",
          "required": true,
          "type": [
            "path"
          ]
        },
        {
          "name": "compact",
          "description": "After deletion, if `compact` is `true` and there is an empty object or array left,\nthe empty object or array is also removed, cascading up to the root. This only\napplies to the path being deleted, and any parent paths.",
          "required": false,
          "default": false,
          "type": [
            "boolean"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "notices": [
        "The `del` function _modifies the current event in place_ and returns the value of the deleted field."
      ],
      "return": {
        "types": [
          "any"
        ],
        "rules": [
          "Returns the value of the field being deleted. Returns `null` if the field doesn't exist."
        ]
      },
      "examples": [
        {
          "title": "Delete a field",
          "input": {
            "log": {
              "field1": 1,
              "field2": 2
            }
          },
          "source": "del(.field1)",
          "output": {
            "log": {
              "field2": 2
            }
          }
        },
        {
          "title": "Rename a field",
          "input": {
            "log": {
              "old_field": "please rename me"
            }
          },
          "source": ".new_field = del(.old_field)",
          "output": {
            "log": {
              "new_field": "please rename me"
            }
          }
        }
      ],
      "deprecated": false
    },
    {
      "anchor": "exists",
      "name": "exists",
      "category": "Path",
      "description": "Checks whether the `path` exists for the target.\n\nThis function distinguishes between a missing path\nand a path with a `null` value. A regular path lookup,\nsuch as `.foo`, cannot distinguish between the two cases\nsince it always returns `null` if the path doesn't exist.",
      "notices": [],
      "arguments": [
        {
          "name": "path",
          "description": "The path of the field to check.",
          "required": true,
          "type": [
            "path"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ]
      },
      "examples": [
        {
          "title": "Exists (field)",
          "input": {
            "log": {
              "field": 1
            }
          },
          "source": "exists(.field)",
          "return": "true"
        },
        {
          "title": "Exists (array element)",
          "input": {
            "log": {
              "array": [
                1,
                2,
                3
              ]
            }
          },
          "source": "exists(.array[2])",
          "return": "true"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "get",
      "name": "get",
      "category": "Path",
      "description": "Dynamically get the value of a given path.\n\nIf you know the path you want to look up, use\nstatic paths such as `.foo.bar[1]` to get the value of that\npath. However, if you do not know the path names,\nuse the dynamic `get` function to get the requested\nvalue.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The object or array to query.",
          "required": true,
          "type": [
            "object",
            "array"
          ]
        },
        {
          "name": "path",
          "description": "An array of path segments to look for the value.",
          "required": true,
          "type": [
            "array"
          ]
        }
      ],
      "internal_failure_reasons": [
        "The `path` segment must be a string or an integer."
      ],
      "return": {
        "types": [
          "any"
        ]
      },
      "examples": [
        {
          "title": "single-segment top-level field",
          "source": "get!(value: { \"foo\": \"bar\" }, path: [\"foo\"])",
          "return": "\"bar\""
        },
        {
          "title": "multi-segment nested field",
          "source": "get!(value: { \"foo\": { \"bar\": \"baz\" } }, path: [\"foo\", \"bar\"])",
          "return": "\"baz\""
        },
        {
          "title": "array indexing",
          "source": "get!(value: [\"foo\", \"bar\", \"baz\"], path: [-2])",
          "return": "\"bar\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "remove",
      "name": "remove",
      "category": "Path",
      "description": "Dynamically remove the value for a given path.\n\nIf you know the path you want to remove, use\nthe `del` function and static paths such as `del(.foo.bar[1])`\nto remove the value at that path. The `del` function returns the\ndeleted value, and is more performant than `remove`.\nHowever, if you do not know the path names, use the dynamic\n`remove` function to remove the value at the provided path.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The object or array to remove data from.",
          "required": true,
          "type": [
            "object",
            "array"
          ]
        },
        {
          "name": "path",
          "description": "An array of path segments to remove the value from.",
          "required": true,
          "type": [
            "array"
          ]
        },
        {
          "name": "compact",
          "description": "After deletion, if `compact` is `true`, any empty objects or\narrays left are also removed.",
          "required": false,
          "default": false,
          "type": [
            "boolean"
          ]
        }
      ],
      "internal_failure_reasons": [
        "The `path` segment must be a string or an integer."
      ],
      "return": {
        "types": [
          "object",
          "array"
        ]
      },
      "examples": [
        {
          "title": "single-segment top-level field",
          "source": "remove!(value: { \"foo\": \"bar\" }, path: [\"foo\"])",
          "return": "{}"
        },
        {
          "title": "multi-segment nested field",
          "source": "remove!(value: { \"foo\": { \"bar\": \"baz\" } }, path: [\"foo\", \"bar\"])",
          "return": "{\"foo\":{}}"
        },
        {
          "title": "array indexing",
          "source": "remove!(value: [\"foo\", \"bar\", \"baz\"], path: [-2])",
          "return": "[\"foo\",\"baz\"]"
        },
        {
          "title": "compaction",
          "source": "remove!(value: { \"foo\": { \"bar\": [42], \"baz\": true } }, path: [\"foo\", \"bar\", 0], compact: true)",
          "return": "{\"foo\":{\"baz\":true}}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "set",
      "name": "set",
      "category": "Path",
      "description": "Dynamically insert data into the path of a given object or array.\n\nIf you know the path you want to assign a value to,\nuse static path assignments such as `.foo.bar[1] = true` for\nimproved performance and readability. However, if you do not\nknow the path names, use the dynamic `set` function to\ninsert the data into the object or array.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The object or array to insert data into.",
          "required": true,
          "type": [
            "object",
            "array"
          ]
        },
        {
          "name": "path",
          "description": "An array of path segments to insert the value into.",
          "required": true,
          "type": [
            "array"
          ]
        },
        {
          "name": "data",
          "description": "The data to be inserted.",
          "required": true,
          "type": [
            "any"
          ]
        }
      ],
      "internal_failure_reasons": [
        "The `path` segment must be a string or an integer."
      ],
      "return": {
        "types": [
          "object",
          "array"
        ]
      },
      "examples": [
        {
          "title": "single-segment top-level field",
          "source": "set!(value: { \"foo\": \"bar\" }, path: [\"foo\"], data: \"baz\")",
          "return": "{\"foo\":\"baz\"}"
        },
        {
          "title": "multi-segment nested field",
          "source": "set!(value: { \"foo\": { \"bar\": \"baz\" } }, path: [\"foo\", \"bar\"], data: \"qux\")",
          "return": "{\"foo\":{\"bar\":\"qux\"}}"
        },
        {
          "title": "array",
          "source": "set!(value: [\"foo\", \"bar\", \"baz\"], path: [-2], data: 42)",
          "return": "[\"foo\",42,\"baz\"]"
        }
      ],
      "deprecated": false,
      "pure": true
    }
  ],
  "Enrichment": [
    {
      "anchor": "find_enrichment_table_records",
      "name": "find_enrichment_table_records",
      "category": "Enrichment",
      "description": "Searches an [enrichment table](/docs/reference/glossary/#enrichment-tables) for rows that match the\nprovided condition.\n\nFor `file` enrichment tables, this condition needs to be a VRL object in which\nthe key-value pairs indicate a field to\tsearch mapped to a value to search in that field.\nThis function returns the rows that match the provided condition(s). _All_ fields need to\nmatch for rows to be returned; if any fields do not match, then no rows are returned.\n\nThere are currently two forms of search criteria:\n\n1. **Exact match search**. The given field must match the value exactly. Case sensitivity\n   can be specified using the `case_sensitive` argument. An exact match search can use an\n   index directly into the dataset, which should make this search fairly \"cheap\" from a\n   performance perspective.\n\n2. **Date range search**. The given field must be greater than or equal to the `from` date\n   and/or less than or equal to the `to` date. A date range search involves\n   sequentially scanning through the rows that have been located using any exact match\n   criteria. This can be an expensive operation if there are many rows returned by any exact\n   match criteria. Therefore, use date ranges as the _only_ criteria when the enrichment\n   data set is very small.\n\nFor `geoip` and `mmdb` enrichment tables, this condition needs to be a VRL object with a single key-value pair\nwhose value needs to be a valid IP address. Example: `{\"ip\": .ip }`. If a return field is expected\nand without a value, `null` is used. This table can return the following fields:\n\n* ISP databases:\n\t* `autonomous_system_number`\n\t* `autonomous_system_organization`\n\t* `isp`\n\t* `organization`\n\n* City databases:\n\t* `city_name`\n\t* `continent_code`\n\t* `country_code`\n\t* `country_name`\n\t* `region_code`\n\t* `region_name`\n\t* `metro_code`\n\t* `latitude`\n\t* `longitude`\n\t* `postal_code`\n\t* `timezone`\n\n* Connection-Type databases:\n\t* `connection_type`\n\nTo use this function, you need to update your configuration to\ninclude an\n[`enrichment_tables`](/docs/reference/configuration/global-options/#enrichment_tables)\nparameter.",
      "notices": [],
      "arguments": [
        {
          "name": "table",
          "description": "The [enrichment table](/docs/reference/glossary/#enrichment-tables) to search.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "condition",
          "description": "The condition to search on. Since the condition is used at boot time to create\nindices into the data, these conditions must be statically defined.",
          "required": true,
          "type": [
            "object"
          ]
        },
        {
          "name": "select",
          "description": "A subset of fields from the enrichment table to return. If not specified,\nall fields are returned.",
          "required": false,
          "type": [
            "array"
          ]
        },
        {
          "name": "case_sensitive",
          "description": "Whether text fields need to match cases exactly.",
          "required": false,
          "type": [
            "boolean"
          ],
          "default": true
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "array"
        ]
      },
      "examples": [
        {
          "title": "Exact match",
          "source": "find_enrichment_table_records!(\"test\",\n  {\n\t\"surname\": \"smith\",\n  },\n  case_sensitive: false)",
          "return": "[{\"id\":1,\"firstname\":\"Bob\",\"surname\":\"Smith\"},{\"id\":2,\"firstname\":\"Fred\",\"surname\":\"Smith\"}]"
        },
        {
          "title": "Date range search",
          "source": "find_enrichment_table_records!(\"test\",\n  {\n\t\"surname\": \"Smith\",\n\t\"date_of_birth\": {\n\t  \"from\": t'1985-01-01T00:00:00Z',\n\t  \"to\": t'1985-12-31T00:00:00Z'\n\t}\n  })",
          "return": "[{\"id\":1,\"firstname\":\"Bob\",\"surname\":\"Smith\"},{\"id\":2,\"firstname\":\"Fred\",\"surname\":\"Smith\"}]"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "get_enrichment_table_record",
      "name": "get_enrichment_table_record",
      "category": "Enrichment",
      "description": "Searches an [enrichment table](/docs/reference/glossary/#enrichment-tables) for a row that matches the\nprovided condition. A single row must be matched. If no rows are found or more than one row is\nfound, an error is returned.\n\nFor `file` enrichment tables, this condition needs to be a VRL object in which\nthe key-value pairs indicate a field to\tsearch mapped to a value to search in that field.\nThis function returns the rows that match the provided condition(s). _All_ fields need to\nmatch for rows to be returned; if any fields do not match, then no rows are returned.\n\nThere are currently two forms of search criteria:\n\n1. **Exact match search**. The given field must match the value exactly. Case sensitivity\n   can be specified using the `case_sensitive` argument. An exact match search can use an\n   index directly into the dataset, which should make this search fairly \"cheap\" from a\n   performance perspective.\n\n2. **Date range search**. The given field must be greater than or equal to the `from` date\n   and/or less than or equal to the `to` date. A date range search involves\n   sequentially scanning through the rows that have been located using any exact match\n   criteria. This can be an expensive operation if there are many rows returned by any exact\n   match criteria. Therefore, use date ranges as the _only_ criteria when the enrichment\n   data set is very small.\n\nFor `geoip` and `mmdb` enrichment tables, this condition needs to be a VRL object with a single key-value pair\nwhose value needs to be a valid IP address. Example: `{\"ip\": .ip }`. If a return field is expected\nand without a value, `null` is used. This table can return the following fields:\n\n* ISP databases:\n\t* `autonomous_system_number`\n\t* `autonomous_system_organization`\n\t* `isp`\n\t* `organization`\n\n* City databases:\n\t* `city_name`\n\t* `continent_code`\n\t* `country_code`\n\t* `country_name`\n\t* `region_code`\n\t* `region_name`\n\t* `metro_code`\n\t* `latitude`\n\t* `longitude`\n\t* `postal_code`\n\t* `timezone`\n\n* Connection-Type databases:\n\t* `connection_type`\n\nTo use this function, you need to update your configuration to\ninclude an\n[`enrichment_tables`](/docs/reference/configuration/global-options/#enrichment_tables)\nparameter.",
      "notices": [],
      "arguments": [
        {
          "name": "table",
          "description": "The [enrichment table](/docs/reference/glossary/#enrichment-tables) to search.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "condition",
          "description": "The condition to search on. Since the condition is used at boot time to create\nindices into the data, these conditions must be statically defined.",
          "required": true,
          "type": [
            "object"
          ]
        },
        {
          "name": "select",
          "description": "A subset of fields from the enrichment table to return. If not specified,\nall fields are returned.",
          "required": false,
          "type": [
            "array"
          ]
        },
        {
          "name": "case_sensitive",
          "description": "Whether the text fields match the case exactly.",
          "required": false,
          "type": [
            "boolean"
          ],
          "default": true
        }
      ],
      "internal_failure_reasons": [
        "The row is not found.",
        "Multiple rows are found that match the condition."
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Exact match",
          "source": "get_enrichment_table_record!(\"test\",\n  {\n    \"surname\": \"bob\",\n    \"firstname\": \"John\"\n  },\n  case_sensitive: false)",
          "return": "{\"id\":1,\"firstname\":\"Bob\",\"surname\":\"Smith\"}"
        },
        {
          "title": "Date range search",
          "source": "get_enrichment_table_record!(\"test\",\n  {\n    \"surname\": \"Smith\",\n    \"date_of_birth\": {\n      \"from\": t'1985-01-01T00:00:00Z',\n      \"to\": t'1985-12-31T00:00:00Z'\n    }\n  })",
          "return": "{\"id\":1,\"firstname\":\"Bob\",\"surname\":\"Smith\"}"
        }
      ],
      "deprecated": false,
      "pure": true
    }
  ],
  "Timestamp": [
    {
      "anchor": "format_timestamp",
      "name": "format_timestamp",
      "category": "Timestamp",
      "description": "Formats `value` into a string representation of the timestamp.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The timestamp to format as text.",
          "required": true,
          "type": [
            "timestamp"
          ]
        },
        {
          "name": "format",
          "description": "The format string as described by the [Chrono library](https://docs.rs/chrono/latest/chrono/format/strftime/index.html#specifiers).",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "timezone",
          "description": "The timezone to use when formatting the timestamp. The parameter uses the TZ identifier or `local`.",
          "required": false,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Format a timestamp (ISO8601/RFC 3339)",
          "source": "format_timestamp!(t'2020-10-21T16:00:00Z', format: \"%+\")",
          "return": "\"2020-10-21T16:00:00+00:00\""
        },
        {
          "title": "Format a timestamp (custom)",
          "source": "format_timestamp!(t'2020-10-21T16:00:00Z', format: \"%v %R\")",
          "return": "\"21-Oct-2020 16:00\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "now",
      "name": "now",
      "category": "Timestamp",
      "description": "Returns the current timestamp in the UTC timezone with nanosecond precision.",
      "notices": [],
      "arguments": [],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "timestamp"
        ]
      },
      "examples": [
        {
          "title": "Generate a current timestamp",
          "source": "now()",
          "return": "\"2021-03-04T10:51:15.928937Z\""
        }
      ],
      "deprecated": false,
      "pure": true
    }
  ],
  "Convert": [
    {
      "anchor": "from_unix_timestamp",
      "name": "from_unix_timestamp",
      "category": "Convert",
      "description": "Converts the `value` integer from a [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time) to a VRL `timestamp`.\n\nConverts from the number of seconds since the Unix epoch by default. To convert from milliseconds or nanoseconds, set the `unit` argument to `milliseconds` or `nanoseconds`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The Unix timestamp to convert.",
          "required": true,
          "type": [
            "integer"
          ]
        },
        {
          "name": "unit",
          "description": "The time unit.",
          "type": [
            "string"
          ],
          "required": false,
          "enum": {
            "seconds": "Express Unix time in seconds",
            "milliseconds": "Express Unix time in milliseconds",
            "nanoseconds": "Express Unix time in nanoseconds",
            "microseconds": "Express Unix time in microseconds"
          },
          "default": "seconds"
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "timestamp"
        ]
      },
      "examples": [
        {
          "title": "Convert from a Unix timestamp (seconds)",
          "source": "from_unix_timestamp!(5)",
          "return": "\"1970-01-01T00:00:05Z\""
        },
        {
          "title": "Convert from a Unix timestamp (milliseconds)",
          "source": "from_unix_timestamp!(5000, unit: \"milliseconds\")",
          "return": "\"1970-01-01T00:00:05Z\""
        },
        {
          "title": "Convert from a Unix timestamp (nanoseconds)",
          "source": "from_unix_timestamp!(5000, unit: \"nanoseconds\")",
          "return": "\"1970-01-01T00:00:00.000005Z\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "to_syslog_facility",
      "name": "to_syslog_facility",
      "category": "Convert",
      "description": "Converts the `value`, a Syslog [facility code](https://en.wikipedia.org/wiki/Syslog#Facility), into its corresponding\nSyslog keyword. For example, `0` into `\"kern\"`, `1` into `\"user\"`, etc.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The facility code.",
          "required": true,
          "type": [
            "integer"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a valid Syslog [facility code](https://en.wikipedia.org/wiki/Syslog#Facility)."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Coerce to a Syslog facility",
          "source": "to_syslog_facility!(4)",
          "return": "\"auth\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "to_syslog_facility_code",
      "name": "to_syslog_facility_code",
      "category": "Convert",
      "description": "Converts the `value`, a Syslog [facility keyword](https://en.wikipedia.org/wiki/Syslog#Facility), into a Syslog integer\nfacility code (`0` to `23`).",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The Syslog facility keyword to convert.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a valid Syslog facility keyword."
      ],
      "return": {
        "types": [
          "integer"
        ]
      },
      "examples": [
        {
          "title": "Coerce to Syslog facility code",
          "source": "to_syslog_facility_code!(\"authpriv\")",
          "return": "10"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "to_syslog_level",
      "name": "to_syslog_level",
      "category": "Convert",
      "description": "Converts the `value`, a Syslog [severity level](https://en.wikipedia.org/wiki/Syslog#Severity_level), into its corresponding keyword,\ni.e. 0 into `\"emerg\"`, 1 into `\"alert\"`, etc.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The severity level.",
          "required": true,
          "type": [
            "integer"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` isn't a valid Syslog [severity level](https://en.wikipedia.org/wiki/Syslog#Severity_level)."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Coerce to a Syslog level",
          "source": "to_syslog_level!(5)",
          "return": "\"notice\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "to_syslog_severity",
      "name": "to_syslog_severity",
      "category": "Convert",
      "description": "Converts the `value`, a Syslog [log level keyword](https://en.wikipedia.org/wiki/Syslog#Severity_level), into a Syslog integer\nseverity level (`0` to `7`).",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The Syslog level keyword to convert.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a valid Syslog level keyword."
      ],
      "return": {
        "types": [
          "integer"
        ],
        "rules": [
          "The now-deprecated keywords `panic`, `error`, and `warn` are converted to `0`, `3`, and `4` respectively."
        ]
      },
      "examples": [
        {
          "title": "Coerce to Syslog severity",
          "source": "to_syslog_severity!(\"alert\")",
          "return": "1"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "to_unix_timestamp",
      "name": "to_unix_timestamp",
      "category": "Convert",
      "description": "Converts the `value` timestamp into a [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time).\n\nReturns the number of seconds since the Unix epoch by default. To return the number in milliseconds or nanoseconds, set the `unit` argument to `milliseconds` or `nanoseconds`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The timestamp to convert into a Unix timestamp.",
          "required": true,
          "type": [
            "timestamp"
          ]
        },
        {
          "name": "unit",
          "description": "The time unit.",
          "type": [
            "string"
          ],
          "required": false,
          "enum": {
            "seconds": "Express Unix time in seconds",
            "milliseconds": "Express Unix time in milliseconds",
            "nanoseconds": "Express Unix time in nanoseconds"
          },
          "default": "seconds"
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "integer"
        ]
      },
      "examples": [
        {
          "title": "Convert to a Unix timestamp (seconds)",
          "source": "to_unix_timestamp(t'2021-01-01T00:00:00+00:00')",
          "return": "1609459200"
        },
        {
          "title": "Convert to a Unix timestamp (milliseconds)",
          "source": "to_unix_timestamp(t'2021-01-01T00:00:00Z', unit: \"milliseconds\")",
          "return": "1609459200000"
        },
        {
          "title": "Convert to a Unix timestamp (nanoseconds)",
          "source": "to_unix_timestamp(t'2021-01-01T00:00:00Z', unit: \"nanoseconds\")",
          "return": "1609459200000000000"
        }
      ],
      "deprecated": false,
      "pure": true
    }
  ],
  "System": [
    {
      "anchor": "get_hostname",
      "name": "get_hostname",
      "category": "System",
      "description": "Returns the local system's hostname.",
      "notices": [],
      "arguments": [],
      "internal_failure_reasons": [
        "Internal hostname resolution failed."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Get hostname",
          "input": {
            "log": {}
          },
          "source": ".hostname = get_hostname!()",
          "output": {
            "log": {
              "hostname": "localhost.localdomain"
            }
          }
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "get_timezone_name",
      "name": "get_timezone_name",
      "category": "System",
      "description": "Returns the name of the timezone in the Vector configuration (see\n[global configuration options](/docs/reference/configuration/global-options)).\nIf the configuration is set to `local`, then it attempts to\ndetermine the name of the timezone from the host OS. If this\nis not possible, then it returns the fixed offset of the\nlocal timezone for the current time in the format `\"[+-]HH:MM\"`,\nfor example, `\"+02:00\"`.",
      "notices": [],
      "arguments": [],
      "internal_failure_reasons": [
        "Retrieval of local timezone information failed."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Get the IANA name of Vector's timezone",
          "input": {
            "log": {}
          },
          "source": ".vector_timezone = get_timezone_name!()",
          "output": {
            "log": {
              "vector_timezone": "UTC"
            }
          }
        }
      ],
      "deprecated": false,
      "pure": true
    }
  ],
  "IP": [
    {
      "anchor": "ip_aton",
      "name": "ip_aton",
      "category": "IP",
      "description": "Converts IPv4 address in numbers-and-dots notation into network-order\nbytes represented as an integer.\n\nThis behavior mimics [inet_aton](https://linux.die.net/man/3/inet_aton).",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The IP address to convert to binary.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a valid IPv4 address."
      ],
      "return": {
        "types": [
          "integer"
        ]
      },
      "examples": [
        {
          "title": "IPv4 to integer",
          "source": "ip_aton!(\"1.2.3.4\")",
          "return": "16909060"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "ip_cidr_contains",
      "name": "ip_cidr_contains",
      "category": "IP",
      "description": "Determines whether the `ip` is contained in the block referenced by the `cidr`.",
      "notices": [],
      "arguments": [
        {
          "name": "cidr",
          "description": "The CIDR mask (v4 or v6).",
          "required": true,
          "type": [
            "string",
            "array"
          ]
        },
        {
          "name": "ip",
          "description": "The IP address (v4 or v6).",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`cidr` is not a valid CIDR.",
        "`ip` is not a valid IP address."
      ],
      "return": {
        "types": [
          "boolean"
        ]
      },
      "examples": [
        {
          "title": "IPv4 contains CIDR",
          "source": "ip_cidr_contains!(\"192.168.0.0/16\", \"192.168.10.32\")",
          "return": "true"
        },
        {
          "title": "IPv4 is private",
          "source": "ip_cidr_contains!([\"10.0.0.0/8\", \"172.16.0.0/12\", \"192.168.0.0/16\"], \"192.168.10.32\")",
          "return": "true"
        },
        {
          "title": "IPv6 contains CIDR",
          "source": "ip_cidr_contains!(\"2001:4f8:4:ba::/64\", \"2001:4f8:4:ba:2e0:81ff:fe22:d1f1\")",
          "return": "true"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "ip_ntoa",
      "name": "ip_ntoa",
      "category": "IP",
      "description": "Converts numeric representation of IPv4 address in network-order bytes\nto numbers-and-dots notation.\n\nThis behavior mimics [inet_ntoa](https://linux.die.net/man/3/inet_ntoa).",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The integer representation of an IPv4 address.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` cannot fit in an unsigned 32-bit integer."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Integer to IPv4",
          "source": "ip_ntoa!(16909060)",
          "return": "\"1.2.3.4\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "ip_ntop",
      "name": "ip_ntop",
      "category": "IP",
      "description": "Converts IPv4 and IPv6 addresses from binary to text form.\n\nThis behavior mimics [inet_ntop](https://linux.die.net/man/3/inet_ntop).",
      "notices": [
        "The binary data for this function is not easily printable.\nHowever, the results from functions such as `decode_base64` or\n`decode_percent` can still be used correctly."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The binary data to convert from.\nFor IPv4 addresses, it must be 4 bytes (32 bits) long.\nFor IPv6 addresses, it must be 16 bytes (128 bits) long.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` must be of length 4 or 16 bytes."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Convert IPv4 address from bytes after decoding from Base64",
          "source": "ip_ntop!(decode_base64!(\"wKgAAQ==\"))",
          "return": "\"192.168.0.1\""
        },
        {
          "title": "Convert IPv6 address from bytes after decoding from Base64",
          "source": "ip_ntop!(decode_base64!(\"IAENuIWjAAAAAIouA3BzNA==\"))",
          "return": "\"2001:db8:85a3::8a2e:370:7334\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "ip_pton",
      "name": "ip_pton",
      "category": "IP",
      "description": "Converts IPv4 and IPv6 addresses from text to binary form.\n\n* The binary form of IPv4 addresses is 4 bytes (32 bits) long.\n* The binary form of IPv6 addresses is 16 bytes (128 bits) long.\n\nThis behavior mimics [inet_pton](https://linux.die.net/man/3/inet_pton).",
      "notices": [
        "The binary data from this function is not easily printable.\nHowever, functions such as `encode_base64` or `encode_percent` can\nstill process it correctly."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The IP address (v4 or v6) to convert to binary form.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a valid IP (v4 or v6) address in text form."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Convert IPv4 address to bytes and encode to Base64",
          "source": "encode_base64(ip_pton!(\"192.168.0.1\"))",
          "return": "\"wKgAAQ==\""
        },
        {
          "title": "Convert IPv6 address to bytes and encode to Base64",
          "source": "encode_base64(ip_pton!(\"2001:db8:85a3::8a2e:370:7334\"))",
          "return": "\"IAENuIWjAAAAAIouA3BzNA==\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "ip_subnet",
      "name": "ip_subnet",
      "category": "IP",
      "description": "Extracts the subnet address from the `ip` using the supplied `subnet`.",
      "notices": [
        "Works with both IPv4 and IPv6 addresses. The IP version for the mask must be the same as the supplied\naddress."
      ],
      "arguments": [
        {
          "name": "ip",
          "description": "The IP address (v4 or v6).",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "subnet",
          "description": "The subnet to extract from the IP address. This can be either a prefix length like `/8` or a net mask\nlike `255.255.0.0`. The net mask can be either an IPv4 or IPv6 address.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`ip` is not a valid IP address.",
        "`subnet` is not a valid subnet."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "IPv4 subnet",
          "source": "ip_subnet!(\"192.168.10.32\", \"255.255.255.0\")",
          "return": "\"192.168.10.0\""
        },
        {
          "title": "IPv6 subnet",
          "source": "ip_subnet!(\"2404:6800:4003:c02::64\", \"/32\")",
          "return": "\"2404:6800::\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "ip_to_ipv6",
      "name": "ip_to_ipv6",
      "category": "IP",
      "description": "Converts the `ip` to an IPv6 address.",
      "notices": [],
      "arguments": [
        {
          "name": "ip",
          "description": "The IP address to convert to IPv6.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`ip` is not a valid IP address."
      ],
      "return": {
        "types": [
          "string"
        ],
        "rules": [
          "The `ip` is returned unchanged if it's already an IPv6 address.",
          "The `ip` is converted to an IPv6 address if it's an IPv4 address."
        ]
      },
      "examples": [
        {
          "title": "IPv4 to IPv6",
          "source": "ip_to_ipv6!(\"192.168.10.32\")",
          "return": "\"::ffff:192.168.10.32\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "ipv6_to_ipv4",
      "name": "ipv6_to_ipv4",
      "category": "IP",
      "description": "Converts the `ip` to an IPv4 address. `ip` is returned unchanged if it's already an IPv4 address. If `ip` is\ncurrently an IPv6 address then it needs to be IPv4 compatible, otherwise an error is thrown.",
      "notices": [],
      "arguments": [
        {
          "name": "ip",
          "description": "The IPv4-mapped IPv6 address to convert.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`ip` is not a valid IP address.",
        "`ip` is an IPv6 address that is not compatible with IPv4."
      ],
      "return": {
        "types": [
          "string"
        ],
        "rules": [
          "The `ip` is returned unchanged if it's already an IPv4 address. If it's an IPv6 address it must be IPv4\ncompatible, otherwise an error is thrown."
        ]
      },
      "examples": [
        {
          "title": "IPv6 to IPv4",
          "source": "ipv6_to_ipv4!(\"::ffff:192.168.0.1\")",
          "return": "\"192.168.0.1\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "is_ipv4",
      "name": "is_ipv4",
      "category": "IP",
      "description": "Check if the string is a valid IPv4 address or not.\n\nAn [IPv4-mapped][https://datatracker.ietf.org/doc/html/rfc6890] or\n[IPv4-compatible][https://datatracker.ietf.org/doc/html/rfc6890] IPv6 address is not considered\nvalid for the purpose of this function.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The IP address to check",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ],
        "rules": [
          "Returns `true` if `value` is a valid IPv4 address.",
          "Returns `false` if `value` is anything else."
        ]
      },
      "examples": [
        {
          "title": "Valid IPv4 address",
          "source": "is_ipv4(\"10.0.102.37\")",
          "return": "true"
        },
        {
          "title": "Valid IPv6 address",
          "source": "is_ipv4(\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\")",
          "return": "false"
        },
        {
          "title": "Arbitrary string",
          "source": "is_ipv4(\"foobar\")",
          "return": "false"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "is_ipv6",
      "name": "is_ipv6",
      "category": "IP",
      "description": "Check if the string is a valid IPv6 address or not.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The IP address to check",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ],
        "rules": [
          "Returns `true` if `value` is a valid IPv6 address.",
          "Returns `false` if `value` is anything else."
        ]
      },
      "examples": [
        {
          "title": "Valid IPv6 address",
          "source": "is_ipv6(\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\")",
          "return": "true"
        },
        {
          "title": "Valid IPv4 address",
          "source": "is_ipv6(\"10.0.102.37\")",
          "return": "false"
        },
        {
          "title": "Arbitrary string",
          "source": "is_ipv6(\"foobar\")",
          "return": "false"
        }
      ],
      "deprecated": false,
      "pure": true
    }
  ],
  "Object": [
    {
      "anchor": "match_datadog_query",
      "name": "match_datadog_query",
      "category": "Object",
      "description": "Matches an object against a [Datadog Search Syntax](https://docs.datadoghq.com/logs/explorer/search_syntax/) query.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The object.",
          "required": true,
          "type": [
            "object"
          ]
        },
        {
          "name": "query",
          "description": "The Datadog Search Syntax query.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ]
      },
      "examples": [
        {
          "title": "OR query",
          "source": "match_datadog_query({\"message\": \"contains this and that\"}, \"this OR that\")",
          "return": "true"
        },
        {
          "title": "AND query",
          "source": "match_datadog_query({\"message\": \"contains only this\"}, \"this AND that\")",
          "return": "false"
        },
        {
          "title": "Attribute wildcard",
          "source": "match_datadog_query({\"name\": \"foobar\"}, \"@name:foo*\")",
          "return": "true"
        },
        {
          "title": "Tag range",
          "source": "match_datadog_query({\"tags\": [\"a:x\", \"b:y\", \"c:z\"]}, s'b:[\"x\" TO \"z\"]')",
          "return": "true"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "merge",
      "name": "merge",
      "category": "Object",
      "description": "Merges the `from` object into the `to` object.",
      "notices": [],
      "arguments": [
        {
          "name": "to",
          "description": "The object to merge into.",
          "required": true,
          "type": [
            "object"
          ]
        },
        {
          "name": "from",
          "description": "The object to merge from.",
          "required": true,
          "type": [
            "object"
          ]
        },
        {
          "name": "deep",
          "description": "A deep merge is performed if `true`, otherwise only top-level fields are merged.",
          "required": false,
          "default": false,
          "type": [
            "boolean"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "object"
        ],
        "rules": [
          "The field from the `from` object is chosen if a key exists in both objects.",
          "Objects are merged recursively if `deep` is specified, a key exists in both objects, and both of those\nfields are also objects."
        ]
      },
      "examples": [
        {
          "title": "Object merge (shallow)",
          "source": "merge(\n\t{\n\t\t\"parent1\": {\n\t\t\t\"child1\": 1,\n\t\t\t\"child2\": 2\n\t\t},\n\t\t\"parent2\": {\n\t\t\t\"child3\": 3\n\t\t}\n\t},\n\t{\n\t\t\"parent1\": {\n\t\t\t\"child2\": 4,\n\t\t\t\"child5\": 5\n\t\t}\n\t}\n)",
          "return": "{\"parent1\":{\"child2\":4,\"child5\":5},\"parent2\":{\"child3\":3}}"
        },
        {
          "title": "Object merge (deep)",
          "source": "merge(\n\t{\n\t\t\"parent1\": {\n\t\t\t\"child1\": 1,\n\t\t\t\"child2\": 2\n\t\t},\n\t\t\"parent2\": {\n\t\t\t\"child3\": 3\n\t\t}\n\t},\n\t{\n\t\t\"parent1\": {\n\t\t\t\"child2\": 4,\n\t\t\t\"child5\": 5\n\t\t}\n\t},\n\tdeep: true\n)",
          "return": "{\"parent1\":{\"child1\":1,\"child2\":4,\"child5\":5},\"parent2\":{\"child3\":3}}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "object_from_array",
      "name": "object_from_array",
      "category": "Object",
      "description": "Iterate over either one array of arrays or a pair of arrays and create an object out of all the key-value pairs contained in them.\nWith one array of arrays, any entries with no value use `null` instead.\nAny keys that are `null` skip the  corresponding value.\n\nIf a single parameter is given, it must contain an array of all the input arrays.",
      "notices": [],
      "arguments": [
        {
          "name": "values",
          "description": "The first array of elements, or the array of input arrays if no other parameter is present.",
          "required": true,
          "type": [
            "array"
          ]
        },
        {
          "name": "keys",
          "description": "The second array of elements. If not present, the first parameter must contain all the arrays.",
          "required": false,
          "type": [
            "array"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`values` and `keys` must be arrays.",
        "If `keys` is not present, `values` must contain only arrays."
      ],
      "return": {
        "types": [
          "object"
        ],
        "rules": [
          "`object_from_array` is considered fallible in the following cases: if any of the parameters is not an array; if only the `value` parameter is present and it is not an array of arrays; or if any of the keys are not either a string or `null`."
        ]
      },
      "examples": [
        {
          "title": "Create an object from one array",
          "source": "object_from_array([[\"one\", 1], [null, 2], [\"two\", 3]])",
          "return": "{\"one\":1,\"two\":3}"
        },
        {
          "title": "Create an object from separate key and value arrays",
          "source": "object_from_array([1, 2, 3], keys: [\"one\", null, \"two\"])",
          "return": "{\"one\":1,\"two\":3}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "unnest",
      "name": "unnest",
      "category": "Object",
      "description": "Unnest an array field from an object to create an array of objects using that field; keeping all other fields.\n\nAssigning the array result of this to `.` results in multiple events being emitted from `remap`. See the\n[`remap` transform docs](/docs/reference/configuration/transforms/remap/#emitting-multiple-log-events) for more details.\n\nThis is also referred to as `explode` in some languages.",
      "arguments": [
        {
          "name": "path",
          "description": "The path of the field to unnest.",
          "required": true,
          "type": [
            "path"
          ]
        }
      ],
      "internal_failure_reasons": [
        "The field path referred to is not an array."
      ],
      "notices": [],
      "return": {
        "types": [
          "array"
        ],
        "rules": [
          "Returns an array of objects that matches the original object, but each with the specified path replaced with a single element from the original path."
        ]
      },
      "examples": [
        {
          "title": "Unnest an array field",
          "input": {
            "log": {
              "hostname": "localhost",
              "messages": [
                "message 1",
                "message 2"
              ]
            }
          },
          "source": ". = unnest!(.messages)",
          "output": [
            {
              "log": {
                "hostname": "localhost",
                "messages": "message 1"
              }
            },
            {
              "log": {
                "hostname": "localhost",
                "messages": "message 2"
              }
            }
          ]
        },
        {
          "title": "Unnest nested an array field",
          "input": {
            "log": {
              "hostname": "localhost",
              "event": {
                "messages": [
                  "message 1",
                  "message 2"
                ]
              }
            }
          },
          "source": ". = unnest!(.event.messages)",
          "output": [
            {
              "log": {
                "hostname": "localhost",
                "event": {
                  "messages": "message 1"
                }
              }
            },
            {
              "log": {
                "hostname": "localhost",
                "event": {
                  "messages": "message 2"
                }
              }
            }
          ]
        }
      ],
      "deprecated": false,
      "pure": true
    }
  ],
  "Parse": [
    {
      "anchor": "parse_apache_log",
      "name": "parse_apache_log",
      "category": "Parse",
      "description": "Parses Apache access and error log lines. Lines can be in [`common`](https://httpd.apache.org/docs/current/logs.html#common),\n[`combined`](https://httpd.apache.org/docs/current/logs.html#combined), or the default [`error`](https://httpd.apache.org/docs/current/logs.html#errorlog) format.",
      "notices": [
        "Missing information in the log message may be indicated by `-`. These fields are omitted in the result."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string to parse.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "timestamp_format",
          "description": "The [date/time format](https://docs.rs/chrono/latest/chrono/format/strftime/index.html) to use for\nencoding the timestamp. The time is parsed in local time if the timestamp does not specify a timezone.",
          "required": false,
          "default": "%d/%b/%Y:%T %z",
          "type": [
            "string"
          ]
        },
        {
          "name": "format",
          "description": "The format to use for parsing the log.",
          "required": true,
          "enum": {
            "common": "Common format",
            "combined": "Apache combined format",
            "error": "Default Apache error format"
          },
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` does not match the specified format.",
        "`timestamp_format` is not a valid format string.",
        "The timestamp in `value` fails to parse using the provided `timestamp_format`."
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse using Apache log format (common)",
          "source": "parse_apache_log!(\"127.0.0.1 bob frank [10/Oct/2000:13:55:36 -0700] \\\"GET /apache_pb.gif HTTP/1.0\\\" 200 2326\", format: \"common\")",
          "return": "{\"host\":\"127.0.0.1\",\"identity\":\"bob\",\"user\":\"frank\",\"timestamp\":\"2000-10-10T20:55:36Z\",\"message\":\"GET /apache_pb.gif HTTP/1.0\",\"method\":\"GET\",\"path\":\"/apache_pb.gif\",\"protocol\":\"HTTP/1.0\",\"status\":200,\"size\":2326}"
        },
        {
          "title": "Parse using Apache log format (combined)",
          "source": "parse_apache_log!(\n\ts'127.0.0.1 bob frank [10/Oct/2000:13:55:36 -0700] \"GET /apache_pb.gif HTTP/1.0\" 200 2326 \"http://www.seniorinfomediaries.com/vertical/channels/front-end/bandwidth\" \"Mozilla/5.0 (X11; Linux i686; rv:5.0) Gecko/1945-10-12 Firefox/37.0\"',\n\t\"combined\",\n)",
          "return": "{\"host\":\"127.0.0.1\",\"identity\":\"bob\",\"user\":\"frank\",\"timestamp\":\"2000-10-10T20:55:36Z\",\"message\":\"GET /apache_pb.gif HTTP/1.0\",\"method\":\"GET\",\"path\":\"/apache_pb.gif\",\"protocol\":\"HTTP/1.0\",\"status\":200,\"size\":2326,\"referrer\":\"http://www.seniorinfomediaries.com/vertical/channels/front-end/bandwidth\",\"agent\":\"Mozilla/5.0 (X11; Linux i686; rv:5.0) Gecko/1945-10-12 Firefox/37.0\"}"
        },
        {
          "title": "Parse using Apache log format (error)",
          "source": "parse_apache_log!(\n\ts'[01/Mar/2021:12:00:19 +0000] [ab:alert] [pid 4803:tid 3814] [client 147.159.108.175:24259] I will bypass the haptic COM bandwidth, that should matrix the CSS driver!',\n\t\"error\"\n)",
          "return": "{\"client\":\"147.159.108.175\",\"message\":\"I will bypass the haptic COM bandwidth, that should matrix the CSS driver!\",\"module\":\"ab\",\"pid\":4803,\"port\":24259,\"severity\":\"alert\",\"thread\":\"3814\",\"timestamp\":\"2021-03-01T12:00:19Z\"}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_aws_alb_log",
      "name": "parse_aws_alb_log",
      "category": "Parse",
      "description": "Parses `value` in the [Elastic Load Balancer Access format](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-access-logs.html#access-log-entry-examples).",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "Access log of the Application Load Balancer.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a properly formatted AWS ALB log."
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse AWS ALB log",
          "source": "parse_aws_alb_log!(\n\t\"http 2018-11-30T22:23:00.186641Z app/my-loadbalancer/50dc6c495c0c9188 192.168.131.39:2817 - 0.000 0.001 0.000 200 200 34 366 \\\"GET http://www.example.com:80/ HTTP/1.1\\\" \\\"curl/7.46.0\\\" - - arn:aws:elasticloadbalancing:us-east-2:123456789012:targetgroup/my-targets/73e2d6bc24d8a067 \\\"Root=1-58337364-23a8c76965a2ef7629b185e3\\\" \\\"-\\\" \\\"-\\\" 0 2018-11-30T22:22:48.364000Z \\\"forward\\\" \\\"-\\\" \\\"-\\\" \\\"-\\\" \\\"-\\\" \\\"-\\\" \\\"-\\\"\"\n)",
          "return": "{\"type\":\"http\",\"timestamp\":\"2018-11-30T22:23:00.186641Z\",\"elb\":\"app/my-loadbalancer/50dc6c495c0c9188\",\"client_host\":\"192.168.131.39:2817\",\"target_host\":null,\"request_processing_time\":0,\"target_processing_time\":0.001,\"response_processing_time\":0,\"elb_status_code\":\"200\",\"target_status_code\":\"200\",\"received_bytes\":34,\"sent_bytes\":366,\"request_method\":\"GET\",\"request_url\":\"http://www.example.com:80/\",\"request_protocol\":\"HTTP/1.1\",\"user_agent\":\"curl/7.46.0\",\"ssl_cipher\":null,\"ssl_protocol\":null,\"target_group_arn\":\"arn:aws:elasticloadbalancing:us-east-2:123456789012:targetgroup/my-targets/73e2d6bc24d8a067\",\"trace_id\":\"Root=1-58337364-23a8c76965a2ef7629b185e3\",\"traceability_id\":null,\"domain_name\":null,\"chosen_cert_arn\":null,\"matched_rule_priority\":\"0\",\"request_creation_time\":\"2018-11-30T22:22:48.364000Z\",\"actions_executed\":\"forward\",\"redirect_url\":null,\"error_reason\":null,\"target_port_list\":[],\"target_status_code_list\":[],\"classification\":null,\"classification_reason\":null}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_aws_cloudwatch_log_subscription_message",
      "name": "parse_aws_cloudwatch_log_subscription_message",
      "category": "Parse",
      "description": "Parses AWS CloudWatch Logs events (configured through AWS Cloudwatch subscriptions) from the\n`aws_kinesis_firehose` source.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string representation of the message to parse.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a properly formatted AWS CloudWatch Log subscription message."
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse AWS Cloudwatch Log subscription message",
          "input": {
            "log": {
              "message": "{\n  \"messageType\": \"DATA_MESSAGE\",\n  \"owner\": \"111111111111\",\n  \"logGroup\": \"test\",\n  \"logStream\": \"test\",\n  \"subscriptionFilters\": [\n\t\"Destination\"\n  ],\n  \"logEvents\": [\n\t{\n\t  \"id\": \"35683658089614582423604394983260738922885519999578275840\",\n\t  \"timestamp\": 1600110569039,\n\t  \"message\": \"{\\\"bytes\\\":26780,\\\"datetime\\\":\\\"14/Sep/2020:11:45:41 -0400\\\",\\\"host\\\":\\\"157.130.216.193\\\",\\\"method\\\":\\\"PUT\\\",\\\"protocol\\\":\\\"HTTP/1.0\\\",\\\"referer\\\":\\\"https://www.principalcross-platform.io/markets/ubiquitous\\\",\\\"request\\\":\\\"/expedite/convergence\\\",\\\"source_type\\\":\\\"stdin\\\",\\\"status\\\":301,\\\"user-identifier\\\":\\\"-\\\"}\"\n\t}\n  ]\n}"
            }
          },
          "source": "parse_aws_cloudwatch_log_subscription_message!(.message)",
          "return": "{\"owner\":\"111111111111\",\"message_type\":\"DATA_MESSAGE\",\"log_group\":\"test\",\"log_stream\":\"test\",\"subscription_filters\":[\"Destination\"],\"log_events\":[{\"id\":\"35683658089614582423604394983260738922885519999578275840\",\"message\":\"{\\\"bytes\\\":26780,\\\"datetime\\\":\\\"14/Sep/2020:11:45:41 -0400\\\",\\\"host\\\":\\\"157.130.216.193\\\",\\\"method\\\":\\\"PUT\\\",\\\"protocol\\\":\\\"HTTP/1.0\\\",\\\"referer\\\":\\\"https://www.principalcross-platform.io/markets/ubiquitous\\\",\\\"request\\\":\\\"/expedite/convergence\\\",\\\"source_type\\\":\\\"stdin\\\",\\\"status\\\":301,\\\"user-identifier\\\":\\\"-\\\"}\",\"timestamp\":\"2020-09-14T19:09:29.039Z\"}]}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_aws_vpc_flow_log",
      "name": "parse_aws_vpc_flow_log",
      "category": "Parse",
      "description": "Parses `value` in the [VPC Flow Logs format](https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html).",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "VPC Flow Log.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "format",
          "description": "VPC Flow Log format.",
          "required": false,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a properly formatted AWS VPC Flow log."
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse AWS VPC Flow log (default format)",
          "source": "parse_aws_vpc_flow_log!(\"2 123456789010 eni-1235b8ca123456789 - - - - - - - 1431280876 1431280934 - NODATA\")",
          "return": "{\"version\":2,\"account_id\":\"123456789010\",\"interface_id\":\"eni-1235b8ca123456789\",\"srcaddr\":null,\"dstaddr\":null,\"srcport\":null,\"dstport\":null,\"protocol\":null,\"packets\":null,\"bytes\":null,\"start\":1431280876,\"end\":1431280934,\"action\":null,\"log_status\":\"NODATA\"}"
        },
        {
          "title": "Parse AWS VPC Flow log (custom format)",
          "source": "parse_aws_vpc_flow_log!(\n\t\"- eni-1235b8ca123456789 10.0.1.5 10.0.0.220 10.0.1.5 203.0.113.5\",\n\t\"instance_id interface_id srcaddr dstaddr pkt_srcaddr pkt_dstaddr\"\n)",
          "return": "{\"instance_id\":null,\"interface_id\":\"eni-1235b8ca123456789\",\"srcaddr\":\"10.0.1.5\",\"dstaddr\":\"10.0.0.220\",\"pkt_srcaddr\":\"10.0.1.5\",\"pkt_dstaddr\":\"203.0.113.5\"}"
        },
        {
          "title": "Parse AWS VPC Flow log including v5 fields",
          "source": "parse_aws_vpc_flow_log!(\"5 52.95.128.179 10.0.0.71 80 34210 6 1616729292 1616729349 IPv4 14 15044 123456789012 vpc-abcdefab012345678 subnet-aaaaaaaa012345678 i-0c50d5961bcb2d47b eni-1235b8ca123456789 ap-southeast-2 apse2-az3 - - ACCEPT 19 52.95.128.179 10.0.0.71 S3 - - ingress OK\",\nformat: \"version srcaddr dstaddr srcport dstport protocol start end type packets bytes account_id vpc_id subnet_id instance_id interface_id region az_id sublocation_type sublocation_id action tcp_flags pkt_srcaddr pkt_dstaddr pkt_src_aws_service pkt_dst_aws_service traffic_path flow_direction log_status\")",
          "return": "{\"account_id\":\"123456789012\",\"action\":\"ACCEPT\",\"az_id\":\"apse2-az3\",\"bytes\":15044,\"dstaddr\":\"10.0.0.71\",\"dstport\":34210,\"end\":1616729349,\"flow_direction\":\"ingress\",\"instance_id\":\"i-0c50d5961bcb2d47b\",\"interface_id\":\"eni-1235b8ca123456789\",\"log_status\":\"OK\",\"packets\":14,\"pkt_dst_aws_service\":null,\"pkt_dstaddr\":\"10.0.0.71\",\"pkt_src_aws_service\":\"S3\",\"pkt_srcaddr\":\"52.95.128.179\",\"protocol\":6,\"region\":\"ap-southeast-2\",\"srcaddr\":\"52.95.128.179\",\"srcport\":80,\"start\":1616729292,\"sublocation_id\":null,\"sublocation_type\":null,\"subnet_id\":\"subnet-aaaaaaaa012345678\",\"tcp_flags\":19,\"traffic_path\":null,\"type\":\"IPv4\",\"version\":5,\"vpc_id\":\"vpc-abcdefab012345678\"}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_bytes",
      "name": "parse_bytes",
      "category": "Parse",
      "description": "Parses the `value` into a human-readable bytes format specified by `unit` and `base`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string of the duration with either binary or SI unit.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "unit",
          "description": "The output units for the byte.",
          "required": true,
          "type": [
            "string"
          ],
          "enum": {
            "B": "Bytes",
            "kiB": "Kilobytes (1024 bytes)",
            "MiB": "Megabytes (1024 ** 2 bytes)",
            "GiB": "Gigabytes (1024 ** 3 bytes)",
            "TiB": "Terabytes (1024 gigabytes)",
            "PiB": "Petabytes (1024 ** 2 gigabytes)",
            "EiB": "Exabytes (1024 ** 3 gigabytes)",
            "kB": "Kilobytes (1 thousand bytes in SI)",
            "MB": "Megabytes (1 million bytes in SI)",
            "GB": "Gigabytes (1 billion bytes in SI)",
            "TB": "Terabytes (1 thousand gigabytes in SI)",
            "PB": "Petabytes (1 million gigabytes in SI)",
            "EB": "Exabytes (1 billion gigabytes in SI)"
          }
        },
        {
          "name": "base",
          "description": "The base for the byte, either 2 or 10.",
          "required": false,
          "type": [
            "string"
          ],
          "default": 2
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a properly formatted bytes."
      ],
      "return": {
        "types": [
          "float"
        ]
      },
      "examples": [
        {
          "title": "Parse bytes (kilobytes)",
          "source": "parse_bytes!(\"1024KiB\", unit: \"MiB\")",
          "return": "1"
        },
        {
          "title": "Parse bytes in SI unit (terabytes)",
          "source": "parse_bytes!(\"4TB\", unit: \"MB\", base: \"10\")",
          "return": "4000000"
        },
        {
          "title": "Parse bytes in ambiguous unit (gigabytes)",
          "source": "parse_bytes!(\"1GB\", unit: \"B\", base: \"2\")",
          "return": "1073741824"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_cbor",
      "name": "parse_cbor",
      "category": "Parse",
      "description": "Parses the `value` as [CBOR](https://cbor.io).",
      "notices": [
        "Only CBOR types are returned."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The CBOR payload to parse.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a valid CBOR-formatted payload."
      ],
      "return": {
        "types": [
          "boolean",
          "integer",
          "float",
          "string",
          "object",
          "array",
          "null"
        ]
      },
      "examples": [
        {
          "title": "Parse CBOR",
          "source": "parse_cbor!(decode_base64!(\"oWVmaWVsZGV2YWx1ZQ==\"))",
          "return": "{\"field\":\"value\"}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_cef",
      "name": "parse_cef",
      "category": "Parse",
      "description": "Parses the `value` in CEF (Common Event Format) format. Ignores everything up to CEF header. Empty values are returned as empty strings. Surrounding quotes are removed from values.",
      "notices": [
        "All values are returned as strings. We recommend manually coercing values to desired types as you see fit."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string to parse.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "translate_custom_fields",
          "description": "Toggles translation of custom field pairs to `key:value`.",
          "required": false,
          "type": [
            "boolean"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a properly formatted CEF string."
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse output generated by PTA",
          "source": "parse_cef!(\n\t\"CEF:0|CyberArk|PTA|12.6|1|Suspected credentials theft|8|suser=mike2@prod1.domain.com shost=prod1.domain.com src=1.1.1.1 duser=andy@dev1.domain.com dhost=dev1.domain.com dst=2.2.2.2 cs1Label=ExtraData cs1=None cs2Label=EventID cs2=52b06812ec3500ed864c461e deviceCustomDate1Label=detectionDate deviceCustomDate1=1388577900000 cs3Label=PTAlink cs3=https://1.1.1.1/incidents/52b06812ec3500ed864c461e cs4Label=ExternalLink cs4=None\"\n)",
          "return": "{\"cefVersion\":\"0\",\"deviceVendor\":\"CyberArk\",\"deviceProduct\":\"PTA\",\"deviceVersion\":\"12.6\",\"deviceEventClassId\":\"1\",\"name\":\"Suspected credentials theft\",\"severity\":\"8\",\"suser\":\"mike2@prod1.domain.com\",\"shost\":\"prod1.domain.com\",\"src\":\"1.1.1.1\",\"duser\":\"andy@dev1.domain.com\",\"dhost\":\"dev1.domain.com\",\"dst\":\"2.2.2.2\",\"cs1Label\":\"ExtraData\",\"cs1\":\"None\",\"cs2Label\":\"EventID\",\"cs2\":\"52b06812ec3500ed864c461e\",\"deviceCustomDate1Label\":\"detectionDate\",\"deviceCustomDate1\":\"1388577900000\",\"cs3Label\":\"PTAlink\",\"cs3\":\"https://1.1.1.1/incidents/52b06812ec3500ed864c461e\",\"cs4Label\":\"ExternalLink\",\"cs4\":\"None\"}"
        },
        {
          "title": "Ignore syslog header",
          "source": "parse_cef!(\n\t\"Sep 29 08:26:10 host CEF:1|Security|threatmanager|1.0|100|worm successfully stopped|10|src=10.0.0.1 dst=2.1.2.2 spt=1232\"\n)",
          "return": "{\"cefVersion\":\"1\",\"deviceVendor\":\"Security\",\"deviceProduct\":\"threatmanager\",\"deviceVersion\":\"1.0\",\"deviceEventClassId\":\"100\",\"name\":\"worm successfully stopped\",\"severity\":\"10\",\"src\":\"10.0.0.1\",\"dst\":\"2.1.2.2\",\"spt\":\"1232\"}"
        },
        {
          "title": "Translate custom fields",
          "source": "parse_cef!(\n\t\"CEF:0|Dev|firewall|2.2|1|Connection denied|5|c6a1=2345:0425:2CA1:0000:0000:0567:5673:23b5 c6a1Label=Device IPv6 Address\",\n\ttranslate_custom_fields: true\n)",
          "return": "{\"cefVersion\":\"0\",\"deviceVendor\":\"Dev\",\"deviceProduct\":\"firewall\",\"deviceVersion\":\"2.2\",\"deviceEventClassId\":\"1\",\"name\":\"Connection denied\",\"severity\":\"5\",\"Device IPv6 Address\":\"2345:0425:2CA1:0000:0000:0567:5673:23b5\"}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_common_log",
      "name": "parse_common_log",
      "category": "Parse",
      "description": "Parses the `value` using the [Common Log Format](https://httpd.apache.org/docs/current/logs.html#common) (CLF).",
      "notices": [
        "Missing information in the log message may be indicated by `-`. These fields are omitted in the result."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string to parse.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "timestamp_format",
          "description": "The [date/time format](https://docs.rs/chrono/latest/chrono/format/strftime/index.html) to use for\nencoding the timestamp.",
          "required": false,
          "default": "%d/%b/%Y:%T %z",
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` does not match the Common Log Format.",
        "`timestamp_format` is not a valid format string.",
        "The timestamp in `value` fails to parse using the provided `timestamp_format`."
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse using Common Log Format (with default timestamp format)",
          "source": "parse_common_log!(\"127.0.0.1 bob frank [10/Oct/2000:13:55:36 -0700] \\\"GET /apache_pb.gif HTTP/1.0\\\" 200 2326\")",
          "return": "{\"host\":\"127.0.0.1\",\"identity\":\"bob\",\"user\":\"frank\",\"timestamp\":\"2000-10-10T20:55:36Z\",\"message\":\"GET /apache_pb.gif HTTP/1.0\",\"method\":\"GET\",\"path\":\"/apache_pb.gif\",\"protocol\":\"HTTP/1.0\",\"status\":200,\"size\":2326}"
        },
        {
          "title": "Parse using Common Log Format (with custom timestamp format)",
          "source": "parse_common_log!(\n\t\"127.0.0.1 bob frank [2000-10-10T20:55:36Z] \\\"GET /apache_pb.gif HTTP/1.0\\\" 200 2326\",\n\t\"%+\"\n)",
          "return": "{\"host\":\"127.0.0.1\",\"identity\":\"bob\",\"user\":\"frank\",\"timestamp\":\"2000-10-10T20:55:36Z\",\"message\":\"GET /apache_pb.gif HTTP/1.0\",\"method\":\"GET\",\"path\":\"/apache_pb.gif\",\"protocol\":\"HTTP/1.0\",\"status\":200,\"size\":2326}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_csv",
      "name": "parse_csv",
      "category": "Parse",
      "description": "Parses a single CSV formatted row. Only the first row is parsed in case of multiline input value.",
      "notices": [
        "All values are returned as strings. We recommend manually coercing values to desired types as you see fit."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string to parse.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "delimiter",
          "description": "The field delimiter to use when parsing. Must be a single-byte utf8 character.",
          "required": false,
          "default": ",",
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "The delimiter must be a single-byte UTF-8 character.",
        "`value` is not a valid CSV string."
      ],
      "return": {
        "types": [
          "array"
        ]
      },
      "examples": [
        {
          "title": "Parse a single CSV formatted row",
          "source": "parse_csv!(\"foo,bar,\\\"foo \\\"\\\", bar\\\"\")",
          "return": "[\"foo\",\"bar\",\"foo \\\", bar\"]"
        },
        {
          "title": "Parse a single CSV formatted row with custom delimiter",
          "source": "parse_csv!(\"foo bar\", delimiter: \" \")",
          "return": "[\"foo\",\"bar\"]"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_dnstap",
      "name": "parse_dnstap",
      "category": "Parse",
      "description": "Parses the `value` as base64 encoded DNSTAP data.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The base64 encoded representation of the DNSTAP data to parse.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "lowercase_hostnames",
          "description": "Whether to turn all hostnames found in resulting data lowercase, for consistency.",
          "required": false,
          "default": false,
          "type": [
            "boolean"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a valid base64 encoded string.",
        "dnstap parsing failed for `value`"
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse dnstap query message",
          "source": "parse_dnstap!(\"ChVqYW1lcy1WaXJ0dWFsLU1hY2hpbmUSC0JJTkQgOS4xNi4zGgBy5wEIAxACGAEiEAAAAAAAAAAAAAAAAAAAAAAqECABBQJwlAAAAAAAAAAAADAw8+0CODVA7+zq9wVNMU3WNlI2kwIAAAABAAAAAAABCWZhY2Vib29rMQNjb20AAAEAAQAAKQIAAACAAAAMAAoACOxjCAG9zVgzWgUDY29tAGAAbQAAAAByZLM4AAAAAQAAAAAAAQJoNQdleGFtcGxlA2NvbQAABgABAAApBNABAUAAADkADwA1AAlubyBTRVAgbWF0Y2hpbmcgdGhlIERTIGZvdW5kIGZvciBkbnNzZWMtZmFpbGVkLm9yZy54AQ==\")",
          "return": "{\"dataType\":\"Message\",\"dataTypeId\":1,\"extraInfo\":\"\",\"messageType\":\"ResolverQuery\",\"messageTypeId\":3,\"queryZone\":\"com.\",\"requestData\":{\"fullRcode\":0,\"header\":{\"aa\":false,\"ad\":false,\"anCount\":0,\"arCount\":1,\"cd\":false,\"id\":37634,\"nsCount\":0,\"opcode\":0,\"qdCount\":1,\"qr\":0,\"ra\":false,\"rcode\":0,\"rd\":false,\"tc\":false},\"opt\":{\"do\":true,\"ednsVersion\":0,\"extendedRcode\":0,\"options\":[{\"optCode\":10,\"optName\":\"Cookie\",\"optValue\":\"7GMIAb3NWDM=\"}],\"udpPayloadSize\":512},\"question\":[{\"class\":\"IN\",\"domainName\":\"facebook1.com.\",\"questionType\":\"A\",\"questionTypeId\":1}],\"rcodeName\":\"NoError\"},\"responseData\":{\"fullRcode\":16,\"header\":{\"aa\":false,\"ad\":false,\"anCount\":0,\"arCount\":1,\"cd\":false,\"id\":45880,\"nsCount\":0,\"opcode\":0,\"qdCount\":1,\"qr\":0,\"ra\":false,\"rcode\":16,\"rd\":false,\"tc\":false},\"opt\":{\"do\":false,\"ednsVersion\":1,\"extendedRcode\":1,\"ede\":[{\"extraText\":\"no SEP matching the DS found for dnssec-failed.org.\",\"infoCode\":9,\"purpose\":\"DNSKEY Missing\"}],\"udpPayloadSize\":1232},\"question\":[{\"class\":\"IN\",\"domainName\":\"h5.example.com.\",\"questionType\":\"SOA\",\"questionTypeId\":6}],\"rcodeName\":\"BADSIG\"},\"responseAddress\":\"2001:502:7094::30\",\"responsePort\":53,\"serverId\":\"james-Virtual-Machine\",\"serverVersion\":\"BIND 9.16.3\",\"socketFamily\":\"INET6\",\"socketProtocol\":\"UDP\",\"sourceAddress\":\"::\",\"sourcePort\":46835,\"time\":1593489007920014000,\"timePrecision\":\"ns\",\"timestamp\":\"2020-06-30T03:50:07.920014129Z\"}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_duration",
      "name": "parse_duration",
      "category": "Parse",
      "description": "Parses the `value` into a human-readable duration format specified by `unit`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string of the duration.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "unit",
          "description": "The output units for the duration.",
          "required": true,
          "type": [
            "string"
          ],
          "enum": {
            "ns": "Nanoseconds (1 billion nanoseconds in a second)",
            "us": "Microseconds (1 million microseconds in a second)",
            "µs": "Microseconds (1 million microseconds in a second)",
            "ms": "Milliseconds (1 thousand microseconds in a second)",
            "cs": "Centiseconds (100 centiseconds in a second)",
            "ds": "Deciseconds (10 deciseconds in a second)",
            "s": "Seconds",
            "m": "Minutes (60 seconds in a minute)",
            "h": "Hours (60 minutes in an hour)",
            "d": "Days (24 hours in a day)"
          }
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a properly formatted duration."
      ],
      "return": {
        "types": [
          "float"
        ]
      },
      "examples": [
        {
          "title": "Parse duration (milliseconds)",
          "source": "parse_duration!(\"1005ms\", unit: \"s\")",
          "return": "1.005"
        },
        {
          "title": "Parse multiple durations (seconds & milliseconds)",
          "source": "parse_duration!(\"1s 1ms\", unit: \"ms\")",
          "return": "1001"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_etld",
      "name": "parse_etld",
      "category": "Parse",
      "description": "Parses the [eTLD](https://developer.mozilla.org/en-US/docs/Glossary/eTLD) from `value` representing domain name.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The domain string.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "plus_parts",
          "description": "Can be provided to get additional parts of the domain name. When 1 is passed,\neTLD+1 will be returned, which represents a domain registrable by a single\norganization. Higher numbers will return subdomains.",
          "required": false,
          "type": [
            "integer"
          ],
          "default": false
        },
        {
          "name": "psl",
          "description": "Can be provided to use a different public suffix list.\n\nBy default, https://publicsuffix.org/list/public_suffix_list.dat is used.",
          "required": false,
          "type": [
            "string"
          ],
          "default": false
        }
      ],
      "internal_failure_reasons": [
        "unable to determine eTLD for `value`"
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse eTLD",
          "source": "parse_etld!(\"sub.sussex.ac.uk\")",
          "return": "{\"etld\":\"ac.uk\",\"etld_plus\":\"ac.uk\",\"known_suffix\":true}"
        },
        {
          "title": "Parse eTLD+1",
          "source": "parse_etld!(\"sub.sussex.ac.uk\", plus_parts: 1)",
          "return": "{\"etld\":\"ac.uk\",\"etld_plus\":\"sussex.ac.uk\",\"known_suffix\":true}"
        },
        {
          "title": "Parse eTLD with unknown suffix",
          "source": "parse_etld!(\"vector.acmecorp\")",
          "return": "{\"etld\":\"acmecorp\",\"etld_plus\":\"acmecorp\",\"known_suffix\":false}"
        },
        {
          "title": "Parse eTLD with custom PSL",
          "source": "parse_etld!(\"vector.acmecorp\", psl: \"resources/public_suffix_list.dat\")",
          "return": "{\"etld\":\"acmecorp\",\"etld_plus\":\"acmecorp\",\"known_suffix\":false}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_glog",
      "name": "parse_glog",
      "category": "Parse",
      "description": "Parses the `value` using the [glog (Google Logging Library)](https://github.com/google/glog) format.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to parse.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` does not match the `glog` format."
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse using glog",
          "source": "parse_glog!(\"I20210131 14:48:54.411655 15520 main.c++:9] Hello world!\")",
          "return": "{\"level\":\"info\",\"timestamp\":\"2021-01-31T14:48:54.411655Z\",\"id\":15520,\"file\":\"main.c++\",\"line\":9,\"message\":\"Hello world!\"}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_grok",
      "name": "parse_grok",
      "category": "Parse",
      "description": "Parses the `value` using the [`grok`](https://github.com/daschl/grok/tree/master/patterns) format. All patterns [listed here](https://github.com/daschl/grok/tree/master/patterns)\nare supported.",
      "notices": [
        "We recommend using community-maintained Grok patterns when possible, as they're more likely to be properly\nvetted and improved over time than bespoke patterns."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string to parse.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "pattern",
          "description": "The [Grok pattern](https://github.com/daschl/grok/tree/master/patterns).",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` fails to parse using the provided `pattern`."
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse using Grok",
          "source": "parse_grok!(\n\t\"2020-10-02T23:22:12.223222Z info Hello world\",\n\t\"%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{GREEDYDATA:message}\"\n)",
          "return": "{\"timestamp\":\"2020-10-02T23:22:12.223222Z\",\"level\":\"info\",\"message\":\"Hello world\"}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_groks",
      "name": "parse_groks",
      "category": "Parse",
      "description": "Parses the `value` using multiple [`grok`](https://github.com/daschl/grok/tree/master/patterns) patterns. All patterns [listed here](https://github.com/daschl/grok/tree/master/patterns)\nare supported.",
      "notices": [
        "We recommend using community-maintained Grok patterns when possible, as they're more likely to be properly\nvetted and improved over time than bespoke patterns."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string to parse.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "patterns",
          "description": "The [Grok patterns](https://github.com/daschl/grok/tree/master/patterns), which are tried in order until the first match.",
          "required": true,
          "type": [
            "array"
          ]
        },
        {
          "name": "aliases",
          "description": "The shared set of grok aliases that can be referenced in the patterns to simplify them.",
          "required": false,
          "default": true,
          "type": [
            "object"
          ]
        },
        {
          "name": "alias_sources",
          "description": "Path to the file containing aliases in a JSON format.",
          "required": false,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` fails to parse using the provided `pattern`.",
        "`patterns` is not an array.",
        "`aliases` is not an object.",
        "`alias_sources` is not a string or doesn't point to a valid file."
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse using multiple Grok patterns",
          "source": "parse_groks!(\n\t\"2020-10-02T23:22:12.223222Z info Hello world\",\n\tpatterns: [\n\t\t\"%{common_prefix} %{_status} %{_message}\",\n\t\t\"%{common_prefix} %{_message}\",\n\t],\n\taliases: {\n\t\t\"common_prefix\": \"%{_timestamp} %{_loglevel}\",\n\t\t\"_timestamp\": \"%{TIMESTAMP_ISO8601:timestamp}\",\n\t\t\"_loglevel\": \"%{LOGLEVEL:level}\",\n\t\t\"_status\": \"%{POSINT:status}\",\n\t\t\"_message\": \"%{GREEDYDATA:message}\"\n\t}\n)",
          "return": "{\"timestamp\":\"2020-10-02T23:22:12.223222Z\",\"level\":\"info\",\"message\":\"Hello world\"}"
        },
        {
          "title": "Parse using aliases from file",
          "source": "parse_groks!(\n  \"username=foo\",\n  patterns: [ \"%{PATTERN_A}\" ],\n  alias_sources: [ \"path/to/aliases.json\" ]\n)\n# aliases.json contents:\n# {\n#   \"PATTERN_A\": \"%{PATTERN_B}\",\n#   \"PATTERN_B\": \"username=%{USERNAME:username}\"\n# }",
          "skip_test": true
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_influxdb",
      "name": "parse_influxdb",
      "category": "Parse",
      "description": "Parses the `value` as an [InfluxDB line protocol](https://docs.influxdata.com/influxdb/cloud/reference/syntax/line-protocol/)\nstring, producing a list of Vector-compatible metrics.",
      "notices": [
        "This function will return a log event with the shape of a Vector-compatible metric, but not a metric event itself.\nYou will likely want to pipe the output of this function through a `log_to_metric` transform with the option `all_metrics`\nset to `true` to convert the metric-shaped log events to metric events so _real_ metrics are produced.",
        "The only metric type that is produced is a `gauge`. Each metric name is prefixed with the `measurement` field, followed\nby an underscore (`_`), and then the `field key` field.",
        "`string` is the only type that is not supported as a field value,\ndue to limitations of Vector's metric model."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string representation of the InfluxDB line protocol to parse.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a valid InfluxDB line protocol string.",
        "field set contains a field value of type `string`.",
        "field set contains a `NaN` field value."
      ],
      "return": {
        "types": [
          "array"
        ]
      },
      "examples": [
        {
          "title": "Parse InfluxDB line protocol",
          "source": "parse_influxdb!(\"cpu,host=A,region=us-west usage_system=64i,usage_user=10u,temperature=50.5,on=true,sleep=false 1590488773254420000\")",
          "return": "[{\"name\":\"cpu_usage_system\",\"tags\":{\"host\":\"A\",\"region\":\"us-west\"},\"timestamp\":\"2020-05-26T10:26:13.254420Z\",\"kind\":\"absolute\",\"gauge\":{\"value\":64}},{\"name\":\"cpu_usage_user\",\"tags\":{\"host\":\"A\",\"region\":\"us-west\"},\"timestamp\":\"2020-05-26T10:26:13.254420Z\",\"kind\":\"absolute\",\"gauge\":{\"value\":10}},{\"name\":\"cpu_temperature\",\"tags\":{\"host\":\"A\",\"region\":\"us-west\"},\"timestamp\":\"2020-05-26T10:26:13.254420Z\",\"kind\":\"absolute\",\"gauge\":{\"value\":50.5}},{\"name\":\"cpu_on\",\"tags\":{\"host\":\"A\",\"region\":\"us-west\"},\"timestamp\":\"2020-05-26T10:26:13.254420Z\",\"kind\":\"absolute\",\"gauge\":{\"value\":1}},{\"name\":\"cpu_sleep\",\"tags\":{\"host\":\"A\",\"region\":\"us-west\"},\"timestamp\":\"2020-05-26T10:26:13.254420Z\",\"kind\":\"absolute\",\"gauge\":{\"value\":0}}]"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_int",
      "name": "parse_int",
      "category": "Parse",
      "description": "Parses the string `value` representing a number in an optional base/radix to an integer.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to parse.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "base",
          "description": "The base the number is in. Must be between 2 and 36 (inclusive).\n\nIf unspecified, the string prefix is used to\ndetermine the base: \"0b\", 8 for \"0\" or \"0o\", 16 for \"0x\",\nand 10 otherwise.",
          "required": false,
          "type": [
            "integer"
          ]
        }
      ],
      "internal_failure_reasons": [
        "The base is not between 2 and 36.",
        "The number cannot be parsed in the base."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Parse decimal",
          "source": "parse_int!(\"-42\")",
          "return": "-42"
        },
        {
          "title": "Parse binary",
          "source": "parse_int!(\"0b1001\")",
          "return": "9"
        },
        {
          "title": "Parse octal",
          "source": "parse_int!(\"0o42\")",
          "return": "34"
        },
        {
          "title": "Parse hexadecimal",
          "source": "parse_int!(\"0x2a\")",
          "return": "42"
        },
        {
          "title": "Parse explicit base",
          "source": "parse_int!(\"2a\", 17)",
          "return": "44"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_json",
      "name": "parse_json",
      "category": "Parse",
      "description": "Parses the `value` as JSON.",
      "notices": [
        "Only JSON types are returned. If you need to convert a `string` into a `timestamp`, consider the\n[`parse_timestamp`](#parse_timestamp) function."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string representation of the JSON to parse.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "max_depth",
          "description": "Number of layers to parse for nested JSON-formatted documents.\nThe value must be in the range of 1 to 128.",
          "required": false,
          "type": [
            "integer"
          ]
        },
        {
          "name": "lossy",
          "description": "Whether to parse the JSON in a lossy manner. Replaces invalid UTF-8 characters\nwith the Unicode character `�` (U+FFFD) if set to true, otherwise returns an error\nif there are any invalid UTF-8 characters present.",
          "required": false,
          "default": true,
          "type": [
            "boolean"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a valid JSON-formatted payload."
      ],
      "return": {
        "types": [
          "boolean",
          "integer",
          "float",
          "string",
          "object",
          "array",
          "null"
        ]
      },
      "examples": [
        {
          "title": "Parse JSON",
          "source": "parse_json!(\"{\\\"key\\\": \\\"val\\\"}\")",
          "return": "{\"key\":\"val\"}"
        },
        {
          "title": "Parse JSON with max_depth",
          "source": "parse_json!(\"{\\\"top_level\\\":{\\\"key\\\": \\\"val\\\"}}\", max_depth: 1)",
          "return": "{\"top_level\":\"{\\\"key\\\": \\\"val\\\"}\"}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_key_value",
      "name": "parse_key_value",
      "category": "Parse",
      "description": "Parses the `value` in key-value format. Also known as [logfmt](https://brandur.org/logfmt).\n\n* Keys and values can be wrapped with `\"`.\n* `\"` characters can be escaped using `\\`.",
      "notices": [
        "All values are returned as strings or as an array of strings for duplicate keys. We recommend manually coercing values to desired types as you see fit."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string to parse.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "key_value_delimiter",
          "description": "The string that separates the key from the value.",
          "required": false,
          "default": "=",
          "type": [
            "string"
          ]
        },
        {
          "name": "field_delimiter",
          "description": "The string that separates each key-value pair.",
          "required": false,
          "default": " ",
          "type": [
            "string"
          ]
        },
        {
          "name": "whitespace",
          "description": "Defines the acceptance of unnecessary whitespace surrounding the configured `key_value_delimiter`.",
          "required": false,
          "enum": {
            "lenient": "Ignore whitespace.",
            "strict": "Parse whitespace as normal character."
          },
          "default": "lenient",
          "type": [
            "string"
          ]
        },
        {
          "name": "accept_standalone_key",
          "description": "Whether a standalone key should be accepted, the resulting object associates such keys with the boolean value `true`.",
          "required": false,
          "type": [
            "boolean"
          ],
          "default": true
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a properly formatted key-value string."
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse logfmt log",
          "source": "parse_key_value!(\n\t\"@timestamp=\\\"Sun Jan 10 16:47:39 EST 2021\\\" level=info msg=\\\"Stopping all fetchers\\\" tag#production=stopping_fetchers id=ConsumerFetcherManager-1382721708341 module=kafka.consumer.ConsumerFetcherManager\"\n)",
          "return": "{\"@timestamp\":\"Sun Jan 10 16:47:39 EST 2021\",\"level\":\"info\",\"msg\":\"Stopping all fetchers\",\"tag#production\":\"stopping_fetchers\",\"id\":\"ConsumerFetcherManager-1382721708341\",\"module\":\"kafka.consumer.ConsumerFetcherManager\"}"
        },
        {
          "title": "Parse comma delimited log",
          "source": "parse_key_value!(\n\t\"path:\\\"/cart_link\\\", host:store.app.com, fwd: \\\"102.30.171.16\\\", dyno: web.1, connect:0ms, service:87ms, status:304, bytes:632, protocol:https\",\n\tfield_delimiter: \",\",\n\tkey_value_delimiter: \":\"\n)",
          "return": "{\"path\":\"/cart_link\",\"host\":\"store.app.com\",\"fwd\":\"102.30.171.16\",\"dyno\":\"web.1\",\"connect\":\"0ms\",\"service\":\"87ms\",\"status\":\"304\",\"bytes\":\"632\",\"protocol\":\"https\"}"
        },
        {
          "title": "Parse comma delimited log with standalone keys",
          "source": "parse_key_value!(\n\t\"env:prod,service:backend,region:eu-east1,beta\",\n\tfield_delimiter: \",\",\n\tkey_value_delimiter: \":\",\n)",
          "return": "{\"env\":\"prod\",\"service\":\"backend\",\"region\":\"eu-east1\",\"beta\":true}"
        },
        {
          "title": "Parse duplicate keys",
          "source": "parse_key_value!(\n\t\"at=info,method=GET,path=\\\"/index\\\",status=200,tags=dev,tags=dummy\",\n\tfield_delimiter: \",\",\n\tkey_value_delimiter: \"=\",\n)",
          "return": "{\"at\":\"info\",\"method\":\"GET\",\"path\":\"/index\",\"status\":\"200\",\"tags\":[\"dev\",\"dummy\"]}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_klog",
      "name": "parse_klog",
      "category": "Parse",
      "description": "Parses the `value` using the [klog](https://github.com/kubernetes/klog) format used by Kubernetes components.",
      "arguments": [
        {
          "name": "value",
          "description": "The string to parse.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` does not match the `klog` format."
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "notices": [
        "This function resolves the year for messages. If the current month is January and the provided month is December, it sets the year to the previous year. Otherwise, it sets the year to the current year."
      ],
      "examples": [
        {
          "title": "Parse using klog",
          "source": "parse_klog!(\"I0505 17:59:40.692994   28133 klog.go:70] hello from klog\")",
          "return": "{\"file\":\"klog.go\",\"id\":28133,\"level\":\"info\",\"line\":70,\"message\":\"hello from klog\",\"timestamp\":\"2025-05-05T17:59:40.692994Z\"}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_linux_authorization",
      "name": "parse_linux_authorization",
      "category": "Parse",
      "description": "Parses Linux authorization logs usually found under either `/var/log/auth.log` (for Debian-based systems) or\n`/var/log/secure` (for RedHat-based systems) according to [Syslog](https://en.wikipedia.org/wiki/Syslog) format.",
      "notices": [
        "The function resolves the year for messages that don't include it. If the current month is January, and the message is for\nDecember, it will take the previous year. Otherwise, take the current year."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The text containing the message to parse.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a properly formatted Syslog message."
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse Linux authorization event",
          "source": "parse_linux_authorization!(\n\ts'Mar 23 01:49:58 localhost sshd[1111]: Accepted publickey for eng from 10.1.1.1 port 8888 ssh2: RSA SHA256:foobar'\n)",
          "return": "{\"appname\":\"sshd\",\"hostname\":\"localhost\",\"message\":\"Accepted publickey for eng from 10.1.1.1 port 8888 ssh2: RSA SHA256:foobar\",\"procid\":1111,\"timestamp\":\"2025-03-23T01:49:58Z\"}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_logfmt",
      "name": "parse_logfmt",
      "category": "Parse",
      "description": "Parses the `value` in [logfmt](https://brandur.org/logfmt).\n\n* Keys and values can be wrapped using the `\"` character.\n* `\"` characters can be escaped by the `\\` character.\n* As per this [logfmt specification](https://pkg.go.dev/github.com/kr/logfmt#section-documentation), the `parse_logfmt` function\n  accepts standalone keys and assigns them a Boolean value of `true`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The string to parse.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a properly formatted key-value string"
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse logfmt log",
          "source": "parse_logfmt!(\n\t\"@timestamp=\\\"Sun Jan 10 16:47:39 EST 2021\\\" level=info msg=\\\"Stopping all fetchers\\\" tag#production=stopping_fetchers id=ConsumerFetcherManager-1382721708341 module=kafka.consumer.ConsumerFetcherManager\"\n)",
          "return": "{\"@timestamp\":\"Sun Jan 10 16:47:39 EST 2021\",\"level\":\"info\",\"msg\":\"Stopping all fetchers\",\"tag#production\":\"stopping_fetchers\",\"id\":\"ConsumerFetcherManager-1382721708341\",\"module\":\"kafka.consumer.ConsumerFetcherManager\"}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_nginx_log",
      "name": "parse_nginx_log",
      "category": "Parse",
      "description": "\tParses Nginx access and error log lines. Lines can be in [`combined`](https://nginx.org/en/docs/http/ngx_http_log_module.html),\n\t[`ingress_upstreaminfo`](https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/log-format/), [`main`](https://hg.nginx.org/pkg-oss/file/tip/debian/debian/nginx.conf) or [`error`](https://github.com/nginx/nginx/blob/branches/stable-1.18/src/core/ngx_log.c#L102) format.",
      "notices": [
        "Missing information in the log message may be indicated by `-`. These fields are omitted in the result.",
        "In case of `ingress_upstreaminfo` format the following fields may be safely omitted in the log message: `remote_addr`, `remote_user`, `http_referer`, `http_user_agent`, `proxy_alternative_upstream_name`, `upstream_addr`, `upstream_response_length`, `upstream_response_time`, `upstream_status`."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string to parse.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "timestamp_format",
          "description": "\nThe [date/time format](https://docs.rs/chrono/latest/chrono/format/strftime/index.html#specifiers) to use for encoding the timestamp. The time is parsed\nin local time if the timestamp doesn't specify a timezone. The default format is `%d/%b/%Y:%T %z` for\ncombined logs and `%Y/%m/%d %H:%M:%S` for error logs.",
          "required": false,
          "default": "%d/%b/%Y:%T %z",
          "type": [
            "string"
          ]
        },
        {
          "name": "format",
          "description": "The format to use for parsing the log.",
          "required": true,
          "enum": {
            "combined": "Nginx combined format",
            "error": "Default Nginx error format",
            "ingress_upstreaminfo": "Provides detailed upstream information (Nginx Ingress Controller)",
            "main": "Nginx main format used by Docker images"
          },
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` does not match the specified format.",
        "`timestamp_format` is not a valid format string.",
        "The timestamp in `value` fails to parse using the provided `timestamp_format`."
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse via Nginx log format (combined)",
          "source": "parse_nginx_log!(\n    s'172.17.0.1 - alice [01/Apr/2021:12:02:31 +0000] \"POST /not-found HTTP/1.1\" 404 153 \"http://localhost/somewhere\" \"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.119 Safari/537.36\" \"2.75\"',\n    \"combined\",\n)",
          "return": "{\"agent\":\"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.119 Safari/537.36\",\"client\":\"172.17.0.1\",\"compression\":\"2.75\",\"referer\":\"http://localhost/somewhere\",\"request\":\"POST /not-found HTTP/1.1\",\"size\":153,\"status\":404,\"timestamp\":\"2021-04-01T12:02:31Z\",\"user\":\"alice\"}"
        },
        {
          "title": "Parse via Nginx log format (error)",
          "source": "parse_nginx_log!(\n    s'2021/04/01 13:02:31 [error] 31#31: *1 open() \"/usr/share/nginx/html/not-found\" failed (2: No such file or directory), client: 172.17.0.1, server: localhost, request: \"POST /not-found HTTP/1.1\", host: \"localhost:8081\"',\n    \"error\"\n)",
          "return": "{\"timestamp\":\"2021-04-01T13:02:31Z\",\"severity\":\"error\",\"pid\":31,\"tid\":31,\"cid\":1,\"message\":\"open() \\\"/usr/share/nginx/html/not-found\\\" failed (2: No such file or directory)\",\"client\":\"172.17.0.1\",\"server\":\"localhost\",\"request\":\"POST /not-found HTTP/1.1\",\"host\":\"localhost:8081\"}"
        },
        {
          "title": "Parse via Nginx log format (ingress_upstreaminfo)",
          "source": "parse_nginx_log!(\n    s'0.0.0.0 - bob [18/Mar/2023:15:00:00 +0000] \"GET /some/path HTTP/2.0\" 200 12312 \"https://10.0.0.1/some/referer\" \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36\" 462 0.050 [some-upstream-service-9000] [some-other-upstream-5000] 10.0.50.80:9000 19437 0.049 200 752178adb17130b291aefd8c386279e7',\n    \"ingress_upstreaminfo\"\n)",
          "return": "{\"body_bytes_size\":12312,\"http_referer\":\"https://10.0.0.1/some/referer\",\"http_user_agent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36\",\"proxy_alternative_upstream_name\":\"some-other-upstream-5000\",\"proxy_upstream_name\":\"some-upstream-service-9000\",\"remote_addr\":\"0.0.0.0\",\"remote_user\":\"bob\",\"req_id\":\"752178adb17130b291aefd8c386279e7\",\"request\":\"GET /some/path HTTP/2.0\",\"request_length\":462,\"request_time\":0.05,\"status\":200,\"timestamp\":\"2023-03-18T15:00:00Z\",\"upstream_addr\":\"10.0.50.80:9000\",\"upstream_response_length\":19437,\"upstream_response_time\":0.049,\"upstream_status\":200}"
        },
        {
          "title": "Parse via Nginx log format (main)",
          "source": "parse_nginx_log!(\n    s'172.24.0.3 - alice [31/Dec/2024:17:32:06 +0000] \"GET / HTTP/1.1\" 200 615 \"https://domain.tld/path\" \"curl/8.11.1\" \"1.2.3.4, 10.10.1.1\"',\n    \"main\"\n)",
          "return": "{\"body_bytes_size\":615,\"http_referer\":\"https://domain.tld/path\",\"http_user_agent\":\"curl/8.11.1\",\"http_x_forwarded_for\":\"1.2.3.4, 10.10.1.1\",\"remote_addr\":\"172.24.0.3\",\"remote_user\":\"alice\",\"request\":\"GET / HTTP/1.1\",\"status\":200,\"timestamp\":\"2024-12-31T17:32:06Z\"}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_proto",
      "name": "parse_proto",
      "category": "Parse",
      "description": "Parses the `value` as a protocol buffer payload.",
      "notices": [
        "\tOnly proto messages are parsed and returned."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The protocol buffer payload to parse.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "desc_file",
          "description": "The path to the protobuf descriptor set file. Must be a literal string.\n\nThis file is the output of protoc -o <path> ...",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "message_type",
          "description": "The name of the message type to use for serializing.\n\nMust be a literal string.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a valid proto payload.",
        "`desc_file` file does not exist.",
        "`message_type` message type does not exist in the descriptor file."
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse proto",
          "source": "parse_proto!(decode_base64!(\"Cgdzb21lb25lIggKBjEyMzQ1Ng==\"), \"resources/protobuf_descriptor_set.desc\", \"test_protobuf.Person\")",
          "return": "{\"name\":\"someone\",\"phones\":[{\"number\":\"123456\"}]}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_query_string",
      "name": "parse_query_string",
      "category": "Parse",
      "description": "Parses the `value` as a query string.",
      "notices": [
        "All values are returned as strings. We recommend manually coercing values to desired types as you see fit. Empty keys and values are allowed."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string to parse.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse query string",
          "source": "parse_query_string(\"foo=%2B1&bar=2&bar=3&xyz\")",
          "return": "{\"foo\":\"+1\",\"bar\":[\"2\",\"3\"],\"xyz\":\"\"}"
        },
        {
          "title": "Parse Ruby on Rails' query string",
          "source": "parse_query_string(\"?foo%5b%5d=1&foo%5b%5d=2\")",
          "return": "{\"foo[]\":[\"1\",\"2\"]}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_regex",
      "name": "parse_regex",
      "category": "Parse",
      "description": "Parses the `value` using the provided [Regex](https://en.wikipedia.org/wiki/Regular_expression) `pattern`.\n\nThis function differs from the `parse_regex_all` function in that it returns only the first match.",
      "notices": [
        "VRL aims to provide purpose-specific [parsing functions](/docs/reference/vrl/functions/#parse-functions) for common log formats.\nBefore reaching for the `parse_regex` function, see if a VRL [`parse_*` function](/docs/reference/vrl/functions/#parse-functions)\nalready exists for your format. If not, we recommend [opening an issue](https://github.com/vectordotdev/vector/issues/new?labels=type%3A+new+feature) to request\nsupport for the desired format.",
        "All values are returned as strings. We recommend manually coercing values to desired types as you see fit."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string to search.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "pattern",
          "description": "The regular expression pattern to search against.",
          "required": true,
          "type": [
            "regex"
          ]
        },
        {
          "name": "numeric_groups",
          "description": "If true, the index of each group in the regular expression is also captured. Index `0`\ncontains the whole match.",
          "required": false,
          "default": false,
          "type": [
            "regex"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` fails to parse using the provided `pattern`."
      ],
      "return": {
        "types": [
          "object"
        ],
        "rules": [
          "Matches return all capture groups corresponding to the leftmost matches in the text.",
          "Raises an error if no match is found."
        ]
      },
      "examples": [
        {
          "title": "Parse using Regex (with capture groups)",
          "source": "parse_regex!(\"first group and second group.\", r'(?P<number>.*?) group')",
          "return": "{\"number\":\"first\"}"
        },
        {
          "title": "Parse using Regex (without capture groups)",
          "source": "parse_regex!(\"first group and second group.\", r'(\\w+) group', numeric_groups: true)",
          "return": "{\"0\":\"first group\",\"1\":\"first\"}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_regex_all",
      "name": "parse_regex_all",
      "category": "Parse",
      "description": "Parses the `value` using the provided [Regex](https://en.wikipedia.org/wiki/Regular_expression) `pattern`.\n\nThis function differs from the `parse_regex` function in that it returns _all_ matches, not just the first.",
      "notices": [
        "VRL aims to provide purpose-specific [parsing functions](/docs/reference/vrl/functions/#parse-functions) for common log formats.\nBefore reaching for the `parse_regex` function, see if a VRL [`parse_*` function](/docs/reference/vrl/functions/#parse-functions)\nalready exists for your format. If not, we recommend [opening an issue](https://github.com/vectordotdev/vector/issues/new?labels=type%3A+new+feature) to request\nsupport for the desired format.",
        "All values are returned as strings. We recommend manually coercing values to desired types as you see fit."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string to search.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "pattern",
          "description": "The regular expression pattern to search against.",
          "required": true,
          "type": [
            "regex"
          ]
        },
        {
          "name": "numeric_groups",
          "description": "If `true`, the index of each group in the regular expression is also captured. Index `0`\ncontains the whole match.",
          "required": false,
          "default": false,
          "type": [
            "regex"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a string.",
        "`pattern` is not a regex."
      ],
      "return": {
        "types": [
          "array"
        ],
        "rules": [
          "Matches return all capture groups corresponding to the leftmost matches in the text.",
          "Raises an error if no match is found."
        ]
      },
      "examples": [
        {
          "title": "Parse using Regex (all matches)",
          "source": "parse_regex_all!(\"first group and second group.\", r'(?P<number>\\w+) group', numeric_groups: true)",
          "return": "[{\"0\":\"first group\",\"1\":\"first\",\"number\":\"first\"},{\"0\":\"second group\",\"1\":\"second\",\"number\":\"second\"}]"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_ruby_hash",
      "name": "parse_ruby_hash",
      "category": "Parse",
      "description": "Parses the `value` as ruby hash.",
      "notices": [
        "Only ruby types are returned. If you need to convert a `string` into a `timestamp`, consider the\n[`parse_timestamp`](#parse_timestamp) function."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string representation of the ruby hash to parse.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a valid ruby hash formatted payload."
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse ruby hash",
          "source": "parse_ruby_hash!(s'{ \"test\" => \"value\", \"testNum\" => 0.2, \"testObj\" => { \"testBool\" => true, \"testNull\" => nil } }')",
          "return": "{\"test\":\"value\",\"testNum\":0.2,\"testObj\":{\"testBool\":true,\"testNull\":null}}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_syslog",
      "name": "parse_syslog",
      "category": "Parse",
      "description": "Parses the `value` in [Syslog](https://en.wikipedia.org/wiki/Syslog) format.",
      "notices": [
        "The function makes a best effort to parse the various Syslog formats that exists out in the wild. This includes\n[RFC 6587](https://tools.ietf.org/html/rfc6587), [RFC 5424](https://tools.ietf.org/html/rfc5424), [RFC 3164](https://tools.ietf.org/html/rfc3164), and other\ncommon variations (such as the Nginx Syslog style).",
        "All values are returned as strings. We recommend manually coercing values to desired types as you see fit."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The text containing the Syslog message to parse.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a properly formatted Syslog message."
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse Syslog log (5424)",
          "source": "parse_syslog!(\n\ts'<13>1 2020-03-13T20:45:38.119Z dynamicwireless.name non 2426 ID931 [exampleSDID@32473 iut=\"3\" eventSource= \"Application\" eventID=\"1011\"] Try to override the THX port, maybe it will reboot the neural interface!'\n)",
          "return": "{\"severity\":\"notice\",\"facility\":\"user\",\"timestamp\":\"2020-03-13T20:45:38.119Z\",\"hostname\":\"dynamicwireless.name\",\"appname\":\"non\",\"procid\":2426,\"msgid\":\"ID931\",\"message\":\"Try to override the THX port, maybe it will reboot the neural interface!\",\"exampleSDID@32473\":{\"eventID\":\"1011\",\"eventSource\":\"Application\",\"iut\":\"3\"},\"version\":1}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_timestamp",
      "name": "parse_timestamp",
      "category": "Parse",
      "description": "Parses the `value` in [strptime](https://docs.rs/chrono/latest/chrono/format/strftime/index.html#specifiers) `format`.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The text of the timestamp.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "format",
          "description": "The [strptime](https://docs.rs/chrono/latest/chrono/format/strftime/index.html#specifiers) format.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "timezone",
          "description": "The [TZ database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) format. By default, this function parses the timestamp by global [`timezone` option](/docs/reference/configuration//global-options#timezone).\nThis argument overwrites the setting and is useful for parsing timestamps without a specified timezone, such as `16/10/2019 12:00:00`.",
          "required": false,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` fails to parse using the provided `format`.",
        "`value` fails to parse using the provided `timezone`."
      ],
      "return": {
        "types": [
          "timestamp"
        ]
      },
      "examples": [
        {
          "title": "Parse timestamp",
          "source": "parse_timestamp!(\"10-Oct-2020 16:00+00:00\", format: \"%v %R %:z\")",
          "return": "\"2020-10-10T16:00:00Z\""
        },
        {
          "title": "Parse timestamp with timezone",
          "source": "parse_timestamp!(\"16/10/2019 12:00:00\", format: \"%d/%m/%Y %H:%M:%S\", timezone: \"Asia/Taipei\")",
          "return": "\"2019-10-16T04:00:00Z\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_tokens",
      "name": "parse_tokens",
      "category": "Parse",
      "description": "Parses the `value` in token format. A token is considered to be one of the following:\n\n* A word surrounded by whitespace.\n* Text delimited by double quotes: `\"..\"`. Quotes can be included in the token if they are escaped by a backslash (`\\`).\n* Text delimited by square brackets: `[..]`. Closing square brackets can be included in the token if they are escaped by a backslash (`\\`).",
      "notices": [
        "All token values are returned as strings. We recommend manually coercing values to desired types as you see fit."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string to tokenize.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a properly formatted tokenized string."
      ],
      "return": {
        "types": [
          "array"
        ]
      },
      "examples": [
        {
          "title": "Parse tokens",
          "source": "parse_tokens(\n\t\"A sentence \\\"with \\\\\\\"a\\\\\\\" sentence inside\\\" and [some brackets]\"\n)",
          "return": "[\"A\",\"sentence\",\"with \\\\\\\"a\\\\\\\" sentence inside\",\"and\",\"some brackets\"]"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_url",
      "name": "parse_url",
      "category": "Parse",
      "description": "Parses the `value` in [URL](https://en.wikipedia.org/wiki/URL) format.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The text of the URL.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "default_known_ports",
          "description": "If true and the port number is not specified in the input URL\nstring (or matches the default port for the scheme), it is\npopulated from well-known ports for the following schemes:\n`http`, `https`, `ws`, `wss`, and `ftp`.",
          "required": false,
          "type": [
            "boolean"
          ],
          "default": false
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a properly formatted URL."
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse URL",
          "source": "parse_url!(\"ftp://foo:bar@example.com:4343/foobar?hello=world#123\")",
          "return": "{\"scheme\":\"ftp\",\"username\":\"foo\",\"password\":\"bar\",\"host\":\"example.com\",\"port\":4343,\"path\":\"/foobar\",\"query\":{\"hello\":\"world\"},\"fragment\":\"123\"}"
        },
        {
          "title": "Parse URL with default port",
          "source": "parse_url!(\"https://example.com\", default_known_ports: true)",
          "return": "{\"scheme\":\"https\",\"username\":\"\",\"password\":\"\",\"host\":\"example.com\",\"port\":443,\"path\":\"/\",\"query\":{},\"fragment\":null}"
        },
        {
          "title": "Parse URL with internationalized domain name",
          "source": "parse_url!(\"https://www.café.com\")",
          "return": "{\"scheme\":\"https\",\"username\":\"\",\"password\":\"\",\"host\":\"www.xn--caf-dma.com\",\"port\":null,\"path\":\"/\",\"query\":{},\"fragment\":null}"
        },
        {
          "title": "Parse URL with mixed case internationalized domain name",
          "source": "parse_url!(\"https://www.CAFé.com\")",
          "return": "{\"scheme\":\"https\",\"username\":\"\",\"password\":\"\",\"host\":\"www.xn--caf-dma.com\",\"port\":null,\"path\":\"/\",\"query\":{},\"fragment\":null}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_user_agent",
      "name": "parse_user_agent",
      "category": "Parse",
      "description": "Parses the `value` as a user agent string, which has [a loosely defined format](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent)\nso this parser only provides best effort guarantee.",
      "notices": [
        "All values are returned as strings or as null. We recommend manually coercing values to desired types as you see fit.",
        "Different modes return different schema.",
        "Field which were not parsed out are set as `null`."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string to parse.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "mode",
          "description": "Determines performance and reliability characteristics.",
          "required": false,
          "enum": {
            "fast": "Fastest mode but most unreliable. Uses parser from project [Woothee](https://github.com/woothee/woothee).",
            "reliable": "Provides greater reliability than `fast` and retains it's speed in common cases.\nParses with [Woothee](https://github.com/woothee/woothee) parser and with parser from [uap project](https://github.com/ua-parser/uap-core) if\nthere are some missing fields that the first parser wasn't able to parse out\nbut the second one maybe can.",
            "enriched": "Parses with both parser from [Woothee](https://github.com/woothee/woothee) and parser from [uap project](https://github.com/ua-parser/uap-core)\nand combines results. Result has the full schema."
          },
          "default": "fast",
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Fast mode",
          "source": "parse_user_agent(\n\t\"Mozilla Firefox 1.0.1 Mozilla/5.0 (X11; U; Linux i686; de-DE; rv:1.7.6) Gecko/20050223 Firefox/1.0.1\"\n)",
          "return": "{\"browser\":{\"family\":\"Firefox\",\"version\":\"1.0.1\"},\"device\":{\"category\":\"pc\"},\"os\":{\"family\":\"Linux\",\"version\":null}}"
        },
        {
          "title": "Reliable mode",
          "source": "parse_user_agent(\n\t\"Mozilla/4.0 (compatible; MSIE 7.66; Windows NT 5.1; SV1; .NET CLR 1.1.4322)\",\n\tmode: \"reliable\"\n)",
          "return": "{\"browser\":{\"family\":\"Internet Explorer\",\"version\":\"7.66\"},\"device\":{\"category\":\"pc\"},\"os\":{\"family\":\"Windows XP\",\"version\":\"NT 5.1\"}}"
        },
        {
          "title": "Enriched mode",
          "source": "parse_user_agent(\n\t\"Opera/9.80 (J2ME/MIDP; Opera Mini/4.3.24214; iPhone; CPU iPhone OS 4_2_1 like Mac OS X; AppleWebKit/24.783; U; en) Presto/2.5.25 Version/10.54\",\n\tmode: \"enriched\"\n)",
          "return": "{\"browser\":{\"family\":\"Opera Mini\",\"major\":\"4\",\"minor\":\"3\",\"patch\":\"24214\",\"version\":\"10.54\"},\"device\":{\"brand\":\"Apple\",\"category\":\"smartphone\",\"family\":\"iPhone\",\"model\":\"iPhone\"},\"os\":{\"family\":\"iOS\",\"major\":\"4\",\"minor\":\"2\",\"patch\":\"1\",\"patch_minor\":null,\"version\":\"4.2.1\"}}"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "parse_xml",
      "name": "parse_xml",
      "category": "Parse",
      "description": "Parses the `value` as XML.",
      "notices": [
        "Valid XML must contain exactly one root node. Always returns an object."
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The string representation of the XML document to parse.",
          "required": true,
          "type": [
            "string"
          ]
        },
        {
          "name": "include_attr",
          "description": "Include XML tag attributes in the returned object.",
          "required": false,
          "default": true,
          "type": [
            "boolean"
          ]
        },
        {
          "name": "attr_prefix",
          "description": "String prefix to use for XML tag attribute keys.",
          "required": false,
          "default": "@",
          "type": [
            "string"
          ]
        },
        {
          "name": "text_key",
          "description": "Key name to use for expanded text nodes.",
          "required": false,
          "default": "text",
          "type": [
            "string"
          ]
        },
        {
          "name": "always_use_text_key",
          "description": "Always return text nodes as `{\"<text_key>\": \"value\"}.`",
          "required": false,
          "default": false,
          "type": [
            "boolean"
          ]
        },
        {
          "name": "parse_bool",
          "description": "Parse \"true\" and \"false\" as boolean.",
          "required": false,
          "default": true,
          "type": [
            "boolean"
          ]
        },
        {
          "name": "parse_null",
          "description": "Parse \"null\" as null.",
          "required": false,
          "default": true,
          "type": [
            "boolean"
          ]
        },
        {
          "name": "parse_number",
          "description": "Parse numbers as integers/floats.",
          "required": false,
          "default": true,
          "type": [
            "boolean"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a valid XML document."
      ],
      "return": {
        "types": [
          "object"
        ]
      },
      "examples": [
        {
          "title": "Parse XML",
          "source": "value = s'<book category=\"CHILDREN\"><title lang=\"en\">Harry Potter</title><author>J K. Rowling</author><year>2005</year></book>';\n\nparse_xml!(value, text_key: \"value\", parse_number: false)",
          "return": "{\"book\":{\"@category\":\"CHILDREN\",\"author\":\"J K. Rowling\",\"title\":{\"@lang\":\"en\",\"value\":\"Harry Potter\"},\"year\":\"2005\"}}"
        }
      ],
      "deprecated": false,
      "pure": true
    }
  ],
  "Random": [
    {
      "anchor": "random_bool",
      "name": "random_bool",
      "category": "Random",
      "description": "Returns a random boolean.",
      "notices": [],
      "arguments": [],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "boolean"
        ]
      },
      "examples": [
        {
          "title": "Random boolean",
          "source": "is_boolean(random_bool())",
          "return": "true"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "random_bytes",
      "name": "random_bytes",
      "category": "Random",
      "description": "A cryptographically secure random number generator. Returns a string value containing the number of\nrandom bytes requested.",
      "notices": [],
      "arguments": [
        {
          "name": "length",
          "description": "The number of bytes to generate. Must not be larger than 64k.",
          "required": true,
          "type": [
            "integer"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`length` is negative.",
        "`length` is larger than the maximum value (64k)."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Generate random base 64 encoded bytes",
          "source": "encode_base64(random_bytes(16))",
          "return": "\"LNu0BBgUbh7XAlXbjSOomQ==\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "random_float",
      "name": "random_float",
      "category": "Random",
      "description": "Returns a random float between [min, max).",
      "notices": [],
      "arguments": [
        {
          "name": "min",
          "description": "Minimum value (inclusive).",
          "required": true,
          "type": [
            "float"
          ]
        },
        {
          "name": "max",
          "description": "Maximum value (exclusive).",
          "required": true,
          "type": [
            "float"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`max` is not greater than `min`."
      ],
      "return": {
        "types": [
          "float"
        ]
      },
      "examples": [
        {
          "title": "Random float from 0.0 to 10.0, not including 10.0",
          "source": "f = random_float(0.0, 10.0)\nf >= 0 && f < 10",
          "return": "true"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "random_int",
      "name": "random_int",
      "category": "Random",
      "description": "Returns a random integer between [min, max).",
      "notices": [],
      "arguments": [
        {
          "name": "min",
          "description": "Minimum value (inclusive).",
          "required": true,
          "type": [
            "integer"
          ]
        },
        {
          "name": "max",
          "description": "Maximum value (exclusive).",
          "required": true,
          "type": [
            "integer"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`max` is not greater than `min`."
      ],
      "return": {
        "types": [
          "integer"
        ]
      },
      "examples": [
        {
          "title": "Random integer from 0 to 10, not including 10",
          "source": "i = random_int(0, 10)\ni >= 0 && i < 10",
          "return": "true"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "uuid_from_friendly_id",
      "name": "uuid_from_friendly_id",
      "category": "Random",
      "description": "Convert a Friendly ID (base62 encoding a 128-bit word) to a UUID.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "A string that is a Friendly ID",
          "required": true,
          "type": [
            "timestamp"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is a string but the text uses characters outside of class [0-9A-Za-z].",
        "`value` is a base62 encoding of an integer, but the integer is greater than or equal to 2^128."
      ],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Convert a Friendly ID to a UUID",
          "source": "uuid_from_friendly_id!(\"3s87yEvnmkiPBMHsj8bwwc\")",
          "return": "\"7f41deed-d5e2-8b5e-7a13-ab4ff93cfad2\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "uuid_v4",
      "name": "uuid_v4",
      "category": "Random",
      "description": "Generates a random [UUIDv4](https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random)) string.",
      "notices": [],
      "arguments": [],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Create a UUIDv4",
          "source": "uuid_v4()",
          "return": "\"1d262f4f-199b-458d-879f-05fd0a5f0683\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "uuid_v7",
      "name": "uuid_v7",
      "category": "Random",
      "description": "Generates a random [UUIDv7](https://datatracker.ietf.org/doc/html/draft-peabody-dispatch-new-uuid-format-04#name-uuid-version-7) string.",
      "notices": [],
      "arguments": [
        {
          "name": "timestamp",
          "description": "The timestamp used to generate the UUIDv7.",
          "required": false,
          "type": [
            "timestamp"
          ],
          "default": "`now()`"
        }
      ],
      "internal_failure_reasons": [],
      "return": {
        "types": [
          "string"
        ]
      },
      "examples": [
        {
          "title": "Create a UUIDv7 with implicit `now()`",
          "source": "uuid_v7()",
          "return": "\"06338364-8305-7b74-8000-de4963503139\""
        },
        {
          "title": "Create a UUIDv7 with explicit `now()`",
          "source": "uuid_v7(now())",
          "return": "\"018e29b3-0bea-7f78-8af3-d32ccb1b93c1\""
        },
        {
          "title": "Create a UUIDv7 with custom timestamp",
          "source": "uuid_v7(t'2020-12-30T22:20:53.824727Z')",
          "return": "\"0176b5bd-5d19-7394-bb60-c21028c6152b\""
        }
      ],
      "deprecated": false,
      "pure": true
    }
  ],
  "Coerce": [
    {
      "anchor": "to_bool",
      "name": "to_bool",
      "category": "Coerce",
      "description": "Coerces the `value` into a boolean.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to convert to a Boolean.",
          "required": true,
          "type": [
            "boolean",
            "integer",
            "float",
            "null",
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a supported boolean representation."
      ],
      "return": {
        "types": [
          "boolean"
        ],
        "rules": [
          "If `value` is `\"true\"`, `\"t\"`, `\"yes\"`, or `\"y\"`, `true` is returned.",
          "If `value` is `\"false\"`, `\"f\"`, `\"no\"`, `\"n\"`, or `\"0\"`, `false` is returned.",
          "If `value` is `0.0`, `false` is returned, otherwise `true` is returned.",
          "If `value` is `0`, `false` is returned, otherwise `true` is returned.",
          "If `value` is `null`, `false` is returned.",
          "If `value` is a Boolean, it's returned unchanged."
        ]
      },
      "examples": [
        {
          "title": "Coerce to a Boolean (string)",
          "source": "to_bool!(\"yes\")",
          "return": "true"
        },
        {
          "title": "Coerce to a Boolean (float)",
          "source": "to_bool(0.0)",
          "return": "false"
        },
        {
          "title": "Coerce to a Boolean (int)",
          "source": "to_bool(0)",
          "return": "false"
        },
        {
          "title": "Coerce to a Boolean (null)",
          "source": "to_bool(null)",
          "return": "false"
        },
        {
          "title": "Coerce to a Boolean (Boolean)",
          "source": "to_bool(true)",
          "return": "true"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "to_float",
      "name": "to_float",
      "category": "Coerce",
      "description": "Coerces the `value` into a float.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to convert to a float. Must be convertible to a float, otherwise an error is raised.",
          "required": true,
          "type": [
            "integer",
            "float",
            "boolean",
            "string",
            "timestamp"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a supported float representation."
      ],
      "return": {
        "types": [
          "float"
        ],
        "rules": [
          "If `value` is a float, it will be returned as-is.",
          "If `value` is an integer, it will be returned as as a float.",
          "If `value` is a string, it must be the string representation of an float or else an error is raised.",
          "If `value` is a boolean, `0.0` is returned for `false` and `1.0` is returned for `true`.",
          "If `value` is a timestamp, a [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time) with fractional seconds is returned."
        ]
      },
      "examples": [
        {
          "title": "Coerce to a float",
          "source": "to_float!(\"3.145\")",
          "return": "3.145"
        },
        {
          "title": "Coerce to a float (timestamp)",
          "source": "to_float(t'2020-12-30T22:20:53.824727Z')",
          "return": "1609366853.824727"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "to_int",
      "name": "to_int",
      "category": "Coerce",
      "description": "Coerces the `value` into an integer.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to convert to an integer.",
          "required": true,
          "type": [
            "integer",
            "float",
            "boolean",
            "string",
            "timestamp",
            "null"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is a string but the text is not an integer.",
        "`value` is not a string, int, or timestamp."
      ],
      "return": {
        "types": [
          "integer"
        ],
        "rules": [
          "If `value` is an integer, it will be returned as-is.",
          "If `value` is a float, it will be truncated to its integer portion.",
          "If `value` is a string, it must be the string representation of an integer or else an error is raised.",
          "If `value` is a boolean, `0` is returned for `false` and `1` is returned for `true`.",
          "If `value` is a timestamp, a [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time) (in seconds) is returned.",
          "If `value` is null, `0` is returned."
        ]
      },
      "examples": [
        {
          "title": "Coerce to an int (string)",
          "source": "to_int!(\"2\")",
          "return": "2"
        },
        {
          "title": "Coerce to an int (timestamp)",
          "source": "to_int(t'2020-12-30T22:20:53.824727Z')",
          "return": "1609366853"
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "to_regex",
      "name": "to_regex",
      "category": "Coerce",
      "description": "Coerces the `value` into a regex.",
      "notices": [
        "Compiling a regular expression is an expensive operation and can limit Vector throughput. Don't use this function unless you are absolutely sure there is no other way!"
      ],
      "arguments": [
        {
          "name": "value",
          "description": "The value to convert to a regex.",
          "required": true,
          "type": [
            "string"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not a string."
      ],
      "return": {
        "types": [
          "regex"
        ],
        "rules": [
          "If `value` is a string that contains a valid regex, returns the regex constructed with this string."
        ]
      },
      "examples": [
        {
          "title": "Coerce to a regex",
          "source": "to_regex(\"^foo$\") ?? r''",
          "return": "\"^foo$\""
        }
      ],
      "deprecated": false,
      "pure": true
    },
    {
      "anchor": "to_string",
      "name": "to_string",
      "category": "Coerce",
      "description": "Coerces the `value` into a string.",
      "notices": [],
      "arguments": [
        {
          "name": "value",
          "description": "The value to convert to a string.",
          "required": true,
          "type": [
            "integer",
            "float",
            "boolean",
            "string",
            "timestamp",
            "null"
          ]
        }
      ],
      "internal_failure_reasons": [
        "`value` is not an integer, float, boolean, string, timestamp, or null."
      ],
      "return": {
        "types": [
          "string"
        ],
        "rules": [
          "If `value` is an integer or float, returns the string representation.",
          "If `value` is a boolean, returns `\"true\"` or `\"false\"`.",
          "If `value` is a timestamp, returns an [RFC 3339](\\(urls.rfc3339)) representation.",
          "If `value` is a null, returns `\"\"`."
        ]
      },
      "examples": [
        {
          "title": "Coerce to a string (Boolean)",
          "source": "to_string(true)",
          "return": "\"true\""
        },
        {
          "title": "Coerce to a string (int)",
          "source": "to_string(52)",
          "return": "\"52\""
        },
        {
          "title": "Coerce to a string (float)",
          "source": "to_string(52.2)",
          "return": "\"52.2\""
        }
      ],
      "deprecated": false,
      "pure": true
    }
  ]
}
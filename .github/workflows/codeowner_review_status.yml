name: Code Owners Approval Check

on:
  pull_request_review:
    types: [submitted, dismissed]
  pull_request: #remove this line before merge, just for testing
    types: [synchronize] 

permissions: {}

# Stop the current running job if a new push is made to the PR
concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref }}
  cancel-in-progress: true

jobs:
  check-code-owners-approval:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: read
    steps:
      - name: Check Code Owners Approval
        id: check_approvals
        uses: actions/github-script@v7
        with:
          github-token: ${{secrets.CODEOWNER_WORKFLOW_TOKEN}}
          script: |
            const { owner, repo, number } = context.issue;
            
            // Get pull request details and files
            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: number });
            const { data: files } = await github.rest.pulls.listFiles({ owner, repo, pull_number: number });
            
            // Check if the base branch is master
            if (pr.base.ref !== 'master') {
              console.log(`Base branch is ${pr.base.ref}. Skipping check.`);
              return;
            }
              
            // Get CODEOWNERS file content
            let codeowners;
            try {
              const { data } = await github.rest.repos.getContent({
                owner,
                repo,
                path: '.github/CODEOWNERS',
              });
              codeowners = Buffer.from(data.content, 'base64').toString('utf8');
            } catch (error) {
              console.log('CODEOWNERS file not found in .github directory. Skipping check.');
              return;
            }
            
            // Parse CODEOWNERS file
            const codeownersRules = codeowners.split('\n')
              .filter(line => line.trim() && !line.startsWith('#'))
              .map(line => {
                const [pattern, ...owners] = line.split(/\s+/);
                return { pattern, owners: owners.map(o => o.trim()) };
              });

            // Extract unique team slugs
            const teamSlugs = [...new Set(codeownersRules.flatMap(rule => rule.owners))]
              .map(owner => owner.replace(/^.*\//, ''));
            

            // Get reviews
            const { data: reviews } = await github.rest.pulls.listReviews({ owner, repo, pull_number: number });

            const approvals = new Set(
              reviews
                .filter(review => review.state === 'APPROVED')
                .map(review => review.user.login)
            );

            // Function to check if a file matches a pattern
            const matchesPattern = (file, pattern) => {
              // Normalize paths to use forward slashes and trim any leading/trailing slashes
              const normalizedFile = file.replace(/^\/+|\/+$/g, '');
              const normalizedPattern = pattern.replace(/^\/+|\/+$/g, '');

              // Special case for root wildcard
              if (pattern === '*') {
                return true;
              }
            
              // Convert the glob pattern to a regex pattern
              let regexPattern = normalizedPattern
                .split('*')
                .map(part => part.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'))
                .join('.*?');
            
              // Handle directory patterns ending with /
              if (pattern.endsWith('/')) {
                regexPattern = `^${regexPattern}.*`;
              } else {
                regexPattern = `^${regexPattern}$`;
              }
            
              // Handle double-star patterns (match across directory boundaries)
              regexPattern = regexPattern.replace(/\\\*\\\*/g, '.*');
            
              // Handle single-star patterns (don't match across directory boundaries)
              regexPattern = regexPattern.replace(/\\\*/g, '[^/]*');
            
              // Create the regex object
              const regex = new RegExp(regexPattern);
            
              // Test the file against the pattern
              const isMatch = regex.test(normalizedFile);
            
              // Debug logging
              console.log({
                file: normalizedFile,
                pattern: normalizedPattern,
                regex: regexPattern,
                isMatch
              });
            
              return isMatch;
            };
            
            // Test function to verify pattern matching
            const testPatterns = () => {
              const testCases = [
                { file: 'README.md', pattern: '*', expected: true },
                { file: 'config/file.txt', pattern: 'config/', expected: true },
                { file: 'config/content/_menus/nav.yml', pattern: 'config/content/_menus/', expected: true },
                { file: '.github/workflows/test.yml', pattern: '.github/', expected: true },
                { file: 'local/subfolder/file.txt', pattern: 'local/**/*', expected: true },
                { file: 'layouts/shortcodes/docs/guide.md', pattern: 'layouts/shortcodes/**/*.md', expected: true },
                { file: 'content/en/thing/expo.md', pattern: 'content/en/thing/expo.md', expected: true },
                { file: 'content/file/cool.html', pattern: 'content/file/cool.html', expected: true },
                // Negative test cases
                { file: 'other/file.txt', pattern: 'config/', expected: false },
                { file: 'config/content/other/file.yml', pattern: 'config/content/_menus/', expected: false },
                { file: 'local/file.txt', pattern: 'local/**/*.md', expected: false },
              ];
            
              testCases.forEach(({ file, pattern, expected }) => {
                const result = matchesPattern(file, pattern);
                console.log(`Testing: ${file} against ${pattern}`);
                console.log(`Result: ${result}, Expected: ${expected}, ${result === expected ? 'PASS' : 'FAIL'}`);
              });
            };
            
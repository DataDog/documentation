name: Code Owners Approval Check

on:
  pull_request_review:
    types: [submitted, dismissed]
  pull_request:
    types: [synchronize]

permissions: {}

concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref }}
  cancel-in-progress: true

jobs:
  check-code-owners-approval:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: read
    steps:
      - name: Check Code Owners Approval
        id: check_approvals
        uses: actions/github-script@v7
        with:
          github-token: ${{secrets.CODEOWNER_WORKFLOW_TOKEN}}
          script: |
            const { owner, repo, number } = context.issue;
            
            // Get pull request details and files
            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: number });
            const { data: files } = await github.rest.pulls.listFiles({ owner, repo, pull_number: number });
            
            if (pr.base.ref !== 'master') {
              console.log(`Base branch is ${pr.base.ref}. Skipping check.`);
              return;
            }
            
            // Get CODEOWNERS file
            let codeowners;
            try {
              const { data } = await github.rest.repos.getContent({
                owner,
                repo,
                path: '.github/CODEOWNERS',
              });
              codeowners = Buffer.from(data.content, 'base64').toString('utf8');
            } catch (error) {
              console.log('CODEOWNERS file not found in .github directory. Skipping check.');
              return;
            }
            
            // Parse CODEOWNERS file, maintaining order for precedence
            const codeownersRules = codeowners.split('\n')
              .filter(line => line.trim() && !line.startsWith('#'))
              .map(line => {
                const [pattern, ...owners] = line.split(/\s+/);
                return { 
                  pattern: pattern.trim(), 
                  owners: owners.map(o => o.trim()).filter(Boolean)
                };
              })
              .reverse(); // Reverse for precedence (last matching rule wins)

            // Get reviews
            const { data: reviews } = await github.rest.pulls.listReviews({ owner, repo, pull_number: number });
            
            // Track latest review state per user
            const latestReviews = new Map();
            reviews.forEach(review => {
              const existing = latestReviews.get(review.user.login);
              if (!existing || review.submitted_at > existing.submitted_at) {
                latestReviews.set(review.user.login, review);
              }
            });

            const approvals = new Set(
              Array.from(latestReviews.values())
                .filter(review => review.state === 'APPROVED')
                .map(review => review.user.login)
            );

            const matchesPattern = (file, pattern) => {
              const normalizedFile = file.replace(/\\/g, '/').replace(/^\/+|\/+$/g, '');
              const normalizedPattern = pattern.replace(/\\/g, '/').replace(/^\/+|\/+$/g, '');

              if (pattern === '*') return true;

              const regexPattern = normalizedPattern
                .replace(/[.+?^${}()|[\]\\]/g, '\\$&')
                .replace(/\*\*/g, '(?:.*)')
                .replace(/\*/g, '(?:[^/]*)')
                .replace(/\/$/, '(?:/.*)?');

              const regex = new RegExp(`^${regexPattern}$`);
              const isMatch = regex.test(normalizedFile);

              console.log({
                file: normalizedFile,
                pattern: normalizedPattern,
                regex: regex.toString(),
                isMatch
              });

              return isMatch;
            };

            // Get file owners with precedence
            const fileOwners = new Map();
            const defaultOwners = new Set();
            
            files.forEach(file => {
              const filename = file.filename;
              const owners = new Set();
              let hasSpecificMatch = false;

              for (const rule of codeownersRules) {
                if (matchesPattern(filename, rule.pattern)) {
                  if (rule.pattern === '*') {
                    rule.owners.forEach(owner => defaultOwners.add(owner));
                  } else {
                    hasSpecificMatch = true;
                    rule.owners.forEach(owner => owners.add(owner));
                    break; // Stop at first specific match due to precedence
                  }
                }
              }

              // Use default owners only if no specific match found
              if (!hasSpecificMatch && defaultOwners.size > 0) {
                defaultOwners.forEach(owner => owners.add(owner));
              }

              fileOwners.set(filename, owners);
            });

            // Collect all unique required owners
            const requiredOwners = new Set();
            for (const owners of fileOwners.values()) {
              owners.forEach(owner => requiredOwners.add(owner));
            }

            // Check team memberships
            async function checkTeamMembership(teamSlug) {
              try {
                const { data: teamMembers } = await github.rest.teams.listMembersInOrg({
                  org: context.repo.owner,
                  team_slug: teamSlug,
                });
                
                return teamMembers.some(member => approvals.has(member.login));
              } catch (error) {
                console.error(`Error checking membership for team ${teamSlug}: ${error}`);
                return false;
              }
            }

            const ownerApprovals = new Map();
            
            for (const owner of requiredOwners) {
              const teamSlug = owner.replace('@DataDog/', '');
              const isApproved = await checkTeamMembership(teamSlug);
              ownerApprovals.set(owner, isApproved);
            }
              
             // Find existing bot comment
            const existingComments = await github.rest.issues.listComments({
              owner,
              repo,
              issue_number: number,
            });

            const botComment = existingComments.data.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('## Code Owners Approval Status')
            );

            // Generate the report
            let report = '## Code Owners Approval Status\n\n';
            report += `Last updated: ${new Date().toISOString()}\n\n`;
            for (const [file, owners] of fileOwners) {
              report += `### ${file}\n`;
              report += 'Required approvals:\n';
              for (const owner of owners) {
                const status = ownerApprovals.get(owner) ? '✅' : '❌';
                report += `- ${status} ${owner}\n`;
              }
              report += '\n';
            }

            // Update or create comment
            if (botComment) {
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: botComment.id,
                body: report
              });
            } else {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: number,
                body: report
              });
            }